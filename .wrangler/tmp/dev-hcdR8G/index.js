"use strict";
(() => {
  // .wrangler/tmp/bundle-zDwYQT/checked-fetch.js
  var urls = /* @__PURE__ */ new Set();
  function checkURL(request, init) {
    const url = request instanceof URL ? request : new URL(
      (typeof request === "string" ? new Request(request, init) : request).url
    );
    if (url.port && url.port !== "443" && url.protocol === "https:") {
      if (!urls.has(url.toString())) {
        urls.add(url.toString());
        console.warn(
          `WARNING: known issue with \`fetch()\` requests to custom HTTPS ports in published Workers:
 - ${url.toString()} - the custom port will be ignored when the Worker is published using the \`wrangler deploy\` command.
`
        );
      }
    }
  }
  globalThis.fetch = new Proxy(globalThis.fetch, {
    apply(target, thisArg, argArray) {
      const [request, init] = argArray;
      checkURL(request, init);
      return Reflect.apply(target, thisArg, argArray);
    }
  });

  // node_modules/wrangler/templates/middleware/common.ts
  var __facade_middleware__ = [];
  function __facade_register__(...args) {
    __facade_middleware__.push(...args.flat());
  }
  function __facade_registerInternal__(...args) {
    __facade_middleware__.unshift(...args.flat());
  }
  function __facade_invokeChain__(request, env, ctx, dispatch, middlewareChain) {
    const [head, ...tail] = middlewareChain;
    const middlewareCtx = {
      dispatch,
      next(newRequest, newEnv) {
        return __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);
      }
    };
    return head(request, env, ctx, middlewareCtx);
  }
  function __facade_invoke__(request, env, ctx, dispatch, finalMiddleware) {
    return __facade_invokeChain__(request, env, ctx, dispatch, [
      ...__facade_middleware__,
      finalMiddleware
    ]);
  }

  // node_modules/wrangler/templates/middleware/loader-sw.ts
  var __FACADE_EVENT_TARGET__;
  if (globalThis.MINIFLARE) {
    __FACADE_EVENT_TARGET__ = new (Object.getPrototypeOf(WorkerGlobalScope))();
  } else {
    __FACADE_EVENT_TARGET__ = new EventTarget();
  }
  function __facade_isSpecialEvent__(type) {
    return type === "fetch" || type === "scheduled";
  }
  var __facade__originalAddEventListener__ = globalThis.addEventListener;
  var __facade__originalRemoveEventListener__ = globalThis.removeEventListener;
  var __facade__originalDispatchEvent__ = globalThis.dispatchEvent;
  globalThis.addEventListener = function(type, listener, options) {
    if (__facade_isSpecialEvent__(type)) {
      __FACADE_EVENT_TARGET__.addEventListener(
        type,
        listener,
        options
      );
    } else {
      __facade__originalAddEventListener__(type, listener, options);
    }
  };
  globalThis.removeEventListener = function(type, listener, options) {
    if (__facade_isSpecialEvent__(type)) {
      __FACADE_EVENT_TARGET__.removeEventListener(
        type,
        listener,
        options
      );
    } else {
      __facade__originalRemoveEventListener__(type, listener, options);
    }
  };
  globalThis.dispatchEvent = function(event) {
    if (__facade_isSpecialEvent__(event.type)) {
      return __FACADE_EVENT_TARGET__.dispatchEvent(event);
    } else {
      return __facade__originalDispatchEvent__(event);
    }
  };
  globalThis.addMiddleware = __facade_register__;
  globalThis.addMiddlewareInternal = __facade_registerInternal__;
  var __facade_waitUntil__ = Symbol("__facade_waitUntil__");
  var __facade_response__ = Symbol("__facade_response__");
  var __facade_dispatched__ = Symbol("__facade_dispatched__");
  var __Facade_ExtendableEvent__ = class extends Event {
    [__facade_waitUntil__] = [];
    waitUntil(promise) {
      if (!(this instanceof __Facade_ExtendableEvent__)) {
        throw new TypeError("Illegal invocation");
      }
      this[__facade_waitUntil__].push(promise);
    }
  };
  var __Facade_FetchEvent__ = class extends __Facade_ExtendableEvent__ {
    #request;
    #passThroughOnException;
    [__facade_response__];
    [__facade_dispatched__] = false;
    constructor(type, init) {
      super(type);
      this.#request = init.request;
      this.#passThroughOnException = init.passThroughOnException;
    }
    get request() {
      return this.#request;
    }
    respondWith(response) {
      if (!(this instanceof __Facade_FetchEvent__)) {
        throw new TypeError("Illegal invocation");
      }
      if (this[__facade_response__] !== void 0) {
        throw new DOMException(
          "FetchEvent.respondWith() has already been called; it can only be called once.",
          "InvalidStateError"
        );
      }
      if (this[__facade_dispatched__]) {
        throw new DOMException(
          "Too late to call FetchEvent.respondWith(). It must be called synchronously in the event handler.",
          "InvalidStateError"
        );
      }
      this.stopImmediatePropagation();
      this[__facade_response__] = response;
    }
    passThroughOnException() {
      if (!(this instanceof __Facade_FetchEvent__)) {
        throw new TypeError("Illegal invocation");
      }
      this.#passThroughOnException();
    }
  };
  var __Facade_ScheduledEvent__ = class extends __Facade_ExtendableEvent__ {
    #scheduledTime;
    #cron;
    #noRetry;
    constructor(type, init) {
      super(type);
      this.#scheduledTime = init.scheduledTime;
      this.#cron = init.cron;
      this.#noRetry = init.noRetry;
    }
    get scheduledTime() {
      return this.#scheduledTime;
    }
    get cron() {
      return this.#cron;
    }
    noRetry() {
      if (!(this instanceof __Facade_ScheduledEvent__)) {
        throw new TypeError("Illegal invocation");
      }
      this.#noRetry();
    }
  };
  __facade__originalAddEventListener__("fetch", (event) => {
    const ctx = {
      waitUntil: event.waitUntil.bind(event),
      passThroughOnException: event.passThroughOnException.bind(event)
    };
    const __facade_sw_dispatch__ = function(type, init) {
      if (type === "scheduled") {
        const facadeEvent = new __Facade_ScheduledEvent__("scheduled", {
          scheduledTime: Date.now(),
          cron: init.cron ?? "",
          noRetry() {
          }
        });
        __FACADE_EVENT_TARGET__.dispatchEvent(facadeEvent);
        event.waitUntil(Promise.all(facadeEvent[__facade_waitUntil__]));
      }
    };
    const __facade_sw_fetch__ = function(request, _env, ctx2) {
      const facadeEvent = new __Facade_FetchEvent__("fetch", {
        request,
        passThroughOnException: ctx2.passThroughOnException
      });
      __FACADE_EVENT_TARGET__.dispatchEvent(facadeEvent);
      facadeEvent[__facade_dispatched__] = true;
      event.waitUntil(Promise.all(facadeEvent[__facade_waitUntil__]));
      const response = facadeEvent[__facade_response__];
      if (response === void 0) {
        throw new Error("No response!");
      }
      return response;
    };
    event.respondWith(
      __facade_invoke__(
        event.request,
        globalThis,
        ctx,
        __facade_sw_dispatch__,
        __facade_sw_fetch__
      )
    );
  });
  __facade__originalAddEventListener__("scheduled", (event) => {
    const facadeEvent = new __Facade_ScheduledEvent__("scheduled", {
      scheduledTime: event.scheduledTime,
      cron: event.cron,
      noRetry: event.noRetry.bind(event)
    });
    __FACADE_EVENT_TARGET__.dispatchEvent(facadeEvent);
    event.waitUntil(Promise.all(facadeEvent[__facade_waitUntil__]));
  });

  // node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts
  function reduceError(e) {
    return {
      name: e?.name,
      message: e?.message ?? String(e),
      stack: e?.stack,
      cause: e?.cause === void 0 ? void 0 : reduceError(e.cause)
    };
  }
  var jsonError = async (request, env, _ctx, middlewareCtx) => {
    try {
      return await middlewareCtx.next(request, env);
    } catch (e) {
      const error = reduceError(e);
      return Response.json(error, {
        status: 500,
        headers: { "MF-Experimental-Error-Stack": "true" }
      });
    }
  };
  var middleware_miniflare3_json_error_default = jsonError;

  // .wrangler/tmp/bundle-zDwYQT/middleware-insertion-facade.js
  __facade_registerInternal__([middleware_miniflare3_json_error_default]);

  // .output/server/index.mjs
  globalThis._importMeta_ = { url: "file:///_entry.js", env: {} }, function() {
    "use strict";
    function _mergeNamespaces(t2, e2) {
      for (var r2 = 0; r2 < e2.length; r2++) {
        const n2 = e2[r2];
        if ("string" != typeof n2 && !Array.isArray(n2)) {
          for (const e3 in n2)
            if ("default" !== e3 && !(e3 in t2)) {
              const r3 = Object.getOwnPropertyDescriptor(n2, e3);
              r3 && Object.defineProperty(t2, e3, r3.get ? r3 : { enumerable: true, get: function() {
                return n2[e3];
              } });
            }
        }
      }
      return Object.freeze(Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }));
    }
    function createNotImplementedError(t2) {
      throw new Error(`[unenv] ${t2} is not implemented yet!`);
    }
    function notImplemented(t2) {
      return Object.assign(() => {
        throw createNotImplementedError(t2);
      }, { __unenv__: true });
    }
    const t = [], e = [], r = "undefined" == typeof Uint8Array ? Array : Uint8Array, n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (let r2 = 0, i2 = 64; r2 < i2; ++r2)
      t[r2] = n[r2], e[n.charCodeAt(r2)] = r2;
    function toByteArray(t2) {
      let n2;
      const i2 = function(t3) {
        const e2 = t3.length;
        if (e2 % 4 > 0)
          throw new Error("Invalid string. Length must be a multiple of 4");
        let r2 = t3.indexOf("=");
        return -1 === r2 && (r2 = e2), [r2, r2 === e2 ? 0 : 4 - r2 % 4];
      }(t2), o2 = i2[0], a2 = i2[1], s2 = new r(function(t3, e2, r2) {
        return 3 * (e2 + r2) / 4 - r2;
      }(0, o2, a2));
      let l2 = 0;
      const p2 = a2 > 0 ? o2 - 4 : o2;
      let c2;
      for (c2 = 0; c2 < p2; c2 += 4)
        n2 = e[t2.charCodeAt(c2)] << 18 | e[t2.charCodeAt(c2 + 1)] << 12 | e[t2.charCodeAt(c2 + 2)] << 6 | e[t2.charCodeAt(c2 + 3)], s2[l2++] = n2 >> 16 & 255, s2[l2++] = n2 >> 8 & 255, s2[l2++] = 255 & n2;
      return 2 === a2 && (n2 = e[t2.charCodeAt(c2)] << 2 | e[t2.charCodeAt(c2 + 1)] >> 4, s2[l2++] = 255 & n2), 1 === a2 && (n2 = e[t2.charCodeAt(c2)] << 10 | e[t2.charCodeAt(c2 + 1)] << 4 | e[t2.charCodeAt(c2 + 2)] >> 2, s2[l2++] = n2 >> 8 & 255, s2[l2++] = 255 & n2), s2;
    }
    function encodeChunk(e2, r2, n2) {
      let i2;
      const o2 = [];
      for (let s2 = r2; s2 < n2; s2 += 3)
        i2 = (e2[s2] << 16 & 16711680) + (e2[s2 + 1] << 8 & 65280) + (255 & e2[s2 + 2]), o2.push(t[(a2 = i2) >> 18 & 63] + t[a2 >> 12 & 63] + t[a2 >> 6 & 63] + t[63 & a2]);
      var a2;
      return o2.join("");
    }
    function fromByteArray(e2) {
      let r2;
      const n2 = e2.length, i2 = n2 % 3, o2 = [], a2 = 16383;
      for (let t2 = 0, r3 = n2 - i2; t2 < r3; t2 += a2)
        o2.push(encodeChunk(e2, t2, t2 + a2 > r3 ? r3 : t2 + a2));
      return 1 === i2 ? (r2 = e2[n2 - 1], o2.push(t[r2 >> 2] + t[r2 << 4 & 63] + "==")) : 2 === i2 && (r2 = (e2[n2 - 2] << 8) + e2[n2 - 1], o2.push(t[r2 >> 10] + t[r2 >> 4 & 63] + t[r2 << 2 & 63] + "=")), o2.join("");
    }
    function read(t2, e2, r2, n2, i2) {
      let o2, a2;
      const s2 = 8 * i2 - n2 - 1, l2 = (1 << s2) - 1, p2 = l2 >> 1;
      let c2 = -7, d2 = r2 ? i2 - 1 : 0;
      const m2 = r2 ? -1 : 1;
      let u2 = t2[e2 + d2];
      for (d2 += m2, o2 = u2 & (1 << -c2) - 1, u2 >>= -c2, c2 += s2; c2 > 0; )
        o2 = 256 * o2 + t2[e2 + d2], d2 += m2, c2 -= 8;
      for (a2 = o2 & (1 << -c2) - 1, o2 >>= -c2, c2 += n2; c2 > 0; )
        a2 = 256 * a2 + t2[e2 + d2], d2 += m2, c2 -= 8;
      if (0 === o2)
        o2 = 1 - p2;
      else {
        if (o2 === l2)
          return a2 ? Number.NaN : (u2 ? -1 : 1) * Number.POSITIVE_INFINITY;
        a2 += Math.pow(2, n2), o2 -= p2;
      }
      return (u2 ? -1 : 1) * a2 * Math.pow(2, o2 - n2);
    }
    function write(t2, e2, r2, n2, i2, o2) {
      let a2, s2, l2, p2 = 8 * o2 - i2 - 1;
      const c2 = (1 << p2) - 1, d2 = c2 >> 1, m2 = 23 === i2 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      let u2 = n2 ? 0 : o2 - 1;
      const h2 = n2 ? 1 : -1, g2 = e2 < 0 || 0 === e2 && 1 / e2 < 0 ? 1 : 0;
      for (e2 = Math.abs(e2), Number.isNaN(e2) || e2 === Number.POSITIVE_INFINITY ? (s2 = Number.isNaN(e2) ? 1 : 0, a2 = c2) : (a2 = Math.floor(Math.log2(e2)), e2 * (l2 = Math.pow(2, -a2)) < 1 && (a2--, l2 *= 2), (e2 += a2 + d2 >= 1 ? m2 / l2 : m2 * Math.pow(2, 1 - d2)) * l2 >= 2 && (a2++, l2 /= 2), a2 + d2 >= c2 ? (s2 = 0, a2 = c2) : a2 + d2 >= 1 ? (s2 = (e2 * l2 - 1) * Math.pow(2, i2), a2 += d2) : (s2 = e2 * Math.pow(2, d2 - 1) * Math.pow(2, i2), a2 = 0)); i2 >= 8; )
        t2[r2 + u2] = 255 & s2, u2 += h2, s2 /= 256, i2 -= 8;
      for (a2 = a2 << i2 | s2, p2 += i2; p2 > 0; )
        t2[r2 + u2] = 255 & a2, u2 += h2, a2 /= 256, p2 -= 8;
      t2[r2 + u2 - h2] |= 128 * g2;
    }
    e["-".charCodeAt(0)] = 62, e["_".charCodeAt(0)] = 63;
    const i = "function" == typeof Symbol && "function" == typeof Symbol.for ? Symbol.for("nodejs.util.inspect.custom") : null, o = 2147483647;
    function createBuffer$1(t2) {
      if (t2 > o)
        throw new RangeError('The value "' + t2 + '" is invalid for option "size"');
      const e2 = new Uint8Array(t2);
      return Object.setPrototypeOf(e2, Buffer$1.prototype), e2;
    }
    function Buffer$1(t2, e2, r2) {
      if ("number" == typeof t2) {
        if ("string" == typeof e2)
          throw new TypeError('The "string" argument must be of type string. Received type number');
        return allocUnsafe(t2);
      }
      return from(t2, e2, r2);
    }
    function from(t2, e2, r2) {
      if ("string" == typeof t2)
        return function(t3, e3) {
          "string" == typeof e3 && "" !== e3 || (e3 = "utf8");
          if (!Buffer$1.isEncoding(e3))
            throw new TypeError("Unknown encoding: " + e3);
          const r3 = 0 | byteLength(t3, e3);
          let n3 = createBuffer$1(r3);
          const i3 = n3.write(t3, e3);
          i3 !== r3 && (n3 = n3.slice(0, i3));
          return n3;
        }(t2, e2);
      if (ArrayBuffer.isView(t2))
        return function(t3) {
          if (isInstance(t3, Uint8Array)) {
            const e3 = new Uint8Array(t3);
            return fromArrayBuffer(e3.buffer, e3.byteOffset, e3.byteLength);
          }
          return fromArrayLike(t3);
        }(t2);
      if (null == t2)
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t2);
      if (isInstance(t2, ArrayBuffer) || t2 && isInstance(t2.buffer, ArrayBuffer))
        return fromArrayBuffer(t2, e2, r2);
      if ("undefined" != typeof SharedArrayBuffer && (isInstance(t2, SharedArrayBuffer) || t2 && isInstance(t2.buffer, SharedArrayBuffer)))
        return fromArrayBuffer(t2, e2, r2);
      if ("number" == typeof t2)
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      const n2 = t2.valueOf && t2.valueOf();
      if (null != n2 && n2 !== t2)
        return Buffer$1.from(n2, e2, r2);
      const i2 = function(t3) {
        if (Buffer$1.isBuffer(t3)) {
          const e3 = 0 | checked(t3.length), r3 = createBuffer$1(e3);
          return 0 === r3.length || t3.copy(r3, 0, 0, e3), r3;
        }
        if (void 0 !== t3.length)
          return "number" != typeof t3.length || numberIsNaN(t3.length) ? createBuffer$1(0) : fromArrayLike(t3);
        if ("Buffer" === t3.type && Array.isArray(t3.data))
          return fromArrayLike(t3.data);
      }(t2);
      if (i2)
        return i2;
      if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof t2[Symbol.toPrimitive])
        return Buffer$1.from(t2[Symbol.toPrimitive]("string"), e2, r2);
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t2);
    }
    function assertSize(t2) {
      if ("number" != typeof t2)
        throw new TypeError('"size" argument must be of type number');
      if (t2 < 0)
        throw new RangeError('The value "' + t2 + '" is invalid for option "size"');
    }
    function allocUnsafe(t2) {
      return assertSize(t2), createBuffer$1(t2 < 0 ? 0 : 0 | checked(t2));
    }
    function fromArrayLike(t2) {
      const e2 = t2.length < 0 ? 0 : 0 | checked(t2.length), r2 = createBuffer$1(e2);
      for (let n2 = 0; n2 < e2; n2 += 1)
        r2[n2] = 255 & t2[n2];
      return r2;
    }
    function fromArrayBuffer(t2, e2, r2) {
      if (e2 < 0 || t2.byteLength < e2)
        throw new RangeError('"offset" is outside of buffer bounds');
      if (t2.byteLength < e2 + (r2 || 0))
        throw new RangeError('"length" is outside of buffer bounds');
      let n2;
      return n2 = void 0 === e2 && void 0 === r2 ? new Uint8Array(t2) : void 0 === r2 ? new Uint8Array(t2, e2) : new Uint8Array(t2, e2, r2), Object.setPrototypeOf(n2, Buffer$1.prototype), n2;
    }
    function checked(t2) {
      if (t2 >= o)
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + o.toString(16) + " bytes");
      return 0 | t2;
    }
    function byteLength(t2, e2) {
      if (Buffer$1.isBuffer(t2))
        return t2.length;
      if (ArrayBuffer.isView(t2) || isInstance(t2, ArrayBuffer))
        return t2.byteLength;
      if ("string" != typeof t2)
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof t2);
      const r2 = t2.length, n2 = arguments.length > 2 && true === arguments[2];
      if (!n2 && 0 === r2)
        return 0;
      let i2 = false;
      for (; ; )
        switch (e2) {
          case "ascii":
          case "latin1":
          case "binary":
            return r2;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(t2).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return 2 * r2;
          case "hex":
            return r2 >>> 1;
          case "base64":
            return base64ToBytes(t2).length;
          default:
            if (i2)
              return n2 ? -1 : utf8ToBytes(t2).length;
            e2 = ("" + e2).toLowerCase(), i2 = true;
        }
    }
    function slowToString(t2, e2, r2) {
      let n2 = false;
      if ((void 0 === e2 || e2 < 0) && (e2 = 0), e2 > this.length)
        return "";
      if ((void 0 === r2 || r2 > this.length) && (r2 = this.length), r2 <= 0)
        return "";
      if ((r2 >>>= 0) <= (e2 >>>= 0))
        return "";
      for (t2 || (t2 = "utf8"); ; )
        switch (t2) {
          case "hex":
            return hexSlice(this, e2, r2);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, e2, r2);
          case "ascii":
            return asciiSlice(this, e2, r2);
          case "latin1":
          case "binary":
            return latin1Slice(this, e2, r2);
          case "base64":
            return base64Slice(this, e2, r2);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, e2, r2);
          default:
            if (n2)
              throw new TypeError("Unknown encoding: " + t2);
            t2 = (t2 + "").toLowerCase(), n2 = true;
        }
    }
    function swap(t2, e2, r2) {
      const n2 = t2[e2];
      t2[e2] = t2[r2], t2[r2] = n2;
    }
    function bidirectionalIndexOf(t2, e2, r2, n2, i2) {
      if (0 === t2.length)
        return -1;
      if ("string" == typeof r2 ? (n2 = r2, r2 = 0) : r2 > 2147483647 ? r2 = 2147483647 : r2 < -2147483648 && (r2 = -2147483648), numberIsNaN(r2 = +r2) && (r2 = i2 ? 0 : t2.length - 1), r2 < 0 && (r2 = t2.length + r2), r2 >= t2.length) {
        if (i2)
          return -1;
        r2 = t2.length - 1;
      } else if (r2 < 0) {
        if (!i2)
          return -1;
        r2 = 0;
      }
      if ("string" == typeof e2 && (e2 = Buffer$1.from(e2, n2)), Buffer$1.isBuffer(e2))
        return 0 === e2.length ? -1 : arrayIndexOf(t2, e2, r2, n2, i2);
      if ("number" == typeof e2)
        return e2 &= 255, "function" == typeof Uint8Array.prototype.indexOf ? i2 ? Uint8Array.prototype.indexOf.call(t2, e2, r2) : Uint8Array.prototype.lastIndexOf.call(t2, e2, r2) : arrayIndexOf(t2, [e2], r2, n2, i2);
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(t2, e2, r2, n2, i2) {
      let o2, a2 = 1, s2 = t2.length, l2 = e2.length;
      if (void 0 !== n2 && ("ucs2" === (n2 = String(n2).toLowerCase()) || "ucs-2" === n2 || "utf16le" === n2 || "utf-16le" === n2)) {
        if (t2.length < 2 || e2.length < 2)
          return -1;
        a2 = 2, s2 /= 2, l2 /= 2, r2 /= 2;
      }
      function read2(t3, e3) {
        return 1 === a2 ? t3[e3] : t3.readUInt16BE(e3 * a2);
      }
      if (i2) {
        let n3 = -1;
        for (o2 = r2; o2 < s2; o2++)
          if (read2(t2, o2) === read2(e2, -1 === n3 ? 0 : o2 - n3)) {
            if (-1 === n3 && (n3 = o2), o2 - n3 + 1 === l2)
              return n3 * a2;
          } else
            -1 !== n3 && (o2 -= o2 - n3), n3 = -1;
      } else
        for (r2 + l2 > s2 && (r2 = s2 - l2), o2 = r2; o2 >= 0; o2--) {
          let r3 = true;
          for (let n3 = 0; n3 < l2; n3++)
            if (read2(t2, o2 + n3) !== read2(e2, n3)) {
              r3 = false;
              break;
            }
          if (r3)
            return o2;
        }
      return -1;
    }
    function hexWrite(t2, e2, r2, n2) {
      r2 = Number(r2) || 0;
      const i2 = t2.length - r2;
      n2 ? (n2 = Number(n2)) > i2 && (n2 = i2) : n2 = i2;
      const o2 = e2.length;
      let a2;
      for (n2 > o2 / 2 && (n2 = o2 / 2), a2 = 0; a2 < n2; ++a2) {
        const n3 = Number.parseInt(e2.slice(2 * a2, 2 * a2 + 2), 16);
        if (numberIsNaN(n3))
          return a2;
        t2[r2 + a2] = n3;
      }
      return a2;
    }
    function utf8Write(t2, e2, r2, n2) {
      return blitBuffer(utf8ToBytes(e2, t2.length - r2), t2, r2, n2);
    }
    function asciiWrite(t2, e2, r2, n2) {
      return blitBuffer(function(t3) {
        const e3 = [];
        for (let r3 = 0; r3 < t3.length; ++r3)
          e3.push(255 & t3.charCodeAt(r3));
        return e3;
      }(e2), t2, r2, n2);
    }
    function base64Write(t2, e2, r2, n2) {
      return blitBuffer(base64ToBytes(e2), t2, r2, n2);
    }
    function ucs2Write(t2, e2, r2, n2) {
      return blitBuffer(function(t3, e3) {
        let r3, n3, i2;
        const o2 = [];
        for (let a2 = 0; a2 < t3.length && !((e3 -= 2) < 0); ++a2)
          r3 = t3.charCodeAt(a2), n3 = r3 >> 8, i2 = r3 % 256, o2.push(i2, n3);
        return o2;
      }(e2, t2.length - r2), t2, r2, n2);
    }
    function base64Slice(t2, e2, r2) {
      return 0 === e2 && r2 === t2.length ? fromByteArray(t2) : fromByteArray(t2.slice(e2, r2));
    }
    function utf8Slice(t2, e2, r2) {
      r2 = Math.min(t2.length, r2);
      const n2 = [];
      let i2 = e2;
      for (; i2 < r2; ) {
        const e3 = t2[i2];
        let o2 = null, a2 = e3 > 239 ? 4 : e3 > 223 ? 3 : e3 > 191 ? 2 : 1;
        if (i2 + a2 <= r2) {
          let r3, n3, s2, l2;
          switch (a2) {
            case 1:
              e3 < 128 && (o2 = e3);
              break;
            case 2:
              r3 = t2[i2 + 1], 128 == (192 & r3) && (l2 = (31 & e3) << 6 | 63 & r3, l2 > 127 && (o2 = l2));
              break;
            case 3:
              r3 = t2[i2 + 1], n3 = t2[i2 + 2], 128 == (192 & r3) && 128 == (192 & n3) && (l2 = (15 & e3) << 12 | (63 & r3) << 6 | 63 & n3, l2 > 2047 && (l2 < 55296 || l2 > 57343) && (o2 = l2));
              break;
            case 4:
              r3 = t2[i2 + 1], n3 = t2[i2 + 2], s2 = t2[i2 + 3], 128 == (192 & r3) && 128 == (192 & n3) && 128 == (192 & s2) && (l2 = (15 & e3) << 18 | (63 & r3) << 12 | (63 & n3) << 6 | 63 & s2, l2 > 65535 && l2 < 1114112 && (o2 = l2));
          }
        }
        null === o2 ? (o2 = 65533, a2 = 1) : o2 > 65535 && (o2 -= 65536, n2.push(o2 >>> 10 & 1023 | 55296), o2 = 56320 | 1023 & o2), n2.push(o2), i2 += a2;
      }
      return function(t3) {
        const e3 = t3.length;
        if (e3 <= a)
          return String.fromCharCode.apply(String, t3);
        let r3 = "", n3 = 0;
        for (; n3 < e3; )
          r3 += String.fromCharCode.apply(String, t3.slice(n3, n3 += a));
        return r3;
      }(n2);
    }
    Buffer$1.TYPED_ARRAY_SUPPORT = function() {
      try {
        const t2 = new Uint8Array(1), e2 = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(e2, Uint8Array.prototype), Object.setPrototypeOf(t2, e2), 42 === t2.foo();
      } catch {
        return false;
      }
    }(), Buffer$1.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This environment lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(Buffer$1.prototype, "parent", { enumerable: true, get: function() {
      if (Buffer$1.isBuffer(this))
        return this.buffer;
    } }), Object.defineProperty(Buffer$1.prototype, "offset", { enumerable: true, get: function() {
      if (Buffer$1.isBuffer(this))
        return this.byteOffset;
    } }), Buffer$1.poolSize = 8192, Buffer$1.from = function(t2, e2, r2) {
      return from(t2, e2, r2);
    }, Object.setPrototypeOf(Buffer$1.prototype, Uint8Array.prototype), Object.setPrototypeOf(Buffer$1, Uint8Array), Buffer$1.alloc = function(t2, e2, r2) {
      return function(t3, e3, r3) {
        return assertSize(t3), t3 <= 0 ? createBuffer$1(t3) : void 0 !== e3 ? "string" == typeof r3 ? createBuffer$1(t3).fill(e3, r3) : createBuffer$1(t3).fill(e3) : createBuffer$1(t3);
      }(t2, e2, r2);
    }, Buffer$1.allocUnsafe = function(t2) {
      return allocUnsafe(t2);
    }, Buffer$1.allocUnsafeSlow = function(t2) {
      return allocUnsafe(t2);
    }, Buffer$1.isBuffer = function(t2) {
      return null != t2 && true === t2._isBuffer && t2 !== Buffer$1.prototype;
    }, Buffer$1.compare = function(t2, e2) {
      if (isInstance(t2, Uint8Array) && (t2 = Buffer$1.from(t2, t2.offset, t2.byteLength)), isInstance(e2, Uint8Array) && (e2 = Buffer$1.from(e2, e2.offset, e2.byteLength)), !Buffer$1.isBuffer(t2) || !Buffer$1.isBuffer(e2))
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      if (t2 === e2)
        return 0;
      let r2 = t2.length, n2 = e2.length;
      for (let i2 = 0, o2 = Math.min(r2, n2); i2 < o2; ++i2)
        if (t2[i2] !== e2[i2]) {
          r2 = t2[i2], n2 = e2[i2];
          break;
        }
      return r2 < n2 ? -1 : n2 < r2 ? 1 : 0;
    }, Buffer$1.isEncoding = function(t2) {
      switch (String(t2).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    }, Buffer$1.concat = function(t2, e2) {
      if (!Array.isArray(t2))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (0 === t2.length)
        return Buffer$1.alloc(0);
      let r2;
      if (void 0 === e2)
        for (e2 = 0, r2 = 0; r2 < t2.length; ++r2)
          e2 += t2[r2].length;
      const n2 = Buffer$1.allocUnsafe(e2);
      let i2 = 0;
      for (r2 = 0; r2 < t2.length; ++r2) {
        let e3 = t2[r2];
        if (isInstance(e3, Uint8Array))
          i2 + e3.length > n2.length ? (Buffer$1.isBuffer(e3) || (e3 = Buffer$1.from(e3.buffer, e3.byteOffset, e3.byteLength)), e3.copy(n2, i2)) : Uint8Array.prototype.set.call(n2, e3, i2);
        else {
          if (!Buffer$1.isBuffer(e3))
            throw new TypeError('"list" argument must be an Array of Buffers');
          e3.copy(n2, i2);
        }
        i2 += e3.length;
      }
      return n2;
    }, Buffer$1.byteLength = byteLength, Buffer$1.prototype._isBuffer = true, Buffer$1.prototype.swap16 = function() {
      const t2 = this.length;
      if (t2 % 2 != 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (let e2 = 0; e2 < t2; e2 += 2)
        swap(this, e2, e2 + 1);
      return this;
    }, Buffer$1.prototype.swap32 = function() {
      const t2 = this.length;
      if (t2 % 4 != 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (let e2 = 0; e2 < t2; e2 += 4)
        swap(this, e2, e2 + 3), swap(this, e2 + 1, e2 + 2);
      return this;
    }, Buffer$1.prototype.swap64 = function() {
      const t2 = this.length;
      if (t2 % 8 != 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (let e2 = 0; e2 < t2; e2 += 8)
        swap(this, e2, e2 + 7), swap(this, e2 + 1, e2 + 6), swap(this, e2 + 2, e2 + 5), swap(this, e2 + 3, e2 + 4);
      return this;
    }, Buffer$1.prototype.toString = function() {
      const t2 = this.length;
      return 0 === t2 ? "" : 0 === arguments.length ? utf8Slice(this, 0, t2) : Reflect.apply(slowToString, this, arguments);
    }, Buffer$1.prototype.toLocaleString = Buffer$1.prototype.toString, Buffer$1.prototype.equals = function(t2) {
      if (!Buffer$1.isBuffer(t2))
        throw new TypeError("Argument must be a Buffer");
      return this === t2 || 0 === Buffer$1.compare(this, t2);
    }, Buffer$1.prototype.inspect = function() {
      let t2 = "";
      return t2 = this.toString("hex", 0, 50).replace(/(.{2})/g, "$1 ").trim(), this.length > 50 && (t2 += " ... "), "<Buffer " + t2 + ">";
    }, i && (Buffer$1.prototype[i] = Buffer$1.prototype.inspect), Buffer$1.prototype.compare = function(t2, e2, r2, n2, i2) {
      if (isInstance(t2, Uint8Array) && (t2 = Buffer$1.from(t2, t2.offset, t2.byteLength)), !Buffer$1.isBuffer(t2))
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof t2);
      if (void 0 === e2 && (e2 = 0), void 0 === r2 && (r2 = t2 ? t2.length : 0), void 0 === n2 && (n2 = 0), void 0 === i2 && (i2 = this.length), e2 < 0 || r2 > t2.length || n2 < 0 || i2 > this.length)
        throw new RangeError("out of range index");
      if (n2 >= i2 && e2 >= r2)
        return 0;
      if (n2 >= i2)
        return -1;
      if (e2 >= r2)
        return 1;
      if (this === t2)
        return 0;
      let o2 = (i2 >>>= 0) - (n2 >>>= 0), a2 = (r2 >>>= 0) - (e2 >>>= 0);
      const s2 = Math.min(o2, a2), l2 = this.slice(n2, i2), p2 = t2.slice(e2, r2);
      for (let t3 = 0; t3 < s2; ++t3)
        if (l2[t3] !== p2[t3]) {
          o2 = l2[t3], a2 = p2[t3];
          break;
        }
      return o2 < a2 ? -1 : a2 < o2 ? 1 : 0;
    }, Buffer$1.prototype.includes = function(t2, e2, r2) {
      return -1 !== this.indexOf(t2, e2, r2);
    }, Buffer$1.prototype.indexOf = function(t2, e2, r2) {
      return bidirectionalIndexOf(this, t2, e2, r2, true);
    }, Buffer$1.prototype.lastIndexOf = function(t2, e2, r2) {
      return bidirectionalIndexOf(this, t2, e2, r2, false);
    }, Buffer$1.prototype.write = function(t2, e2, r2, n2) {
      if (void 0 === e2)
        n2 = "utf8", r2 = this.length, e2 = 0;
      else if (void 0 === r2 && "string" == typeof e2)
        n2 = e2, r2 = this.length, e2 = 0;
      else {
        if (!Number.isFinite(e2))
          throw new TypeError("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        e2 >>>= 0, Number.isFinite(r2) ? (r2 >>>= 0, void 0 === n2 && (n2 = "utf8")) : (n2 = r2, r2 = void 0);
      }
      const i2 = this.length - e2;
      if ((void 0 === r2 || r2 > i2) && (r2 = i2), t2.length > 0 && (r2 < 0 || e2 < 0) || e2 > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      n2 || (n2 = "utf8");
      let o2 = false;
      for (; ; )
        switch (n2) {
          case "hex":
            return hexWrite(this, t2, e2, r2);
          case "utf8":
          case "utf-8":
            return utf8Write(this, t2, e2, r2);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, t2, e2, r2);
          case "base64":
            return base64Write(this, t2, e2, r2);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, t2, e2, r2);
          default:
            if (o2)
              throw new TypeError("Unknown encoding: " + n2);
            n2 = ("" + n2).toLowerCase(), o2 = true;
        }
    }, Buffer$1.prototype.toJSON = function() {
      return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
    };
    const a = 4096;
    function asciiSlice(t2, e2, r2) {
      let n2 = "";
      r2 = Math.min(t2.length, r2);
      for (let i2 = e2; i2 < r2; ++i2)
        n2 += String.fromCharCode(127 & t2[i2]);
      return n2;
    }
    function latin1Slice(t2, e2, r2) {
      let n2 = "";
      r2 = Math.min(t2.length, r2);
      for (let i2 = e2; i2 < r2; ++i2)
        n2 += String.fromCharCode(t2[i2]);
      return n2;
    }
    function hexSlice(t2, e2, r2) {
      const n2 = t2.length;
      (!e2 || e2 < 0) && (e2 = 0), (!r2 || r2 < 0 || r2 > n2) && (r2 = n2);
      let i2 = "";
      for (let n3 = e2; n3 < r2; ++n3)
        i2 += p[t2[n3]];
      return i2;
    }
    function utf16leSlice(t2, e2, r2) {
      const n2 = t2.slice(e2, r2);
      let i2 = "";
      for (let t3 = 0; t3 < n2.length - 1; t3 += 2)
        i2 += String.fromCharCode(n2[t3] + 256 * n2[t3 + 1]);
      return i2;
    }
    function checkOffset(t2, e2, r2) {
      if (t2 % 1 != 0 || t2 < 0)
        throw new RangeError("offset is not uint");
      if (t2 + e2 > r2)
        throw new RangeError("Trying to access beyond buffer length");
    }
    function checkInt(t2, e2, r2, n2, i2, o2) {
      if (!Buffer$1.isBuffer(t2))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (e2 > i2 || e2 < o2)
        throw new RangeError('"value" argument is out of bounds');
      if (r2 + n2 > t2.length)
        throw new RangeError("Index out of range");
    }
    function wrtBigUInt64LE(t2, e2, r2, n2, i2) {
      checkIntBI(e2, n2, i2, t2, r2, 7);
      let o2 = Number(e2 & BigInt(4294967295));
      t2[r2++] = o2, o2 >>= 8, t2[r2++] = o2, o2 >>= 8, t2[r2++] = o2, o2 >>= 8, t2[r2++] = o2;
      let a2 = Number(e2 >> BigInt(32) & BigInt(4294967295));
      return t2[r2++] = a2, a2 >>= 8, t2[r2++] = a2, a2 >>= 8, t2[r2++] = a2, a2 >>= 8, t2[r2++] = a2, r2;
    }
    function wrtBigUInt64BE(t2, e2, r2, n2, i2) {
      checkIntBI(e2, n2, i2, t2, r2, 7);
      let o2 = Number(e2 & BigInt(4294967295));
      t2[r2 + 7] = o2, o2 >>= 8, t2[r2 + 6] = o2, o2 >>= 8, t2[r2 + 5] = o2, o2 >>= 8, t2[r2 + 4] = o2;
      let a2 = Number(e2 >> BigInt(32) & BigInt(4294967295));
      return t2[r2 + 3] = a2, a2 >>= 8, t2[r2 + 2] = a2, a2 >>= 8, t2[r2 + 1] = a2, a2 >>= 8, t2[r2] = a2, r2 + 8;
    }
    function checkIEEE754(t2, e2, r2, n2, i2, o2) {
      if (r2 + n2 > t2.length)
        throw new RangeError("Index out of range");
      if (r2 < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(t2, e2, r2, n2, i2) {
      return e2 = +e2, r2 >>>= 0, i2 || checkIEEE754(t2, 0, r2, 4), write(t2, e2, r2, n2, 23, 4), r2 + 4;
    }
    function writeDouble(t2, e2, r2, n2, i2) {
      return e2 = +e2, r2 >>>= 0, i2 || checkIEEE754(t2, 0, r2, 8), write(t2, e2, r2, n2, 52, 8), r2 + 8;
    }
    Buffer$1.prototype.slice = function(t2, e2) {
      const r2 = this.length;
      (t2 = Math.trunc(t2)) < 0 ? (t2 += r2) < 0 && (t2 = 0) : t2 > r2 && (t2 = r2), (e2 = void 0 === e2 ? r2 : Math.trunc(e2)) < 0 ? (e2 += r2) < 0 && (e2 = 0) : e2 > r2 && (e2 = r2), e2 < t2 && (e2 = t2);
      const n2 = this.subarray(t2, e2);
      return Object.setPrototypeOf(n2, Buffer$1.prototype), n2;
    }, Buffer$1.prototype.readUintLE = Buffer$1.prototype.readUIntLE = function(t2, e2, r2) {
      t2 >>>= 0, e2 >>>= 0, r2 || checkOffset(t2, e2, this.length);
      let n2 = this[t2], i2 = 1, o2 = 0;
      for (; ++o2 < e2 && (i2 *= 256); )
        n2 += this[t2 + o2] * i2;
      return n2;
    }, Buffer$1.prototype.readUintBE = Buffer$1.prototype.readUIntBE = function(t2, e2, r2) {
      t2 >>>= 0, e2 >>>= 0, r2 || checkOffset(t2, e2, this.length);
      let n2 = this[t2 + --e2], i2 = 1;
      for (; e2 > 0 && (i2 *= 256); )
        n2 += this[t2 + --e2] * i2;
      return n2;
    }, Buffer$1.prototype.readUint8 = Buffer$1.prototype.readUInt8 = function(t2, e2) {
      return t2 >>>= 0, e2 || checkOffset(t2, 1, this.length), this[t2];
    }, Buffer$1.prototype.readUint16LE = Buffer$1.prototype.readUInt16LE = function(t2, e2) {
      return t2 >>>= 0, e2 || checkOffset(t2, 2, this.length), this[t2] | this[t2 + 1] << 8;
    }, Buffer$1.prototype.readUint16BE = Buffer$1.prototype.readUInt16BE = function(t2, e2) {
      return t2 >>>= 0, e2 || checkOffset(t2, 2, this.length), this[t2] << 8 | this[t2 + 1];
    }, Buffer$1.prototype.readUint32LE = Buffer$1.prototype.readUInt32LE = function(t2, e2) {
      return t2 >>>= 0, e2 || checkOffset(t2, 4, this.length), (this[t2] | this[t2 + 1] << 8 | this[t2 + 2] << 16) + 16777216 * this[t2 + 3];
    }, Buffer$1.prototype.readUint32BE = Buffer$1.prototype.readUInt32BE = function(t2, e2) {
      return t2 >>>= 0, e2 || checkOffset(t2, 4, this.length), 16777216 * this[t2] + (this[t2 + 1] << 16 | this[t2 + 2] << 8 | this[t2 + 3]);
    }, Buffer$1.prototype.readBigUInt64LE = defineBigIntMethod(function(t2) {
      validateNumber(t2 >>>= 0, "offset");
      const e2 = this[t2], r2 = this[t2 + 7];
      void 0 !== e2 && void 0 !== r2 || boundsError(t2, this.length - 8);
      const n2 = e2 + 256 * this[++t2] + 65536 * this[++t2] + this[++t2] * 2 ** 24, i2 = this[++t2] + 256 * this[++t2] + 65536 * this[++t2] + r2 * 2 ** 24;
      return BigInt(n2) + (BigInt(i2) << BigInt(32));
    }), Buffer$1.prototype.readBigUInt64BE = defineBigIntMethod(function(t2) {
      validateNumber(t2 >>>= 0, "offset");
      const e2 = this[t2], r2 = this[t2 + 7];
      void 0 !== e2 && void 0 !== r2 || boundsError(t2, this.length - 8);
      const n2 = e2 * 2 ** 24 + 65536 * this[++t2] + 256 * this[++t2] + this[++t2], i2 = this[++t2] * 2 ** 24 + 65536 * this[++t2] + 256 * this[++t2] + r2;
      return (BigInt(n2) << BigInt(32)) + BigInt(i2);
    }), Buffer$1.prototype.readIntLE = function(t2, e2, r2) {
      t2 >>>= 0, e2 >>>= 0, r2 || checkOffset(t2, e2, this.length);
      let n2 = this[t2], i2 = 1, o2 = 0;
      for (; ++o2 < e2 && (i2 *= 256); )
        n2 += this[t2 + o2] * i2;
      return i2 *= 128, n2 >= i2 && (n2 -= Math.pow(2, 8 * e2)), n2;
    }, Buffer$1.prototype.readIntBE = function(t2, e2, r2) {
      t2 >>>= 0, e2 >>>= 0, r2 || checkOffset(t2, e2, this.length);
      let n2 = e2, i2 = 1, o2 = this[t2 + --n2];
      for (; n2 > 0 && (i2 *= 256); )
        o2 += this[t2 + --n2] * i2;
      return i2 *= 128, o2 >= i2 && (o2 -= Math.pow(2, 8 * e2)), o2;
    }, Buffer$1.prototype.readInt8 = function(t2, e2) {
      return t2 >>>= 0, e2 || checkOffset(t2, 1, this.length), 128 & this[t2] ? -1 * (255 - this[t2] + 1) : this[t2];
    }, Buffer$1.prototype.readInt16LE = function(t2, e2) {
      t2 >>>= 0, e2 || checkOffset(t2, 2, this.length);
      const r2 = this[t2] | this[t2 + 1] << 8;
      return 32768 & r2 ? 4294901760 | r2 : r2;
    }, Buffer$1.prototype.readInt16BE = function(t2, e2) {
      t2 >>>= 0, e2 || checkOffset(t2, 2, this.length);
      const r2 = this[t2 + 1] | this[t2] << 8;
      return 32768 & r2 ? 4294901760 | r2 : r2;
    }, Buffer$1.prototype.readInt32LE = function(t2, e2) {
      return t2 >>>= 0, e2 || checkOffset(t2, 4, this.length), this[t2] | this[t2 + 1] << 8 | this[t2 + 2] << 16 | this[t2 + 3] << 24;
    }, Buffer$1.prototype.readInt32BE = function(t2, e2) {
      return t2 >>>= 0, e2 || checkOffset(t2, 4, this.length), this[t2] << 24 | this[t2 + 1] << 16 | this[t2 + 2] << 8 | this[t2 + 3];
    }, Buffer$1.prototype.readBigInt64LE = defineBigIntMethod(function(t2) {
      validateNumber(t2 >>>= 0, "offset");
      const e2 = this[t2], r2 = this[t2 + 7];
      void 0 !== e2 && void 0 !== r2 || boundsError(t2, this.length - 8);
      const n2 = this[t2 + 4] + 256 * this[t2 + 5] + 65536 * this[t2 + 6] + (r2 << 24);
      return (BigInt(n2) << BigInt(32)) + BigInt(e2 + 256 * this[++t2] + 65536 * this[++t2] + this[++t2] * 2 ** 24);
    }), Buffer$1.prototype.readBigInt64BE = defineBigIntMethod(function(t2) {
      validateNumber(t2 >>>= 0, "offset");
      const e2 = this[t2], r2 = this[t2 + 7];
      void 0 !== e2 && void 0 !== r2 || boundsError(t2, this.length - 8);
      const n2 = (e2 << 24) + 65536 * this[++t2] + 256 * this[++t2] + this[++t2];
      return (BigInt(n2) << BigInt(32)) + BigInt(this[++t2] * 2 ** 24 + 65536 * this[++t2] + 256 * this[++t2] + r2);
    }), Buffer$1.prototype.readFloatLE = function(t2, e2) {
      return t2 >>>= 0, e2 || checkOffset(t2, 4, this.length), read(this, t2, true, 23, 4);
    }, Buffer$1.prototype.readFloatBE = function(t2, e2) {
      return t2 >>>= 0, e2 || checkOffset(t2, 4, this.length), read(this, t2, false, 23, 4);
    }, Buffer$1.prototype.readDoubleLE = function(t2, e2) {
      return t2 >>>= 0, e2 || checkOffset(t2, 8, this.length), read(this, t2, true, 52, 8);
    }, Buffer$1.prototype.readDoubleBE = function(t2, e2) {
      return t2 >>>= 0, e2 || checkOffset(t2, 8, this.length), read(this, t2, false, 52, 8);
    }, Buffer$1.prototype.writeUintLE = Buffer$1.prototype.writeUIntLE = function(t2, e2, r2, n2) {
      if (t2 = +t2, e2 >>>= 0, r2 >>>= 0, !n2) {
        checkInt(this, t2, e2, r2, Math.pow(2, 8 * r2) - 1, 0);
      }
      let i2 = 1, o2 = 0;
      for (this[e2] = 255 & t2; ++o2 < r2 && (i2 *= 256); )
        this[e2 + o2] = t2 / i2 & 255;
      return e2 + r2;
    }, Buffer$1.prototype.writeUintBE = Buffer$1.prototype.writeUIntBE = function(t2, e2, r2, n2) {
      if (t2 = +t2, e2 >>>= 0, r2 >>>= 0, !n2) {
        checkInt(this, t2, e2, r2, Math.pow(2, 8 * r2) - 1, 0);
      }
      let i2 = r2 - 1, o2 = 1;
      for (this[e2 + i2] = 255 & t2; --i2 >= 0 && (o2 *= 256); )
        this[e2 + i2] = t2 / o2 & 255;
      return e2 + r2;
    }, Buffer$1.prototype.writeUint8 = Buffer$1.prototype.writeUInt8 = function(t2, e2, r2) {
      return t2 = +t2, e2 >>>= 0, r2 || checkInt(this, t2, e2, 1, 255, 0), this[e2] = 255 & t2, e2 + 1;
    }, Buffer$1.prototype.writeUint16LE = Buffer$1.prototype.writeUInt16LE = function(t2, e2, r2) {
      return t2 = +t2, e2 >>>= 0, r2 || checkInt(this, t2, e2, 2, 65535, 0), this[e2] = 255 & t2, this[e2 + 1] = t2 >>> 8, e2 + 2;
    }, Buffer$1.prototype.writeUint16BE = Buffer$1.prototype.writeUInt16BE = function(t2, e2, r2) {
      return t2 = +t2, e2 >>>= 0, r2 || checkInt(this, t2, e2, 2, 65535, 0), this[e2] = t2 >>> 8, this[e2 + 1] = 255 & t2, e2 + 2;
    }, Buffer$1.prototype.writeUint32LE = Buffer$1.prototype.writeUInt32LE = function(t2, e2, r2) {
      return t2 = +t2, e2 >>>= 0, r2 || checkInt(this, t2, e2, 4, 4294967295, 0), this[e2 + 3] = t2 >>> 24, this[e2 + 2] = t2 >>> 16, this[e2 + 1] = t2 >>> 8, this[e2] = 255 & t2, e2 + 4;
    }, Buffer$1.prototype.writeUint32BE = Buffer$1.prototype.writeUInt32BE = function(t2, e2, r2) {
      return t2 = +t2, e2 >>>= 0, r2 || checkInt(this, t2, e2, 4, 4294967295, 0), this[e2] = t2 >>> 24, this[e2 + 1] = t2 >>> 16, this[e2 + 2] = t2 >>> 8, this[e2 + 3] = 255 & t2, e2 + 4;
    }, Buffer$1.prototype.writeBigUInt64LE = defineBigIntMethod(function(t2, e2 = 0) {
      return wrtBigUInt64LE(this, t2, e2, BigInt(0), BigInt("0xffffffffffffffff"));
    }), Buffer$1.prototype.writeBigUInt64BE = defineBigIntMethod(function(t2, e2 = 0) {
      return wrtBigUInt64BE(this, t2, e2, BigInt(0), BigInt("0xffffffffffffffff"));
    }), Buffer$1.prototype.writeIntLE = function(t2, e2, r2, n2) {
      if (t2 = +t2, e2 >>>= 0, !n2) {
        const n3 = Math.pow(2, 8 * r2 - 1);
        checkInt(this, t2, e2, r2, n3 - 1, -n3);
      }
      let i2 = 0, o2 = 1, a2 = 0;
      for (this[e2] = 255 & t2; ++i2 < r2 && (o2 *= 256); )
        t2 < 0 && 0 === a2 && 0 !== this[e2 + i2 - 1] && (a2 = 1), this[e2 + i2] = Math.trunc(t2 / o2) - a2 & 255;
      return e2 + r2;
    }, Buffer$1.prototype.writeIntBE = function(t2, e2, r2, n2) {
      if (t2 = +t2, e2 >>>= 0, !n2) {
        const n3 = Math.pow(2, 8 * r2 - 1);
        checkInt(this, t2, e2, r2, n3 - 1, -n3);
      }
      let i2 = r2 - 1, o2 = 1, a2 = 0;
      for (this[e2 + i2] = 255 & t2; --i2 >= 0 && (o2 *= 256); )
        t2 < 0 && 0 === a2 && 0 !== this[e2 + i2 + 1] && (a2 = 1), this[e2 + i2] = Math.trunc(t2 / o2) - a2 & 255;
      return e2 + r2;
    }, Buffer$1.prototype.writeInt8 = function(t2, e2, r2) {
      return t2 = +t2, e2 >>>= 0, r2 || checkInt(this, t2, e2, 1, 127, -128), t2 < 0 && (t2 = 255 + t2 + 1), this[e2] = 255 & t2, e2 + 1;
    }, Buffer$1.prototype.writeInt16LE = function(t2, e2, r2) {
      return t2 = +t2, e2 >>>= 0, r2 || checkInt(this, t2, e2, 2, 32767, -32768), this[e2] = 255 & t2, this[e2 + 1] = t2 >>> 8, e2 + 2;
    }, Buffer$1.prototype.writeInt16BE = function(t2, e2, r2) {
      return t2 = +t2, e2 >>>= 0, r2 || checkInt(this, t2, e2, 2, 32767, -32768), this[e2] = t2 >>> 8, this[e2 + 1] = 255 & t2, e2 + 2;
    }, Buffer$1.prototype.writeInt32LE = function(t2, e2, r2) {
      return t2 = +t2, e2 >>>= 0, r2 || checkInt(this, t2, e2, 4, 2147483647, -2147483648), this[e2] = 255 & t2, this[e2 + 1] = t2 >>> 8, this[e2 + 2] = t2 >>> 16, this[e2 + 3] = t2 >>> 24, e2 + 4;
    }, Buffer$1.prototype.writeInt32BE = function(t2, e2, r2) {
      return t2 = +t2, e2 >>>= 0, r2 || checkInt(this, t2, e2, 4, 2147483647, -2147483648), t2 < 0 && (t2 = 4294967295 + t2 + 1), this[e2] = t2 >>> 24, this[e2 + 1] = t2 >>> 16, this[e2 + 2] = t2 >>> 8, this[e2 + 3] = 255 & t2, e2 + 4;
    }, Buffer$1.prototype.writeBigInt64LE = defineBigIntMethod(function(t2, e2 = 0) {
      return wrtBigUInt64LE(this, t2, e2, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    }), Buffer$1.prototype.writeBigInt64BE = defineBigIntMethod(function(t2, e2 = 0) {
      return wrtBigUInt64BE(this, t2, e2, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    }), Buffer$1.prototype.writeFloatLE = function(t2, e2, r2) {
      return writeFloat(this, t2, e2, true, r2);
    }, Buffer$1.prototype.writeFloatBE = function(t2, e2, r2) {
      return writeFloat(this, t2, e2, false, r2);
    }, Buffer$1.prototype.writeDoubleLE = function(t2, e2, r2) {
      return writeDouble(this, t2, e2, true, r2);
    }, Buffer$1.prototype.writeDoubleBE = function(t2, e2, r2) {
      return writeDouble(this, t2, e2, false, r2);
    }, Buffer$1.prototype.copy = function(t2, e2, r2, n2) {
      if (!Buffer$1.isBuffer(t2))
        throw new TypeError("argument should be a Buffer");
      if (r2 || (r2 = 0), n2 || 0 === n2 || (n2 = this.length), e2 >= t2.length && (e2 = t2.length), e2 || (e2 = 0), n2 > 0 && n2 < r2 && (n2 = r2), n2 === r2)
        return 0;
      if (0 === t2.length || 0 === this.length)
        return 0;
      if (e2 < 0)
        throw new RangeError("targetStart out of bounds");
      if (r2 < 0 || r2 >= this.length)
        throw new RangeError("Index out of range");
      if (n2 < 0)
        throw new RangeError("sourceEnd out of bounds");
      n2 > this.length && (n2 = this.length), t2.length - e2 < n2 - r2 && (n2 = t2.length - e2 + r2);
      const i2 = n2 - r2;
      return this === t2 && "function" == typeof Uint8Array.prototype.copyWithin ? this.copyWithin(e2, r2, n2) : Uint8Array.prototype.set.call(t2, this.subarray(r2, n2), e2), i2;
    }, Buffer$1.prototype.fill = function(t2, e2, r2, n2) {
      if ("string" == typeof t2) {
        if ("string" == typeof e2 ? (n2 = e2, e2 = 0, r2 = this.length) : "string" == typeof r2 && (n2 = r2, r2 = this.length), void 0 !== n2 && "string" != typeof n2)
          throw new TypeError("encoding must be a string");
        if ("string" == typeof n2 && !Buffer$1.isEncoding(n2))
          throw new TypeError("Unknown encoding: " + n2);
        if (1 === t2.length) {
          const e3 = t2.charCodeAt(0);
          ("utf8" === n2 && e3 < 128 || "latin1" === n2) && (t2 = e3);
        }
      } else
        "number" == typeof t2 ? t2 &= 255 : "boolean" == typeof t2 && (t2 = Number(t2));
      if (e2 < 0 || this.length < e2 || this.length < r2)
        throw new RangeError("Out of range index");
      if (r2 <= e2)
        return this;
      let i2;
      if (e2 >>>= 0, r2 = void 0 === r2 ? this.length : r2 >>> 0, t2 || (t2 = 0), "number" == typeof t2)
        for (i2 = e2; i2 < r2; ++i2)
          this[i2] = t2;
      else {
        const o2 = Buffer$1.isBuffer(t2) ? t2 : Buffer$1.from(t2, n2), a2 = o2.length;
        if (0 === a2)
          throw new TypeError('The value "' + t2 + '" is invalid for argument "value"');
        for (i2 = 0; i2 < r2 - e2; ++i2)
          this[i2 + e2] = o2[i2 % a2];
      }
      return this;
    };
    const s = {};
    function E(t2, e2, r2) {
      s[t2] = class extends r2 {
        constructor() {
          super(), Object.defineProperty(this, "message", { value: Reflect.apply(e2, this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${t2}]`, this.stack, delete this.name;
        }
        get code() {
          return t2;
        }
        set code(t3) {
          Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: t3, writable: true });
        }
        toString() {
          return `${this.name} [${t2}]: ${this.message}`;
        }
      };
    }
    function addNumericalSeparator(t2) {
      let e2 = "", r2 = t2.length;
      const n2 = "-" === t2[0] ? 1 : 0;
      for (; r2 >= n2 + 4; r2 -= 3)
        e2 = `_${t2.slice(r2 - 3, r2)}${e2}`;
      return `${t2.slice(0, r2)}${e2}`;
    }
    function checkIntBI(t2, e2, r2, n2, i2, o2) {
      if (t2 > r2 || t2 < e2) {
        const n3 = "bigint" == typeof e2 ? "n" : "";
        let i3;
        throw i3 = o2 > 3 ? 0 === e2 || e2 === BigInt(0) ? `>= 0${n3} and < 2${n3} ** ${8 * (o2 + 1)}${n3}` : `>= -(2${n3} ** ${8 * (o2 + 1) - 1}${n3}) and < 2 ** ${8 * (o2 + 1) - 1}${n3}` : `>= ${e2}${n3} and <= ${r2}${n3}`, new s.ERR_OUT_OF_RANGE("value", i3, t2);
      }
      !function(t3, e3, r3) {
        validateNumber(e3, "offset"), void 0 !== t3[e3] && void 0 !== t3[e3 + r3] || boundsError(e3, t3.length - (r3 + 1));
      }(n2, i2, o2);
    }
    function validateNumber(t2, e2) {
      if ("number" != typeof t2)
        throw new s.ERR_INVALID_ARG_TYPE(e2, "number", t2);
    }
    function boundsError(t2, e2, r2) {
      if (Math.floor(t2) !== t2)
        throw validateNumber(t2, r2), new s.ERR_OUT_OF_RANGE(r2 || "offset", "an integer", t2);
      if (e2 < 0)
        throw new s.ERR_BUFFER_OUT_OF_BOUNDS();
      throw new s.ERR_OUT_OF_RANGE(r2 || "offset", `>= ${r2 ? 1 : 0} and <= ${e2}`, t2);
    }
    E("ERR_BUFFER_OUT_OF_BOUNDS", function(t2) {
      return t2 ? `${t2} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    }, RangeError), E("ERR_INVALID_ARG_TYPE", function(t2, e2) {
      return `The "${t2}" argument must be of type number. Received type ${typeof e2}`;
    }, TypeError), E("ERR_OUT_OF_RANGE", function(t2, e2, r2) {
      let n2 = `The value of "${t2}" is out of range.`, i2 = r2;
      return Number.isInteger(r2) && Math.abs(r2) > 2 ** 32 ? i2 = addNumericalSeparator(String(r2)) : "bigint" == typeof r2 && (i2 = String(r2), (r2 > BigInt(2) ** BigInt(32) || r2 < -(BigInt(2) ** BigInt(32))) && (i2 = addNumericalSeparator(i2)), i2 += "n"), n2 += ` It must be ${e2}. Received ${i2}`, n2;
    }, RangeError);
    const l = /[^\w+/-]/g;
    function utf8ToBytes(t2, e2) {
      let r2;
      e2 = e2 || Number.POSITIVE_INFINITY;
      const n2 = t2.length;
      let i2 = null;
      const o2 = [];
      for (let a2 = 0; a2 < n2; ++a2) {
        if (r2 = t2.charCodeAt(a2), r2 > 55295 && r2 < 57344) {
          if (!i2) {
            if (r2 > 56319) {
              (e2 -= 3) > -1 && o2.push(239, 191, 189);
              continue;
            }
            if (a2 + 1 === n2) {
              (e2 -= 3) > -1 && o2.push(239, 191, 189);
              continue;
            }
            i2 = r2;
            continue;
          }
          if (r2 < 56320) {
            (e2 -= 3) > -1 && o2.push(239, 191, 189), i2 = r2;
            continue;
          }
          r2 = 65536 + (i2 - 55296 << 10 | r2 - 56320);
        } else
          i2 && (e2 -= 3) > -1 && o2.push(239, 191, 189);
        if (i2 = null, r2 < 128) {
          if ((e2 -= 1) < 0)
            break;
          o2.push(r2);
        } else if (r2 < 2048) {
          if ((e2 -= 2) < 0)
            break;
          o2.push(r2 >> 6 | 192, 63 & r2 | 128);
        } else if (r2 < 65536) {
          if ((e2 -= 3) < 0)
            break;
          o2.push(r2 >> 12 | 224, r2 >> 6 & 63 | 128, 63 & r2 | 128);
        } else {
          if (!(r2 < 1114112))
            throw new Error("Invalid code point");
          if ((e2 -= 4) < 0)
            break;
          o2.push(r2 >> 18 | 240, r2 >> 12 & 63 | 128, r2 >> 6 & 63 | 128, 63 & r2 | 128);
        }
      }
      return o2;
    }
    function base64ToBytes(t2) {
      return toByteArray(function(t3) {
        if ((t3 = (t3 = t3.split("=")[0]).trim().replace(l, "")).length < 2)
          return "";
        for (; t3.length % 4 != 0; )
          t3 += "=";
        return t3;
      }(t2));
    }
    function blitBuffer(t2, e2, r2, n2) {
      let i2;
      for (i2 = 0; i2 < n2 && !(i2 + r2 >= e2.length || i2 >= t2.length); ++i2)
        e2[i2 + r2] = t2[i2];
      return i2;
    }
    function isInstance(t2, e2) {
      return t2 instanceof e2 || null != t2 && null != t2.constructor && null != t2.constructor.name && t2.constructor.name === e2.name;
    }
    function numberIsNaN(t2) {
      return t2 != t2;
    }
    const p = function() {
      const t2 = "0123456789abcdef", e2 = Array.from({ length: 256 });
      for (let r2 = 0; r2 < 16; ++r2) {
        const n2 = 16 * r2;
        for (let i2 = 0; i2 < 16; ++i2)
          e2[n2 + i2] = t2[r2] + t2[i2];
      }
      return e2;
    }();
    function defineBigIntMethod(t2) {
      return "undefined" == typeof BigInt ? BufferBigIntNotDefined : t2;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
    const c = globalThis.Buffer || Buffer$1;
    notImplemented("buffer.resolveObjectURL"), notImplemented("buffer.transcode"), notImplemented("buffer.isUtf8"), notImplemented("buffer.isAscii");
    const d = {};
    let m, u;
    function defaultSetTimeout() {
      throw new Error("setTimeout has not been defined");
    }
    function defaultClearTimeout() {
      throw new Error("clearTimeout has not been defined");
    }
    function runTimeout(t2) {
      if (m === setTimeout)
        return setTimeout(t2, 0);
      if ((m === defaultSetTimeout || !m) && setTimeout)
        return m = setTimeout, setTimeout(t2, 0);
      try {
        return m(t2, 0);
      } catch {
        try {
          return m.call(null, t2, 0);
        } catch {
          return m.call(this, t2, 0);
        }
      }
    }
    !function() {
      try {
        m = "function" == typeof setTimeout ? setTimeout : defaultSetTimeout;
      } catch {
        m = defaultSetTimeout;
      }
      try {
        u = "function" == typeof clearTimeout ? clearTimeout : defaultClearTimeout;
      } catch {
        u = defaultClearTimeout;
      }
    }();
    let h, g = [], x = false, v = -1;
    function cleanUpNextTick() {
      x && h && (x = false, h.length > 0 ? g = [...h, ...g] : v = -1, g.length > 0 && drainQueue());
    }
    function drainQueue() {
      if (x)
        return;
      const t2 = runTimeout(cleanUpNextTick);
      x = true;
      let e2 = g.length;
      for (; e2; ) {
        for (h = g, g = []; ++v < e2; )
          h && h[v].run();
        v = -1, e2 = g.length;
      }
      h = null, x = false, function(t3) {
        if (u === clearTimeout)
          return clearTimeout(t3);
        if ((u === defaultClearTimeout || !u) && clearTimeout)
          return u = clearTimeout, clearTimeout(t3);
        try {
          return u(t3);
        } catch {
          try {
            return u.call(null, t3);
          } catch {
            return u.call(this, t3);
          }
        }
      }(t2);
    }
    function Item(t2, e2) {
      this.fun = t2, this.array = e2;
    }
    d.nextTick = function(t2) {
      const e2 = Array.from({ length: arguments.length - 1 });
      if (arguments.length > 1)
        for (let t3 = 1; t3 < arguments.length; t3++)
          e2[t3 - 1] = arguments[t3];
      g.push(new Item(t2, e2)), 1 !== g.length || x || runTimeout(drainQueue);
    }, Item.prototype.run = function() {
      this.fun.apply(null, this.array);
    }, d.title = "unenv";
    const y = /* @__PURE__ */ Object.create(null), b = globalThis.process?.env, _getEnv$1 = (t2) => b || globalThis.__env__ || (t2 ? y : globalThis);
    function noop$2() {
      return d;
    }
    d.env = new Proxy(y, { get: (t2, e2) => _getEnv$1()[e2] ?? y[e2], has: (t2, e2) => e2 in _getEnv$1() || e2 in y, set: (t2, e2, r2) => (_getEnv$1(true)[e2] = r2, true), deleteProperty(t2, e2) {
      delete _getEnv$1(true)[e2];
    }, ownKeys() {
      const t2 = _getEnv$1();
      return Object.keys(t2);
    } }), d.argv = [], d.version = "", d.versions = {}, d.on = noop$2, d.addListener = noop$2, d.once = noop$2, d.off = noop$2, d.removeListener = noop$2, d.removeAllListeners = noop$2, d.emit = noop$2, d.prependListener = noop$2, d.prependOnceListener = noop$2, d.listeners = function(t2) {
      return [];
    }, d.binding = function(t2) {
      throw new Error("[unenv] process.binding is not supported");
    };
    let w = "/";
    d.cwd = function() {
      return w;
    }, d.chdir = function(t2) {
      w = t2;
    }, d.umask = function() {
      return 0;
    };
    const k = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof global ? global : {};
    k.process = k.process || d;
    const S = k.process;
    var C = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {}, _ = {}, P = { exports: {} };
    function Mime$1() {
      this._types = /* @__PURE__ */ Object.create(null), this._extensions = /* @__PURE__ */ Object.create(null);
      for (let t2 = 0; t2 < arguments.length; t2++)
        this.define(arguments[t2]);
      this.define = this.define.bind(this), this.getType = this.getType.bind(this), this.getExtension = this.getExtension.bind(this);
    }
    Mime$1.prototype.define = function(t2, e2) {
      for (let r2 in t2) {
        let n2 = t2[r2].map(function(t3) {
          return t3.toLowerCase();
        });
        r2 = r2.toLowerCase();
        for (let t3 = 0; t3 < n2.length; t3++) {
          const i2 = n2[t3];
          if ("*" !== i2[0]) {
            if (!e2 && i2 in this._types)
              throw new Error('Attempt to change mapping for "' + i2 + '" extension from "' + this._types[i2] + '" to "' + r2 + '". Pass `force=true` to allow this, otherwise remove "' + i2 + '" from the list of extensions for "' + r2 + '".');
            this._types[i2] = r2;
          }
        }
        if (e2 || !this._extensions[r2]) {
          const t3 = n2[0];
          this._extensions[r2] = "*" !== t3[0] ? t3 : t3.substr(1);
        }
      }
    }, Mime$1.prototype.getType = function(t2) {
      let e2 = (t2 = String(t2)).replace(/^.*[/\\]/, "").toLowerCase(), r2 = e2.replace(/^.*\./, "").toLowerCase(), n2 = e2.length < t2.length;
      return (r2.length < e2.length - 1 || !n2) && this._types[r2] || null;
    }, Mime$1.prototype.getExtension = function(t2) {
      return (t2 = /^\s*([^;\s]*)/.test(t2) && RegExp.$1) && this._extensions[t2.toLowerCase()] || null;
    };
    var T, A = new Mime$1({ "application/andrew-inset": ["ez"], "application/applixware": ["aw"], "application/atom+xml": ["atom"], "application/atomcat+xml": ["atomcat"], "application/atomdeleted+xml": ["atomdeleted"], "application/atomsvc+xml": ["atomsvc"], "application/atsc-dwd+xml": ["dwd"], "application/atsc-held+xml": ["held"], "application/atsc-rsat+xml": ["rsat"], "application/bdoc": ["bdoc"], "application/calendar+xml": ["xcs"], "application/ccxml+xml": ["ccxml"], "application/cdfx+xml": ["cdfx"], "application/cdmi-capability": ["cdmia"], "application/cdmi-container": ["cdmic"], "application/cdmi-domain": ["cdmid"], "application/cdmi-object": ["cdmio"], "application/cdmi-queue": ["cdmiq"], "application/cu-seeme": ["cu"], "application/dash+xml": ["mpd"], "application/davmount+xml": ["davmount"], "application/docbook+xml": ["dbk"], "application/dssc+der": ["dssc"], "application/dssc+xml": ["xdssc"], "application/ecmascript": ["es", "ecma"], "application/emma+xml": ["emma"], "application/emotionml+xml": ["emotionml"], "application/epub+zip": ["epub"], "application/exi": ["exi"], "application/express": ["exp"], "application/fdt+xml": ["fdt"], "application/font-tdpfr": ["pfr"], "application/geo+json": ["geojson"], "application/gml+xml": ["gml"], "application/gpx+xml": ["gpx"], "application/gxf": ["gxf"], "application/gzip": ["gz"], "application/hjson": ["hjson"], "application/hyperstudio": ["stk"], "application/inkml+xml": ["ink", "inkml"], "application/ipfix": ["ipfix"], "application/its+xml": ["its"], "application/java-archive": ["jar", "war", "ear"], "application/java-serialized-object": ["ser"], "application/java-vm": ["class"], "application/javascript": ["js", "mjs"], "application/json": ["json", "map"], "application/json5": ["json5"], "application/jsonml+json": ["jsonml"], "application/ld+json": ["jsonld"], "application/lgr+xml": ["lgr"], "application/lost+xml": ["lostxml"], "application/mac-binhex40": ["hqx"], "application/mac-compactpro": ["cpt"], "application/mads+xml": ["mads"], "application/manifest+json": ["webmanifest"], "application/marc": ["mrc"], "application/marcxml+xml": ["mrcx"], "application/mathematica": ["ma", "nb", "mb"], "application/mathml+xml": ["mathml"], "application/mbox": ["mbox"], "application/mediaservercontrol+xml": ["mscml"], "application/metalink+xml": ["metalink"], "application/metalink4+xml": ["meta4"], "application/mets+xml": ["mets"], "application/mmt-aei+xml": ["maei"], "application/mmt-usd+xml": ["musd"], "application/mods+xml": ["mods"], "application/mp21": ["m21", "mp21"], "application/mp4": ["mp4s", "m4p"], "application/msword": ["doc", "dot"], "application/mxf": ["mxf"], "application/n-quads": ["nq"], "application/n-triples": ["nt"], "application/node": ["cjs"], "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"], "application/oda": ["oda"], "application/oebps-package+xml": ["opf"], "application/ogg": ["ogx"], "application/omdoc+xml": ["omdoc"], "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"], "application/oxps": ["oxps"], "application/p2p-overlay+xml": ["relo"], "application/patch-ops-error+xml": ["xer"], "application/pdf": ["pdf"], "application/pgp-encrypted": ["pgp"], "application/pgp-signature": ["asc", "sig"], "application/pics-rules": ["prf"], "application/pkcs10": ["p10"], "application/pkcs7-mime": ["p7m", "p7c"], "application/pkcs7-signature": ["p7s"], "application/pkcs8": ["p8"], "application/pkix-attr-cert": ["ac"], "application/pkix-cert": ["cer"], "application/pkix-crl": ["crl"], "application/pkix-pkipath": ["pkipath"], "application/pkixcmp": ["pki"], "application/pls+xml": ["pls"], "application/postscript": ["ai", "eps", "ps"], "application/provenance+xml": ["provx"], "application/pskc+xml": ["pskcxml"], "application/raml+yaml": ["raml"], "application/rdf+xml": ["rdf", "owl"], "application/reginfo+xml": ["rif"], "application/relax-ng-compact-syntax": ["rnc"], "application/resource-lists+xml": ["rl"], "application/resource-lists-diff+xml": ["rld"], "application/rls-services+xml": ["rs"], "application/route-apd+xml": ["rapd"], "application/route-s-tsid+xml": ["sls"], "application/route-usd+xml": ["rusd"], "application/rpki-ghostbusters": ["gbr"], "application/rpki-manifest": ["mft"], "application/rpki-roa": ["roa"], "application/rsd+xml": ["rsd"], "application/rss+xml": ["rss"], "application/rtf": ["rtf"], "application/sbml+xml": ["sbml"], "application/scvp-cv-request": ["scq"], "application/scvp-cv-response": ["scs"], "application/scvp-vp-request": ["spq"], "application/scvp-vp-response": ["spp"], "application/sdp": ["sdp"], "application/senml+xml": ["senmlx"], "application/sensml+xml": ["sensmlx"], "application/set-payment-initiation": ["setpay"], "application/set-registration-initiation": ["setreg"], "application/shf+xml": ["shf"], "application/sieve": ["siv", "sieve"], "application/smil+xml": ["smi", "smil"], "application/sparql-query": ["rq"], "application/sparql-results+xml": ["srx"], "application/srgs": ["gram"], "application/srgs+xml": ["grxml"], "application/sru+xml": ["sru"], "application/ssdl+xml": ["ssdl"], "application/ssml+xml": ["ssml"], "application/swid+xml": ["swidtag"], "application/tei+xml": ["tei", "teicorpus"], "application/thraud+xml": ["tfi"], "application/timestamped-data": ["tsd"], "application/toml": ["toml"], "application/trig": ["trig"], "application/ttml+xml": ["ttml"], "application/ubjson": ["ubj"], "application/urc-ressheet+xml": ["rsheet"], "application/urc-targetdesc+xml": ["td"], "application/voicexml+xml": ["vxml"], "application/wasm": ["wasm"], "application/widget": ["wgt"], "application/winhlp": ["hlp"], "application/wsdl+xml": ["wsdl"], "application/wspolicy+xml": ["wspolicy"], "application/xaml+xml": ["xaml"], "application/xcap-att+xml": ["xav"], "application/xcap-caps+xml": ["xca"], "application/xcap-diff+xml": ["xdf"], "application/xcap-el+xml": ["xel"], "application/xcap-ns+xml": ["xns"], "application/xenc+xml": ["xenc"], "application/xhtml+xml": ["xhtml", "xht"], "application/xliff+xml": ["xlf"], "application/xml": ["xml", "xsl", "xsd", "rng"], "application/xml-dtd": ["dtd"], "application/xop+xml": ["xop"], "application/xproc+xml": ["xpl"], "application/xslt+xml": ["*xsl", "xslt"], "application/xspf+xml": ["xspf"], "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"], "application/yang": ["yang"], "application/yin+xml": ["yin"], "application/zip": ["zip"], "audio/3gpp": ["*3gpp"], "audio/adpcm": ["adp"], "audio/amr": ["amr"], "audio/basic": ["au", "snd"], "audio/midi": ["mid", "midi", "kar", "rmi"], "audio/mobile-xmf": ["mxmf"], "audio/mp3": ["*mp3"], "audio/mp4": ["m4a", "mp4a"], "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"], "audio/ogg": ["oga", "ogg", "spx", "opus"], "audio/s3m": ["s3m"], "audio/silk": ["sil"], "audio/wav": ["wav"], "audio/wave": ["*wav"], "audio/webm": ["weba"], "audio/xm": ["xm"], "font/collection": ["ttc"], "font/otf": ["otf"], "font/ttf": ["ttf"], "font/woff": ["woff"], "font/woff2": ["woff2"], "image/aces": ["exr"], "image/apng": ["apng"], "image/avif": ["avif"], "image/bmp": ["bmp"], "image/cgm": ["cgm"], "image/dicom-rle": ["drle"], "image/emf": ["emf"], "image/fits": ["fits"], "image/g3fax": ["g3"], "image/gif": ["gif"], "image/heic": ["heic"], "image/heic-sequence": ["heics"], "image/heif": ["heif"], "image/heif-sequence": ["heifs"], "image/hej2k": ["hej2"], "image/hsj2": ["hsj2"], "image/ief": ["ief"], "image/jls": ["jls"], "image/jp2": ["jp2", "jpg2"], "image/jpeg": ["jpeg", "jpg", "jpe"], "image/jph": ["jph"], "image/jphc": ["jhc"], "image/jpm": ["jpm"], "image/jpx": ["jpx", "jpf"], "image/jxr": ["jxr"], "image/jxra": ["jxra"], "image/jxrs": ["jxrs"], "image/jxs": ["jxs"], "image/jxsc": ["jxsc"], "image/jxsi": ["jxsi"], "image/jxss": ["jxss"], "image/ktx": ["ktx"], "image/ktx2": ["ktx2"], "image/png": ["png"], "image/sgi": ["sgi"], "image/svg+xml": ["svg", "svgz"], "image/t38": ["t38"], "image/tiff": ["tif", "tiff"], "image/tiff-fx": ["tfx"], "image/webp": ["webp"], "image/wmf": ["wmf"], "message/disposition-notification": ["disposition-notification"], "message/global": ["u8msg"], "message/global-delivery-status": ["u8dsn"], "message/global-disposition-notification": ["u8mdn"], "message/global-headers": ["u8hdr"], "message/rfc822": ["eml", "mime"], "model/3mf": ["3mf"], "model/gltf+json": ["gltf"], "model/gltf-binary": ["glb"], "model/iges": ["igs", "iges"], "model/mesh": ["msh", "mesh", "silo"], "model/mtl": ["mtl"], "model/obj": ["obj"], "model/step+xml": ["stpx"], "model/step+zip": ["stpz"], "model/step-xml+zip": ["stpxz"], "model/stl": ["stl"], "model/vrml": ["wrl", "vrml"], "model/x3d+binary": ["*x3db", "x3dbz"], "model/x3d+fastinfoset": ["x3db"], "model/x3d+vrml": ["*x3dv", "x3dvz"], "model/x3d+xml": ["x3d", "x3dz"], "model/x3d-vrml": ["x3dv"], "text/cache-manifest": ["appcache", "manifest"], "text/calendar": ["ics", "ifb"], "text/coffeescript": ["coffee", "litcoffee"], "text/css": ["css"], "text/csv": ["csv"], "text/html": ["html", "htm", "shtml"], "text/jade": ["jade"], "text/jsx": ["jsx"], "text/less": ["less"], "text/markdown": ["markdown", "md"], "text/mathml": ["mml"], "text/mdx": ["mdx"], "text/n3": ["n3"], "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"], "text/richtext": ["rtx"], "text/rtf": ["*rtf"], "text/sgml": ["sgml", "sgm"], "text/shex": ["shex"], "text/slim": ["slim", "slm"], "text/spdx": ["spdx"], "text/stylus": ["stylus", "styl"], "text/tab-separated-values": ["tsv"], "text/troff": ["t", "tr", "roff", "man", "me", "ms"], "text/turtle": ["ttl"], "text/uri-list": ["uri", "uris", "urls"], "text/vcard": ["vcard"], "text/vtt": ["vtt"], "text/xml": ["*xml"], "text/yaml": ["yaml", "yml"], "video/3gpp": ["3gp", "3gpp"], "video/3gpp2": ["3g2"], "video/h261": ["h261"], "video/h263": ["h263"], "video/h264": ["h264"], "video/iso.segment": ["m4s"], "video/jpeg": ["jpgv"], "video/jpm": ["*jpm", "jpgm"], "video/mj2": ["mj2", "mjp2"], "video/mp2t": ["ts"], "video/mp4": ["mp4", "mp4v", "mpg4"], "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"], "video/ogg": ["ogv"], "video/quicktime": ["qt", "mov"], "video/webm": ["webm"] }), I = P.exports;
    Object.defineProperty(I, "__esModule", { value: true });
    const N = { ...((T = A) && T.__esModule ? T : { default: T }).default };
    N.lookup = N.getType, N.extension = N.getExtension;
    const noop$1 = () => {
    };
    N.define = noop$1, N.load = noop$1, N.default_type = "application/octet-stream", N.charsets = { lookup: () => "UTF-8" }, P.exports = N;
    var R = P.exports, O = {};
    Object.defineProperty(O, "__esModule", { value: true }), O.InternalError = O.NotFoundError = O.MethodNotAllowedError = O.KVError = void 0;
    class KVError extends Error {
      constructor(t2, e2 = 500) {
        super(t2), Object.setPrototypeOf(this, new.target.prototype), this.name = KVError.name, this.status = e2;
      }
    }
    O.KVError = KVError;
    O.MethodNotAllowedError = class extends KVError {
      constructor(t2 = "Not a valid request method", e2 = 405) {
        super(t2, e2);
      }
    };
    O.NotFoundError = class extends KVError {
      constructor(t2 = "Not Found", e2 = 404) {
        super(t2, e2);
      }
    };
    O.InternalError = class extends KVError {
      constructor(t2 = "Internal Error in KV Asset Handler", e2 = 500) {
        super(t2, e2);
      }
    }, function(t2) {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.InternalError = t2.NotFoundError = t2.MethodNotAllowedError = t2.serveSinglePageApp = t2.mapRequestToAsset = t2.getAssetFromKV = void 0;
      const e2 = R, r2 = O;
      Object.defineProperty(t2, "MethodNotAllowedError", { enumerable: true, get: function() {
        return r2.MethodNotAllowedError;
      } }), Object.defineProperty(t2, "NotFoundError", { enumerable: true, get: function() {
        return r2.NotFoundError;
      } }), Object.defineProperty(t2, "InternalError", { enumerable: true, get: function() {
        return r2.InternalError;
      } });
      const n2 = { browserTTL: null, edgeTTL: 172800, bypassCache: false }, parseStringAsObject = (t3) => "string" == typeof t3 ? JSON.parse(t3) : t3, i2 = { ASSET_NAMESPACE: "undefined" != typeof __STATIC_CONTENT ? __STATIC_CONTENT : void 0, ASSET_MANIFEST: "undefined" != typeof __STATIC_CONTENT_MANIFEST ? parseStringAsObject(__STATIC_CONTENT_MANIFEST) : {}, cacheControl: n2, defaultMimeType: "text/plain", defaultDocument: "index.html", pathIsEncoded: false, defaultETag: "strong" };
      function assignOptions(t3) {
        return Object.assign({}, i2, t3);
      }
      const mapRequestToAsset = (t3, r3) => {
        r3 = assignOptions(r3);
        const n3 = new URL(t3.url);
        let i3 = n3.pathname;
        return i3.endsWith("/") ? i3 = i3.concat(r3.defaultDocument) : e2.getType(i3) || (i3 = i3.concat("/" + r3.defaultDocument)), n3.pathname = i3, new Request(n3.toString(), t3);
      };
      t2.mapRequestToAsset = mapRequestToAsset, t2.serveSinglePageApp = function(t3, e3) {
        e3 = assignOptions(e3), t3 = mapRequestToAsset(t3, e3);
        const r3 = new URL(t3.url);
        return r3.pathname.endsWith(".html") ? new Request(`${r3.origin}/${e3.defaultDocument}`, t3) : t3;
      };
      t2.getAssetFromKV = async (t3, i3) => {
        i3 = assignOptions(i3);
        const o2 = t3.request, a2 = i3.ASSET_NAMESPACE, s2 = parseStringAsObject(i3.ASSET_MANIFEST);
        if (void 0 === a2)
          throw new r2.InternalError("there is no KV namespace bound to the script");
        const l2 = new URL(o2.url).pathname.replace(/^\/+/, "");
        let p2, c2 = i3.pathIsEncoded;
        if (i3.mapRequestToAsset)
          p2 = i3.mapRequestToAsset(o2);
        else if (s2[l2])
          p2 = o2;
        else if (s2[decodeURIComponent(l2)])
          c2 = true, p2 = o2;
        else {
          const t4 = mapRequestToAsset(o2), e3 = new URL(t4.url).pathname.replace(/^\/+/, "");
          s2[decodeURIComponent(e3)] ? (c2 = true, p2 = t4) : p2 = mapRequestToAsset(o2, i3);
        }
        if (!["GET", "HEAD"].includes(p2.method))
          throw new r2.MethodNotAllowedError(`${p2.method} is not a valid request method`);
        const d2 = new URL(p2.url);
        let m2 = (c2 ? decodeURIComponent(d2.pathname) : d2.pathname).replace(/^\/+/, "");
        const u2 = caches.default;
        let h2 = e2.getType(m2) || i3.defaultMimeType;
        (h2.startsWith("text") || "application/javascript" === h2) && (h2 += "; charset=utf-8");
        let g2 = false;
        void 0 !== s2 && s2[m2] && (m2 = s2[m2], g2 = true);
        let x2 = new Request(`${d2.origin}/${m2}`, o2);
        const v2 = (() => {
          switch (typeof i3.cacheControl) {
            case "function":
              return i3.cacheControl(o2);
            case "object":
              return i3.cacheControl;
            default:
              return n2;
          }
        })(), formatETag = (t4 = m2, e3 = i3.defaultETag) => {
          if (!t4)
            return "";
          switch (e3) {
            case "weak":
              return t4.startsWith("W/") ? t4 : t4.startsWith('"') && t4.endsWith('"') ? `W/${t4}` : `W/"${t4}"`;
            case "strong":
              return t4.startsWith('W/"') && (t4 = t4.replace("W/", "")), t4.endsWith('"') || (t4 = `"${t4}"`), t4;
            default:
              return "";
          }
        };
        i3.cacheControl = Object.assign({}, n2, v2), (i3.cacheControl.bypassCache || null === i3.cacheControl.edgeTTL || "HEAD" == o2.method) && (g2 = false);
        const y2 = "number" == typeof i3.cacheControl.browserTTL;
        let b2 = null;
        if (g2 && (b2 = await u2.match(x2)), b2)
          if (b2.status > 300 && b2.status < 400)
            b2.body && "cancel" in Object.getPrototypeOf(b2.body) && b2.body.cancel(), b2 = new Response(null, b2);
          else {
            let t4 = { headers: new Headers(b2.headers), status: 0, statusText: "" };
            t4.headers.set("cf-cache-status", "HIT"), b2.status ? (t4.status = b2.status, t4.statusText = b2.statusText) : t4.headers.has("Content-Range") ? (t4.status = 206, t4.statusText = "Partial Content") : (t4.status = 200, t4.statusText = "OK"), b2 = new Response(b2.body, t4);
          }
        else {
          const e3 = await a2.get(m2, "arrayBuffer");
          if (null === e3)
            throw new r2.NotFoundError(`could not find ${m2} in your content namespace`);
          b2 = new Response(e3), g2 && (b2.headers.set("Accept-Ranges", "bytes"), b2.headers.set("Content-Length", String(e3.byteLength)), b2.headers.has("etag") || b2.headers.set("etag", formatETag(m2)), b2.headers.set("Cache-Control", `max-age=${i3.cacheControl.edgeTTL}`), t3.waitUntil(u2.put(x2, b2.clone())), b2.headers.set("CF-Cache-Status", "MISS"));
        }
        if (b2.headers.set("Content-Type", h2), 304 === b2.status) {
          let t4 = formatETag(b2.headers.get("etag")), e3 = x2.headers.get("if-none-match"), r3 = b2.headers.get("CF-Cache-Status");
          t4 && (e3 && e3 === t4 && "MISS" === r3 ? b2.headers.set("CF-Cache-Status", "EXPIRED") : b2.headers.set("CF-Cache-Status", "REVALIDATED"), b2.headers.set("etag", formatETag(t4, "weak")));
        }
        return y2 ? b2.headers.set("Cache-Control", `max-age=${i3.cacheControl.browserTTL}`) : b2.headers.delete("Cache-Control"), b2;
      };
    }(_);
    const L = /#/g, M = /&/g, B = /=/g, D = /\+/g, j = /%5e/gi, F = /%60/gi, $ = /%7c/gi, V = /%20/gi;
    function encodeQueryValue$1(t2) {
      return (e2 = "string" == typeof t2 ? t2 : JSON.stringify(t2), encodeURI("" + e2).replace($, "|")).replace(D, "%2B").replace(V, "+").replace(L, "%23").replace(M, "%26").replace(F, "`").replace(j, "^");
      var e2;
    }
    function encodeQueryKey$1(t2) {
      return encodeQueryValue$1(t2).replace(B, "%3D");
    }
    function decode$1(t2 = "") {
      try {
        return decodeURIComponent("" + t2);
      } catch {
        return "" + t2;
      }
    }
    function decodeQueryValue(t2) {
      return decode$1(t2.replace(D, " "));
    }
    function parseQuery$1(t2 = "") {
      const e2 = {};
      "?" === t2[0] && (t2 = t2.slice(1));
      for (const r2 of t2.split("&")) {
        const t3 = r2.match(/([^=]+)=?(.*)/) || [];
        if (t3.length < 2)
          continue;
        const n2 = decode$1(t3[1].replace(D, " "));
        if ("__proto__" === n2 || "constructor" === n2)
          continue;
        const i2 = decodeQueryValue(t3[2] || "");
        void 0 === e2[n2] ? e2[n2] = i2 : Array.isArray(e2[n2]) ? e2[n2].push(i2) : e2[n2] = [e2[n2], i2];
      }
      return e2;
    }
    function stringifyQuery$1(t2) {
      return Object.keys(t2).filter((e2) => void 0 !== t2[e2]).map((e2) => {
        return r2 = e2, "number" != typeof (n2 = t2[e2]) && "boolean" != typeof n2 || (n2 = String(n2)), n2 ? Array.isArray(n2) ? n2.map((t3) => `${encodeQueryKey$1(r2)}=${encodeQueryValue$1(t3)}`).join("&") : `${encodeQueryKey$1(r2)}=${encodeQueryValue$1(n2)}` : encodeQueryKey$1(r2);
        var r2, n2;
      }).filter(Boolean).join("&");
    }
    const z = /^[\s\w\0+.-]{2,}:([/\\]{1,2})/, U = /^[\s\w\0+.-]{2,}:([/\\]{2})?/, H = /^([/\\]\s*){2,}[^/\\]/;
    function hasProtocol(t2, e2 = {}) {
      return "boolean" == typeof e2 && (e2 = { acceptRelative: e2 }), e2.strict ? z.test(t2) : U.test(t2) || !!e2.acceptRelative && H.test(t2);
    }
    const q = /^[\s\0]*(blob|data|javascript|vbscript):$/i;
    const W = /\/$|\/\?|\/#/;
    function hasTrailingSlash(t2 = "", e2) {
      return e2 ? W.test(t2) : t2.endsWith("/");
    }
    function withoutTrailingSlash(t2 = "", e2) {
      if (!e2)
        return (hasTrailingSlash(t2) ? t2.slice(0, -1) : t2) || "/";
      if (!hasTrailingSlash(t2, true))
        return t2 || "/";
      let r2 = t2, n2 = "";
      const i2 = t2.indexOf("#");
      i2 >= 0 && (r2 = t2.slice(0, i2), n2 = t2.slice(i2));
      const [o2, ...a2] = r2.split("?");
      return (o2.slice(0, -1) || "/") + (a2.length > 0 ? `?${a2.join("?")}` : "") + n2;
    }
    function withTrailingSlash(t2 = "", e2) {
      if (!e2)
        return t2.endsWith("/") ? t2 : t2 + "/";
      if (hasTrailingSlash(t2, true))
        return t2 || "/";
      let r2 = t2, n2 = "";
      const i2 = t2.indexOf("#");
      if (i2 >= 0 && (r2 = t2.slice(0, i2), n2 = t2.slice(i2), !r2))
        return n2;
      const [o2, ...a2] = r2.split("?");
      return o2 + "/" + (a2.length > 0 ? `?${a2.join("?")}` : "") + n2;
    }
    function withLeadingSlash(t2 = "") {
      return function(t3 = "") {
        return t3.startsWith("/");
      }(t2) ? t2 : "/" + t2;
    }
    function withoutBase(t2, e2) {
      if (isEmptyURL(e2))
        return t2;
      const r2 = withoutTrailingSlash(e2);
      if (!t2.startsWith(r2))
        return t2;
      const n2 = t2.slice(r2.length);
      return "/" === n2[0] ? n2 : "/" + n2;
    }
    function withQuery(t2, e2) {
      const r2 = parseURL$1(t2), n2 = { ...parseQuery$1(r2.search), ...e2 };
      return r2.search = stringifyQuery$1(n2), function(t3) {
        const e3 = t3.pathname || "", r3 = t3.search ? (t3.search.startsWith("?") ? "" : "?") + t3.search : "", n3 = t3.hash || "", i2 = t3.auth ? t3.auth + "@" : "", o2 = t3.host || "", a2 = t3.protocol ? t3.protocol + "//" : "";
        return a2 + i2 + o2 + e3 + r3 + n3;
      }(r2);
    }
    function getQuery$1(t2) {
      return parseQuery$1(parseURL$1(t2).search);
    }
    function isEmptyURL(t2) {
      return !t2 || "/" === t2;
    }
    const K = /^\.?\//;
    function joinURL(t2, ...e2) {
      let r2 = t2 || "";
      for (const t3 of e2.filter((t4) => function(t5) {
        return t5 && "/" !== t5;
      }(t4)))
        if (r2) {
          const e3 = t3.replace(K, "");
          r2 = withTrailingSlash(r2) + e3;
        } else
          r2 = t3;
      return r2;
    }
    function parseURL$1(t2 = "", e2) {
      const r2 = t2.match(/^[\s\0]*(blob:|data:|javascript:|vbscript:)(.*)/i);
      if (r2) {
        const [, t3, e3 = ""] = r2;
        return { protocol: t3.toLowerCase(), pathname: e3, href: t3 + e3, auth: "", host: "", search: "", hash: "" };
      }
      if (!hasProtocol(t2, { acceptRelative: true }))
        return e2 ? parseURL$1(e2 + t2) : parsePath(t2);
      const [, n2 = "", i2, o2 = ""] = t2.replace(/\\/g, "/").match(/^[\s\0]*([\w+.-]{2,}:)?\/\/([^/@]+@)?(.*)/) || [], [, a2 = "", s2 = ""] = o2.match(/([^#/?]*)(.*)?/) || [], { pathname: l2, search: p2, hash: c2 } = parsePath(s2.replace(/\/(?=[A-Za-z]:)/, ""));
      return { protocol: n2.toLowerCase(), auth: i2 ? i2.slice(0, Math.max(0, i2.length - 1)) : "", host: a2, pathname: l2, search: p2, hash: c2 };
    }
    function parsePath(t2 = "") {
      const [e2 = "", r2 = "", n2 = ""] = (t2.match(/([^#?]*)(\?[^#]*)?(#.*)?/) || []).splice(1);
      return { pathname: e2, search: r2, hash: n2 };
    }
    const G = { NORMAL: 0, WILDCARD: 1, PLACEHOLDER: 2 };
    function createRouter$2(t2 = {}) {
      const e2 = { options: t2, rootNode: createRadixNode(), staticRoutesMap: {} }, normalizeTrailingSlash = (e3) => t2.strictTrailingSlash ? e3 : e3.replace(/\/$/, "") || "/";
      if (t2.routes)
        for (const r2 in t2.routes)
          insert(e2, normalizeTrailingSlash(r2), t2.routes[r2]);
      return { ctx: e2, lookup: (t3) => function(t4, e3) {
        const r2 = t4.staticRoutesMap[e3];
        if (r2)
          return r2.data;
        const n2 = e3.split("/"), i2 = {};
        let o2 = false, a2 = null, s2 = t4.rootNode, l2 = null;
        for (let t5 = 0; t5 < n2.length; t5++) {
          const e4 = n2[t5];
          null !== s2.wildcardChildNode && (a2 = s2.wildcardChildNode, l2 = n2.slice(t5).join("/"));
          const r3 = s2.children.get(e4);
          if (void 0 !== r3)
            s2 = r3;
          else {
            if (s2 = s2.placeholderChildNode, null === s2)
              break;
            i2[s2.paramName] = e4, o2 = true;
          }
        }
        null !== s2 && null !== s2.data || null === a2 || (s2 = a2, i2[s2.paramName || "_"] = l2, o2 = true);
        if (!s2)
          return null;
        if (o2)
          return { ...s2.data, params: o2 ? i2 : void 0 };
        return s2.data;
      }(e2, normalizeTrailingSlash(t3)), insert: (t3, r2) => insert(e2, normalizeTrailingSlash(t3), r2), remove: (t3) => function(t4, e3) {
        let r2 = false;
        const n2 = e3.split("/");
        let i2 = t4.rootNode;
        for (const t5 of n2)
          if (i2 = i2.children.get(t5), !i2)
            return r2;
        if (i2.data) {
          const t5 = n2[n2.length - 1];
          if (i2.data = null, 0 === Object.keys(i2.children).length) {
            const e4 = i2.parent;
            e4.children.delete(t5), e4.wildcardChildNode = null, e4.placeholderChildNode = null;
          }
          r2 = true;
        }
        return r2;
      }(e2, normalizeTrailingSlash(t3)) };
    }
    function insert(t2, e2, r2) {
      let n2 = true;
      const i2 = e2.split("/");
      let o2 = t2.rootNode, a2 = 0;
      for (const t3 of i2) {
        let e3;
        if (e3 = o2.children.get(t3))
          o2 = e3;
        else {
          const r3 = getNodeType(t3);
          e3 = createRadixNode({ type: r3, parent: o2 }), o2.children.set(t3, e3), r3 === G.PLACEHOLDER ? (e3.paramName = "*" === t3 ? "_" + a2++ : t3.slice(1), o2.placeholderChildNode = e3, n2 = false) : r3 === G.WILDCARD && (o2.wildcardChildNode = e3, e3.paramName = t3.slice(3) || "_", n2 = false), o2 = e3;
        }
      }
      return o2.data = r2, true === n2 && (t2.staticRoutesMap[e2] = o2), o2;
    }
    function createRadixNode(t2 = {}) {
      return { type: t2.type || G.NORMAL, parent: t2.parent || null, children: /* @__PURE__ */ new Map(), data: t2.data || null, paramName: t2.paramName || null, wildcardChildNode: null, placeholderChildNode: null };
    }
    function getNodeType(t2) {
      return t2.startsWith("**") ? G.WILDCARD : ":" === t2[0] || "*" === t2 ? G.PLACEHOLDER : G.NORMAL;
    }
    function toRouteMatcher(t2) {
      return function(t3) {
        return { ctx: { table: t3 }, matchAll: (e2) => _matchRoutes(e2, t3) };
      }(_routerNodeToTable("", t2.ctx.rootNode));
    }
    function _matchRoutes(t2, e2) {
      const r2 = [];
      for (const [n3, i2] of _sortRoutesMap(e2.wildcard))
        t2.startsWith(n3) && r2.push(i2);
      for (const [n3, i2] of _sortRoutesMap(e2.dynamic))
        if (t2.startsWith(n3 + "/")) {
          const e3 = "/" + t2.slice(n3.length).split("/").splice(2).join("/");
          r2.push(..._matchRoutes(e3, i2));
        }
      const n2 = e2.static.get(t2);
      return n2 && r2.push(n2), r2.filter(Boolean);
    }
    function _sortRoutesMap(t2) {
      return [...t2.entries()].sort((t3, e2) => t3[0].length - e2[0].length);
    }
    function _routerNodeToTable(t2, e2) {
      const r2 = { static: /* @__PURE__ */ new Map(), wildcard: /* @__PURE__ */ new Map(), dynamic: /* @__PURE__ */ new Map() };
      return function _addNode(t3, e3) {
        if (t3)
          if (e3.type !== G.NORMAL || t3.includes("*") || t3.includes(":")) {
            if (e3.type === G.WILDCARD)
              r2.wildcard.set(t3.replace("/**", ""), e3.data);
            else if (e3.type === G.PLACEHOLDER) {
              const n2 = _routerNodeToTable("", e3);
              return e3.data && n2.static.set("/", e3.data), void r2.dynamic.set(t3.replace(/\/\*|\/:\w+/, ""), n2);
            }
          } else
            r2.static.set(t3, e3.data);
        for (const [r3, n2] of e3.children.entries())
          _addNode(`${t3}/${r3}`.replace("//", "/"), n2);
      }(t2, e2), r2;
    }
    const J = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/, Y = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/, X = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
    function jsonParseTransform(t2, e2) {
      if (!("__proto__" === t2 || "constructor" === t2 && e2 && "object" == typeof e2 && "prototype" in e2))
        return e2;
      !function(t3) {
        console.warn(`[destr] Dropping "${t3}" key to prevent prototype pollution.`);
      }(t2);
    }
    function destr(t2, e2 = {}) {
      if ("string" != typeof t2)
        return t2;
      const r2 = t2.trim();
      if ('"' === t2[0] && '"' === t2.at(-1) && !t2.includes("\\"))
        return r2.slice(1, -1);
      if (r2.length <= 9) {
        const t3 = r2.toLowerCase();
        if ("true" === t3)
          return true;
        if ("false" === t3)
          return false;
        if ("undefined" === t3)
          return;
        if ("null" === t3)
          return null;
        if ("nan" === t3)
          return Number.NaN;
        if ("infinity" === t3)
          return Number.POSITIVE_INFINITY;
        if ("-infinity" === t3)
          return Number.NEGATIVE_INFINITY;
      }
      if (!X.test(t2)) {
        if (e2.strict)
          throw new SyntaxError("[destr] Invalid JSON");
        return t2;
      }
      try {
        if (J.test(t2) || Y.test(t2)) {
          if (e2.strict)
            throw new Error("[destr] Possible prototype pollution");
          return JSON.parse(t2, jsonParseTransform);
        }
        return JSON.parse(t2);
      } catch (r3) {
        if (e2.strict)
          throw r3;
        return t2;
      }
    }
    function _defu(t2, e2, r2 = ".", n2) {
      if (!_isPlainObject(e2))
        return _defu(t2, {}, r2, n2);
      const i2 = Object.assign({}, e2);
      for (const e3 in t2) {
        if ("__proto__" === e3 || "constructor" === e3)
          continue;
        const o2 = t2[e3];
        null != o2 && (n2 && n2(i2, e3, o2, r2) || (Array.isArray(o2) && Array.isArray(i2[e3]) ? i2[e3] = [...o2, ...i2[e3]] : _isPlainObject(o2) && _isPlainObject(i2[e3]) ? i2[e3] = _defu(o2, i2[e3], (r2 ? `${r2}.` : "") + e3.toString(), n2) : i2[e3] = o2));
      }
      return i2;
    }
    function _isPlainObject(t2) {
      if (null === t2 || "object" != typeof t2)
        return false;
      const e2 = Object.getPrototypeOf(t2);
      return !(null !== e2 && e2 !== Object.prototype && null !== Object.getPrototypeOf(e2) || Symbol.toStringTag in t2 || Symbol.iterator in t2);
    }
    function createDefu(t2) {
      return (...e2) => e2.reduce((e3, r2) => _defu(e3, r2, "", t2), {});
    }
    const Q = createDefu(), Z = createDefu((t2, e2, r2) => {
      if (void 0 !== t2[e2] && "function" == typeof r2)
        return t2[e2] = r2(t2[e2]), true;
    });
    let tt = 10, et = class {
      __unenv__ = true;
      _events = /* @__PURE__ */ Object.create(null);
      _maxListeners;
      static get defaultMaxListeners() {
        return tt;
      }
      static set defaultMaxListeners(t2) {
        if ("number" != typeof t2 || t2 < 0 || Number.isNaN(t2))
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t2 + ".");
        tt = t2;
      }
      setMaxListeners(t2) {
        if ("number" != typeof t2 || t2 < 0 || Number.isNaN(t2))
          throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t2 + ".");
        return this._maxListeners = t2, this;
      }
      getMaxListeners() {
        return _getMaxListeners(this);
      }
      emit(t2, ...e2) {
        if (!this._events[t2] || 0 === this._events[t2].length)
          return false;
        if ("error" === t2) {
          let t3;
          if (e2.length > 0 && (t3 = e2[0]), t3 instanceof Error)
            throw t3;
          const r2 = new Error("Unhandled error." + (t3 ? " (" + t3.message + ")" : ""));
          throw r2.context = t3, r2;
        }
        for (const r2 of this._events[t2])
          (r2.listener || r2).apply(this, e2);
        return true;
      }
      addListener(t2, e2) {
        return _addListener(this, t2, e2, false);
      }
      on(t2, e2) {
        return _addListener(this, t2, e2, false);
      }
      prependListener(t2, e2) {
        return _addListener(this, t2, e2, true);
      }
      once(t2, e2) {
        return this.on(t2, _wrapOnce(this, t2, e2));
      }
      prependOnceListener(t2, e2) {
        return this.prependListener(t2, _wrapOnce(this, t2, e2));
      }
      removeListener(t2, e2) {
        return function(t3, e3, r2) {
          if (_checkListener(r2), !t3._events[e3] || 0 === t3._events[e3].length)
            return t3;
          const n2 = t3._events[e3].length;
          if (t3._events[e3] = t3._events[e3].filter((t4) => t4 !== r2), n2 === t3._events[e3].length)
            return t3;
          t3._events.removeListener && t3.emit("removeListener", e3, r2.listener || r2);
          0 === t3._events[e3].length && delete t3._events[e3];
          return t3;
        }(this, t2, e2);
      }
      off(t2, e2) {
        return this.removeListener(t2, e2);
      }
      removeAllListeners(t2) {
        return function(t3, e2) {
          if (!t3._events[e2] || 0 === t3._events[e2].length)
            return t3;
          if (t3._events.removeListener)
            for (const r2 of t3._events[e2])
              t3.emit("removeListener", e2, r2.listener || r2);
          return delete t3._events[e2], t3;
        }(this, t2);
      }
      listeners(t2) {
        return _listeners(this, t2, true);
      }
      rawListeners(t2) {
        return _listeners(this, t2, false);
      }
      listenerCount(t2) {
        return this.rawListeners(t2).length;
      }
      eventNames() {
        return Object.keys(this._events);
      }
    };
    function _addListener(t2, e2, r2, n2) {
      _checkListener(r2), void 0 !== t2._events.newListener && t2.emit("newListener", e2, r2.listener || r2), t2._events[e2] || (t2._events[e2] = []), n2 ? t2._events[e2].unshift(r2) : t2._events[e2].push(r2);
      const i2 = _getMaxListeners(t2);
      if (i2 > 0 && t2._events[e2].length > i2 && !t2._events[e2].warned) {
        t2._events[e2].warned = true;
        const r3 = new Error(`[unenv] Possible EventEmitter memory leak detected. ${t2._events[e2].length} ${e2} listeners added. Use emitter.setMaxListeners() to increase limit`);
        r3.name = "MaxListenersExceededWarning", r3.emitter = t2, r3.type = e2, r3.count = t2._events[e2]?.length, console.warn(r3);
      }
      return t2;
    }
    function _wrapOnce(t2, e2, r2) {
      let n2 = false;
      const wrapper = (...i2) => {
        if (!n2)
          return t2.removeListener(e2, wrapper), n2 = true, 0 === i2.length ? r2.call(t2) : r2.apply(t2, i2);
      };
      return wrapper.listener = r2, wrapper;
    }
    function _getMaxListeners(t2) {
      return t2._maxListeners ?? et.defaultMaxListeners;
    }
    function _listeners(t2, e2, r2) {
      let n2 = t2._events[e2];
      return "function" == typeof n2 && (n2 = [n2]), r2 ? n2.map((t3) => t3.listener || t3) : n2;
    }
    function _checkListener(t2) {
      if ("function" != typeof t2)
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t2);
    }
    const rt = globalThis.EventEmitter || et;
    class _Readable extends rt {
      __unenv__ = true;
      readableEncoding = null;
      readableEnded = true;
      readableFlowing = false;
      readableHighWaterMark = 0;
      readableLength = 0;
      readableObjectMode = false;
      readableAborted = false;
      readableDidRead = false;
      closed = false;
      errored = null;
      readable = false;
      destroyed = false;
      static from(t2, e2) {
        return new _Readable(e2);
      }
      constructor(t2) {
        super();
      }
      _read(t2) {
      }
      read(t2) {
      }
      setEncoding(t2) {
        return this;
      }
      pause() {
        return this;
      }
      resume() {
        return this;
      }
      isPaused() {
        return true;
      }
      unpipe(t2) {
        return this;
      }
      unshift(t2, e2) {
      }
      wrap(t2) {
        return this;
      }
      push(t2, e2) {
        return false;
      }
      _destroy(t2, e2) {
        this.removeAllListeners();
      }
      destroy(t2) {
        return this.destroyed = true, this._destroy(t2), this;
      }
      pipe(t2, e2) {
        return {};
      }
      compose(t2, e2) {
        throw new Error("[unenv] Method not implemented.");
      }
      [Symbol.asyncDispose]() {
        return this.destroy(), Promise.resolve();
      }
      async *[Symbol.asyncIterator]() {
        throw createNotImplementedError("Readable.asyncIterator");
      }
      iterator(t2) {
        throw createNotImplementedError("Readable.iterator");
      }
      map(t2, e2) {
        throw createNotImplementedError("Readable.map");
      }
      filter(t2, e2) {
        throw createNotImplementedError("Readable.filter");
      }
      forEach(t2, e2) {
        throw createNotImplementedError("Readable.forEach");
      }
      reduce(t2, e2, r2) {
        throw createNotImplementedError("Readable.reduce");
      }
      find(t2, e2) {
        throw createNotImplementedError("Readable.find");
      }
      findIndex(t2, e2) {
        throw createNotImplementedError("Readable.findIndex");
      }
      some(t2, e2) {
        throw createNotImplementedError("Readable.some");
      }
      toArray(t2) {
        throw createNotImplementedError("Readable.toArray");
      }
      every(t2, e2) {
        throw createNotImplementedError("Readable.every");
      }
      flatMap(t2, e2) {
        throw createNotImplementedError("Readable.flatMap");
      }
      drop(t2, e2) {
        throw createNotImplementedError("Readable.drop");
      }
      take(t2, e2) {
        throw createNotImplementedError("Readable.take");
      }
      asIndexedPairs(t2) {
        throw createNotImplementedError("Readable.asIndexedPairs");
      }
    }
    const nt = globalThis.Readable || _Readable;
    const it = globalThis.Writable || class extends rt {
      __unenv__ = true;
      writable = true;
      writableEnded = false;
      writableFinished = false;
      writableHighWaterMark = 0;
      writableLength = 0;
      writableObjectMode = false;
      writableCorked = 0;
      closed = false;
      errored = null;
      writableNeedDrain = false;
      destroyed = false;
      _data;
      _encoding = "utf-8";
      constructor(t2) {
        super();
      }
      pipe(t2, e2) {
        return {};
      }
      _write(t2, e2, r2) {
        if (this.writableEnded)
          r2 && r2();
        else {
          if (void 0 === this._data)
            this._data = t2;
          else {
            const r3 = "string" == typeof this._data ? c.from(this._data, this._encoding || e2 || "utf8") : this._data, n2 = "string" == typeof t2 ? c.from(t2, e2 || this._encoding || "utf8") : t2;
            this._data = c.concat([r3, n2]);
          }
          this._encoding = e2, r2 && r2();
        }
      }
      _writev(t2, e2) {
      }
      _destroy(t2, e2) {
      }
      _final(t2) {
      }
      write(t2, e2, r2) {
        const n2 = "string" == typeof e2 ? this._encoding : "utf-8", i2 = "function" == typeof e2 ? e2 : "function" == typeof r2 ? r2 : void 0;
        return this._write(t2, n2, i2), true;
      }
      setDefaultEncoding(t2) {
        return this;
      }
      end(t2, e2, r2) {
        const n2 = "function" == typeof t2 ? t2 : "function" == typeof e2 ? e2 : "function" == typeof r2 ? r2 : void 0;
        if (this.writableEnded)
          return n2 && n2(), this;
        const i2 = t2 === n2 ? void 0 : t2;
        if (i2) {
          const t3 = e2 === n2 ? void 0 : e2;
          this.write(i2, t3, n2);
        }
        return this.writableEnded = true, this.writableFinished = true, this.emit("close"), this.emit("finish"), this;
      }
      cork() {
      }
      uncork() {
      }
      destroy(t2) {
        return this.destroyed = true, delete this._data, this.removeAllListeners(), this;
      }
      compose(t2, e2) {
        throw new Error("[h3] Method not implemented.");
      }
    }, ot = class {
      allowHalfOpen = true;
      _destroy;
      constructor(t2 = new nt(), e2 = new it()) {
        Object.assign(this, t2), Object.assign(this, e2), this._destroy = function(...t3) {
          return function(...e3) {
            for (const r2 of t3)
              r2(...e3);
          };
        }(t2._destroy, e2._destroy);
      }
    };
    function getDuplex() {
      return Object.assign(ot.prototype, nt.prototype), Object.assign(ot.prototype, it.prototype), ot;
    }
    const at = getDuplex(), st = globalThis.Duplex || at;
    class Socket extends st {
      __unenv__ = true;
      bufferSize = 0;
      bytesRead = 0;
      bytesWritten = 0;
      connecting = false;
      destroyed = false;
      pending = false;
      localAddress = "";
      localPort = 0;
      remoteAddress = "";
      remoteFamily = "";
      remotePort = 0;
      autoSelectFamilyAttemptedAddresses = [];
      readyState = "readOnly";
      constructor(t2) {
        super();
      }
      write(t2, e2, r2) {
        return false;
      }
      connect(t2, e2, r2) {
        return this;
      }
      end(t2, e2, r2) {
        return this;
      }
      setEncoding(t2) {
        return this;
      }
      pause() {
        return this;
      }
      resume() {
        return this;
      }
      setTimeout(t2, e2) {
        return this;
      }
      setNoDelay(t2) {
        return this;
      }
      setKeepAlive(t2, e2) {
        return this;
      }
      address() {
        return {};
      }
      unref() {
        return this;
      }
      ref() {
        return this;
      }
      destroySoon() {
        this.destroy();
      }
      resetAndDestroy() {
        const t2 = new Error("ERR_SOCKET_CLOSED");
        return t2.code = "ERR_SOCKET_CLOSED", this.destroy(t2), this;
      }
    }
    class IncomingMessage extends nt {
      __unenv__ = {};
      aborted = false;
      httpVersion = "1.1";
      httpVersionMajor = 1;
      httpVersionMinor = 1;
      complete = true;
      connection;
      socket;
      headers = {};
      trailers = {};
      method = "GET";
      url = "/";
      statusCode = 200;
      statusMessage = "";
      closed = false;
      errored = null;
      readable = false;
      constructor(t2) {
        super(), this.socket = this.connection = t2 || new Socket();
      }
      get rawHeaders() {
        return function(t2) {
          const e2 = [];
          for (const r2 in t2)
            if (Array.isArray(t2[r2]))
              for (const n2 of t2[r2])
                e2.push(r2, n2);
            else
              e2.push(r2, t2[r2]);
          return e2;
        }(this.headers);
      }
      get rawTrailers() {
        return [];
      }
      setTimeout(t2, e2) {
        return this;
      }
      get headersDistinct() {
        return _distinct(this.headers);
      }
      get trailersDistinct() {
        return _distinct(this.trailers);
      }
    }
    function _distinct(t2) {
      const e2 = {};
      for (const [r2, n2] of Object.entries(t2))
        r2 && (e2[r2] = (Array.isArray(n2) ? n2 : [n2]).filter(Boolean));
      return e2;
    }
    class ServerResponse extends it {
      __unenv__ = true;
      statusCode = 200;
      statusMessage = "";
      upgrading = false;
      chunkedEncoding = false;
      shouldKeepAlive = false;
      useChunkedEncodingByDefault = false;
      sendDate = false;
      finished = false;
      headersSent = false;
      strictContentLength = false;
      connection = null;
      socket = null;
      req;
      _headers = {};
      constructor(t2) {
        super(), this.req = t2;
      }
      assignSocket(t2) {
        t2._httpMessage = this, this.socket = t2, this.connection = t2, this.emit("socket", t2), this._flush();
      }
      _flush() {
        this.flushHeaders();
      }
      detachSocket(t2) {
      }
      writeContinue(t2) {
      }
      writeHead(t2, e2, r2) {
        t2 && (this.statusCode = t2), "string" == typeof e2 && (this.statusMessage = e2, e2 = void 0);
        const n2 = r2 || e2;
        if (n2)
          if (Array.isArray(n2))
            ;
          else
            for (const t3 in n2)
              this.setHeader(t3, n2[t3]);
        return this.headersSent = true, this;
      }
      writeProcessing() {
      }
      setTimeout(t2, e2) {
        return this;
      }
      appendHeader(t2, e2) {
        t2 = t2.toLowerCase();
        const r2 = this._headers[t2], n2 = [...Array.isArray(r2) ? r2 : [r2], ...Array.isArray(e2) ? e2 : [e2]].filter(Boolean);
        return this._headers[t2] = n2.length > 1 ? n2 : n2[0], this;
      }
      setHeader(t2, e2) {
        return this._headers[t2.toLowerCase()] = e2, this;
      }
      getHeader(t2) {
        return this._headers[t2.toLowerCase()];
      }
      getHeaders() {
        return this._headers;
      }
      getHeaderNames() {
        return Object.keys(this._headers);
      }
      hasHeader(t2) {
        return t2.toLowerCase() in this._headers;
      }
      removeHeader(t2) {
        delete this._headers[t2.toLowerCase()];
      }
      addTrailers(t2) {
      }
      flushHeaders() {
      }
      writeEarlyHints(t2, e2) {
        "function" == typeof e2 && e2();
      }
    }
    function hasProp$1(t2, e2) {
      try {
        return e2 in t2;
      } catch {
        return false;
      }
    }
    var lt = Object.defineProperty, __publicField$1 = (t2, e2, r2) => (((t3, e3, r3) => {
      e3 in t3 ? lt(t3, e3, { enumerable: true, configurable: true, writable: true, value: r3 }) : t3[e3] = r3;
    })(t2, "symbol" != typeof e2 ? e2 + "" : e2, r2), r2);
    class H3Error extends Error {
      constructor(t2, e2 = {}) {
        super(t2, e2), __publicField$1(this, "statusCode", 500), __publicField$1(this, "fatal", false), __publicField$1(this, "unhandled", false), __publicField$1(this, "statusMessage"), __publicField$1(this, "data"), __publicField$1(this, "cause"), e2.cause && !this.cause && (this.cause = e2.cause);
      }
      toJSON() {
        const t2 = { message: this.message, statusCode: sanitizeStatusCode(this.statusCode, 500) };
        return this.statusMessage && (t2.statusMessage = sanitizeStatusMessage(this.statusMessage)), void 0 !== this.data && (t2.data = this.data), t2;
      }
    }
    function createError$1(t2) {
      if ("string" == typeof t2)
        return new H3Error(t2);
      if (isError(t2))
        return t2;
      const e2 = new H3Error(t2.message ?? t2.statusMessage ?? "", { cause: t2.cause || t2 });
      if (hasProp$1(t2, "stack"))
        try {
          Object.defineProperty(e2, "stack", { get: () => t2.stack });
        } catch {
          try {
            e2.stack = t2.stack;
          } catch {
          }
        }
      if (t2.data && (e2.data = t2.data), t2.statusCode ? e2.statusCode = sanitizeStatusCode(t2.statusCode, e2.statusCode) : t2.status && (e2.statusCode = sanitizeStatusCode(t2.status, e2.statusCode)), t2.statusMessage ? e2.statusMessage = t2.statusMessage : t2.statusText && (e2.statusMessage = t2.statusText), e2.statusMessage) {
        const t3 = e2.statusMessage;
        sanitizeStatusMessage(e2.statusMessage) !== t3 && console.warn("[h3] Please prefer using `message` for longer error messages instead of `statusMessage`. In the future, `statusMessage` will be sanitized by default.");
      }
      return void 0 !== t2.fatal && (e2.fatal = t2.fatal), void 0 !== t2.unhandled && (e2.unhandled = t2.unhandled), e2;
    }
    function isError(t2) {
      return true === t2?.constructor?.__h3_error__;
    }
    function getRequestHeaders(t2) {
      const e2 = {};
      for (const r2 in t2.node.req.headers) {
        const n2 = t2.node.req.headers[r2];
        e2[r2] = Array.isArray(n2) ? n2.filter(Boolean).join(", ") : n2;
      }
      return e2;
    }
    __publicField$1(H3Error, "__h3_error__", true);
    const pt = Symbol.for("h3RawBody"), ct = ["PATCH", "POST", "PUT", "DELETE"];
    function readRawBody(t2, e2 = "utf8") {
      !function(t3, e3, r3) {
        if (!function(t4, e4, r4) {
          if (r4 && "HEAD" === t4.method)
            return true;
          if ("string" == typeof e4) {
            if (t4.method === e4)
              return true;
          } else if (e4.includes(t4.method))
            return true;
          return false;
        }(t3, e3, r3))
          throw createError$1({ statusCode: 405, statusMessage: "HTTP method is not allowed." });
      }(t2, ct);
      const r2 = t2._requestBody || t2.web?.request?.body || t2.node.req[pt] || t2.node.req.body;
      if (r2) {
        const t3 = Promise.resolve(r2).then((t4) => c.isBuffer(t4) ? t4 : "function" == typeof t4.pipeTo ? new Promise((e3, r3) => {
          const n3 = [];
          t4.pipeTo(new WritableStream({ write(t5) {
            n3.push(t5);
          }, close() {
            e3(c.concat(n3));
          }, abort(t5) {
            r3(t5);
          } })).catch(r3);
        }) : "function" == typeof t4.pipe ? new Promise((e3, r3) => {
          const n3 = [];
          t4.on("data", (t5) => {
            n3.push(t5);
          }).on("end", () => {
            e3(c.concat(n3));
          }).on("error", r3);
        }) : t4.constructor === Object ? c.from(JSON.stringify(t4)) : c.from(t4));
        return e2 ? t3.then((t4) => t4.toString(e2)) : t3;
      }
      if (!Number.parseInt(t2.node.req.headers["content-length"] || ""))
        return Promise.resolve(void 0);
      const n2 = t2.node.req[pt] = new Promise((e3, r3) => {
        const n3 = [];
        t2.node.req.on("error", (t3) => {
          r3(t3);
        }).on("data", (t3) => {
          n3.push(t3);
        }).on("end", () => {
          e3(c.concat(n3));
        });
      });
      return e2 ? n2.then((t3) => t3.toString(e2)) : n2;
    }
    function handleCacheHeaders(t2, e2) {
      const r2 = ["public", ...e2.cacheControls || []];
      let n2 = false;
      if (void 0 !== e2.maxAge && r2.push("max-age=" + +e2.maxAge, "s-maxage=" + +e2.maxAge), e2.modifiedTime) {
        const r3 = new Date(e2.modifiedTime), i2 = t2.node.req.headers["if-modified-since"];
        t2.node.res.setHeader("last-modified", r3.toUTCString()), i2 && new Date(i2) >= e2.modifiedTime && (n2 = true);
      }
      if (e2.etag) {
        t2.node.res.setHeader("etag", e2.etag);
        t2.node.req.headers["if-none-match"] === e2.etag && (n2 = true);
      }
      return t2.node.res.setHeader("cache-control", r2.join(", ")), !!n2 && (t2.node.res.statusCode = 304, t2.handled || t2.node.res.end(), true);
    }
    const dt = { html: "text/html", json: "application/json" }, mt = /[^\u0009\u0020-\u007E]/g;
    function sanitizeStatusMessage(t2 = "") {
      return t2.replace(mt, "");
    }
    function sanitizeStatusCode(t2, e2 = 200) {
      return t2 ? ("string" == typeof t2 && (t2 = Number.parseInt(t2, 10)), t2 < 100 || t2 > 999 ? e2 : t2) : e2;
    }
    function splitCookiesString(t2) {
      if (Array.isArray(t2))
        return t2.flatMap((t3) => splitCookiesString(t3));
      if ("string" != typeof t2)
        return [];
      const e2 = [];
      let r2, n2, i2, o2, a2, s2 = 0;
      const skipWhitespace = () => {
        for (; s2 < t2.length && /\s/.test(t2.charAt(s2)); )
          s2 += 1;
        return s2 < t2.length;
      };
      for (; s2 < t2.length; ) {
        for (r2 = s2, a2 = false; skipWhitespace(); )
          if (n2 = t2.charAt(s2), "," === n2) {
            for (i2 = s2, s2 += 1, skipWhitespace(), o2 = s2; s2 < t2.length && (n2 = t2.charAt(s2), "=" !== n2 && ";" !== n2 && "," !== n2); )
              s2 += 1;
            s2 < t2.length && "=" === t2.charAt(s2) ? (a2 = true, s2 = o2, e2.push(t2.slice(r2, i2)), r2 = s2) : s2 = i2 + 1;
          } else
            s2 += 1;
        (!a2 || s2 >= t2.length) && e2.push(t2.slice(r2, t2.length));
      }
      return e2;
    }
    const ut = "undefined" == typeof setImmediate ? (t2) => t2() : setImmediate;
    function send(t2, e2, r2) {
      return r2 && function(t3, e3) {
        e3 && !t3.node.res.getHeader("content-type") && t3.node.res.setHeader("content-type", e3);
      }(t2, r2), new Promise((r3) => {
        ut(() => {
          t2.handled || t2.node.res.end(e2), r3();
        });
      });
    }
    function setResponseStatus(t2, e2, r2) {
      e2 && (t2.node.res.statusCode = sanitizeStatusCode(e2, t2.node.res.statusCode)), r2 && (t2.node.res.statusMessage = sanitizeStatusMessage(r2));
    }
    function getResponseStatus(t2) {
      return t2.node.res.statusCode;
    }
    function getResponseStatusText(t2) {
      return t2.node.res.statusMessage;
    }
    function setResponseHeaders(t2, e2) {
      for (const [r2, n2] of Object.entries(e2))
        t2.node.res.setHeader(r2, n2);
    }
    const ht = setResponseHeaders;
    function setResponseHeader(t2, e2, r2) {
      t2.node.res.setHeader(e2, r2);
    }
    function sendStream(t2, e2) {
      if (!e2 || "object" != typeof e2)
        throw new Error("[h3] Invalid stream provided.");
      if (t2.node.res._data = e2, !t2.node.res.socket)
        return t2._handled = true, Promise.resolve();
      if (hasProp$1(e2, "pipeTo") && "function" == typeof e2.pipeTo)
        return e2.pipeTo(new WritableStream({ write(e3) {
          t2.node.res.write(e3);
        } })).then(() => {
          t2.node.res.end();
        });
      if (hasProp$1(e2, "pipe") && "function" == typeof e2.pipe)
        return new Promise((r2, n2) => {
          e2.pipe(t2.node.res), e2.on && (e2.on("end", () => {
            t2.node.res.end(), r2();
          }), e2.on("error", (t3) => {
            n2(t3);
          })), t2.node.res.on("close", () => {
            e2.abort && e2.abort();
          });
        });
      throw new Error("[h3] Invalid or incompatible stream provided.");
    }
    function sendWebResponse(t2, e2) {
      for (const [r2, n2] of e2.headers)
        "set-cookie" === r2 ? t2.node.res.appendHeader(r2, splitCookiesString(n2)) : t2.node.res.setHeader(r2, n2);
      if (e2.status && (t2.node.res.statusCode = sanitizeStatusCode(e2.status, t2.node.res.statusCode)), e2.statusText && (t2.node.res.statusMessage = sanitizeStatusMessage(e2.statusText)), e2.redirected && t2.node.res.setHeader("location", e2.url), e2.body)
        return sendStream(t2, e2.body);
      t2.node.res.end();
    }
    const ft = /* @__PURE__ */ new Set(["PATCH", "POST", "PUT", "DELETE"]), gt = /* @__PURE__ */ new Set(["transfer-encoding", "connection", "keep-alive", "upgrade", "expect", "host"]);
    async function proxyRequest(t2, e2, r2 = {}) {
      let n2, i2;
      ft.has(t2.method) && (r2.streamRequest ? (n2 = function(t3) {
        if (ct.includes(t3.method))
          return t3.web?.request?.body || t3._requestBody || new ReadableStream({ start: (e3) => {
            t3.node.req.on("data", (t4) => {
              e3.enqueue(t4);
            }), t3.node.req.on("end", () => {
              e3.close();
            }), t3.node.req.on("error", (t4) => {
              e3.error(t4);
            });
          } });
      }(t2), i2 = "half") : n2 = await readRawBody(t2, false).catch(() => {
      }));
      const o2 = r2.fetchOptions?.method || t2.method, a2 = function(t3, ...e3) {
        const r3 = e3.filter(Boolean);
        if (0 === r3.length)
          return t3;
        const n3 = new Headers(t3);
        for (const t4 of r3)
          for (const [e4, r4] of Object.entries(t4))
            void 0 !== r4 && n3.set(e4, r4);
        return n3;
      }(getProxyRequestHeaders(t2), r2.fetchOptions?.headers, r2.headers);
      return async function(t3, e3, r3 = {}) {
        const n3 = await _getFetch(r3.fetch)(e3, { headers: r3.headers, ignoreResponseError: true, ...r3.fetchOptions });
        t3.node.res.statusCode = sanitizeStatusCode(n3.status, t3.node.res.statusCode), t3.node.res.statusMessage = sanitizeStatusMessage(n3.statusText);
        const i3 = [];
        for (const [e4, r4] of n3.headers.entries())
          "content-encoding" !== e4 && "content-length" !== e4 && ("set-cookie" !== e4 ? t3.node.res.setHeader(e4, r4) : i3.push(...splitCookiesString(r4)));
        i3.length > 0 && t3.node.res.setHeader("set-cookie", i3.map((t4) => (r3.cookieDomainRewrite && (t4 = rewriteCookieProperty(t4, r3.cookieDomainRewrite, "domain")), r3.cookiePathRewrite && (t4 = rewriteCookieProperty(t4, r3.cookiePathRewrite, "path")), t4)));
        r3.onResponse && await r3.onResponse(t3, n3);
        if (void 0 !== n3._data)
          return n3._data;
        if (t3.handled)
          return;
        if (false === r3.sendStream) {
          const e4 = new Uint8Array(await n3.arrayBuffer());
          return t3.node.res.end(e4);
        }
        if (n3.body)
          for await (const e4 of n3.body)
            t3.node.res.write(e4);
        return t3.node.res.end();
      }(t2, e2, { ...r2, fetchOptions: { method: o2, body: n2, duplex: i2, ...r2.fetchOptions, headers: a2 } });
    }
    function getProxyRequestHeaders(t2) {
      const e2 = /* @__PURE__ */ Object.create(null), r2 = getRequestHeaders(t2);
      for (const t3 in r2)
        gt.has(t3) || (e2[t3] = r2[t3]);
      return e2;
    }
    function fetchWithEvent(t2, e2, r2, n2) {
      return _getFetch(n2?.fetch)(e2, { ...r2, context: r2?.context || t2.context, headers: { ...getProxyRequestHeaders(t2), ...r2?.headers } });
    }
    function _getFetch(t2) {
      if (t2)
        return t2;
      if (globalThis.fetch)
        return globalThis.fetch;
      throw new Error("fetch is not available. Try importing `node-fetch-native/polyfill` for Node.js.");
    }
    function rewriteCookieProperty(t2, e2, r2) {
      const n2 = "string" == typeof e2 ? { "*": e2 } : e2;
      return t2.replace(new RegExp(`(;\\s*${r2}=)([^;]+)`, "gi"), (t3, e3, r3) => {
        let i2;
        if (r3 in n2)
          i2 = n2[r3];
        else {
          if (!("*" in n2))
            return t3;
          i2 = n2["*"];
        }
        return i2 ? e3 + i2 : "";
      });
    }
    var xt = Object.defineProperty, __publicField = (t2, e2, r2) => (((t3, e3, r3) => {
      e3 in t3 ? xt(t3, e3, { enumerable: true, configurable: true, writable: true, value: r3 }) : t3[e3] = r3;
    })(t2, "symbol" != typeof e2 ? e2 + "" : e2, r2), r2);
    class H3Event {
      constructor(t2, e2) {
        __publicField(this, "__is_event__", true), __publicField(this, "node"), __publicField(this, "web"), __publicField(this, "context", {}), __publicField(this, "_method"), __publicField(this, "_path"), __publicField(this, "_headers"), __publicField(this, "_requestBody"), __publicField(this, "_handled", false), this.node = { req: t2, res: e2 };
      }
      get method() {
        return this._method || (this._method = (this.node.req.method || "GET").toUpperCase()), this._method;
      }
      get path() {
        return this._path || this.node.req.url || "/";
      }
      get headers() {
        return this._headers || (this._headers = function(t2) {
          const e2 = new Headers();
          for (const [r2, n2] of Object.entries(t2))
            if (Array.isArray(n2))
              for (const t3 of n2)
                e2.append(r2, t3);
            else
              n2 && e2.set(r2, n2);
          return e2;
        }(this.node.req.headers)), this._headers;
      }
      get handled() {
        return this._handled || this.node.res.writableEnded || this.node.res.headersSent;
      }
      respondWith(t2) {
        return Promise.resolve(t2).then((t3) => sendWebResponse(this, t3));
      }
      toString() {
        return `[${this.method}] ${this.path}`;
      }
      toJSON() {
        return this.toString();
      }
      get req() {
        return this.node.req;
      }
      get res() {
        return this.node.res;
      }
    }
    function isEvent(t2) {
      return hasProp$1(t2, "__is_event__");
    }
    function createEvent(t2, e2) {
      return new H3Event(t2, e2);
    }
    function defineEventHandler(t2) {
      if ("function" == typeof t2)
        return Object.assign(t2, { __is_handler__: true });
      const e2 = { onRequest: _normalizeArray(t2.onRequest), onBeforeResponse: _normalizeArray(t2.onBeforeResponse) };
      return Object.assign((r2) => async function(t3, e3, r3) {
        if (r3.onRequest) {
          for (const e4 of r3.onRequest)
            if (await e4(t3), t3.handled)
              return;
        }
        const n2 = await e3(t3), i2 = { body: n2 };
        if (r3.onBeforeResponse)
          for (const e4 of r3.onBeforeResponse)
            await e4(t3, i2);
        return i2.body;
      }(r2, t2.handler, e2), { __is_handler__: true });
    }
    function _normalizeArray(t2) {
      return t2 ? Array.isArray(t2) ? t2 : [t2] : void 0;
    }
    const vt = defineEventHandler;
    function isEventHandler(t2) {
      return hasProp$1(t2, "__is_handler__");
    }
    function toEventHandler(t2, e2, r2) {
      return isEventHandler(t2) || console.warn("[h3] Implicit event handler conversion is deprecated. Use `eventHandler()` or `fromNodeMiddleware()` to define event handlers.", r2 && "/" !== r2 ? `
     Route: ${r2}` : "", `
     Handler: ${t2}`), t2;
    }
    const lazyEventHandler = function(t2) {
      let e2, r2;
      return vt((n2) => r2 ? r2(n2) : (r2 ? Promise.resolve(r2) : (e2 || (e2 = Promise.resolve(t2()).then((t3) => {
        const e3 = t3.default || t3;
        if ("function" != typeof e3)
          throw new TypeError("Invalid lazy handler result. It should be a function:", e3);
        return r2 = toEventHandler(t3.default || t3), r2;
      })), e2)).then((t3) => t3(n2)));
    };
    function createApp(t2 = {}) {
      const e2 = [], r2 = function(t3, e3) {
        const r3 = e3.debug ? 2 : void 0;
        return vt(async (n3) => {
          n3.node.req.originalUrl = n3.node.req.originalUrl || n3.node.req.url || "/";
          const i2 = n3._path || n3.node.req.url || "/";
          let o2;
          e3.onRequest && await e3.onRequest(n3);
          for (const a2 of t3) {
            if (a2.route.length > 1) {
              if (!i2.startsWith(a2.route))
                continue;
              o2 = i2.slice(a2.route.length) || "/";
            } else
              o2 = i2;
            if (a2.match && !a2.match(o2, n3))
              continue;
            n3._path = o2, n3.node.req.url = o2;
            const t4 = await a2.handler(n3), s2 = void 0 === t4 ? void 0 : await t4;
            if (void 0 !== s2) {
              const t5 = { body: s2 };
              return e3.onBeforeResponse && await e3.onBeforeResponse(n3, t5), await handleHandlerResponse(n3, t5.body, r3), void (e3.onAfterResponse && await e3.onAfterResponse(n3, t5));
            }
            if (n3.handled)
              return void (e3.onAfterResponse && await e3.onAfterResponse(n3, void 0));
          }
          if (!n3.handled)
            throw createError$1({ statusCode: 404, statusMessage: `Cannot find any path matching ${n3.path || "/"}.` });
          e3.onAfterResponse && await e3.onAfterResponse(n3, void 0);
        });
      }(e2, t2), n2 = { use: (t3, e3, r3) => use(n2, t3, e3, r3), handler: r2, stack: e2, options: t2 };
      return n2;
    }
    function use(t2, e2, r2, n2) {
      if (Array.isArray(e2))
        for (const i2 of e2)
          use(t2, i2, r2, n2);
      else if (Array.isArray(r2))
        for (const i2 of r2)
          use(t2, e2, i2, n2);
      else
        "string" == typeof e2 ? t2.stack.push(normalizeLayer({ ...n2, route: e2, handler: r2 })) : "function" == typeof e2 ? t2.stack.push(normalizeLayer({ ...r2, route: "/", handler: e2 })) : t2.stack.push(normalizeLayer({ ...e2 }));
      return t2;
    }
    function normalizeLayer(t2) {
      let e2 = t2.handler;
      return e2.handler && (e2 = e2.handler), t2.lazy ? e2 = lazyEventHandler(e2) : isEventHandler(e2) || (e2 = toEventHandler(e2, 0, t2.route)), { route: withoutTrailingSlash(t2.route), match: t2.match, handler: e2 };
    }
    function handleHandlerResponse(t2, e2, r2) {
      if (null === e2)
        return function(t3, e3) {
          if (t3.handled)
            return;
          e3 || 200 === t3.node.res.statusCode || (e3 = t3.node.res.statusCode);
          const r3 = sanitizeStatusCode(e3, 204);
          204 === r3 && t3.node.res.removeHeader("content-length"), t3.node.res.writeHead(r3), t3.node.res.end();
        }(t2);
      if (e2) {
        if (n2 = e2, "undefined" != typeof Response && n2 instanceof Response)
          return sendWebResponse(t2, e2);
        if (function(t3) {
          if (!t3 || "object" != typeof t3)
            return false;
          if ("function" == typeof t3.pipe) {
            if ("function" == typeof t3._read)
              return true;
            if ("function" == typeof t3.abort)
              return true;
          }
          return "function" == typeof t3.pipeTo;
        }(e2))
          return sendStream(t2, e2);
        if (e2.buffer)
          return send(t2, e2);
        if (e2.arrayBuffer && "function" == typeof e2.arrayBuffer)
          return e2.arrayBuffer().then((r3) => send(t2, c.from(r3), e2.type));
        if (e2 instanceof Error)
          throw createError$1(e2);
        if ("function" == typeof e2.end)
          return true;
      }
      var n2;
      const i2 = typeof e2;
      if ("string" === i2)
        return send(t2, e2, dt.html);
      if ("object" === i2 || "boolean" === i2 || "number" === i2)
        return send(t2, JSON.stringify(e2, void 0, r2), dt.json);
      if ("bigint" === i2)
        return send(t2, e2.toString(), dt.json);
      throw createError$1({ statusCode: 500, statusMessage: `[h3] Cannot send ${i2} as response.` });
    }
    const yt = ["connect", "delete", "get", "head", "options", "post", "put", "trace", "patch"];
    function toNodeListener(t2) {
      return async function(e2, r2) {
        const n2 = createEvent(e2, r2);
        try {
          await t2.handler(n2);
        } catch (e3) {
          const r3 = createError$1(e3);
          if (isError(e3) || (r3.unhandled = true), t2.options.onError && await t2.options.onError(r3, n2), n2.handled)
            return;
          (r3.unhandled || r3.fatal) && console.error("[h3]", r3.fatal ? "[fatal]" : "[unhandled]", r3), await function(t3, e4, r4) {
            if (t3.handled)
              return;
            const n3 = isError(e4) ? e4 : createError$1(e4), i2 = { statusCode: n3.statusCode, statusMessage: n3.statusMessage, stack: [], data: n3.data };
            if (r4 && (i2.stack = (n3.stack || "").split("\n").map((t4) => t4.trim())), t3.handled)
              return;
            setResponseStatus(t3, Number.parseInt(n3.statusCode), n3.statusMessage), t3.node.res.setHeader("content-type", dt.json), t3.node.res.end(JSON.stringify(i2, void 0, 2));
          }(n2, r3, !!t2.options.debug);
        }
      };
    }
    class FetchError extends Error {
      constructor(t2, e2) {
        super(t2, e2), this.name = "FetchError", e2?.cause && !this.cause && (this.cause = e2.cause);
      }
    }
    const bt = new Set(Object.freeze(["PATCH", "POST", "PUT", "DELETE"]));
    function isPayloadMethod(t2 = "GET") {
      return bt.has(t2.toUpperCase());
    }
    const wt = /* @__PURE__ */ new Set(["image/svg", "application/xml", "application/xhtml", "application/html"]), kt = /^application\/(?:[\w!#$%&*.^`~-]*\+)?json(;.+)?$/i;
    function mergeFetchOptions(t2, e2, r2 = globalThis.Headers) {
      const n2 = { ...e2, ...t2 };
      if (e2?.params && t2?.params && (n2.params = { ...e2?.params, ...t2?.params }), e2?.query && t2?.query && (n2.query = { ...e2?.query, ...t2?.query }), e2?.headers && t2?.headers) {
        n2.headers = new r2(e2?.headers || {});
        for (const [e3, i2] of new r2(t2?.headers || {}))
          n2.headers.set(e3, i2);
      }
      return n2;
    }
    const St = /* @__PURE__ */ new Set([408, 409, 425, 429, 500, 502, 503, 504]), Ct = /* @__PURE__ */ new Set([101, 204, 205, 304]);
    function createFetch$1(t2 = {}) {
      const { fetch: e2 = globalThis.fetch, Headers: r2 = globalThis.Headers, AbortController: n2 = globalThis.AbortController } = t2;
      async function onError(t3) {
        const e3 = t3.error && "AbortError" === t3.error.name && !t3.options.timeout || false;
        if (false !== t3.options.retry && !e3) {
          let e4;
          e4 = "number" == typeof t3.options.retry ? t3.options.retry : isPayloadMethod(t3.options.method) ? 0 : 1;
          const r4 = t3.response && t3.response.status || 500;
          if (e4 > 0 && (Array.isArray(t3.options.retryStatusCodes) ? t3.options.retryStatusCodes.includes(r4) : St.has(r4))) {
            const r5 = t3.options.retryDelay || 0;
            return r5 > 0 && await new Promise((t4) => setTimeout(t4, r5)), $fetchRaw(t3.request, { ...t3.options, retry: e4 - 1, timeout: t3.options.timeout });
          }
        }
        const r3 = function(t4) {
          const e4 = t4.error?.message || t4.error?.toString() || "", r4 = t4.request?.method || t4.options?.method || "GET", n3 = t4.request?.url || String(t4.request) || "/", i2 = `[${r4}] ${JSON.stringify(n3)}`, o2 = t4.response ? `${t4.response.status} ${t4.response.statusText}` : "<no response>", a2 = new FetchError(`${i2}: ${o2}${e4 ? ` ${e4}` : ""}`, t4.error ? { cause: t4.error } : void 0);
          for (const e5 of ["request", "options", "response"])
            Object.defineProperty(a2, e5, { get: () => t4[e5] });
          for (const [e5, r5] of [["data", "_data"], ["status", "status"], ["statusCode", "status"], ["statusText", "statusText"], ["statusMessage", "statusText"]])
            Object.defineProperty(a2, e5, { get: () => t4.response && t4.response[r5] });
          return a2;
        }(t3);
        throw Error.captureStackTrace && Error.captureStackTrace(r3, $fetchRaw), r3;
      }
      const $fetchRaw = async function(i2, o2 = {}) {
        const a2 = { request: i2, options: mergeFetchOptions(o2, t2.defaults, r2), response: void 0, error: void 0 };
        if (a2.options.method = a2.options.method?.toUpperCase(), a2.options.onRequest && await a2.options.onRequest(a2), "string" == typeof a2.request && (a2.options.baseURL && (a2.request = function(t3, e3) {
          if (isEmptyURL(e3) || hasProtocol(t3))
            return t3;
          const r3 = withoutTrailingSlash(e3);
          return t3.startsWith(r3) ? t3 : joinURL(r3, t3);
        }(a2.request, a2.options.baseURL)), (a2.options.query || a2.options.params) && (a2.request = withQuery(a2.request, { ...a2.options.params, ...a2.options.query }))), a2.options.body && isPayloadMethod(a2.options.method) && (!function(t3) {
          if (void 0 === t3)
            return false;
          const e3 = typeof t3;
          return "string" === e3 || "number" === e3 || "boolean" === e3 || null === e3 || "object" === e3 && (!!Array.isArray(t3) || !t3.buffer && (t3.constructor && "Object" === t3.constructor.name || "function" == typeof t3.toJSON));
        }(a2.options.body) ? ("pipeTo" in a2.options.body && "function" == typeof a2.options.body.pipeTo || "function" == typeof a2.options.body.pipe) && ("duplex" in a2.options || (a2.options.duplex = "half")) : (a2.options.body = "string" == typeof a2.options.body ? a2.options.body : JSON.stringify(a2.options.body), a2.options.headers = new r2(a2.options.headers || {}), a2.options.headers.has("content-type") || a2.options.headers.set("content-type", "application/json"), a2.options.headers.has("accept") || a2.options.headers.set("accept", "application/json"))), !a2.options.signal && a2.options.timeout) {
          const t3 = new n2();
          setTimeout(() => t3.abort(), a2.options.timeout), a2.options.signal = t3.signal;
        }
        try {
          a2.response = await e2(a2.request, a2.options);
        } catch (t3) {
          return a2.error = t3, a2.options.onRequestError && await a2.options.onRequestError(a2), await onError(a2);
        }
        if (a2.response.body && !Ct.has(a2.response.status) && "HEAD" !== a2.options.method) {
          const t3 = (a2.options.parseResponse ? "json" : a2.options.responseType) || function(t4 = "") {
            if (!t4)
              return "json";
            const e3 = t4.split(";").shift() || "";
            return kt.test(e3) ? "json" : wt.has(e3) || e3.startsWith("text/") ? "text" : "blob";
          }(a2.response.headers.get("content-type") || "");
          switch (t3) {
            case "json": {
              const t4 = await a2.response.text(), e3 = a2.options.parseResponse || destr;
              a2.response._data = e3(t4);
              break;
            }
            case "stream":
              a2.response._data = a2.response.body;
              break;
            default:
              a2.response._data = await a2.response[t3]();
          }
        }
        return a2.options.onResponse && await a2.options.onResponse(a2), !a2.options.ignoreResponseError && a2.response.status >= 400 && a2.response.status < 600 ? (a2.options.onResponseError && await a2.options.onResponseError(a2), await onError(a2)) : a2.response;
      }, $fetch = async function(t3, e3) {
        return (await $fetchRaw(t3, e3))._data;
      };
      return $fetch.raw = $fetchRaw, $fetch.native = (...t3) => e2(...t3), $fetch.create = (e3 = {}) => createFetch$1({ ...t2, defaults: { ...t2.defaults, ...e3 } }), $fetch;
    }
    const Et = function() {
      if ("undefined" != typeof globalThis)
        return globalThis;
      if ("undefined" != typeof self)
        return self;
      if ("undefined" != typeof global)
        return global;
      throw new Error("unable to locate global object");
    }(), _t = Et.fetch || (() => Promise.reject(new Error("[ofetch] global.fetch is not supported!"))), Pt = Et.Headers, Tt = Et.AbortController, At = createFetch$1({ fetch: _t, Headers: Pt, AbortController: Tt }), It = /* @__PURE__ */ new Set([101, 204, 205, 304]);
    function flatHooks(t2, e2 = {}, r2) {
      for (const n2 in t2) {
        const i2 = t2[n2], o2 = r2 ? `${r2}:${n2}` : n2;
        "object" == typeof i2 && null !== i2 ? flatHooks(i2, e2, o2) : "function" == typeof i2 && (e2[o2] = i2);
      }
      return e2;
    }
    const Nt = { run: (t2) => t2() }, Rt = void 0 !== console.createTask ? console.createTask : () => Nt;
    function serialTaskCaller(t2, e2) {
      const r2 = e2.shift(), n2 = Rt(r2);
      return t2.reduce((t3, r3) => t3.then(() => n2.run(() => r3(...e2))), Promise.resolve());
    }
    function parallelTaskCaller(t2, e2) {
      const r2 = e2.shift(), n2 = Rt(r2);
      return Promise.all(t2.map((t3) => n2.run(() => t3(...e2))));
    }
    function callEachWith(t2, e2) {
      for (const r2 of [...t2])
        r2(e2);
    }
    class Hookable {
      constructor() {
        this._hooks = {}, this._before = void 0, this._after = void 0, this._deprecatedMessages = void 0, this._deprecatedHooks = {}, this.hook = this.hook.bind(this), this.callHook = this.callHook.bind(this), this.callHookWith = this.callHookWith.bind(this);
      }
      hook(t2, e2, r2 = {}) {
        if (!t2 || "function" != typeof e2)
          return () => {
          };
        const n2 = t2;
        let i2;
        for (; this._deprecatedHooks[t2]; )
          i2 = this._deprecatedHooks[t2], t2 = i2.to;
        if (i2 && !r2.allowDeprecated) {
          let t3 = i2.message;
          t3 || (t3 = `${n2} hook has been deprecated` + (i2.to ? `, please use ${i2.to}` : "")), this._deprecatedMessages || (this._deprecatedMessages = /* @__PURE__ */ new Set()), this._deprecatedMessages.has(t3) || (console.warn(t3), this._deprecatedMessages.add(t3));
        }
        if (!e2.name)
          try {
            Object.defineProperty(e2, "name", { get: () => "_" + t2.replace(/\W+/g, "_") + "_hook_cb", configurable: true });
          } catch {
          }
        return this._hooks[t2] = this._hooks[t2] || [], this._hooks[t2].push(e2), () => {
          e2 && (this.removeHook(t2, e2), e2 = void 0);
        };
      }
      hookOnce(t2, e2) {
        let r2, _function = (...t3) => ("function" == typeof r2 && r2(), r2 = void 0, _function = void 0, e2(...t3));
        return r2 = this.hook(t2, _function), r2;
      }
      removeHook(t2, e2) {
        if (this._hooks[t2]) {
          const r2 = this._hooks[t2].indexOf(e2);
          -1 !== r2 && this._hooks[t2].splice(r2, 1), 0 === this._hooks[t2].length && delete this._hooks[t2];
        }
      }
      deprecateHook(t2, e2) {
        this._deprecatedHooks[t2] = "string" == typeof e2 ? { to: e2 } : e2;
        const r2 = this._hooks[t2] || [];
        delete this._hooks[t2];
        for (const e3 of r2)
          this.hook(t2, e3);
      }
      deprecateHooks(t2) {
        Object.assign(this._deprecatedHooks, t2);
        for (const e2 in t2)
          this.deprecateHook(e2, t2[e2]);
      }
      addHooks(t2) {
        const e2 = flatHooks(t2), r2 = Object.keys(e2).map((t3) => this.hook(t3, e2[t3]));
        return () => {
          for (const t3 of r2.splice(0, r2.length))
            t3();
        };
      }
      removeHooks(t2) {
        const e2 = flatHooks(t2);
        for (const t3 in e2)
          this.removeHook(t3, e2[t3]);
      }
      removeAllHooks() {
        for (const t2 in this._hooks)
          delete this._hooks[t2];
      }
      callHook(t2, ...e2) {
        return e2.unshift(t2), this.callHookWith(serialTaskCaller, t2, ...e2);
      }
      callHookParallel(t2, ...e2) {
        return e2.unshift(t2), this.callHookWith(parallelTaskCaller, t2, ...e2);
      }
      callHookWith(t2, e2, ...r2) {
        const n2 = this._before || this._after ? { name: e2, args: r2, context: {} } : void 0;
        this._before && callEachWith(this._before, n2);
        const i2 = t2(e2 in this._hooks ? [...this._hooks[e2]] : [], r2);
        return i2 instanceof Promise ? i2.finally(() => {
          this._after && n2 && callEachWith(this._after, n2);
        }) : (this._after && n2 && callEachWith(this._after, n2), i2);
      }
      beforeEach(t2) {
        return this._before = this._before || [], this._before.push(t2), () => {
          if (void 0 !== this._before) {
            const e2 = this._before.indexOf(t2);
            -1 !== e2 && this._before.splice(e2, 1);
          }
        };
      }
      afterEach(t2) {
        return this._after = this._after || [], this._after.push(t2), () => {
          if (void 0 !== this._after) {
            const e2 = this._after.indexOf(t2);
            -1 !== e2 && this._after.splice(e2, 1);
          }
        };
      }
    }
    function createHooks() {
      return new Hookable();
    }
    const Ot = /\d/, Lt = ["-", "_", "/", "."];
    function isUppercase(t2 = "") {
      if (!Ot.test(t2))
        return t2.toUpperCase() === t2;
    }
    function kebabCase(t2, e2) {
      return t2 ? (Array.isArray(t2) ? t2 : function(t3, e3) {
        const r2 = e3 ?? Lt, n2 = [];
        if (!t3 || "string" != typeof t3)
          return n2;
        let i2, o2, a2 = "";
        for (const e4 of t3) {
          const t4 = r2.includes(e4);
          if (true === t4) {
            n2.push(a2), a2 = "", i2 = void 0;
            continue;
          }
          const s2 = isUppercase(e4);
          if (false === o2) {
            if (false === i2 && true === s2) {
              n2.push(a2), a2 = e4, i2 = s2;
              continue;
            }
            if (true === i2 && false === s2 && a2.length > 1) {
              const t5 = a2.at(-1);
              n2.push(a2.slice(0, Math.max(0, a2.length - 1))), a2 = t5 + e4, i2 = s2;
              continue;
            }
          }
          a2 += e4, i2 = s2, o2 = t4;
        }
        return n2.push(a2), n2;
      }(t2)).map((t3) => t3.toLowerCase()).join(e2 ?? "-") : "";
    }
    function klona(t2) {
      if ("object" != typeof t2)
        return t2;
      var e2, r2, n2 = Object.prototype.toString.call(t2);
      if ("[object Object]" === n2) {
        if (t2.constructor !== Object && "function" == typeof t2.constructor)
          for (e2 in r2 = new t2.constructor(), t2)
            t2.hasOwnProperty(e2) && r2[e2] !== t2[e2] && (r2[e2] = klona(t2[e2]));
        else
          for (e2 in r2 = {}, t2)
            "__proto__" === e2 ? Object.defineProperty(r2, e2, { value: klona(t2[e2]), configurable: true, enumerable: true, writable: true }) : r2[e2] = klona(t2[e2]);
        return r2;
      }
      if ("[object Array]" === n2) {
        for (e2 = t2.length, r2 = Array(e2); e2--; )
          r2[e2] = klona(t2[e2]);
        return r2;
      }
      return "[object Set]" === n2 ? (r2 = /* @__PURE__ */ new Set(), t2.forEach(function(t3) {
        r2.add(klona(t3));
      }), r2) : "[object Map]" === n2 ? (r2 = /* @__PURE__ */ new Map(), t2.forEach(function(t3, e3) {
        r2.set(klona(e3), klona(t3));
      }), r2) : "[object Date]" === n2 ? /* @__PURE__ */ new Date(+t2) : "[object RegExp]" === n2 ? ((r2 = new RegExp(t2.source, t2.flags)).lastIndex = t2.lastIndex, r2) : "[object DataView]" === n2 ? new t2.constructor(klona(t2.buffer)) : "[object ArrayBuffer]" === n2 ? t2.slice(0) : "Array]" === n2.slice(-6) ? new t2.constructor(t2) : t2;
    }
    const Mt = Z({ nuxt: { buildId: "ce0d6636-88d2-41b3-ae46-7553fc961e21" } }), Bt = { app: { baseURL: "/", buildAssetsDir: "/_nuxt/", cdnURL: "" }, nitro: { envPrefix: "NUXT_", routeRules: { "/__nuxt_error": { cache: false }, "/_nuxt/builds/meta/**": { headers: { "cache-control": "public, max-age=31536000, immutable" } }, "/_nuxt/builds/**": { headers: { "cache-control": "public, max-age=1, immutable" } }, "/_nuxt/**": { headers: { "cache-control": "public, max-age=31536000, immutable" } } } }, public: {} }, Dt = "NITRO_", jt = Bt.nitro.envPrefix ?? S.env.NITRO_ENV_PREFIX ?? "_", Ft = _deepFreeze(_applyEnv(klona(Bt)));
    function useRuntimeConfig$1(t2) {
      if (!t2)
        return Ft;
      if (t2.context.nitro.runtimeConfig)
        return t2.context.nitro.runtimeConfig;
      const e2 = klona(Bt);
      return _applyEnv(e2), t2.context.nitro.runtimeConfig = e2, e2;
    }
    function _getEnv(t2) {
      const e2 = (r2 = t2, kebabCase(r2 || "", "_")).toUpperCase();
      var r2;
      return destr(S.env[Dt + e2] ?? S.env[jt + e2]);
    }
    function _isObject(t2) {
      return "object" == typeof t2 && !Array.isArray(t2);
    }
    function _applyEnv(t2, e2 = "") {
      for (const r2 in t2) {
        const n2 = e2 ? `${e2}_${r2}` : r2, i2 = _getEnv(n2);
        _isObject(t2[r2]) ? (_isObject(i2) && (t2[r2] = { ...t2[r2], ...i2 }), _applyEnv(t2[r2], n2)) : t2[r2] = i2 ?? t2[r2];
      }
      return t2;
    }
    function _deepFreeze(t2) {
      const e2 = Object.getOwnPropertyNames(t2);
      for (const r2 of e2) {
        const e3 = t2[r2];
        e3 && "object" == typeof e3 && _deepFreeze(e3);
      }
      return Object.freeze(t2);
    }
    _deepFreeze(klona(Mt)), new Proxy(/* @__PURE__ */ Object.create(null), { get: (t2, e2) => {
      console.warn("Please use `useRuntimeConfig()` instead of accessing config directly.");
      const r2 = useRuntimeConfig$1();
      if (e2 in r2)
        return r2[e2];
    } });
    const $t = Object.freeze({ ignoreUnknown: false, respectType: false, respectFunctionNames: false, respectFunctionProperties: false, unorderedObjects: true, unorderedArrays: false, unorderedSets: false, excludeKeys: void 0, excludeValues: void 0, replacer: void 0 });
    function objectHash(t2, e2) {
      const r2 = createHasher(e2 = e2 ? { ...$t, ...e2 } : $t);
      return r2.dispatch(t2), r2.toString();
    }
    const Vt = Object.freeze(["prototype", "__proto__", "constructor"]);
    function createHasher(t2) {
      let e2 = "", r2 = /* @__PURE__ */ new Map();
      const write2 = (t3) => {
        e2 += t3;
      };
      return { toString: () => e2, getContext: () => r2, dispatch(e3) {
        t2.replacer && (e3 = t2.replacer(e3));
        return this[null === e3 ? "null" : typeof e3](e3);
      }, object(e3) {
        if (e3 && "function" == typeof e3.toJSON)
          return this.object(e3.toJSON());
        const n2 = Object.prototype.toString.call(e3);
        let i2 = "";
        const o2 = n2.length;
        i2 = o2 < 10 ? "unknown:[" + n2 + "]" : n2.slice(8, o2 - 1), i2 = i2.toLowerCase();
        let a2 = null;
        if (void 0 !== (a2 = r2.get(e3)))
          return this.dispatch("[CIRCULAR:" + a2 + "]");
        if (r2.set(e3, r2.size), void 0 !== c && c.isBuffer && c.isBuffer(e3))
          return write2("buffer:"), write2(e3.toString("utf8"));
        if ("object" !== i2 && "function" !== i2 && "asyncfunction" !== i2)
          this[i2] ? this[i2](e3) : t2.ignoreUnknown || this.unkown(e3, i2);
        else {
          let r3 = Object.keys(e3);
          t2.unorderedObjects && (r3 = r3.sort());
          let n3 = [];
          false === t2.respectType || isNativeFunction(e3) || (n3 = Vt), t2.excludeKeys && (r3 = r3.filter((e4) => !t2.excludeKeys(e4)), n3 = n3.filter((e4) => !t2.excludeKeys(e4))), write2("object:" + (r3.length + n3.length) + ":");
          const dispatchForKey = (r4) => {
            this.dispatch(r4), write2(":"), t2.excludeValues || this.dispatch(e3[r4]), write2(",");
          };
          for (const t3 of r3)
            dispatchForKey(t3);
          for (const t3 of n3)
            dispatchForKey(t3);
        }
      }, array(e3, n2) {
        if (n2 = void 0 === n2 ? false !== t2.unorderedArrays : n2, write2("array:" + e3.length + ":"), !n2 || e3.length <= 1) {
          for (const t3 of e3)
            this.dispatch(t3);
          return;
        }
        const i2 = /* @__PURE__ */ new Map(), o2 = e3.map((e4) => {
          const r3 = createHasher(t2);
          r3.dispatch(e4);
          for (const [t3, e5] of r3.getContext())
            i2.set(t3, e5);
          return r3.toString();
        });
        return r2 = i2, o2.sort(), this.array(o2, false);
      }, date: (t3) => write2("date:" + t3.toJSON()), symbol: (t3) => write2("symbol:" + t3.toString()), unkown(t3, e3) {
        if (write2(e3), t3)
          return write2(":"), t3 && "function" == typeof t3.entries ? this.array(Array.from(t3.entries()), true) : void 0;
      }, error: (t3) => write2("error:" + t3.toString()), boolean: (t3) => write2("bool:" + t3), string(t3) {
        write2("string:" + t3.length + ":"), write2(t3);
      }, function(e3) {
        write2("fn:"), isNativeFunction(e3) ? this.dispatch("[native]") : this.dispatch(e3.toString()), false !== t2.respectFunctionNames && this.dispatch("function-name:" + String(e3.name)), t2.respectFunctionProperties && this.object(e3);
      }, number: (t3) => write2("number:" + t3), xml: (t3) => write2("xml:" + t3.toString()), null: () => write2("Null"), undefined: () => write2("Undefined"), regexp: (t3) => write2("regex:" + t3.toString()), uint8array(t3) {
        return write2("uint8array:"), this.dispatch(Array.prototype.slice.call(t3));
      }, uint8clampedarray(t3) {
        return write2("uint8clampedarray:"), this.dispatch(Array.prototype.slice.call(t3));
      }, int8array(t3) {
        return write2("int8array:"), this.dispatch(Array.prototype.slice.call(t3));
      }, uint16array(t3) {
        return write2("uint16array:"), this.dispatch(Array.prototype.slice.call(t3));
      }, int16array(t3) {
        return write2("int16array:"), this.dispatch(Array.prototype.slice.call(t3));
      }, uint32array(t3) {
        return write2("uint32array:"), this.dispatch(Array.prototype.slice.call(t3));
      }, int32array(t3) {
        return write2("int32array:"), this.dispatch(Array.prototype.slice.call(t3));
      }, float32array(t3) {
        return write2("float32array:"), this.dispatch(Array.prototype.slice.call(t3));
      }, float64array(t3) {
        return write2("float64array:"), this.dispatch(Array.prototype.slice.call(t3));
      }, arraybuffer(t3) {
        return write2("arraybuffer:"), this.dispatch(new Uint8Array(t3));
      }, url: (t3) => write2("url:" + t3.toString()), map(e3) {
        write2("map:");
        const r3 = [...e3];
        return this.array(r3, false !== t2.unorderedSets);
      }, set(e3) {
        write2("set:");
        const r3 = [...e3];
        return this.array(r3, false !== t2.unorderedSets);
      }, file(t3) {
        return write2("file:"), this.dispatch([t3.name, t3.size, t3.type, t3.lastModfied]);
      }, blob() {
        if (t2.ignoreUnknown)
          return write2("[blob]");
        throw new Error('Hashing Blob objects is currently not supported\nUse "options.replacer" or "options.ignoreUnknown"\n');
      }, domwindow: () => write2("domwindow"), bigint: (t3) => write2("bigint:" + t3.toString()), process: () => write2("process"), timer: () => write2("timer"), pipe: () => write2("pipe"), tcp: () => write2("tcp"), udp: () => write2("udp"), tty: () => write2("tty"), statwatcher: () => write2("statwatcher"), securecontext: () => write2("securecontext"), connection: () => write2("connection"), zlib: () => write2("zlib"), context: () => write2("context"), nodescript: () => write2("nodescript"), httpparser: () => write2("httpparser"), dataview: () => write2("dataview"), signal: () => write2("signal"), fsevent: () => write2("fsevent"), tlswrap: () => write2("tlswrap") };
    }
    const zt = "[native code] }", Ut = zt.length;
    function isNativeFunction(t2) {
      return "function" == typeof t2 && Function.prototype.toString.call(t2).slice(-Ut) === zt;
    }
    class WordArray {
      constructor(t2, e2) {
        t2 = this.words = t2 || [], this.sigBytes = void 0 === e2 ? 4 * t2.length : e2;
      }
      toString(t2) {
        return (t2 || Ht).stringify(this);
      }
      concat(t2) {
        if (this.clamp(), this.sigBytes % 4)
          for (let e2 = 0; e2 < t2.sigBytes; e2++) {
            const r2 = t2.words[e2 >>> 2] >>> 24 - e2 % 4 * 8 & 255;
            this.words[this.sigBytes + e2 >>> 2] |= r2 << 24 - (this.sigBytes + e2) % 4 * 8;
          }
        else
          for (let e2 = 0; e2 < t2.sigBytes; e2 += 4)
            this.words[this.sigBytes + e2 >>> 2] = t2.words[e2 >>> 2];
        return this.sigBytes += t2.sigBytes, this;
      }
      clamp() {
        this.words[this.sigBytes >>> 2] &= 4294967295 << 32 - this.sigBytes % 4 * 8, this.words.length = Math.ceil(this.sigBytes / 4);
      }
      clone() {
        return new WordArray([...this.words]);
      }
    }
    const Ht = { stringify(t2) {
      const e2 = [];
      for (let r2 = 0; r2 < t2.sigBytes; r2++) {
        const n2 = t2.words[r2 >>> 2] >>> 24 - r2 % 4 * 8 & 255;
        e2.push((n2 >>> 4).toString(16), (15 & n2).toString(16));
      }
      return e2.join("");
    } }, qt = { stringify(t2) {
      const e2 = [];
      for (let r2 = 0; r2 < t2.sigBytes; r2 += 3) {
        const n2 = (t2.words[r2 >>> 2] >>> 24 - r2 % 4 * 8 & 255) << 16 | (t2.words[r2 + 1 >>> 2] >>> 24 - (r2 + 1) % 4 * 8 & 255) << 8 | t2.words[r2 + 2 >>> 2] >>> 24 - (r2 + 2) % 4 * 8 & 255;
        for (let i2 = 0; i2 < 4 && 8 * r2 + 6 * i2 < 8 * t2.sigBytes; i2++)
          e2.push("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".charAt(n2 >>> 6 * (3 - i2) & 63));
      }
      return e2.join("");
    } }, Wt = { parse(t2) {
      const e2 = t2.length, r2 = [];
      for (let n2 = 0; n2 < e2; n2++)
        r2[n2 >>> 2] |= (255 & t2.charCodeAt(n2)) << 24 - n2 % 4 * 8;
      return new WordArray(r2, e2);
    } }, Kt = { parse: (t2) => Wt.parse(unescape(encodeURIComponent(t2))) };
    class BufferedBlockAlgorithm {
      constructor() {
        this._data = new WordArray(), this._nDataBytes = 0, this._minBufferSize = 0, this.blockSize = 16;
      }
      reset() {
        this._data = new WordArray(), this._nDataBytes = 0;
      }
      _append(t2) {
        "string" == typeof t2 && (t2 = Kt.parse(t2)), this._data.concat(t2), this._nDataBytes += t2.sigBytes;
      }
      _doProcessBlock(t2, e2) {
      }
      _process(t2) {
        let e2, r2 = this._data.sigBytes / (4 * this.blockSize);
        r2 = t2 ? Math.ceil(r2) : Math.max((0 | r2) - this._minBufferSize, 0);
        const n2 = r2 * this.blockSize, i2 = Math.min(4 * n2, this._data.sigBytes);
        if (n2) {
          for (let t3 = 0; t3 < n2; t3 += this.blockSize)
            this._doProcessBlock(this._data.words, t3);
          e2 = this._data.words.splice(0, n2), this._data.sigBytes -= i2;
        }
        return new WordArray(e2, i2);
      }
    }
    class Hasher extends BufferedBlockAlgorithm {
      update(t2) {
        return this._append(t2), this._process(), this;
      }
      finalize(t2) {
        t2 && this._append(t2);
      }
    }
    const Gt = [1779033703, -1150833019, 1013904242, -1521486534, 1359893119, -1694144372, 528734635, 1541459225], Jt = [1116352408, 1899447441, -1245643825, -373957723, 961987163, 1508970993, -1841331548, -1424204075, -670586216, 310598401, 607225278, 1426881987, 1925078388, -2132889090, -1680079193, -1046744716, -459576895, -272742522, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, -1740746414, -1473132947, -1341970488, -1084653625, -958395405, -710438585, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, -2117940946, -1838011259, -1564481375, -1474664885, -1035236496, -949202525, -778901479, -694614492, -200395387, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, -2067236844, -1933114872, -1866530822, -1538233109, -1090935817, -965641998], Yt = [];
    class SHA256 extends Hasher {
      constructor() {
        super(...arguments), this._hash = new WordArray([...Gt]);
      }
      reset() {
        super.reset(), this._hash = new WordArray([...Gt]);
      }
      _doProcessBlock(t2, e2) {
        const r2 = this._hash.words;
        let n2 = r2[0], i2 = r2[1], o2 = r2[2], a2 = r2[3], s2 = r2[4], l2 = r2[5], p2 = r2[6], c2 = r2[7];
        for (let r3 = 0; r3 < 64; r3++) {
          if (r3 < 16)
            Yt[r3] = 0 | t2[e2 + r3];
          else {
            const t3 = Yt[r3 - 15], e3 = (t3 << 25 | t3 >>> 7) ^ (t3 << 14 | t3 >>> 18) ^ t3 >>> 3, n3 = Yt[r3 - 2], i3 = (n3 << 15 | n3 >>> 17) ^ (n3 << 13 | n3 >>> 19) ^ n3 >>> 10;
            Yt[r3] = e3 + Yt[r3 - 7] + i3 + Yt[r3 - 16];
          }
          const d2 = n2 & i2 ^ n2 & o2 ^ i2 & o2, m2 = (n2 << 30 | n2 >>> 2) ^ (n2 << 19 | n2 >>> 13) ^ (n2 << 10 | n2 >>> 22), u2 = c2 + ((s2 << 26 | s2 >>> 6) ^ (s2 << 21 | s2 >>> 11) ^ (s2 << 7 | s2 >>> 25)) + (s2 & l2 ^ ~s2 & p2) + Jt[r3] + Yt[r3];
          c2 = p2, p2 = l2, l2 = s2, s2 = a2 + u2 | 0, a2 = o2, o2 = i2, i2 = n2, n2 = u2 + (m2 + d2) | 0;
        }
        r2[0] = r2[0] + n2 | 0, r2[1] = r2[1] + i2 | 0, r2[2] = r2[2] + o2 | 0, r2[3] = r2[3] + a2 | 0, r2[4] = r2[4] + s2 | 0, r2[5] = r2[5] + l2 | 0, r2[6] = r2[6] + p2 | 0, r2[7] = r2[7] + c2 | 0;
      }
      finalize(t2) {
        super.finalize(t2);
        const e2 = 8 * this._nDataBytes, r2 = 8 * this._data.sigBytes;
        return this._data.words[r2 >>> 5] |= 128 << 24 - r2 % 32, this._data.words[14 + (r2 + 64 >>> 9 << 4)] = Math.floor(e2 / 4294967296), this._data.words[15 + (r2 + 64 >>> 9 << 4)] = e2, this._data.sigBytes = 4 * this._data.words.length, this._process(), this._hash;
      }
    }
    function hash(t2, e2 = {}) {
      const r2 = "string" == typeof t2 ? t2 : objectHash(t2, e2);
      return (n2 = r2, new SHA256().finalize(n2).toString(qt)).slice(0, 10);
      var n2;
    }
    function asyncCall(t2, ...e2) {
      try {
        return (r2 = t2(...e2)) && "function" == typeof r2.then ? r2 : Promise.resolve(r2);
      } catch (t3) {
        return Promise.reject(t3);
      }
      var r2;
    }
    function stringify$1(t2) {
      if (function(t3) {
        const e2 = typeof t3;
        return null === t3 || "object" !== e2 && "function" !== e2;
      }(t2))
        return String(t2);
      if (function(t3) {
        const e2 = Object.getPrototypeOf(t3);
        return !e2 || e2.isPrototypeOf(Object);
      }(t2) || Array.isArray(t2))
        return JSON.stringify(t2);
      if ("function" == typeof t2.toJSON)
        return stringify$1(t2.toJSON());
      throw new Error("[unstorage] Cannot stringify value!");
    }
    function checkBufferSupport() {
      if (void 0 === typeof c)
        throw new TypeError("[unstorage] Buffer is not supported!");
    }
    const Xt = "base64:";
    const Qt = ["hasItem", "getItem", "getItemRaw", "setItem", "setItemRaw", "removeItem", "getMeta", "setMeta", "removeMeta", "getKeys", "clear", "mount", "unmount"];
    function normalizeKey$1(t2) {
      return t2 ? t2.split("?")[0].replace(/[/\\]/g, ":").replace(/:+/g, ":").replace(/^:|:$/g, "") : "";
    }
    function joinKeys(...t2) {
      return normalizeKey$1(t2.join(":"));
    }
    function normalizeBaseKey(t2) {
      return (t2 = normalizeKey$1(t2)) ? t2 + ":" : "";
    }
    const memory = () => {
      const t2 = /* @__PURE__ */ new Map();
      return { name: "memory", options: {}, hasItem: (e2) => t2.has(e2), getItem: (e2) => t2.get(e2) ?? null, getItemRaw: (e2) => t2.get(e2) ?? null, setItem(e2, r2) {
        t2.set(e2, r2);
      }, setItemRaw(e2, r2) {
        t2.set(e2, r2);
      }, removeItem(e2) {
        t2.delete(e2);
      }, getKeys: () => Array.from(t2.keys()), clear() {
        t2.clear();
      }, dispose() {
        t2.clear();
      } };
    };
    function watch(t2, e2, r2) {
      return t2.watch ? t2.watch((t3, n2) => e2(t3, r2 + n2)) : () => {
      };
    }
    async function dispose(t2) {
      "function" == typeof t2.dispose && await asyncCall(t2.dispose);
    }
    const Zt = {}, normalizeKey = function(t2) {
      return t2 ? t2.split("?")[0].replace(/[/\\]/g, ":").replace(/:+/g, ":").replace(/^:|:$/g, "") : "";
    }, te = { getKeys: () => Promise.resolve(Object.keys(Zt)), hasItem: (t2) => (t2 = normalizeKey(t2), Promise.resolve(t2 in Zt)), getItem: (t2) => (t2 = normalizeKey(t2), Promise.resolve(Zt[t2] ? Zt[t2].import() : null)), getMeta: (t2) => (t2 = normalizeKey(t2), Promise.resolve(Zt[t2] ? Zt[t2].meta : {})) }, ee = function(t2 = {}) {
      const e2 = { mounts: { "": t2.driver || memory() }, mountpoints: [""], watching: false, watchListeners: [], unwatch: {} }, getMount = (t3) => {
        for (const r3 of e2.mountpoints)
          if (t3.startsWith(r3))
            return { base: r3, relativeKey: t3.slice(r3.length), driver: e2.mounts[r3] };
        return { base: "", relativeKey: t3, driver: e2.mounts[""] };
      }, getMounts = (t3, r3) => e2.mountpoints.filter((e3) => e3.startsWith(t3) || r3 && t3.startsWith(e3)).map((r4) => ({ relativeBase: t3.length > r4.length ? t3.slice(r4.length) : void 0, mountpoint: r4, driver: e2.mounts[r4] })), onChange = (t3, r3) => {
        if (e2.watching) {
          r3 = normalizeKey$1(r3);
          for (const n2 of e2.watchListeners)
            n2(t3, r3);
        }
      }, stopWatch = async () => {
        if (e2.watching) {
          for (const t3 in e2.unwatch)
            await e2.unwatch[t3]();
          e2.unwatch = {}, e2.watching = false;
        }
      }, runBatch = (t3, e3, r3) => {
        const n2 = /* @__PURE__ */ new Map(), getBatch = (t4) => {
          let e4 = n2.get(t4.base);
          return e4 || (e4 = { driver: t4.driver, base: t4.base, items: [] }, n2.set(t4.base, e4)), e4;
        };
        for (const r4 of t3) {
          const t4 = "string" == typeof r4, n3 = normalizeKey$1(t4 ? r4 : r4.key), i2 = t4 ? void 0 : r4.value, o2 = t4 || !r4.options ? e3 : { ...e3, ...r4.options }, a2 = getMount(n3);
          getBatch(a2).items.push({ key: n3, value: i2, relativeKey: a2.relativeKey, options: o2 });
        }
        return Promise.all([...n2.values()].map((t4) => r3(t4))).then((t4) => t4.flat());
      }, r2 = { hasItem(t3, e3 = {}) {
        t3 = normalizeKey$1(t3);
        const { relativeKey: r3, driver: n2 } = getMount(t3);
        return asyncCall(n2.hasItem, r3, e3);
      }, getItem(t3, e3 = {}) {
        t3 = normalizeKey$1(t3);
        const { relativeKey: r3, driver: n2 } = getMount(t3);
        return asyncCall(n2.getItem, r3, e3).then((t4) => destr(t4));
      }, getItems: (t3, e3) => runBatch(t3, e3, (t4) => t4.driver.getItems ? asyncCall(t4.driver.getItems, t4.items.map((t5) => ({ key: t5.relativeKey, options: t5.options })), e3).then((e4) => e4.map((e5) => ({ key: joinKeys(t4.base, e5.key), value: destr(e5.value) }))) : Promise.all(t4.items.map((e4) => asyncCall(t4.driver.getItem, e4.relativeKey, e4.options).then((t5) => ({ key: e4.key, value: destr(t5) }))))), getItemRaw(t3, e3 = {}) {
        t3 = normalizeKey$1(t3);
        const { relativeKey: r3, driver: n2 } = getMount(t3);
        return n2.getItemRaw ? asyncCall(n2.getItemRaw, r3, e3) : asyncCall(n2.getItem, r3, e3).then((t4) => function(t5) {
          return "string" != typeof t5 ? t5 : t5.startsWith(Xt) ? (checkBufferSupport(), c.from(t5.slice(Xt.length), "base64")) : t5;
        }(t4));
      }, async setItem(t3, e3, n2 = {}) {
        if (void 0 === e3)
          return r2.removeItem(t3);
        t3 = normalizeKey$1(t3);
        const { relativeKey: i2, driver: o2 } = getMount(t3);
        o2.setItem && (await asyncCall(o2.setItem, i2, stringify$1(e3), n2), o2.watch || onChange("update", t3));
      }, async setItems(t3, e3) {
        await runBatch(t3, e3, async (t4) => {
          t4.driver.setItems && await asyncCall(t4.driver.setItems, t4.items.map((t5) => ({ key: t5.relativeKey, value: stringify$1(t5.value), options: t5.options })), e3), t4.driver.setItem && await Promise.all(t4.items.map((e4) => asyncCall(t4.driver.setItem, e4.relativeKey, stringify$1(e4.value), e4.options)));
        });
      }, async setItemRaw(t3, e3, n2 = {}) {
        if (void 0 === e3)
          return r2.removeItem(t3, n2);
        t3 = normalizeKey$1(t3);
        const { relativeKey: i2, driver: o2 } = getMount(t3);
        if (o2.setItemRaw)
          await asyncCall(o2.setItemRaw, i2, e3, n2);
        else {
          if (!o2.setItem)
            return;
          await asyncCall(o2.setItem, i2, function(t4) {
            if ("string" == typeof t4)
              return t4;
            checkBufferSupport();
            const e4 = c.from(t4).toString("base64");
            return Xt + e4;
          }(e3), n2);
        }
        o2.watch || onChange("update", t3);
      }, async removeItem(t3, e3 = {}) {
        "boolean" == typeof e3 && (e3 = { removeMeta: e3 }), t3 = normalizeKey$1(t3);
        const { relativeKey: r3, driver: n2 } = getMount(t3);
        n2.removeItem && (await asyncCall(n2.removeItem, r3, e3), (e3.removeMeta || e3.removeMata) && await asyncCall(n2.removeItem, r3 + "$", e3), n2.watch || onChange("remove", t3));
      }, async getMeta(t3, e3 = {}) {
        "boolean" == typeof e3 && (e3 = { nativeOnly: e3 }), t3 = normalizeKey$1(t3);
        const { relativeKey: r3, driver: n2 } = getMount(t3), i2 = /* @__PURE__ */ Object.create(null);
        if (n2.getMeta && Object.assign(i2, await asyncCall(n2.getMeta, r3, e3)), !e3.nativeOnly) {
          const t4 = await asyncCall(n2.getItem, r3 + "$", e3).then((t5) => destr(t5));
          t4 && "object" == typeof t4 && ("string" == typeof t4.atime && (t4.atime = new Date(t4.atime)), "string" == typeof t4.mtime && (t4.mtime = new Date(t4.mtime)), Object.assign(i2, t4));
        }
        return i2;
      }, setMeta(t3, e3, r3 = {}) {
        return this.setItem(t3 + "$", e3, r3);
      }, removeMeta(t3, e3 = {}) {
        return this.removeItem(t3 + "$", e3);
      }, async getKeys(t3, e3 = {}) {
        t3 = normalizeBaseKey(t3);
        const r3 = getMounts(t3, true);
        let n2 = [];
        const i2 = [];
        for (const t4 of r3) {
          const r4 = (await asyncCall(t4.driver.getKeys, t4.relativeBase, e3)).map((e4) => t4.mountpoint + normalizeKey$1(e4)).filter((t5) => !n2.some((e4) => t5.startsWith(e4)));
          i2.push(...r4), n2 = [t4.mountpoint, ...n2.filter((e4) => !e4.startsWith(t4.mountpoint))];
        }
        return t3 ? i2.filter((e4) => e4.startsWith(t3) && !e4.endsWith("$")) : i2.filter((t4) => !t4.endsWith("$"));
      }, async clear(t3, e3 = {}) {
        t3 = normalizeBaseKey(t3), await Promise.all(getMounts(t3, false).map(async (t4) => {
          if (t4.driver.clear)
            return asyncCall(t4.driver.clear, t4.relativeBase, e3);
          if (t4.driver.removeItem) {
            const r3 = await t4.driver.getKeys(t4.relativeBase || "", e3);
            return Promise.all(r3.map((r4) => t4.driver.removeItem(r4, e3)));
          }
        }));
      }, async dispose() {
        await Promise.all(Object.values(e2.mounts).map((t3) => dispose(t3)));
      }, watch: async (t3) => (await (async () => {
        if (!e2.watching) {
          e2.watching = true;
          for (const t4 in e2.mounts)
            e2.unwatch[t4] = await watch(e2.mounts[t4], onChange, t4);
        }
      })(), e2.watchListeners.push(t3), async () => {
        e2.watchListeners = e2.watchListeners.filter((e3) => e3 !== t3), 0 === e2.watchListeners.length && await stopWatch();
      }), async unwatch() {
        e2.watchListeners = [], await stopWatch();
      }, mount(t3, n2) {
        if ((t3 = normalizeBaseKey(t3)) && e2.mounts[t3])
          throw new Error(`already mounted at ${t3}`);
        return t3 && (e2.mountpoints.push(t3), e2.mountpoints.sort((t4, e3) => e3.length - t4.length)), e2.mounts[t3] = n2, e2.watching && Promise.resolve(watch(n2, onChange, t3)).then((r3) => {
          e2.unwatch[t3] = r3;
        }).catch(console.error), r2;
      }, async unmount(t3, r3 = true) {
        (t3 = normalizeBaseKey(t3)) && e2.mounts[t3] && (e2.watching && t3 in e2.unwatch && (e2.unwatch[t3](), delete e2.unwatch[t3]), r3 && await dispose(e2.mounts[t3]), e2.mountpoints = e2.mountpoints.filter((e3) => e3 !== t3), delete e2.mounts[t3]);
      }, getMount(t3 = "") {
        t3 = normalizeKey$1(t3) + ":";
        const e3 = getMount(t3);
        return { driver: e3.driver, base: e3.base };
      }, getMounts(t3 = "", e3 = {}) {
        t3 = normalizeKey$1(t3);
        return getMounts(t3, e3.parents).map((t4) => ({ driver: t4.driver, base: t4.mountpoint }));
      } };
      return r2;
    }({});
    function useStorage(t2 = "") {
      return t2 ? function(t3, e2) {
        if (!(e2 = normalizeBaseKey(e2)))
          return t3;
        const r2 = { ...t3 };
        for (const n2 of Qt)
          r2[n2] = (r3 = "", ...i2) => t3[n2](e2 + r3, ...i2);
        return r2.getKeys = (r3 = "", ...n2) => t3.getKeys(e2 + r3, ...n2).then((t4) => t4.map((t5) => t5.slice(e2.length))), r2;
      }(ee, t2) : ee;
    }
    ee.mount("/assets", te);
    const re = { name: "_", base: "/cache", swr: true, maxAge: 1 };
    const cachedFunction = function(t2, e2 = {}) {
      e2 = { ...re, ...e2 };
      const r2 = {}, n2 = e2.group || "nitro/functions", i2 = e2.name || t2.name || "_", o2 = e2.integrity || hash([t2, e2]), a2 = e2.validate || ((t3) => void 0 !== t3.value);
      return async (...s2) => {
        const l2 = e2.shouldBypassCache?.(...s2);
        if (l2)
          return t2(...s2);
        const p2 = await (e2.getKey || getKey)(...s2), c2 = e2.shouldInvalidateCache?.(...s2), d2 = await async function(t3, s3, l3, p3) {
          const c3 = [e2.base, n2, i2, t3 + ".json"].filter(Boolean).join(":").replace(/:\/$/, ":index"), d3 = await useStorage().getItem(c3) || {}, m3 = 1e3 * (e2.maxAge ?? e2.maxAge ?? 0);
          m3 && (d3.expires = Date.now() + m3);
          const u2 = l3 || d3.integrity !== o2 || m3 && Date.now() - (d3.mtime || 0) > m3 || false === a2(d3), h2 = u2 ? (async () => {
            const n3 = r2[t3];
            n3 || (void 0 !== d3.value && (e2.staleMaxAge || 0) >= 0 && false === e2.swr && (d3.value = void 0, d3.integrity = void 0, d3.mtime = void 0, d3.expires = void 0), r2[t3] = Promise.resolve(s3()));
            try {
              d3.value = await r2[t3];
            } catch (e3) {
              throw n3 || delete r2[t3], e3;
            }
            if (!n3 && (d3.mtime = Date.now(), d3.integrity = o2, delete r2[t3], false !== a2(d3))) {
              const t4 = useStorage().setItem(c3, d3).catch((t5) => {
                console.error("[nitro] [cache] Cache write error.", t5), useNitroApp().captureError(t5, { event: p3, tags: ["cache"] });
              });
              p3 && p3.waitUntil && p3.waitUntil(t4);
            }
          })() : Promise.resolve();
          return void 0 === d3.value ? await h2 : u2 && p3 && p3.waitUntil && p3.waitUntil(h2), e2.swr && false !== a2(d3) ? (h2.catch((t4) => {
            console.error("[nitro] [cache] SWR handler error.", t4), useNitroApp().captureError(t4, { event: p3, tags: ["cache"] });
          }), d3) : h2.then(() => d3);
        }(p2, () => t2(...s2), c2, s2[0] && isEvent(s2[0]) ? s2[0] : void 0);
        let m2 = d2.value;
        return e2.transform && (m2 = await e2.transform(d2, ...s2) || m2), m2;
      };
    };
    function getKey(...t2) {
      return t2.length > 0 ? hash(t2, {}) : "";
    }
    function escapeKey(t2) {
      return String(t2).replace(/\W/g, "");
    }
    function cloneWithProxy(t2, e2) {
      return new Proxy(t2, { get: (t3, r2, n2) => r2 in e2 ? e2[r2] : Reflect.get(t3, r2, n2), set: (t3, r2, n2, i2) => r2 in e2 ? (e2[r2] = n2, true) : Reflect.set(t3, r2, n2, i2) });
    }
    const cachedEventHandler = function(t2, e2 = re) {
      const r2 = (e2.varies || []).filter(Boolean).map((t3) => t3.toLowerCase()).sort(), n2 = { ...e2, getKey: async (t3) => {
        const n3 = await e2.getKey?.(t3);
        if (n3)
          return escapeKey(n3);
        const i3 = t3.node.req.originalUrl || t3.node.req.url || t3.path;
        return [`${escapeKey(decodeURI(parseURL$1(i3).pathname)).slice(0, 16) || "index"}.${hash(i3)}`, ...r2.map((e3) => [e3, t3.node.req.headers[e3]]).map(([t4, e3]) => `${escapeKey(t4)}.${hash(e3)}`)].join(":");
      }, validate: (t3) => !!t3.value && (!(t3.value.code >= 400) && (void 0 !== t3.value.body && ("undefined" !== t3.value.headers.etag && "undefined" !== t3.value.headers["last-modified"]))), group: e2.group || "nitro/handlers", integrity: e2.integrity || hash([t2, e2]) }, i2 = cachedFunction(async (n3) => {
        const i3 = {};
        for (const t3 of r2)
          i3[t3] = n3.node.req.headers[t3];
        const o2 = cloneWithProxy(n3.node.req, { headers: i3 }), a2 = {};
        let s2;
        const l2 = cloneWithProxy(n3.node.res, { statusCode: 200, writableEnded: false, writableFinished: false, headersSent: false, closed: false, getHeader: (t3) => a2[t3], setHeader(t3, e3) {
          return a2[t3] = e3, this;
        }, getHeaderNames: () => Object.keys(a2), hasHeader: (t3) => t3 in a2, removeHeader(t3) {
          delete a2[t3];
        }, getHeaders: () => a2, end(t3, e3, r3) {
          return "string" == typeof t3 && (s2 = t3), "function" == typeof e3 && e3(), "function" == typeof r3 && r3(), this;
        }, write(t3, e3, r3) {
          return "string" == typeof t3 && (s2 = t3), "function" == typeof e3 && e3(), "function" == typeof r3 && r3(), this;
        }, writeHead(t3, e3) {
          if (this.statusCode = t3, e3)
            for (const t4 in e3)
              this.setHeader(t4, e3[t4]);
          return this;
        } }), p2 = createEvent(o2, l2);
        p2.context = n3.context;
        const c2 = await t2(p2) || s2, d2 = p2.node.res.getHeaders();
        d2.etag = String(d2.Etag || d2.etag || `W/"${hash(c2)}"`), d2["last-modified"] = String(d2["Last-Modified"] || d2["last-modified"] || (/* @__PURE__ */ new Date()).toUTCString());
        const m2 = [];
        e2.swr ? (e2.maxAge && m2.push(`s-maxage=${e2.maxAge}`), e2.staleMaxAge ? m2.push(`stale-while-revalidate=${e2.staleMaxAge}`) : m2.push("stale-while-revalidate")) : e2.maxAge && m2.push(`max-age=${e2.maxAge}`), m2.length > 0 && (d2["cache-control"] = m2.join(", "));
        return { code: p2.node.res.statusCode, headers: d2, body: c2 };
      }, n2);
      return defineEventHandler(async (r3) => {
        if (e2.headersOnly) {
          if (handleCacheHeaders(r3, { maxAge: e2.maxAge }))
            return;
          return t2(r3);
        }
        const n3 = await i2(r3);
        if (r3.node.res.headersSent || r3.node.res.writableEnded)
          return n3.body;
        if (!handleCacheHeaders(r3, { modifiedTime: new Date(n3.headers["last-modified"]), etag: n3.headers.etag, maxAge: e2.maxAge })) {
          r3.node.res.statusCode = n3.code;
          for (const t3 in n3.headers) {
            const e3 = n3.headers[t3];
            "set-cookie" === t3 ? r3.node.res.appendHeader(t3, splitCookiesString(e3)) : r3.node.res.setHeader(t3, e3);
          }
          return n3.body;
        }
      });
    }, ne = toRouteMatcher(createRouter$2({ routes: useRuntimeConfig$1().nitro.routeRules }));
    function createRouteRulesHandler(t2) {
      return vt((e2) => {
        const r2 = getRouteRules(e2);
        if (r2.headers && ht(e2, r2.headers), r2.redirect)
          return function(t3, e3, r3 = 302) {
            return t3.node.res.statusCode = sanitizeStatusCode(r3, t3.node.res.statusCode), t3.node.res.setHeader("location", e3), send(t3, `<!DOCTYPE html><html><head><meta http-equiv="refresh" content="0; url=${e3.replace(/"/g, "%22")}"></head></html>`, dt.html);
          }(e2, r2.redirect.to, r2.redirect.statusCode);
        if (r2.proxy) {
          let n2 = r2.proxy.to;
          if (n2.endsWith("/**")) {
            let t3 = e2.path;
            const i2 = r2.proxy._proxyStripBase;
            i2 && (t3 = withoutBase(t3, i2)), n2 = joinURL(n2.slice(0, -3), t3);
          } else if (e2.path.includes("?")) {
            n2 = withQuery(n2, getQuery$1(e2.path));
          }
          return proxyRequest(e2, n2, { fetch: t2.localFetch, ...r2.proxy });
        }
      });
    }
    function getRouteRules(t2) {
      return t2.context._nitro = t2.context._nitro || {}, t2.context._nitro.routeRules || (t2.context._nitro.routeRules = getRouteRulesForPath(withoutBase(t2.path.split("?")[0], useRuntimeConfig$1().app.baseURL))), t2.context._nitro.routeRules;
    }
    function getRouteRulesForPath(t2) {
      return Q({}, ...ne.matchAll(t2).reverse());
    }
    const ie = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof global ? global : {}, oe = "__unctx__", ae = ie[oe] || (ie[oe] = function(t2 = {}) {
      const e2 = {};
      return { get: (r2, n2 = {}) => (e2[r2] || (e2[r2] = function(t3 = {}) {
        let e3, r3 = false;
        const checkConflict = (t4) => {
          if (e3 && e3 !== t4)
            throw new Error("Context conflict");
        };
        let n3;
        if (t3.asyncContext) {
          const e4 = t3.AsyncLocalStorage || globalThis.AsyncLocalStorage;
          e4 ? n3 = new e4() : console.warn("[unctx] `AsyncLocalStorage` is not provided.");
        }
        const _getCurrentInstance = () => {
          if (n3 && void 0 === e3) {
            const t4 = n3.getStore();
            if (void 0 !== t4)
              return t4;
          }
          return e3;
        };
        return { use: () => {
          const t4 = _getCurrentInstance();
          if (void 0 === t4)
            throw new Error("Context is not available");
          return t4;
        }, tryUse: () => _getCurrentInstance(), set: (t4, n4) => {
          n4 || checkConflict(t4), e3 = t4, r3 = true;
        }, unset: () => {
          e3 = void 0, r3 = false;
        }, call: (t4, i2) => {
          checkConflict(t4), e3 = t4;
          try {
            return n3 ? n3.run(t4, i2) : i2();
          } finally {
            r3 || (e3 = void 0);
          }
        }, async callAsync(t4, i2) {
          e3 = t4;
          const onRestore = () => {
            e3 = t4;
          }, onLeave = () => e3 === t4 ? onRestore : void 0;
          le.add(onLeave);
          try {
            const o2 = n3 ? n3.run(t4, i2) : i2();
            return r3 || (e3 = void 0), await o2;
          } finally {
            le.delete(onLeave);
          }
        } };
      }({ ...t2, ...n2 })), e2[r2], e2[r2]) };
    }()), getContext = (t2, e2 = {}) => ae.get(t2, e2), se = "__unctx_async_handlers__", le = ie[se] || (ie[se] = /* @__PURE__ */ new Set()), pe = [];
    const errorHandler = async function(t2, e2) {
      const { stack: r2, statusCode: n2, statusMessage: i2, message: o2 } = function(t3) {
        const e3 = "function" == typeof S.cwd ? S.cwd() : "/", r3 = (t3.stack || "").split("\n").splice(1).filter((t4) => t4.includes("at ")).map((t4) => ({ text: t4.replace(e3 + "/", "./").replace("webpack:/", "").replace("file://", "").trim(), internal: t4.includes("node_modules") && !t4.includes(".cache") || t4.includes("internal") || t4.includes("new Promise") })), n3 = t3.statusCode || 500, i3 = t3.statusMessage ?? (404 === n3 ? "Not Found" : ""), o3 = t3.message || t3.toString();
        return { stack: r3, statusCode: n3, statusMessage: i3, message: o3 };
      }(t2), a2 = { url: e2.path, statusCode: n2, statusMessage: i2, message: o2, stack: "", data: t2.data };
      if (t2.unhandled || t2.fatal) {
        const e3 = ["[nuxt]", "[request error]", t2.unhandled && "[unhandled]", t2.fatal && "[fatal]", 200 !== Number(a2.statusCode) && `[${a2.statusCode}]`].filter(Boolean).join(" ");
        console.error(e3, a2.message + "\n" + r2.map((t3) => "  " + t3.text).join("  \n"));
      }
      if (e2.handled)
        return;
      if (setResponseStatus(e2, 200 !== a2.statusCode && a2.statusCode || 500, a2.statusMessage), function(t3) {
        if (hasReqHeader(t3, "accept", "text/html"))
          return false;
        return hasReqHeader(t3, "accept", "application/json") || hasReqHeader(t3, "user-agent", "curl/") || hasReqHeader(t3, "user-agent", "httpie/") || hasReqHeader(t3, "sec-fetch-mode", "cors") || t3.path.startsWith("/api/") || t3.path.endsWith(".json");
      }(e2))
        return setResponseHeader(e2, "Content-Type", "application/json"), send(e2, JSON.stringify(a2));
      const s2 = e2.path.startsWith("/__nuxt_error") ? null : await useNitroApp().localFetch(withQuery(joinURL(useRuntimeConfig$1().app.baseURL, "/__nuxt_error"), a2), { headers: getRequestHeaders(e2), redirect: "manual" }).catch(() => null);
      if (!s2) {
        const { template: t3 } = await Promise.resolve().then(function() {
          return fe;
        });
        if (e2.handled)
          return;
        return setResponseHeader(e2, "Content-Type", "text/html;charset=UTF-8"), send(e2, t3(a2));
      }
      const l2 = await s2.text();
      if (!e2.handled) {
        for (const [t3, r3] of s2.headers.entries())
          setResponseHeader(e2, t3, r3);
        return setResponseStatus(e2, s2.status && 200 !== s2.status ? s2.status : void 0, s2.statusText), send(e2, l2);
      }
    }, _lazy_R70nke = () => Promise.resolve().then(function() {
      return Nl;
    }), ce = [{ route: "/__nuxt_error", handler: _lazy_R70nke, lazy: true, middleware: false, method: void 0 }, { route: "/**", handler: _lazy_R70nke, lazy: true, middleware: false, method: void 0 }];
    const de = function() {
      const t2 = useRuntimeConfig$1(), e2 = createHooks(), captureError = (t3, r3 = {}) => {
        const n3 = e2.callHookParallel("error", t3, r3).catch((t4) => {
          console.error("Error while capturing another error", t4);
        });
        if (r3.event && isEvent(r3.event)) {
          const e3 = r3.event.context.nitro?.errors;
          e3 && e3.push({ error: t3, context: r3 }), r3.event.waitUntil && r3.event.waitUntil(n3);
        }
      }, r2 = createApp({ debug: destr(false), onError: (t3, e3) => (captureError(t3, { event: e3, tags: ["request"] }), errorHandler(t3, e3)), onRequest: async (t3) => {
        await de.hooks.callHook("request", t3).catch((e3) => {
          captureError(e3, { event: t3, tags: ["request"] });
        });
      }, onBeforeResponse: async (t3, e3) => {
        await de.hooks.callHook("beforeResponse", t3, e3).catch((e4) => {
          captureError(e4, { event: t3, tags: ["request", "response"] });
        });
      }, onAfterResponse: async (t3, e3) => {
        await de.hooks.callHook("afterResponse", t3, e3).catch((e4) => {
          captureError(e4, { event: t3, tags: ["request", "response"] });
        });
      } }), n2 = function(t3 = {}) {
        const e3 = createRouter$2({}), r3 = {};
        let n3;
        const i3 = {}, addRoute = (t4, n4, o3) => {
          let a3 = r3[t4];
          if (a3 || (r3[t4] = a3 = { path: t4, handlers: {} }, e3.insert(t4, a3)), Array.isArray(o3))
            for (const e4 of o3)
              addRoute(t4, n4, e4);
          else
            a3.handlers[o3] = toEventHandler(n4, 0, t4);
          return i3;
        };
        i3.use = i3.add = (t4, e4, r4) => addRoute(t4, e4, r4 || "all");
        for (const t4 of yt)
          i3[t4] = (e4, r4) => i3.add(e4, r4, t4);
        return i3.handler = vt((r4) => {
          let i4 = r4.path || "/";
          const o3 = i4.indexOf("?");
          -1 !== o3 && (i4 = i4.slice(0, Math.max(0, o3)));
          const a3 = e3.lookup(i4);
          if (!a3 || !a3.handlers) {
            if (t3.preemptive || t3.preemtive)
              throw createError$1({ statusCode: 404, name: "Not Found", statusMessage: `Cannot find any route matching ${r4.path || "/"}.` });
            return;
          }
          const s3 = (r4.node.req.method || "get").toLowerCase();
          let l3 = a3.handlers[s3] || a3.handlers.all;
          if (!l3) {
            n3 || (n3 = toRouteMatcher(e3));
            const t4 = n3.matchAll(i4).reverse();
            for (const e4 of t4) {
              if (e4.handlers[s3]) {
                l3 = e4.handlers[s3], a3.handlers[s3] = a3.handlers[s3] || l3;
                break;
              }
              if (e4.handlers.all) {
                l3 = e4.handlers.all, a3.handlers.all = a3.handlers.all || l3;
                break;
              }
            }
          }
          if (!l3) {
            if (t3.preemptive || t3.preemtive)
              throw createError$1({ statusCode: 405, name: "Method Not Allowed", statusMessage: `Method ${s3} is not allowed on this route.` });
            return;
          }
          r4.context.matchedRoute = a3;
          const p2 = a3.params || {};
          return r4.context.params = p2, Promise.resolve(l3(r4)).then((e4) => void 0 === e4 && (t3.preemptive || t3.preemtive) ? null : e4);
        }), i3;
      }({ preemptive: true }), i2 = (o2 = toNodeListener(r2), function(t3) {
        const e3 = new IncomingMessage(), r3 = new ServerResponse(e3);
        if (e3.url = t3.url || "/", e3.method = t3.method || "GET", e3.headers = {}, t3.headers) {
          const r4 = "function" == typeof t3.headers.entries ? t3.headers.entries() : Object.entries(t3.headers);
          for (const [t4, n3] of r4)
            n3 && (e3.headers[t4.toLowerCase()] = n3);
        }
        return e3.headers.host = e3.headers.host || t3.host || "localhost", e3.connection.encrypted = e3.connection.encrypted || "https" === t3.protocol, e3.body = t3.body || null, e3.__unenv__ = t3.context, o2(e3, r3).then(() => {
          let t4 = r3._data;
          (It.has(r3.statusCode) || "HEAD" === e3.method.toUpperCase()) && (t4 = null, delete r3._headers["content-length"]);
          const n3 = { body: t4, headers: r3._headers, status: r3.statusCode, statusText: r3.statusMessage };
          return e3.destroy(), r3.destroy(), n3;
        });
      });
      var o2;
      const a2 = function(t3, e3 = global.fetch) {
        return async function(r3, n3) {
          const i3 = r3.toString();
          if (!i3.startsWith("/"))
            return e3(i3, n3);
          try {
            const e4 = await t3({ url: i3, ...n3 });
            return new Response(e4.body, { status: e4.status, statusText: e4.statusText, headers: Object.fromEntries(Object.entries(e4.headers).map(([t4, e5]) => [t4, Array.isArray(e5) ? e5.join(",") : String(e5) || ""])) });
          } catch (t4) {
            return new Response(t4.toString(), { status: Number.parseInt(t4.statusCode || t4.code) || 500, statusText: t4.statusText });
          }
        };
      }(i2, globalThis.fetch), localFetch = (t3, e3) => a2(t3, e3).then((t4) => function(t5) {
        if (!t5.headers.has("set-cookie"))
          return t5;
        return new Response(t5.body, { status: t5.status, statusText: t5.statusText, headers: normalizeCookieHeaders(t5.headers) });
      }(t4)), s2 = createFetch$1({ fetch: localFetch, Headers: Pt, defaults: { baseURL: t2.app.baseURL } });
      globalThis.$fetch = s2, r2.use(createRouteRulesHandler({ localFetch })), r2.use(vt((t3) => {
        t3.context.nitro = t3.context.nitro || { errors: [] };
        const e3 = t3.node.req?.__unenv__;
        e3 && Object.assign(t3.context, e3), t3.fetch = (e4, r3) => fetchWithEvent(t3, e4, r3, { fetch: localFetch }), t3.$fetch = (e4, r3) => fetchWithEvent(t3, e4, r3, { fetch: s2 }), t3.waitUntil = (r3) => {
          t3.context.nitro._waitUntilPromises || (t3.context.nitro._waitUntilPromises = []), t3.context.nitro._waitUntilPromises.push(r3), e3?.waitUntil && e3.waitUntil(r3);
        }, t3.captureError = (e4, r3) => {
          captureError(e4, { event: t3, ...r3 });
        };
      }));
      for (const e3 of ce) {
        let i3 = e3.lazy ? lazyEventHandler(e3.handler) : e3.handler;
        if (e3.middleware || !e3.route) {
          const n3 = (t2.app.baseURL + (e3.route || "/")).replace(/\/+/g, "/");
          r2.use(n3, i3);
        } else {
          const t3 = getRouteRulesForPath(e3.route.replace(/:\w+|\*\*/g, "_"));
          t3.cache && (i3 = cachedEventHandler(i3, { group: "nitro/routes", ...t3.cache })), n2.use(e3.route, i3, e3.method);
        }
      }
      r2.use(t2.app.baseURL, n2.handler);
      const l2 = { hooks: e2, h3App: r2, router: n2, localCall: i2, localFetch, captureError };
      for (const t3 of pe)
        try {
          t3(l2);
        } catch (t4) {
          throw captureError(t4, { tags: ["plugin"] }), t4;
        }
      return l2;
    }(), useNitroApp = () => de, me = /post|put|patch/i;
    function hasReqHeader(t2, e2, r2) {
      const n2 = function(t3, e3) {
        return getRequestHeaders(t3)[e3.toLowerCase()];
      }(t2, e2);
      return n2 && "string" == typeof n2 && n2.toLowerCase().includes(r2);
    }
    function joinHeaders(t2) {
      return Array.isArray(t2) ? t2.join(", ") : String(t2);
    }
    function normalizeCookieHeader(t2 = "") {
      return splitCookiesString(joinHeaders(t2));
    }
    function normalizeCookieHeaders(t2) {
      const e2 = new Headers();
      for (const [r2, n2] of t2)
        if ("set-cookie" === r2)
          for (const t3 of normalizeCookieHeader(n2))
            e2.append("set-cookie", t3);
        else
          e2.set(r2, joinHeaders(n2));
      return e2;
    }
    const ue = { "/_nuxt/builds/meta": { maxAge: 31536e3 }, "/_nuxt/builds": { maxAge: 1 }, "/_nuxt": { maxAge: 31536e3 } };
    function assetsCacheControl(t2) {
      const e2 = function(t3 = "") {
        for (const e3 in ue)
          if (t3.startsWith(e3))
            return ue[e3];
        return {};
      }(new URL(t2.url).pathname);
      return e2.maxAge ? { browserTTL: e2.maxAge, edgeTTL: e2.maxAge } : {};
    }
    addEventListener("fetch", (t2) => {
      t2.respondWith(async function(t3) {
        try {
          return await _.getAssetFromKV(t3, { cacheControl: assetsCacheControl, mapRequestToAsset: baseURLModifier });
        } catch {
        }
        const e2 = new URL(t3.request.url);
        let r2;
        n2 = t3.request, me.test(n2.method) && (r2 = c.from(await t3.request.arrayBuffer()));
        var n2;
        return de.localFetch(e2.pathname + e2.search, { context: { cf: t3.request.cf, waitUntil: (e3) => t3.waitUntil(e3), cloudflare: { event: t3 } }, host: e2.hostname, protocol: e2.protocol, headers: t3.request.headers, method: t3.request.method, redirect: t3.request.redirect, body: r2 });
      }(t2));
    });
    const baseURLModifier = (t2) => {
      const e2 = withoutBase(t2.url, useRuntimeConfig$1().app.baseURL);
      return _.mapRequestToAsset(new Request(e2, t2));
    }, he = { appName: "Nuxt", version: "", statusCode: 500, statusMessage: "Server error", description: "This page is temporarily unavailable." }, template$1 = (t2) => function({ messages: t3 }) {
      var e2, r2 = "";
      return r2 + "<!DOCTYPE html><html><head><title>" + (null == (e2 = t3.statusCode) ? "" : e2) + " - " + (null == (e2 = t3.statusMessage) ? "" : e2) + " | " + (null == (e2 = t3.appName) ? "" : e2) + `</title><meta charset="utf-8"><meta content="width=device-width,initial-scale=1,minimum-scale=1" name="viewport"><style>.spotlight{background:linear-gradient(45deg, #00DC82 0%, #36E4DA 50%, #0047E1 100%);filter:blur(20vh)}*,:before,:after{-webkit-box-sizing:border-box;box-sizing:border-box;border-width:0;border-style:solid;border-color:#e0e0e0}*{--tw-ring-inset:var(--tw-empty, );--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(14, 165, 233, .5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000}:root{-moz-tab-size:4;-o-tab-size:4;tab-size:4}body{margin:0;font-family:inherit;line-height:inherit}html{-webkit-text-size-adjust:100%;font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,"Apple Color Emoji","Segoe UI Emoji",Segoe UI Symbol,"Noto Color Emoji";line-height:1.5}h1,p{margin:0}h1{font-size:inherit;font-weight:inherit}.bg-white{--tw-bg-opacity:1;background-color:rgba(255,255,255,var(--tw-bg-opacity))}.grid{display:-ms-grid;display:grid}.place-content-center{place-content:center}.font-sans{font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,"Apple Color Emoji","Segoe UI Emoji",Segoe UI Symbol,"Noto Color Emoji"}.font-medium{font-weight:500}.font-light{font-weight:300}.h-1\\/2{height:50%}.text-8xl{font-size:6rem;line-height:1}.text-xl{font-size:1.25rem;line-height:1.75rem}.leading-tight{line-height:1.25}.mb-8{margin-bottom:2rem}.mb-16{margin-bottom:4rem}.max-w-520px{max-width:520px}.min-h-screen{min-height:100vh}.overflow-hidden{overflow:hidden}.px-8{padding-left:2rem;padding-right:2rem}.fixed{position:fixed}.left-0{left:0}.right-0{right:0}.-bottom-1\\/2{bottom:-50%}.text-center{text-align:center}.text-black{--tw-text-opacity:1;color:rgba(0,0,0,var(--tw-text-opacity))}.antialiased{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}@media (min-width: 640px){.sm\\:text-4xl{font-size:2.25rem;line-height:2.5rem}.sm\\:text-10xl{font-size:10rem;line-height:1}.sm\\:px-0{padding-left:0;padding-right:0}}@media (prefers-color-scheme: dark){.dark\\:bg-black{--tw-bg-opacity:1;background-color:rgba(0,0,0,var(--tw-bg-opacity))}.dark\\:text-white{--tw-text-opacity:1;color:rgba(255,255,255,var(--tw-text-opacity))}}</style><script>(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const e of document.querySelectorAll('link[rel="modulepreload"]'))i(e);new MutationObserver(e=>{for(const r of e)if(r.type==="childList")for(const o of r.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&i(o)}).observe(document,{childList:!0,subtree:!0});function s(e){const r={};return e.integrity&&(r.integrity=e.integrity),e.referrerPolicy&&(r.referrerPolicy=e.referrerPolicy),e.crossOrigin==="use-credentials"?r.credentials="include":e.crossOrigin==="anonymous"?r.credentials="omit":r.credentials="same-origin",r}function i(e){if(e.ep)return;e.ep=!0;const r=s(e);fetch(e.href,r)}})();<\/script></head><body class="font-sans antialiased bg-white dark:bg-black text-black dark:text-white grid min-h-screen place-content-center overflow-hidden"><div class="fixed -bottom-1/2 left-0 right-0 h-1/2 spotlight"></div><div class="max-w-520px text-center"><h1 class="text-8xl sm:text-10xl font-medium mb-8">` + (null == (e2 = t3.statusCode) ? "" : e2) + '</h1><p class="text-xl px-8 sm:px-0 sm:text-4xl font-light mb-16 leading-tight">' + (null == (e2 = t3.description) ? "" : e2) + "</p></div></body></html>";
    }({ messages: { ...he, ...t2 } }), fe = Object.freeze(Object.defineProperty({ __proto__: null, template: template$1 }, Symbol.toStringTag, { value: "Module" }));
    function getModuleDependencies(t2, e2) {
      if (e2._dependencies[t2])
        return e2._dependencies[t2];
      const r2 = e2._dependencies[t2] = { scripts: {}, styles: {}, preload: {}, prefetch: {} }, n2 = e2.manifest[t2];
      if (!n2)
        return r2;
      n2.file && (r2.preload[t2] = n2, (n2.isEntry || n2.sideEffects) && (r2.scripts[t2] = n2));
      for (const t3 of n2.css || [])
        r2.styles[t3] = r2.preload[t3] = r2.prefetch[t3] = e2.manifest[t3];
      for (const t3 of n2.assets || [])
        r2.preload[t3] = r2.prefetch[t3] = e2.manifest[t3];
      for (const t3 of n2.imports || []) {
        const n3 = getModuleDependencies(t3, e2);
        Object.assign(r2.styles, n3.styles), Object.assign(r2.preload, n3.preload), Object.assign(r2.prefetch, n3.prefetch);
      }
      const i2 = {};
      for (const t3 in r2.preload) {
        const e3 = r2.preload[t3];
        e3.preload && (i2[t3] = e3);
      }
      return r2.preload = i2, r2;
    }
    function getRequestDependencies(t2, e2) {
      if (t2._requestDependencies)
        return t2._requestDependencies;
      const r2 = function(t3, e3) {
        const r3 = Array.from(t3).sort().join(",");
        if (e3._dependencySets[r3])
          return e3._dependencySets[r3];
        const n2 = { scripts: {}, styles: {}, preload: {}, prefetch: {} };
        for (const r4 of t3) {
          const t4 = getModuleDependencies(r4, e3);
          Object.assign(n2.scripts, t4.scripts), Object.assign(n2.styles, t4.styles), Object.assign(n2.preload, t4.preload), Object.assign(n2.prefetch, t4.prefetch);
          for (const t5 of e3.manifest[r4]?.dynamicImports || []) {
            const r5 = getModuleDependencies(t5, e3);
            Object.assign(n2.prefetch, r5.scripts), Object.assign(n2.prefetch, r5.styles), Object.assign(n2.prefetch, r5.preload);
          }
        }
        const i2 = {};
        for (const t4 in n2.prefetch) {
          const e4 = n2.prefetch[t4];
          e4.prefetch && (i2[t4] = e4);
        }
        n2.prefetch = i2;
        for (const t4 in n2.preload)
          delete n2.prefetch[t4];
        for (const t4 in n2.styles)
          delete n2.preload[t4], delete n2.prefetch[t4];
        return e3._dependencySets[r3] = n2, n2;
      }(new Set(Array.from([...e2._entrypoints, ...t2.modules || t2._registeredComponents || []])), e2);
      return t2._requestDependencies = r2, r2;
    }
    function renderStyles(t2, e2) {
      const { styles: r2 } = getRequestDependencies(t2, e2);
      return Object.values(r2).map((t3) => renderLinkToString({ rel: "stylesheet", href: e2.buildAssetsURL(t3.file) })).join("");
    }
    function getResources(t2, e2) {
      return [...getPreloadLinks(t2, e2), ...getPrefetchLinks(t2, e2)];
    }
    function renderResourceHints(t2, e2) {
      return getResources(t2, e2).map(renderLinkToString).join("");
    }
    function renderResourceHeaders(t2, e2) {
      return { link: getResources(t2, e2).map(renderLinkToHeader).join(", ") };
    }
    function getPreloadLinks(t2, e2) {
      const { preload: r2 } = getRequestDependencies(t2, e2);
      return Object.values(r2).map((t3) => ({ rel: t3.module ? "modulepreload" : "preload", as: t3.resourceType, type: t3.mimeType ?? null, crossorigin: "font" === t3.resourceType || "script" === t3.resourceType || t3.module ? "" : null, href: e2.buildAssetsURL(t3.file) }));
    }
    function getPrefetchLinks(t2, e2) {
      const { prefetch: r2 } = getRequestDependencies(t2, e2);
      return Object.values(r2).map((t3) => ({ rel: "prefetch", as: t3.resourceType, type: t3.mimeType ?? null, crossorigin: "font" === t3.resourceType || "script" === t3.resourceType || t3.module ? "" : null, href: e2.buildAssetsURL(t3.file) }));
    }
    function renderScripts(t2, e2) {
      const { scripts: r2 } = getRequestDependencies(t2, e2);
      return Object.values(r2).map((t3) => {
        return r3 = { type: t3.module ? "module" : null, src: e2.buildAssetsURL(t3.file), defer: t3.module ? null : "", crossorigin: "" }, `<script${Object.entries(r3).map(([t4, e3]) => null === e3 ? "" : e3 ? ` ${t4}="${e3}"` : " " + t4).join("")}><\/script>`;
        var r3;
      }).join("");
    }
    function createRenderer(t2, e2) {
      const r2 = function({ manifest: t3, buildAssetsURL: e3 }) {
        const r3 = { buildAssetsURL: e3 || withLeadingSlash, manifest: void 0, updateManifest, _dependencies: void 0, _dependencySets: void 0, _entrypoints: void 0 };
        function updateManifest(t4) {
          const e4 = Object.entries(t4);
          r3.manifest = t4, r3._dependencies = {}, r3._dependencySets = {}, r3._entrypoints = e4.filter((t5) => t5[1].isEntry).map(([t5]) => t5);
        }
        return updateManifest(t3), r3;
      }(e2);
      return { rendererContext: r2, async renderToString(n2) {
        n2._registeredComponents = n2._registeredComponents || /* @__PURE__ */ new Set();
        const i2 = await Promise.resolve(t2).then((t3) => t3.default || t3), o2 = await i2(n2), wrap = (t3) => () => t3(n2, r2);
        return { html: await e2.renderToString(o2, n2), renderResourceHeaders: wrap(renderResourceHeaders), renderResourceHints: wrap(renderResourceHints), renderStyles: wrap(renderStyles), renderScripts: wrap(renderScripts) };
      } };
    }
    function renderLinkToString(t2) {
      return `<link${Object.entries(t2).map(([t3, e2]) => null === e2 ? "" : e2 ? ` ${t3}="${e2}"` : " " + t3).join("")}>`;
    }
    function renderLinkToHeader(t2) {
      return `<${t2.href}>${Object.entries(t2).map(([t3, e2]) => "href" === t3 || null === e2 ? "" : e2 ? `; ${t3}="${e2}"` : `; ${t3}`).join("")}`;
    }
    const ge = { "<": "\\u003C", "\\": "\\\\", "\b": "\\b", "\f": "\\f", "\n": "\\n", "\r": "\\r", "	": "\\t", "\u2028": "\\u2028", "\u2029": "\\u2029" };
    class DevalueError extends Error {
      constructor(t2, e2) {
        super(t2), this.name = "DevalueError", this.path = e2.join("");
      }
    }
    function is_primitive(t2) {
      return Object(t2) !== t2;
    }
    const xe = Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
    function is_plain_object(t2) {
      const e2 = Object.getPrototypeOf(t2);
      return e2 === Object.prototype || null === e2 || Object.getOwnPropertyNames(e2).sort().join("\0") === xe;
    }
    function get_type(t2) {
      return Object.prototype.toString.call(t2).slice(8, -1);
    }
    function get_escaped_char(t2) {
      switch (t2) {
        case '"':
          return '\\"';
        case "<":
          return "\\u003C";
        case "\\":
          return "\\\\";
        case "\n":
          return "\\n";
        case "\r":
          return "\\r";
        case "	":
          return "\\t";
        case "\b":
          return "\\b";
        case "\f":
          return "\\f";
        case "\u2028":
          return "\\u2028";
        case "\u2029":
          return "\\u2029";
        default:
          return t2 < " " ? `\\u${t2.charCodeAt(0).toString(16).padStart(4, "0")}` : "";
      }
    }
    function stringify_string(t2) {
      let e2 = "", r2 = 0;
      const n2 = t2.length;
      for (let i2 = 0; i2 < n2; i2 += 1) {
        const n3 = get_escaped_char(t2[i2]);
        n3 && (e2 += t2.slice(r2, i2) + n3, r2 = i2 + 1);
      }
      return `"${0 === r2 ? t2 : e2 + t2.slice(r2)}"`;
    }
    const ve = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$", ye = /[<\b\f\n\r\t\0\u2028\u2029]/g, be = /^(?:do|if|in|for|int|let|new|try|var|byte|case|char|else|enum|goto|long|this|void|with|await|break|catch|class|const|final|float|short|super|throw|while|yield|delete|double|export|import|native|return|switch|throws|typeof|boolean|default|extends|finally|package|private|abstract|continue|debugger|function|volatile|interface|protected|transient|implements|instanceof|synchronized)$/;
    function uneval(t2, e2) {
      const r2 = /* @__PURE__ */ new Map(), n2 = [], i2 = /* @__PURE__ */ new Map();
      !function walk2(t3) {
        if ("function" == typeof t3)
          throw new DevalueError("Cannot stringify a function", n2);
        if (!is_primitive(t3)) {
          if (r2.has(t3))
            return void r2.set(t3, r2.get(t3) + 1);
          if (r2.set(t3, 1), e2) {
            const r3 = e2(t3);
            if ("string" == typeof r3)
              return void i2.set(t3, r3);
          }
          switch (get_type(t3)) {
            case "Number":
            case "BigInt":
            case "String":
            case "Boolean":
            case "Date":
            case "RegExp":
              return;
            case "Array":
              t3.forEach((t4, e3) => {
                n2.push(`[${e3}]`), walk2(t4), n2.pop();
              });
              break;
            case "Set":
              Array.from(t3).forEach(walk2);
              break;
            case "Map":
              for (const [e3, r3] of t3)
                n2.push(`.get(${is_primitive(e3) ? stringify_primitive$1(e3) : "..."})`), walk2(r3), n2.pop();
              break;
            default:
              if (!is_plain_object(t3))
                throw new DevalueError("Cannot stringify arbitrary non-POJOs", n2);
              if (Object.getOwnPropertySymbols(t3).length > 0)
                throw new DevalueError("Cannot stringify POJOs with symbolic keys", n2);
              for (const e3 in t3)
                n2.push(`.${e3}`), walk2(t3[e3]), n2.pop();
          }
        }
      }(t2);
      const o2 = /* @__PURE__ */ new Map();
      function stringify2(t3) {
        if (o2.has(t3))
          return o2.get(t3);
        if (is_primitive(t3))
          return stringify_primitive$1(t3);
        if (i2.has(t3))
          return i2.get(t3);
        const e3 = get_type(t3);
        switch (e3) {
          case "Number":
          case "String":
          case "Boolean":
            return `Object(${stringify2(t3.valueOf())})`;
          case "RegExp":
            return `new RegExp(${stringify_string(t3.source)}, "${t3.flags}")`;
          case "Date":
            return `new Date(${t3.getTime()})`;
          case "Array":
            const r3 = t3.map((e4, r4) => r4 in t3 ? stringify2(e4) : ""), n3 = 0 === t3.length || t3.length - 1 in t3 ? "" : ",";
            return `[${r3.join(",")}${n3}]`;
          case "Set":
          case "Map":
            return `new ${e3}([${Array.from(t3).map(stringify2).join(",")}])`;
          default:
            const i3 = `{${Object.keys(t3).map((e4) => `${function(t4) {
              return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(t4) ? t4 : escape_unsafe_chars(JSON.stringify(t4));
            }(e4)}:${stringify2(t3[e4])}`).join(",")}}`;
            return null === Object.getPrototypeOf(t3) ? Object.keys(t3).length > 0 ? `Object.assign(Object.create(null),${i3})` : "Object.create(null)" : i3;
        }
      }
      Array.from(r2).filter((t3) => t3[1] > 1).sort((t3, e3) => e3[1] - t3[1]).forEach((t3, e3) => {
        o2.set(t3[0], function(t4) {
          let e4 = "";
          do {
            e4 = ve[t4 % ve.length] + e4, t4 = ~~(t4 / ve.length) - 1;
          } while (t4 >= 0);
          return be.test(e4) ? `${e4}0` : e4;
        }(e3));
      });
      const a2 = stringify2(t2);
      if (o2.size) {
        const t3 = [], e3 = [], r3 = [];
        return o2.forEach((n3, o3) => {
          if (t3.push(n3), i2.has(o3))
            return void r3.push(i2.get(o3));
          if (is_primitive(o3))
            return void r3.push(stringify_primitive$1(o3));
          switch (get_type(o3)) {
            case "Number":
            case "String":
            case "Boolean":
              r3.push(`Object(${stringify2(o3.valueOf())})`);
              break;
            case "RegExp":
              r3.push(o3.toString());
              break;
            case "Date":
              r3.push(`new Date(${o3.getTime()})`);
              break;
            case "Array":
              r3.push(`Array(${o3.length})`), o3.forEach((t4, r4) => {
                e3.push(`${n3}[${r4}]=${stringify2(t4)}`);
              });
              break;
            case "Set":
              r3.push("new Set"), e3.push(`${n3}.${Array.from(o3).map((t4) => `add(${stringify2(t4)})`).join(".")}`);
              break;
            case "Map":
              r3.push("new Map"), e3.push(`${n3}.${Array.from(o3).map(([t4, e4]) => `set(${stringify2(t4)}, ${stringify2(e4)})`).join(".")}`);
              break;
            default:
              r3.push(null === Object.getPrototypeOf(o3) ? "Object.create(null)" : "{}"), Object.keys(o3).forEach((t4) => {
                e3.push(`${n3}${function(t5) {
                  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(t5) ? `.${t5}` : `[${escape_unsafe_chars(JSON.stringify(t5))}]`;
                }(t4)}=${stringify2(o3[t4])}`);
              });
          }
        }), e3.push(`return ${a2}`), `(function(${t3.join(",")}){${e3.join(";")}}(${r3.join(",")}))`;
      }
      return a2;
    }
    function escape_unsafe_char(t2) {
      return ge[t2] || t2;
    }
    function escape_unsafe_chars(t2) {
      return t2.replace(ye, escape_unsafe_char);
    }
    function stringify_primitive$1(t2) {
      if ("string" == typeof t2)
        return stringify_string(t2);
      if (void 0 === t2)
        return "void 0";
      if (0 === t2 && 1 / t2 < 0)
        return "-0";
      const e2 = String(t2);
      return "number" == typeof t2 ? e2.replace(/^(-)?0\./, "$1.") : "bigint" == typeof t2 ? t2 + "n" : e2;
    }
    const we = -1, ke = -2, Se = -3, Ce = -4, Ee = -5, _e = -6;
    function stringify(t2, e2) {
      const r2 = [], n2 = /* @__PURE__ */ new Map(), i2 = [];
      for (const t3 in e2)
        i2.push({ key: t3, fn: e2[t3] });
      const o2 = [];
      let a2 = 0;
      const s2 = function flatten(t3) {
        if ("function" == typeof t3)
          throw new DevalueError("Cannot stringify a function", o2);
        if (n2.has(t3))
          return n2.get(t3);
        if (void 0 === t3)
          return we;
        if (Number.isNaN(t3))
          return Se;
        if (t3 === 1 / 0)
          return Ce;
        if (t3 === -1 / 0)
          return Ee;
        if (0 === t3 && 1 / t3 < 0)
          return _e;
        const e3 = a2++;
        n2.set(t3, e3);
        for (const { key: n3, fn: o3 } of i2) {
          const i3 = o3(t3);
          if (i3)
            return r2[e3] = `["${n3}",${flatten(i3)}]`, e3;
        }
        let s3 = "";
        if (is_primitive(t3))
          s3 = stringify_primitive(t3);
        else {
          switch (get_type(t3)) {
            case "Number":
            case "String":
            case "Boolean":
              s3 = `["Object",${stringify_primitive(t3)}]`;
              break;
            case "BigInt":
              s3 = `["BigInt",${t3}]`;
              break;
            case "Date":
              s3 = `["Date","${t3.toISOString()}"]`;
              break;
            case "RegExp":
              const { source: e4, flags: r3 } = t3;
              s3 = r3 ? `["RegExp",${stringify_string(e4)},"${r3}"]` : `["RegExp",${stringify_string(e4)}]`;
              break;
            case "Array":
              s3 = "[";
              for (let e5 = 0; e5 < t3.length; e5 += 1)
                e5 > 0 && (s3 += ","), e5 in t3 ? (o2.push(`[${e5}]`), s3 += flatten(t3[e5]), o2.pop()) : s3 += ke;
              s3 += "]";
              break;
            case "Set":
              s3 = '["Set"';
              for (const e5 of t3)
                s3 += `,${flatten(e5)}`;
              s3 += "]";
              break;
            case "Map":
              s3 = '["Map"';
              for (const [e5, r4] of t3)
                o2.push(`.get(${is_primitive(e5) ? stringify_primitive(e5) : "..."})`), s3 += `,${flatten(e5)},${flatten(r4)}`;
              s3 += "]";
              break;
            default:
              if (!is_plain_object(t3))
                throw new DevalueError("Cannot stringify arbitrary non-POJOs", o2);
              if (Object.getOwnPropertySymbols(t3).length > 0)
                throw new DevalueError("Cannot stringify POJOs with symbolic keys", o2);
              if (null === Object.getPrototypeOf(t3)) {
                s3 = '["null"';
                for (const e5 in t3)
                  o2.push(`.${e5}`), s3 += `,${stringify_string(e5)},${flatten(t3[e5])}`, o2.pop();
                s3 += "]";
              } else {
                s3 = "{";
                let e5 = false;
                for (const r4 in t3)
                  e5 && (s3 += ","), e5 = true, o2.push(`.${r4}`), s3 += `${stringify_string(r4)}:${flatten(t3[r4])}`, o2.pop();
                s3 += "}";
              }
          }
        }
        return r2[e3] = s3, e3;
      }(t2);
      return s2 < 0 ? `${s2}` : `[${r2.join(",")}]`;
    }
    function stringify_primitive(t2) {
      const e2 = typeof t2;
      return "string" === e2 ? stringify_string(t2) : t2 instanceof String ? stringify_string(t2.toString()) : void 0 === t2 ? we.toString() : 0 === t2 && 1 / t2 < 0 ? _e.toString() : "bigint" === e2 ? `["BigInt","${t2}"]` : String(t2);
    }
    var Pe = { exports: {} }, Te = {}, Ae = { exports: {} }, Ie = {}, Ne = { exports: {} }, Re = {}, Oe = { exports: {} }, Le = {}, Me = { exports: {} }, Be = {};
    function makeMap(t2, e2) {
      const r2 = /* @__PURE__ */ Object.create(null), n2 = t2.split(",");
      for (let t3 = 0; t3 < n2.length; t3++)
        r2[n2[t3]] = true;
      return e2 ? (t3) => !!r2[t3.toLowerCase()] : (t3) => !!r2[t3];
    }
    Object.defineProperty(Be, "__esModule", { value: true });
    const De = Object.assign, je = Object.prototype.hasOwnProperty, Fe = Array.isArray, isMap = (t2) => "[object Map]" === toTypeString(t2), isSet = (t2) => "[object Set]" === toTypeString(t2), isDate = (t2) => "[object Date]" === toTypeString(t2), isFunction = (t2) => "function" == typeof t2, isString = (t2) => "string" == typeof t2, isSymbol = (t2) => "symbol" == typeof t2, isObject$1 = (t2) => null !== t2 && "object" == typeof t2, $e = Object.prototype.toString, toTypeString = (t2) => $e.call(t2), isPlainObject = (t2) => "[object Object]" === toTypeString(t2), Ve = makeMap(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"), ze = makeMap("bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"), cacheStringFunction = (t2) => {
      const e2 = /* @__PURE__ */ Object.create(null);
      return (r2) => e2[r2] || (e2[r2] = t2(r2));
    }, Ue = /-(\w)/g, He = cacheStringFunction((t2) => t2.replace(Ue, (t3, e2) => e2 ? e2.toUpperCase() : "")), qe = /\B([A-Z])/g, We = cacheStringFunction((t2) => t2.replace(qe, "-$1").toLowerCase()), Ke = cacheStringFunction((t2) => t2.charAt(0).toUpperCase() + t2.slice(1)), Ge = cacheStringFunction((t2) => t2 ? `on${Ke(t2)}` : "");
    let Je;
    const Ye = /^[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*$/;
    const Xe = { 1: "TEXT", 2: "CLASS", 4: "STYLE", 8: "PROPS", 16: "FULL_PROPS", 32: "NEED_HYDRATION", 64: "STABLE_FRAGMENT", 128: "KEYED_FRAGMENT", 256: "UNKEYED_FRAGMENT", 512: "NEED_PATCH", 1024: "DYNAMIC_SLOTS", 2048: "DEV_ROOT_FRAGMENT", [-1]: "HOISTED", [-2]: "BAIL" }, Qe = { 1: "STABLE", 2: "DYNAMIC", 3: "FORWARDED" }, Ze = makeMap("Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console"), tr = Ze;
    function normalizeStyle(t2) {
      if (Fe(t2)) {
        const e2 = {};
        for (let r2 = 0; r2 < t2.length; r2++) {
          const n2 = t2[r2], i2 = isString(n2) ? parseStringStyle(n2) : normalizeStyle(n2);
          if (i2)
            for (const t3 in i2)
              e2[t3] = i2[t3];
        }
        return e2;
      }
      if (isString(t2) || isObject$1(t2))
        return t2;
    }
    const er = /;(?![^(]*\))/g, rr = /:([^]+)/, nr = /\/\*[^]*?\*\//g;
    function parseStringStyle(t2) {
      const e2 = {};
      return t2.replace(nr, "").split(er).forEach((t3) => {
        if (t3) {
          const r2 = t3.split(rr);
          r2.length > 1 && (e2[r2[0].trim()] = r2[1].trim());
        }
      }), e2;
    }
    function normalizeClass(t2) {
      let e2 = "";
      if (isString(t2))
        e2 = t2;
      else if (Fe(t2))
        for (let r2 = 0; r2 < t2.length; r2++) {
          const n2 = normalizeClass(t2[r2]);
          n2 && (e2 += n2 + " ");
        }
      else if (isObject$1(t2))
        for (const r2 in t2)
          t2[r2] && (e2 += r2 + " ");
      return e2.trim();
    }
    const ir = makeMap("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot"), or = makeMap("svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view"), ar = makeMap("area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr"), sr = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", lr = makeMap(sr), pr = makeMap(sr + ",async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected");
    const cr = /[>/="'\u0009\u000a\u000c\u0020]/, dr = {};
    const mr = makeMap("accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap"), ur = makeMap("xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xmlns:xlink,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan"), hr = /["'&<>]/;
    const fr = /^-?>|<!--|-->|--!>|<!-$/g;
    function looseEqual(t2, e2) {
      if (t2 === e2)
        return true;
      let r2 = isDate(t2), n2 = isDate(e2);
      if (r2 || n2)
        return !(!r2 || !n2) && t2.getTime() === e2.getTime();
      if (r2 = isSymbol(t2), n2 = isSymbol(e2), r2 || n2)
        return t2 === e2;
      if (r2 = Fe(t2), n2 = Fe(e2), r2 || n2)
        return !(!r2 || !n2) && function(t3, e3) {
          if (t3.length !== e3.length)
            return false;
          let r3 = true;
          for (let n3 = 0; r3 && n3 < t3.length; n3++)
            r3 = looseEqual(t3[n3], e3[n3]);
          return r3;
        }(t2, e2);
      if (r2 = isObject$1(t2), n2 = isObject$1(e2), r2 || n2) {
        if (!r2 || !n2)
          return false;
        if (Object.keys(t2).length !== Object.keys(e2).length)
          return false;
        for (const r3 in t2) {
          const n3 = t2.hasOwnProperty(r3), i2 = e2.hasOwnProperty(r3);
          if (n3 && !i2 || !n3 && i2 || !looseEqual(t2[r3], e2[r3]))
            return false;
        }
      }
      return String(t2) === String(e2);
    }
    const replacer = (t2, e2) => e2 && e2.__v_isRef ? replacer(t2, e2.value) : isMap(e2) ? { [`Map(${e2.size})`]: [...e2.entries()].reduce((t3, [e3, r2], n2) => (t3[stringifySymbol(e3, n2) + " =>"] = r2, t3), {}) } : isSet(e2) ? { [`Set(${e2.size})`]: [...e2.values()].map((t3) => stringifySymbol(t3)) } : isSymbol(e2) ? stringifySymbol(e2) : !isObject$1(e2) || Fe(e2) || isPlainObject(e2) ? e2 : String(e2), stringifySymbol = (t2, e2 = "") => {
      var r2;
      return isSymbol(t2) ? `Symbol(${null != (r2 = t2.description) ? r2 : e2})` : t2;
    };
    Be.EMPTY_ARR = [], Be.EMPTY_OBJ = {}, Be.NO = () => false, Be.NOOP = () => {
    }, Be.PatchFlagNames = Xe, Be.camelize = He, Be.capitalize = Ke, Be.def = (t2, e2, r2) => {
      Object.defineProperty(t2, e2, { configurable: true, enumerable: false, value: r2 });
    }, Be.escapeHtml = function(t2) {
      const e2 = "" + t2, r2 = hr.exec(e2);
      if (!r2)
        return e2;
      let n2, i2, o2 = "", a2 = 0;
      for (i2 = r2.index; i2 < e2.length; i2++) {
        switch (e2.charCodeAt(i2)) {
          case 34:
            n2 = "&quot;";
            break;
          case 38:
            n2 = "&amp;";
            break;
          case 39:
            n2 = "&#39;";
            break;
          case 60:
            n2 = "&lt;";
            break;
          case 62:
            n2 = "&gt;";
            break;
          default:
            continue;
        }
        a2 !== i2 && (o2 += e2.slice(a2, i2)), a2 = i2 + 1, o2 += n2;
      }
      return a2 !== i2 ? o2 + e2.slice(a2, i2) : o2;
    }, Be.escapeHtmlComment = function(t2) {
      return t2.replace(fr, "");
    }, Be.extend = De, Be.genPropsAccessExp = function(t2) {
      return Ye.test(t2) ? `__props.${t2}` : `__props[${JSON.stringify(t2)}]`;
    }, Be.generateCodeFrame = function(t2, e2 = 0, r2 = t2.length) {
      let n2 = t2.split(/(\r?\n)/);
      const i2 = n2.filter((t3, e3) => e3 % 2 == 1);
      n2 = n2.filter((t3, e3) => e3 % 2 == 0);
      let o2 = 0;
      const a2 = [];
      for (let t3 = 0; t3 < n2.length; t3++)
        if (o2 += n2[t3].length + (i2[t3] && i2[t3].length || 0), o2 >= e2) {
          for (let s2 = t3 - 2; s2 <= t3 + 2 || r2 > o2; s2++) {
            if (s2 < 0 || s2 >= n2.length)
              continue;
            const l2 = s2 + 1;
            a2.push(`${l2}${" ".repeat(Math.max(3 - String(l2).length, 0))}|  ${n2[s2]}`);
            const p2 = n2[s2].length, c2 = i2[s2] && i2[s2].length || 0;
            if (s2 === t3) {
              const t4 = e2 - (o2 - (p2 + c2)), n3 = Math.max(1, r2 > o2 ? p2 - t4 : r2 - e2);
              a2.push("   |  " + " ".repeat(t4) + "^".repeat(n3));
            } else if (s2 > t3) {
              if (r2 > o2) {
                const t4 = Math.max(Math.min(r2 - o2, p2), 1);
                a2.push("   |  " + "^".repeat(t4));
              }
              o2 += p2 + c2;
            }
          }
          break;
        }
      return a2.join("\n");
    }, Be.getGlobalThis = () => Je || (Je = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : void 0 !== C ? C : {}), Be.hasChanged = (t2, e2) => !Object.is(t2, e2), Be.hasOwn = (t2, e2) => je.call(t2, e2), Be.hyphenate = We, Be.includeBooleanAttr = function(t2) {
      return !!t2 || "" === t2;
    }, Be.invokeArrayFns = (t2, e2) => {
      for (let r2 = 0; r2 < t2.length; r2++)
        t2[r2](e2);
    }, Be.isArray = Fe, Be.isBooleanAttr = pr, Be.isBuiltInDirective = ze, Be.isDate = isDate, Be.isFunction = isFunction, Be.isGloballyAllowed = Ze, Be.isGloballyWhitelisted = tr, Be.isHTMLTag = ir, Be.isIntegerKey = (t2) => isString(t2) && "NaN" !== t2 && "-" !== t2[0] && "" + parseInt(t2, 10) === t2, Be.isKnownHtmlAttr = mr, Be.isKnownSvgAttr = ur, Be.isMap = isMap, Be.isModelListener = (t2) => t2.startsWith("onUpdate:"), Be.isObject = isObject$1, Be.isOn = (t2) => 111 === t2.charCodeAt(0) && 110 === t2.charCodeAt(1) && (t2.charCodeAt(2) > 122 || t2.charCodeAt(2) < 97), Be.isPlainObject = isPlainObject, Be.isPromise = (t2) => (isObject$1(t2) || isFunction(t2)) && isFunction(t2.then) && isFunction(t2.catch), Be.isRegExp = (t2) => "[object RegExp]" === toTypeString(t2), Be.isReservedProp = Ve, Be.isSSRSafeAttrName = function(t2) {
      if (dr.hasOwnProperty(t2))
        return dr[t2];
      const e2 = cr.test(t2);
      return e2 && console.error(`unsafe attribute name: ${t2}`), dr[t2] = !e2;
    }, Be.isSVGTag = or, Be.isSet = isSet, Be.isSpecialBooleanAttr = lr, Be.isString = isString, Be.isSymbol = isSymbol, Be.isVoidTag = ar, Be.looseEqual = looseEqual, Be.looseIndexOf = function(t2, e2) {
      return t2.findIndex((t3) => looseEqual(t3, e2));
    }, Be.looseToNumber = (t2) => {
      const e2 = parseFloat(t2);
      return isNaN(e2) ? t2 : e2;
    }, Be.makeMap = makeMap, Be.normalizeClass = normalizeClass, Be.normalizeProps = function(t2) {
      if (!t2)
        return null;
      let { class: e2, style: r2 } = t2;
      return e2 && !isString(e2) && (t2.class = normalizeClass(e2)), r2 && (t2.style = normalizeStyle(r2)), t2;
    }, Be.normalizeStyle = normalizeStyle, Be.objectToString = $e, Be.parseStringStyle = parseStringStyle, Be.propsToAttrMap = { acceptCharset: "accept-charset", className: "class", htmlFor: "for", httpEquiv: "http-equiv" }, Be.remove = (t2, e2) => {
      const r2 = t2.indexOf(e2);
      r2 > -1 && t2.splice(r2, 1);
    }, Be.slotFlagsText = Qe, Be.stringifyStyle = function(t2) {
      let e2 = "";
      if (!t2 || isString(t2))
        return e2;
      for (const r2 in t2) {
        const n2 = t2[r2], i2 = r2.startsWith("--") ? r2 : We(r2);
        (isString(n2) || "number" == typeof n2) && (e2 += `${i2}:${n2};`);
      }
      return e2;
    }, Be.toDisplayString = (t2) => isString(t2) ? t2 : null == t2 ? "" : Fe(t2) || isObject$1(t2) && (t2.toString === $e || !isFunction(t2.toString)) ? JSON.stringify(t2, replacer, 2) : String(t2), Be.toHandlerKey = Ge, Be.toNumber = (t2) => {
      const e2 = isString(t2) ? Number(t2) : NaN;
      return isNaN(e2) ? t2 : e2;
    }, Be.toRawType = (t2) => toTypeString(t2).slice(8, -1), Be.toTypeString = toTypeString, Me.exports = Be;
    var gr = Me.exports;
    Object.defineProperty(Le, "__esModule", { value: true });
    var xr = gr;
    let vr;
    class EffectScope {
      constructor(t2 = false) {
        this.detached = t2, this._active = true, this.effects = [], this.cleanups = [], this.parent = vr, !t2 && vr && (this.index = (vr.scopes || (vr.scopes = [])).push(this) - 1);
      }
      get active() {
        return this._active;
      }
      run(t2) {
        if (this._active) {
          const e2 = vr;
          try {
            return vr = this, t2();
          } finally {
            vr = e2;
          }
        }
      }
      on() {
        vr = this;
      }
      off() {
        vr = this.parent;
      }
      stop(t2) {
        if (this._active) {
          let e2, r2;
          for (e2 = 0, r2 = this.effects.length; e2 < r2; e2++)
            this.effects[e2].stop();
          for (e2 = 0, r2 = this.cleanups.length; e2 < r2; e2++)
            this.cleanups[e2]();
          if (this.scopes)
            for (e2 = 0, r2 = this.scopes.length; e2 < r2; e2++)
              this.scopes[e2].stop(true);
          if (!this.detached && this.parent && !t2) {
            const t3 = this.parent.scopes.pop();
            t3 && t3 !== this && (this.parent.scopes[this.index] = t3, t3.index = this.index);
          }
          this.parent = void 0, this._active = false;
        }
      }
    }
    function recordEffectScope(t2, e2 = vr) {
      e2 && e2.active && e2.effects.push(t2);
    }
    const createDep = (t2) => {
      const e2 = new Set(t2);
      return e2.w = 0, e2.n = 0, e2;
    }, wasTracked = (t2) => (t2.w & wr) > 0, newTracked = (t2) => (t2.n & wr) > 0, yr = /* @__PURE__ */ new WeakMap();
    let br = 0, wr = 1;
    const kr = 30;
    let Sr;
    const Cr = Symbol(""), Er = Symbol("");
    class ReactiveEffect {
      constructor(t2, e2 = null, r2) {
        this.fn = t2, this.scheduler = e2, this.active = true, this.deps = [], this.parent = void 0, recordEffectScope(this, r2);
      }
      run() {
        if (!this.active)
          return this.fn();
        let t2 = Sr, e2 = _r;
        for (; t2; ) {
          if (t2 === this)
            return;
          t2 = t2.parent;
        }
        try {
          return this.parent = Sr, Sr = this, _r = true, wr = 1 << ++br, br <= kr ? (({ deps: t3 }) => {
            if (t3.length)
              for (let e3 = 0; e3 < t3.length; e3++)
                t3[e3].w |= wr;
          })(this) : cleanupEffect(this), this.fn();
        } finally {
          br <= kr && ((t3) => {
            const { deps: e3 } = t3;
            if (e3.length) {
              let r2 = 0;
              for (let n2 = 0; n2 < e3.length; n2++) {
                const i2 = e3[n2];
                wasTracked(i2) && !newTracked(i2) ? i2.delete(t3) : e3[r2++] = i2, i2.w &= ~wr, i2.n &= ~wr;
              }
              e3.length = r2;
            }
          })(this), wr = 1 << --br, Sr = this.parent, _r = e2, this.parent = void 0, this.deferStop && this.stop();
        }
      }
      stop() {
        Sr === this ? this.deferStop = true : this.active && (cleanupEffect(this), this.onStop && this.onStop(), this.active = false);
      }
    }
    function cleanupEffect(t2) {
      const { deps: e2 } = t2;
      if (e2.length) {
        for (let r2 = 0; r2 < e2.length; r2++)
          e2[r2].delete(t2);
        e2.length = 0;
      }
    }
    let _r = true;
    const Pr = [];
    function pauseTracking() {
      Pr.push(_r), _r = false;
    }
    function resetTracking() {
      const t2 = Pr.pop();
      _r = void 0 === t2 || t2;
    }
    function track(t2, e2, r2) {
      if (_r && Sr) {
        let e3 = yr.get(t2);
        e3 || yr.set(t2, e3 = /* @__PURE__ */ new Map());
        let n2 = e3.get(r2);
        n2 || e3.set(r2, n2 = createDep()), trackEffects(n2);
      }
    }
    function trackEffects(t2, e2) {
      let r2 = false;
      br <= kr ? newTracked(t2) || (t2.n |= wr, r2 = !wasTracked(t2)) : r2 = !t2.has(Sr), r2 && (t2.add(Sr), Sr.deps.push(t2));
    }
    function trigger(t2, e2, r2, n2, i2, o2) {
      const a2 = yr.get(t2);
      if (!a2)
        return;
      let s2 = [];
      if ("clear" === e2)
        s2 = [...a2.values()];
      else if ("length" === r2 && xr.isArray(t2)) {
        const t3 = Number(n2);
        a2.forEach((e3, r3) => {
          ("length" === r3 || !xr.isSymbol(r3) && r3 >= t3) && s2.push(e3);
        });
      } else
        switch (void 0 !== r2 && s2.push(a2.get(r2)), e2) {
          case "add":
            xr.isArray(t2) ? xr.isIntegerKey(r2) && s2.push(a2.get("length")) : (s2.push(a2.get(Cr)), xr.isMap(t2) && s2.push(a2.get(Er)));
            break;
          case "delete":
            xr.isArray(t2) || (s2.push(a2.get(Cr)), xr.isMap(t2) && s2.push(a2.get(Er)));
            break;
          case "set":
            xr.isMap(t2) && s2.push(a2.get(Cr));
        }
      if (1 === s2.length)
        s2[0] && triggerEffects(s2[0]);
      else {
        const t3 = [];
        for (const e3 of s2)
          e3 && t3.push(...e3);
        triggerEffects(createDep(t3));
      }
    }
    function triggerEffects(t2, e2) {
      const r2 = xr.isArray(t2) ? t2 : [...t2];
      for (const t3 of r2)
        t3.computed && triggerEffect(t3);
      for (const t3 of r2)
        t3.computed || triggerEffect(t3);
    }
    function triggerEffect(t2, e2) {
      (t2 !== Sr || t2.allowRecurse) && (t2.scheduler ? t2.scheduler() : t2.run());
    }
    const Tr = xr.makeMap("__proto__,__v_isRef,__isVue"), Ar = new Set(Object.getOwnPropertyNames(Symbol).filter((t2) => "arguments" !== t2 && "caller" !== t2).map((t2) => Symbol[t2]).filter(xr.isSymbol)), Ir = createArrayInstrumentations();
    function createArrayInstrumentations() {
      const t2 = {};
      return ["includes", "indexOf", "lastIndexOf"].forEach((e2) => {
        t2[e2] = function(...t3) {
          const r2 = toRaw(this);
          for (let t4 = 0, e3 = this.length; t4 < e3; t4++)
            track(r2, 0, t4 + "");
          const n2 = r2[e2](...t3);
          return -1 === n2 || false === n2 ? r2[e2](...t3.map(toRaw)) : n2;
        };
      }), ["push", "pop", "shift", "unshift", "splice"].forEach((e2) => {
        t2[e2] = function(...t3) {
          pauseTracking();
          const r2 = toRaw(this)[e2].apply(this, t3);
          return resetTracking(), r2;
        };
      }), t2;
    }
    function hasOwnProperty(t2) {
      const e2 = toRaw(this);
      return track(e2, 0, t2), e2.hasOwnProperty(t2);
    }
    class BaseReactiveHandler {
      constructor(t2 = false, e2 = false) {
        this._isReadonly = t2, this._shallow = e2;
      }
      get(t2, e2, r2) {
        const n2 = this._isReadonly, i2 = this._shallow;
        if ("__v_isReactive" === e2)
          return !n2;
        if ("__v_isReadonly" === e2)
          return n2;
        if ("__v_isShallow" === e2)
          return i2;
        if ("__v_raw" === e2)
          return r2 === (n2 ? i2 ? Wr : qr : i2 ? Hr : Ur).get(t2) || Object.getPrototypeOf(t2) === Object.getPrototypeOf(r2) ? t2 : void 0;
        const o2 = xr.isArray(t2);
        if (!n2) {
          if (o2 && xr.hasOwn(Ir, e2))
            return Reflect.get(Ir, e2, r2);
          if ("hasOwnProperty" === e2)
            return hasOwnProperty;
        }
        const a2 = Reflect.get(t2, e2, r2);
        return (xr.isSymbol(e2) ? Ar.has(e2) : Tr(e2)) ? a2 : (n2 || track(t2, 0, e2), i2 ? a2 : isRef(a2) ? o2 && xr.isIntegerKey(e2) ? a2 : a2.value : xr.isObject(a2) ? n2 ? readonly(a2) : reactive(a2) : a2);
      }
    }
    class MutableReactiveHandler extends BaseReactiveHandler {
      constructor(t2 = false) {
        super(false, t2);
      }
      set(t2, e2, r2, n2) {
        let i2 = t2[e2];
        if (!this._shallow) {
          const e3 = isReadonly(i2);
          if (isShallow(r2) || isReadonly(r2) || (i2 = toRaw(i2), r2 = toRaw(r2)), !xr.isArray(t2) && isRef(i2) && !isRef(r2))
            return !e3 && (i2.value = r2, true);
        }
        const o2 = xr.isArray(t2) && xr.isIntegerKey(e2) ? Number(e2) < t2.length : xr.hasOwn(t2, e2), a2 = Reflect.set(t2, e2, r2, n2);
        return t2 === toRaw(n2) && (o2 ? xr.hasChanged(r2, i2) && trigger(t2, "set", e2, r2) : trigger(t2, "add", e2, r2)), a2;
      }
      deleteProperty(t2, e2) {
        const r2 = xr.hasOwn(t2, e2);
        t2[e2];
        const n2 = Reflect.deleteProperty(t2, e2);
        return n2 && r2 && trigger(t2, "delete", e2, void 0), n2;
      }
      has(t2, e2) {
        const r2 = Reflect.has(t2, e2);
        return xr.isSymbol(e2) && Ar.has(e2) || track(t2, 0, e2), r2;
      }
      ownKeys(t2) {
        return track(t2, 0, xr.isArray(t2) ? "length" : Cr), Reflect.ownKeys(t2);
      }
    }
    class ReadonlyReactiveHandler extends BaseReactiveHandler {
      constructor(t2 = false) {
        super(true, t2);
      }
      set(t2, e2) {
        return true;
      }
      deleteProperty(t2, e2) {
        return true;
      }
    }
    const Nr = new MutableReactiveHandler(), Rr = new ReadonlyReactiveHandler(), Or = new MutableReactiveHandler(true), Lr = new ReadonlyReactiveHandler(true), toShallow = (t2) => t2, getProto = (t2) => Reflect.getPrototypeOf(t2);
    function get(t2, e2, r2 = false, n2 = false) {
      const i2 = toRaw(t2 = t2.__v_raw), o2 = toRaw(e2);
      r2 || (xr.hasChanged(e2, o2) && track(i2, 0, e2), track(i2, 0, o2));
      const { has: a2 } = getProto(i2), s2 = n2 ? toShallow : r2 ? toReadonly : toReactive;
      return a2.call(i2, e2) ? s2(t2.get(e2)) : a2.call(i2, o2) ? s2(t2.get(o2)) : void (t2 !== i2 && t2.get(e2));
    }
    function has$2(t2, e2 = false) {
      const r2 = this.__v_raw, n2 = toRaw(r2), i2 = toRaw(t2);
      return e2 || (xr.hasChanged(t2, i2) && track(n2, 0, t2), track(n2, 0, i2)), t2 === i2 ? r2.has(t2) : r2.has(t2) || r2.has(i2);
    }
    function size(t2, e2 = false) {
      return t2 = t2.__v_raw, !e2 && track(toRaw(t2), 0, Cr), Reflect.get(t2, "size", t2);
    }
    function add(t2) {
      t2 = toRaw(t2);
      const e2 = toRaw(this);
      return getProto(e2).has.call(e2, t2) || (e2.add(t2), trigger(e2, "add", t2, t2)), this;
    }
    function set(t2, e2) {
      e2 = toRaw(e2);
      const r2 = toRaw(this), { has: n2, get: i2 } = getProto(r2);
      let o2 = n2.call(r2, t2);
      o2 || (t2 = toRaw(t2), o2 = n2.call(r2, t2));
      const a2 = i2.call(r2, t2);
      return r2.set(t2, e2), o2 ? xr.hasChanged(e2, a2) && trigger(r2, "set", t2, e2) : trigger(r2, "add", t2, e2), this;
    }
    function deleteEntry(t2) {
      const e2 = toRaw(this), { has: r2, get: n2 } = getProto(e2);
      let i2 = r2.call(e2, t2);
      i2 || (t2 = toRaw(t2), i2 = r2.call(e2, t2)), n2 && n2.call(e2, t2);
      const o2 = e2.delete(t2);
      return i2 && trigger(e2, "delete", t2, void 0), o2;
    }
    function clear() {
      const t2 = toRaw(this), e2 = 0 !== t2.size, r2 = t2.clear();
      return e2 && trigger(t2, "clear", void 0, void 0), r2;
    }
    function createForEach(t2, e2) {
      return function(r2, n2) {
        const i2 = this, o2 = i2.__v_raw, a2 = toRaw(o2), s2 = e2 ? toShallow : t2 ? toReadonly : toReactive;
        return !t2 && track(a2, 0, Cr), o2.forEach((t3, e3) => r2.call(n2, s2(t3), s2(e3), i2));
      };
    }
    function createIterableMethod(t2, e2, r2) {
      return function(...n2) {
        const i2 = this.__v_raw, o2 = toRaw(i2), a2 = xr.isMap(o2), s2 = "entries" === t2 || t2 === Symbol.iterator && a2, l2 = "keys" === t2 && a2, p2 = i2[t2](...n2), c2 = r2 ? toShallow : e2 ? toReadonly : toReactive;
        return !e2 && track(o2, 0, l2 ? Er : Cr), { next() {
          const { value: t3, done: e3 } = p2.next();
          return e3 ? { value: t3, done: e3 } : { value: s2 ? [c2(t3[0]), c2(t3[1])] : c2(t3), done: e3 };
        }, [Symbol.iterator]() {
          return this;
        } };
      };
    }
    function createReadonlyMethod(t2) {
      return function(...e2) {
        return "delete" !== t2 && ("clear" === t2 ? void 0 : this);
      };
    }
    function createInstrumentations() {
      const t2 = { get(t3) {
        return get(this, t3);
      }, get size() {
        return size(this);
      }, has: has$2, add, set, delete: deleteEntry, clear, forEach: createForEach(false, false) }, e2 = { get(t3) {
        return get(this, t3, false, true);
      }, get size() {
        return size(this);
      }, has: has$2, add, set, delete: deleteEntry, clear, forEach: createForEach(false, true) }, r2 = { get(t3) {
        return get(this, t3, true);
      }, get size() {
        return size(this, true);
      }, has(t3) {
        return has$2.call(this, t3, true);
      }, add: createReadonlyMethod("add"), set: createReadonlyMethod("set"), delete: createReadonlyMethod("delete"), clear: createReadonlyMethod("clear"), forEach: createForEach(true, false) }, n2 = { get(t3) {
        return get(this, t3, true, true);
      }, get size() {
        return size(this, true);
      }, has(t3) {
        return has$2.call(this, t3, true);
      }, add: createReadonlyMethod("add"), set: createReadonlyMethod("set"), delete: createReadonlyMethod("delete"), clear: createReadonlyMethod("clear"), forEach: createForEach(true, true) };
      return ["keys", "values", "entries", Symbol.iterator].forEach((i2) => {
        t2[i2] = createIterableMethod(i2, false, false), r2[i2] = createIterableMethod(i2, true, false), e2[i2] = createIterableMethod(i2, false, true), n2[i2] = createIterableMethod(i2, true, true);
      }), [t2, r2, e2, n2];
    }
    const [Mr, Br, Dr, jr] = createInstrumentations();
    function createInstrumentationGetter(t2, e2) {
      const r2 = e2 ? t2 ? jr : Dr : t2 ? Br : Mr;
      return (e3, n2, i2) => "__v_isReactive" === n2 ? !t2 : "__v_isReadonly" === n2 ? t2 : "__v_raw" === n2 ? e3 : Reflect.get(xr.hasOwn(r2, n2) && n2 in e3 ? r2 : e3, n2, i2);
    }
    const Fr = { get: createInstrumentationGetter(false, false) }, $r = { get: createInstrumentationGetter(false, true) }, Vr = { get: createInstrumentationGetter(true, false) }, zr = { get: createInstrumentationGetter(true, true) }, Ur = /* @__PURE__ */ new WeakMap(), Hr = /* @__PURE__ */ new WeakMap(), qr = /* @__PURE__ */ new WeakMap(), Wr = /* @__PURE__ */ new WeakMap();
    function reactive(t2) {
      return isReadonly(t2) ? t2 : createReactiveObject(t2, false, Nr, Fr, Ur);
    }
    function readonly(t2) {
      return createReactiveObject(t2, true, Rr, Vr, qr);
    }
    function createReactiveObject(t2, e2, r2, n2, i2) {
      if (!xr.isObject(t2))
        return t2;
      if (t2.__v_raw && (!e2 || !t2.__v_isReactive))
        return t2;
      const o2 = i2.get(t2);
      if (o2)
        return o2;
      const a2 = (s2 = t2).__v_skip || !Object.isExtensible(s2) ? 0 : function(t3) {
        switch (t3) {
          case "Object":
          case "Array":
            return 1;
          case "Map":
          case "Set":
          case "WeakMap":
          case "WeakSet":
            return 2;
          default:
            return 0;
        }
      }(xr.toRawType(s2));
      var s2;
      if (0 === a2)
        return t2;
      const l2 = new Proxy(t2, 2 === a2 ? n2 : r2);
      return i2.set(t2, l2), l2;
    }
    function isReactive(t2) {
      return isReadonly(t2) ? isReactive(t2.__v_raw) : !(!t2 || !t2.__v_isReactive);
    }
    function isReadonly(t2) {
      return !(!t2 || !t2.__v_isReadonly);
    }
    function isShallow(t2) {
      return !(!t2 || !t2.__v_isShallow);
    }
    function toRaw(t2) {
      const e2 = t2 && t2.__v_raw;
      return e2 ? toRaw(e2) : t2;
    }
    const toReactive = (t2) => xr.isObject(t2) ? reactive(t2) : t2, toReadonly = (t2) => xr.isObject(t2) ? readonly(t2) : t2;
    function trackRefValue(t2) {
      _r && Sr && trackEffects((t2 = toRaw(t2)).dep || (t2.dep = createDep()));
    }
    function triggerRefValue(t2, e2) {
      const r2 = (t2 = toRaw(t2)).dep;
      r2 && triggerEffects(r2);
    }
    function isRef(t2) {
      return !(!t2 || true !== t2.__v_isRef);
    }
    function ref(t2) {
      return createRef(t2, false);
    }
    function createRef(t2, e2) {
      return isRef(t2) ? t2 : new RefImpl(t2, e2);
    }
    class RefImpl {
      constructor(t2, e2) {
        this.__v_isShallow = e2, this.dep = void 0, this.__v_isRef = true, this._rawValue = e2 ? t2 : toRaw(t2), this._value = e2 ? t2 : toReactive(t2);
      }
      get value() {
        return trackRefValue(this), this._value;
      }
      set value(t2) {
        const e2 = this.__v_isShallow || isShallow(t2) || isReadonly(t2);
        t2 = e2 ? t2 : toRaw(t2), xr.hasChanged(t2, this._rawValue) && (this._rawValue = t2, this._value = e2 ? t2 : toReactive(t2), triggerRefValue(this));
      }
    }
    function unref(t2) {
      return isRef(t2) ? t2.value : t2;
    }
    const Kr = { get: (t2, e2, r2) => unref(Reflect.get(t2, e2, r2)), set: (t2, e2, r2, n2) => {
      const i2 = t2[e2];
      return isRef(i2) && !isRef(r2) ? (i2.value = r2, true) : Reflect.set(t2, e2, r2, n2);
    } };
    class CustomRefImpl {
      constructor(t2) {
        this.dep = void 0, this.__v_isRef = true;
        const { get: e2, set: r2 } = t2(() => trackRefValue(this), () => triggerRefValue(this));
        this._get = e2, this._set = r2;
      }
      get value() {
        return this._get();
      }
      set value(t2) {
        this._set(t2);
      }
    }
    class ObjectRefImpl {
      constructor(t2, e2, r2) {
        this._object = t2, this._key = e2, this._defaultValue = r2, this.__v_isRef = true;
      }
      get value() {
        const t2 = this._object[this._key];
        return void 0 === t2 ? this._defaultValue : t2;
      }
      set value(t2) {
        this._object[this._key] = t2;
      }
      get dep() {
        return t2 = toRaw(this._object), e2 = this._key, null == (r2 = yr.get(t2)) ? void 0 : r2.get(e2);
        var t2, e2, r2;
      }
    }
    class GetterRefImpl {
      constructor(t2) {
        this._getter = t2, this.__v_isRef = true, this.__v_isReadonly = true;
      }
      get value() {
        return this._getter();
      }
    }
    function propertyToRef(t2, e2, r2) {
      const n2 = t2[e2];
      return isRef(n2) ? n2 : new ObjectRefImpl(t2, e2, r2);
    }
    class ComputedRefImpl {
      constructor(t2, e2, r2, n2) {
        this._setter = e2, this.dep = void 0, this.__v_isRef = true, this.__v_isReadonly = false, this._dirty = true, this.effect = new ReactiveEffect(t2, () => {
          this._dirty || (this._dirty = true, triggerRefValue(this));
        }), this.effect.computed = this, this.effect.active = this._cacheable = !n2, this.__v_isReadonly = r2;
      }
      get value() {
        const t2 = toRaw(this);
        return trackRefValue(t2), !t2._dirty && t2._cacheable || (t2._dirty = false, t2._value = t2.effect.run()), t2._value;
      }
      set value(t2) {
        this._setter(t2);
      }
    }
    const Gr = Promise.resolve(), Jr = [];
    let Yr = false;
    const flush = () => {
      for (let t2 = 0; t2 < Jr.length; t2++)
        Jr[t2]();
      Jr.length = 0, Yr = false;
    };
    class DeferredComputedRefImpl {
      constructor(t2) {
        let e2;
        this.dep = void 0, this._dirty = true, this.__v_isRef = true, this.__v_isReadonly = true;
        let r2 = false, n2 = false;
        this.effect = new ReactiveEffect(t2, (t3) => {
          if (this.dep) {
            if (t3)
              e2 = this._value, r2 = true;
            else if (!n2) {
              const t4 = r2 ? e2 : this._value;
              n2 = true, r2 = false, i2 = () => {
                this.effect.active && this._get() !== t4 && triggerRefValue(this), n2 = false;
              }, Jr.push(i2), Yr || (Yr = true, Gr.then(flush));
            }
            for (const t4 of this.dep)
              t4.computed instanceof DeferredComputedRefImpl && t4.scheduler(true);
          }
          var i2;
          this._dirty = true;
        }), this.effect.computed = this;
      }
      _get() {
        return this._dirty ? (this._dirty = false, this._value = this.effect.run()) : this._value;
      }
      get value() {
        return trackRefValue(this), toRaw(this)._get();
      }
    }
    Le.EffectScope = EffectScope, Le.ITERATE_KEY = Cr, Le.ReactiveEffect = ReactiveEffect, Le.computed = function(t2, e2, r2 = false) {
      let n2, i2;
      const o2 = xr.isFunction(t2);
      return o2 ? (n2 = t2, i2 = xr.NOOP) : (n2 = t2.get, i2 = t2.set), new ComputedRefImpl(n2, i2, o2 || !i2, r2);
    }, Le.customRef = function(t2) {
      return new CustomRefImpl(t2);
    }, Le.deferredComputed = function(t2) {
      return new DeferredComputedRefImpl(t2);
    }, Le.effect = function(t2, e2) {
      t2.effect instanceof ReactiveEffect && (t2 = t2.effect.fn);
      const r2 = new ReactiveEffect(t2);
      e2 && (xr.extend(r2, e2), e2.scope && recordEffectScope(r2, e2.scope)), e2 && e2.lazy || r2.run();
      const n2 = r2.run.bind(r2);
      return n2.effect = r2, n2;
    }, Le.effectScope = function(t2) {
      return new EffectScope(t2);
    }, Le.enableTracking = function() {
      Pr.push(_r), _r = true;
    }, Le.getCurrentScope = function() {
      return vr;
    }, Le.isProxy = function(t2) {
      return isReactive(t2) || isReadonly(t2);
    }, Le.isReactive = isReactive, Le.isReadonly = isReadonly, Le.isRef = isRef, Le.isShallow = isShallow, Le.markRaw = function(t2) {
      return xr.def(t2, "__v_skip", true), t2;
    }, Le.onScopeDispose = function(t2) {
      vr && vr.cleanups.push(t2);
    }, Le.pauseTracking = pauseTracking, Le.proxyRefs = function(t2) {
      return isReactive(t2) ? t2 : new Proxy(t2, Kr);
    }, Le.reactive = reactive, Le.readonly = readonly, Le.ref = ref, Le.resetTracking = resetTracking, Le.shallowReactive = function(t2) {
      return createReactiveObject(t2, false, Or, $r, Hr);
    }, Le.shallowReadonly = function(t2) {
      return createReactiveObject(t2, true, Lr, zr, Wr);
    }, Le.shallowRef = function(t2) {
      return createRef(t2, true);
    }, Le.stop = function(t2) {
      t2.effect.stop();
    }, Le.toRaw = toRaw, Le.toRef = function(t2, e2, r2) {
      return isRef(t2) ? t2 : xr.isFunction(t2) ? new GetterRefImpl(t2) : xr.isObject(t2) && arguments.length > 1 ? propertyToRef(t2, e2, r2) : ref(t2);
    }, Le.toRefs = function(t2) {
      const e2 = xr.isArray(t2) ? new Array(t2.length) : {};
      for (const r2 in t2)
        e2[r2] = propertyToRef(t2, r2);
      return e2;
    }, Le.toValue = function(t2) {
      return xr.isFunction(t2) ? t2() : unref(t2);
    }, Le.track = track, Le.trigger = trigger, Le.triggerRef = function(t2) {
      triggerRefValue(t2);
    }, Le.unref = unref, Oe.exports = Le;
    var Xr = Oe.exports;
    !function(t2) {
      Object.defineProperty(t2, "__esModule", { value: true });
      var e2 = Xr, r2 = gr;
      function callWithErrorHandling(t3, e3, r3, n3) {
        let i3;
        try {
          i3 = n3 ? t3(...n3) : t3();
        } catch (t4) {
          handleError(t4, e3, r3);
        }
        return i3;
      }
      function callWithAsyncErrorHandling(t3, e3, n3, i3) {
        if (r2.isFunction(t3)) {
          const o4 = callWithErrorHandling(t3, e3, n3, i3);
          return o4 && r2.isPromise(o4) && o4.catch((t4) => {
            handleError(t4, e3, n3);
          }), o4;
        }
        const o3 = [];
        for (let r3 = 0; r3 < t3.length; r3++)
          o3.push(callWithAsyncErrorHandling(t3[r3], e3, n3, i3));
        return o3;
      }
      function handleError(t3, e3, r3, n3 = true) {
        e3 && e3.vnode;
        if (e3) {
          let n4 = e3.parent;
          const i3 = e3.proxy, o3 = r3;
          for (; n4; ) {
            const e4 = n4.ec;
            if (e4) {
              for (let r4 = 0; r4 < e4.length; r4++)
                if (false === e4[r4](t3, i3, o3))
                  return;
            }
            n4 = n4.parent;
          }
          const a3 = e3.appContext.config.errorHandler;
          if (a3)
            return void callWithErrorHandling(a3, null, 10, [t3, i3, o3]);
        }
        !function(t4, e4, r4, n4 = true) {
          console.error(t4);
        }(t3, 0, 0, n3);
      }
      let n2 = false, i2 = false;
      const o2 = [];
      let a2 = 0;
      const s2 = [];
      let l2 = null, p2 = 0;
      const c2 = Promise.resolve();
      let d2 = null;
      function nextTick(t3) {
        const e3 = d2 || c2;
        return t3 ? e3.then(this ? t3.bind(this) : t3) : e3;
      }
      function queueJob(t3) {
        o2.length && o2.includes(t3, n2 && t3.allowRecurse ? a2 + 1 : a2) || (null == t3.id ? o2.push(t3) : o2.splice(function(t4) {
          let e3 = a2 + 1, r3 = o2.length;
          for (; e3 < r3; ) {
            const n3 = e3 + r3 >>> 1, i3 = o2[n3], a3 = getId(i3);
            a3 < t4 || a3 === t4 && i3.pre ? e3 = n3 + 1 : r3 = n3;
          }
          return e3;
        }(t3.id), 0, t3), queueFlush());
      }
      function queueFlush() {
        n2 || i2 || (i2 = true, d2 = c2.then(flushJobs));
      }
      function queuePostFlushCb(t3) {
        r2.isArray(t3) ? s2.push(...t3) : l2 && l2.includes(t3, t3.allowRecurse ? p2 + 1 : p2) || s2.push(t3), queueFlush();
      }
      function flushPreFlushCbs(t3, e3, r3 = n2 ? a2 + 1 : 0) {
        for (; r3 < o2.length; r3++) {
          const e4 = o2[r3];
          if (e4 && e4.pre) {
            if (t3 && e4.id !== t3.uid)
              continue;
            o2.splice(r3, 1), r3--, e4();
          }
        }
      }
      function flushPostFlushCbs(t3) {
        if (s2.length) {
          const t4 = [...new Set(s2)];
          if (s2.length = 0, l2)
            return void l2.push(...t4);
          for (l2 = t4, l2.sort((t5, e3) => getId(t5) - getId(e3)), p2 = 0; p2 < l2.length; p2++)
            l2[p2]();
          l2 = null, p2 = 0;
        }
      }
      const getId = (t3) => null == t3.id ? 1 / 0 : t3.id, comparator = (t3, e3) => {
        const r3 = getId(t3) - getId(e3);
        if (0 === r3) {
          if (t3.pre && !e3.pre)
            return -1;
          if (e3.pre && !t3.pre)
            return 1;
        }
        return r3;
      };
      function flushJobs(t3) {
        i2 = false, n2 = true, o2.sort(comparator);
        try {
          for (a2 = 0; a2 < o2.length; a2++) {
            const t4 = o2[a2];
            t4 && false !== t4.active && callWithErrorHandling(t4, null, 14);
          }
        } finally {
          a2 = 0, o2.length = 0, flushPostFlushCbs(), n2 = false, d2 = null, (o2.length || s2.length) && flushJobs();
        }
      }
      t2.devtools = void 0;
      let m2 = [];
      function emit(t3, e3, ...n3) {
        if (t3.isUnmounted)
          return;
        const i3 = t3.vnode.props || r2.EMPTY_OBJ;
        let o3 = n3;
        const a3 = e3.startsWith("update:"), s3 = a3 && e3.slice(7);
        if (s3 && s3 in i3) {
          const t4 = `${"modelValue" === s3 ? "model" : s3}Modifiers`, { number: e4, trim: a4 } = i3[t4] || r2.EMPTY_OBJ;
          a4 && (o3 = n3.map((t5) => r2.isString(t5) ? t5.trim() : t5)), e4 && (o3 = n3.map(r2.looseToNumber));
        }
        let l3, p3 = i3[l3 = r2.toHandlerKey(e3)] || i3[l3 = r2.toHandlerKey(r2.camelize(e3))];
        !p3 && a3 && (p3 = i3[l3 = r2.toHandlerKey(r2.hyphenate(e3))]), p3 && callWithAsyncErrorHandling(p3, t3, 6, o3);
        const c3 = i3[l3 + "Once"];
        if (c3) {
          if (t3.emitted) {
            if (t3.emitted[l3])
              return;
          } else
            t3.emitted = {};
          t3.emitted[l3] = true, callWithAsyncErrorHandling(c3, t3, 6, o3);
        }
      }
      function normalizeEmitsOptions(t3, e3, n3 = false) {
        const i3 = e3.emitsCache, o3 = i3.get(t3);
        if (void 0 !== o3)
          return o3;
        const a3 = t3.emits;
        let s3 = {}, l3 = false;
        if (!r2.isFunction(t3)) {
          const extendEmits = (t4) => {
            const n4 = normalizeEmitsOptions(t4, e3, true);
            n4 && (l3 = true, r2.extend(s3, n4));
          };
          !n3 && e3.mixins.length && e3.mixins.forEach(extendEmits), t3.extends && extendEmits(t3.extends), t3.mixins && t3.mixins.forEach(extendEmits);
        }
        return a3 || l3 ? (r2.isArray(a3) ? a3.forEach((t4) => s3[t4] = null) : r2.extend(s3, a3), r2.isObject(t3) && i3.set(t3, s3), s3) : (r2.isObject(t3) && i3.set(t3, null), null);
      }
      function isEmitListener(t3, e3) {
        return !(!t3 || !r2.isOn(e3)) && (e3 = e3.slice(2).replace(/Once$/, ""), r2.hasOwn(t3, e3[0].toLowerCase() + e3.slice(1)) || r2.hasOwn(t3, r2.hyphenate(e3)) || r2.hasOwn(t3, e3));
      }
      let u2 = null, h2 = null;
      function setCurrentRenderingInstance(t3) {
        const e3 = u2;
        return u2 = t3, h2 = t3 && t3.type.__scopeId || null, e3;
      }
      function withCtx(t3, e3 = u2, r3) {
        if (!e3)
          return t3;
        if (t3._n)
          return t3;
        const renderFnWithContext = (...r4) => {
          renderFnWithContext._d && setBlockTracking(-1);
          const n3 = setCurrentRenderingInstance(e3);
          let i3;
          try {
            i3 = t3(...r4);
          } finally {
            setCurrentRenderingInstance(n3), renderFnWithContext._d && setBlockTracking(1);
          }
          return i3;
        };
        return renderFnWithContext._n = true, renderFnWithContext._c = true, renderFnWithContext._d = true, renderFnWithContext;
      }
      function renderComponentRoot(t3) {
        const { type: e3, vnode: n3, proxy: i3, withProxy: o3, props: a3, propsOptions: [s3], slots: l3, attrs: p3, emit: c3, render: d3, renderCache: m3, data: u3, setupState: h3, ctx: g3, inheritAttrs: x3 } = t3;
        let v3, y3;
        const b3 = setCurrentRenderingInstance(t3);
        try {
          if (4 & n3.shapeFlag) {
            const t4 = o3 || i3, e4 = t4;
            v3 = normalizeVNode(d3.call(e4, t4, m3, a3, h3, u3, g3)), y3 = p3;
          } else {
            const t4 = e3;
            0, v3 = normalizeVNode(t4.length > 1 ? t4(a3, { attrs: p3, slots: l3, emit: c3 }) : t4(a3, null)), y3 = e3.props ? p3 : getFunctionalFallthrough(p3);
          }
        } catch (e4) {
          X2.length = 0, handleError(e4, t3, 1), v3 = createVNode(J2);
        }
        let w3 = v3;
        if (y3 && false !== x3) {
          const t4 = Object.keys(y3), { shapeFlag: e4 } = w3;
          t4.length && 7 & e4 && (s3 && t4.some(r2.isModelListener) && (y3 = filterModelListeners(y3, s3)), w3 = cloneVNode(w3, y3));
        }
        return n3.dirs && (w3 = cloneVNode(w3), w3.dirs = w3.dirs ? w3.dirs.concat(n3.dirs) : n3.dirs), n3.transition && (w3.transition = n3.transition), v3 = w3, setCurrentRenderingInstance(b3), v3;
      }
      const getFunctionalFallthrough = (t3) => {
        let e3;
        for (const n3 in t3)
          ("class" === n3 || "style" === n3 || r2.isOn(n3)) && ((e3 || (e3 = {}))[n3] = t3[n3]);
        return e3;
      }, filterModelListeners = (t3, e3) => {
        const n3 = {};
        for (const i3 in t3)
          r2.isModelListener(i3) && i3.slice(9) in e3 || (n3[i3] = t3[i3]);
        return n3;
      };
      function hasPropsChanged(t3, e3, r3) {
        const n3 = Object.keys(e3);
        if (n3.length !== Object.keys(t3).length)
          return true;
        for (let i3 = 0; i3 < n3.length; i3++) {
          const o3 = n3[i3];
          if (e3[o3] !== t3[o3] && !isEmitListener(r3, o3))
            return true;
        }
        return false;
      }
      function updateHOCHostEl({ vnode: t3, parent: e3 }, r3) {
        for (; e3 && e3.subTree === t3; )
          (t3 = e3.vnode).el = r3, e3 = e3.parent;
      }
      const g2 = "components";
      const x2 = Symbol.for("v-ndc");
      function resolveAsset(t3, e3, n3 = true, i3 = false) {
        const o3 = u2 || nt2;
        if (o3) {
          const n4 = o3.type;
          if (t3 === g2) {
            const t4 = getComponentName(n4, false);
            if (t4 && (t4 === e3 || t4 === r2.camelize(e3) || t4 === r2.capitalize(r2.camelize(e3))))
              return n4;
          }
          const a3 = resolve(o3[t3] || n4[t3], e3) || resolve(o3.appContext[t3], e3);
          return !a3 && i3 ? n4 : a3;
        }
      }
      function resolve(t3, e3) {
        return t3 && (t3[e3] || t3[r2.camelize(e3)] || t3[r2.capitalize(r2.camelize(e3))]);
      }
      const isSuspense = (t3) => t3.__isSuspense, v2 = { name: "Suspense", __isSuspense: true, process(t3, e3, r3, n3, i3, o3, a3, s3, l3, p3) {
        null == t3 ? function(t4, e4, r4, n4, i4, o4, a4, s4, l4) {
          const { p: p4, o: { createElement: c3 } } = l4, d3 = c3("div"), m3 = t4.suspense = createSuspenseBoundary(t4, i4, n4, e4, d3, r4, o4, a4, s4, l4);
          p4(null, m3.pendingBranch = t4.ssContent, d3, null, n4, m3, o4, a4), m3.deps > 0 ? (triggerEvent(t4, "onPending"), triggerEvent(t4, "onFallback"), p4(null, t4.ssFallback, e4, r4, n4, null, o4, a4), setActiveBranch(m3, t4.ssFallback)) : m3.resolve(false, true);
        }(e3, r3, n3, i3, o3, a3, s3, l3, p3) : function(t4, e4, r4, n4, i4, o4, a4, s4, { p: l4, um: p4, o: { createElement: c3 } }) {
          const d3 = e4.suspense = t4.suspense;
          d3.vnode = e4, e4.el = t4.el;
          const m3 = e4.ssContent, u3 = e4.ssFallback, { activeBranch: h3, pendingBranch: g3, isInFallback: x3, isHydrating: v3 } = d3;
          if (g3)
            d3.pendingBranch = m3, isSameVNodeType(m3, g3) ? (l4(g3, m3, d3.hiddenContainer, null, i4, d3, o4, a4, s4), d3.deps <= 0 ? d3.resolve() : x3 && (l4(h3, u3, r4, n4, i4, null, o4, a4, s4), setActiveBranch(d3, u3))) : (d3.pendingId++, v3 ? (d3.isHydrating = false, d3.activeBranch = g3) : p4(g3, i4, d3), d3.deps = 0, d3.effects.length = 0, d3.hiddenContainer = c3("div"), x3 ? (l4(null, m3, d3.hiddenContainer, null, i4, d3, o4, a4, s4), d3.deps <= 0 ? d3.resolve() : (l4(h3, u3, r4, n4, i4, null, o4, a4, s4), setActiveBranch(d3, u3))) : h3 && isSameVNodeType(m3, h3) ? (l4(h3, m3, r4, n4, i4, d3, o4, a4, s4), d3.resolve(true)) : (l4(null, m3, d3.hiddenContainer, null, i4, d3, o4, a4, s4), d3.deps <= 0 && d3.resolve()));
          else if (h3 && isSameVNodeType(m3, h3))
            l4(h3, m3, r4, n4, i4, d3, o4, a4, s4), setActiveBranch(d3, m3);
          else if (triggerEvent(e4, "onPending"), d3.pendingBranch = m3, d3.pendingId++, l4(null, m3, d3.hiddenContainer, null, i4, d3, o4, a4, s4), d3.deps <= 0)
            d3.resolve();
          else {
            const { timeout: t5, pendingId: e5 } = d3;
            t5 > 0 ? setTimeout(() => {
              d3.pendingId === e5 && d3.fallback(u3);
            }, t5) : 0 === t5 && d3.fallback(u3);
          }
        }(t3, e3, r3, n3, i3, a3, s3, l3, p3);
      }, hydrate: function(t3, e3, r3, n3, i3, o3, a3, s3, l3) {
        const p3 = e3.suspense = createSuspenseBoundary(e3, n3, r3, t3.parentNode, document.createElement("div"), null, i3, o3, a3, s3, true), c3 = l3(t3, p3.pendingBranch = e3.ssContent, r3, p3, o3, a3);
        0 === p3.deps && p3.resolve(false, true);
        return c3;
      }, create: createSuspenseBoundary, normalize: function(t3) {
        const { shapeFlag: e3, children: r3 } = t3, n3 = 32 & e3;
        t3.ssContent = normalizeSuspenseSlot(n3 ? r3.default : r3), t3.ssFallback = n3 ? normalizeSuspenseSlot(r3.fallback) : createVNode(J2);
      } };
      function triggerEvent(t3, e3) {
        const n3 = t3.props && t3.props[e3];
        r2.isFunction(n3) && n3();
      }
      function createSuspenseBoundary(t3, e3, n3, i3, o3, a3, s3, l3, p3, c3, d3 = false) {
        const { p: m3, m: u3, um: h3, n: g3, o: { parentNode: x3, remove: v3 } } = c3;
        let y3;
        const b3 = function(t4) {
          var e4;
          return null != (null == (e4 = t4.props) ? void 0 : e4.suspensible) && false !== t4.props.suspensible;
        }(t3);
        b3 && (null == e3 ? void 0 : e3.pendingBranch) && (y3 = e3.pendingId, e3.deps++);
        const w3 = t3.props ? r2.toNumber(t3.props.timeout) : void 0, k3 = { vnode: t3, parent: e3, parentComponent: n3, isSVG: s3, container: i3, hiddenContainer: o3, anchor: a3, deps: 0, pendingId: 0, timeout: "number" == typeof w3 ? w3 : -1, activeBranch: null, pendingBranch: null, isInFallback: !d3, isHydrating: d3, isUnmounted: false, effects: [], resolve(t4 = false, r3 = false) {
          const { vnode: n4, activeBranch: i4, pendingBranch: o4, pendingId: a4, effects: s4, parentComponent: l4, container: p4 } = k3;
          let c4 = false;
          if (k3.isHydrating)
            k3.isHydrating = false;
          else if (!t4) {
            c4 = i4 && o4.transition && "out-in" === o4.transition.mode, c4 && (i4.transition.afterLeave = () => {
              a4 === k3.pendingId && (u3(o4, p4, g3(i4), 0), queuePostFlushCb(s4));
            });
            let { anchor: t5 } = k3;
            i4 && (t5 = g3(i4), h3(i4, l4, k3, true)), c4 || u3(o4, p4, t5, 0);
          }
          setActiveBranch(k3, o4), k3.pendingBranch = null, k3.isInFallback = false;
          let d4 = k3.parent, m4 = false;
          for (; d4; ) {
            if (d4.pendingBranch) {
              d4.effects.push(...s4), m4 = true;
              break;
            }
            d4 = d4.parent;
          }
          m4 || c4 || queuePostFlushCb(s4), k3.effects = [], b3 && e3 && e3.pendingBranch && y3 === e3.pendingId && (e3.deps--, 0 !== e3.deps || r3 || e3.resolve()), triggerEvent(n4, "onResolve");
        }, fallback(t4) {
          if (!k3.pendingBranch)
            return;
          const { vnode: e4, activeBranch: r3, parentComponent: n4, container: i4, isSVG: o4 } = k3;
          triggerEvent(e4, "onFallback");
          const a4 = g3(r3), mountFallback = () => {
            k3.isInFallback && (m3(null, t4, i4, a4, n4, null, o4, l3, p3), setActiveBranch(k3, t4));
          }, s4 = t4.transition && "out-in" === t4.transition.mode;
          s4 && (r3.transition.afterLeave = mountFallback), k3.isInFallback = true, h3(r3, n4, null, true), s4 || mountFallback();
        }, move(t4, e4, r3) {
          k3.activeBranch && u3(k3.activeBranch, t4, e4, r3), k3.container = t4;
        }, next: () => k3.activeBranch && g3(k3.activeBranch), registerDep(t4, e4) {
          const r3 = !!k3.pendingBranch;
          r3 && k3.deps++;
          const n4 = t4.vnode.el;
          t4.asyncDep.catch((e5) => {
            handleError(e5, t4, 0);
          }).then((i4) => {
            if (t4.isUnmounted || k3.isUnmounted || k3.pendingId !== t4.suspenseId)
              return;
            t4.asyncResolved = true;
            const { vnode: o4 } = t4;
            handleSetupResult(t4, i4, false), n4 && (o4.el = n4);
            const a4 = !n4 && t4.subTree.el;
            e4(t4, o4, x3(n4 || t4.subTree.el), n4 ? null : g3(t4.subTree), k3, s3, p3), a4 && v3(a4), updateHOCHostEl(t4, o4.el), r3 && 0 == --k3.deps && k3.resolve();
          });
        }, unmount(t4, e4) {
          k3.isUnmounted = true, k3.activeBranch && h3(k3.activeBranch, n3, t4, e4), k3.pendingBranch && h3(k3.pendingBranch, n3, t4, e4);
        } };
        return k3;
      }
      function normalizeSuspenseSlot(t3) {
        let e3;
        if (r2.isFunction(t3)) {
          const r3 = Z2 && t3._c;
          r3 && (t3._d = false, openBlock()), t3 = t3(), r3 && (t3._d = true, e3 = Q2, closeBlock());
        }
        if (r2.isArray(t3)) {
          const e4 = function(t4) {
            let e5;
            for (let r3 = 0; r3 < t4.length; r3++) {
              const n3 = t4[r3];
              if (!isVNode(n3))
                return;
              if (n3.type !== J2 || "v-if" === n3.children) {
                if (e5)
                  return;
                e5 = n3;
              }
            }
            return e5;
          }(t3);
          t3 = e4;
        }
        return t3 = normalizeVNode(t3), e3 && !t3.dynamicChildren && (t3.dynamicChildren = e3.filter((e4) => e4 !== t3)), t3;
      }
      function queueEffectWithSuspense(t3, e3) {
        e3 && e3.pendingBranch ? r2.isArray(t3) ? e3.effects.push(...t3) : e3.effects.push(t3) : queuePostFlushCb(t3);
      }
      function setActiveBranch(t3, e3) {
        t3.activeBranch = e3;
        const { vnode: r3, parentComponent: n3 } = t3, i3 = r3.el = e3.el;
        n3 && n3.subTree === r3 && (n3.vnode.el = i3, updateHOCHostEl(n3, i3));
      }
      const y2 = {};
      function watch2(t3, e3, r3) {
        return doWatch(t3, e3, r3);
      }
      function doWatch(t3, n3, { immediate: i3, deep: o3, flush: a3, onTrack: s3, onTrigger: l3 } = r2.EMPTY_OBJ) {
        var p3;
        const c3 = e2.getCurrentScope() === (null == (p3 = nt2) ? void 0 : p3.scope) ? nt2 : null;
        let d3, m3, u3 = false, h3 = false;
        if (e2.isRef(t3) ? (d3 = () => t3.value, u3 = e2.isShallow(t3)) : e2.isReactive(t3) ? (d3 = () => t3, o3 = true) : r2.isArray(t3) ? (h3 = true, u3 = t3.some((t4) => e2.isReactive(t4) || e2.isShallow(t4)), d3 = () => t3.map((t4) => e2.isRef(t4) ? t4.value : e2.isReactive(t4) ? traverse(t4) : r2.isFunction(t4) ? callWithErrorHandling(t4, c3, 2) : void 0)) : d3 = r2.isFunction(t3) ? n3 ? () => callWithErrorHandling(t3, c3, 2) : () => {
          if (!c3 || !c3.isUnmounted)
            return m3 && m3(), callWithAsyncErrorHandling(t3, c3, 3, [onCleanup]);
        } : r2.NOOP, n3 && o3) {
          const t4 = d3;
          d3 = () => traverse(t4());
        }
        let g3, onCleanup = (t4) => {
          m3 = b3.onStop = () => {
            callWithErrorHandling(t4, c3, 4), m3 = b3.onStop = void 0;
          };
        };
        if (pt2) {
          if (onCleanup = r2.NOOP, n3 ? i3 && callWithAsyncErrorHandling(n3, c3, 3, [d3(), h3 ? [] : void 0, onCleanup]) : d3(), "sync" !== a3)
            return r2.NOOP;
          {
            const t4 = useSSRContext();
            g3 = t4.__watcherHandles || (t4.__watcherHandles = []);
          }
        }
        let x3 = h3 ? new Array(t3.length).fill(y2) : y2;
        const job = () => {
          if (b3.active)
            if (n3) {
              const t4 = b3.run();
              (o3 || u3 || (h3 ? t4.some((t5, e3) => r2.hasChanged(t5, x3[e3])) : r2.hasChanged(t4, x3))) && (m3 && m3(), callWithAsyncErrorHandling(n3, c3, 3, [t4, x3 === y2 ? void 0 : h3 && x3[0] === y2 ? [] : x3, onCleanup]), x3 = t4);
            } else
              b3.run();
        };
        let v3;
        job.allowRecurse = !!n3, "sync" === a3 ? v3 = job : "post" === a3 ? v3 = () => H2(job, c3 && c3.suspense) : (job.pre = true, c3 && (job.id = c3.uid), v3 = () => queueJob(job));
        const b3 = new e2.ReactiveEffect(d3, v3);
        n3 ? i3 ? job() : x3 = b3.run() : "post" === a3 ? H2(b3.run.bind(b3), c3 && c3.suspense) : b3.run();
        const unwatch = () => {
          b3.stop(), c3 && c3.scope && r2.remove(c3.scope.effects, b3);
        };
        return g3 && g3.push(unwatch), unwatch;
      }
      function instanceWatch(t3, e3, n3) {
        const i3 = this.proxy, o3 = r2.isString(t3) ? t3.includes(".") ? createPathGetter(i3, t3) : () => i3[t3] : t3.bind(i3, i3);
        let a3;
        r2.isFunction(e3) ? a3 = e3 : (a3 = e3.handler, n3 = e3);
        const s3 = nt2;
        setCurrentInstance(this);
        const l3 = doWatch(o3, a3.bind(i3), n3);
        return s3 ? setCurrentInstance(s3) : unsetCurrentInstance(), l3;
      }
      function createPathGetter(t3, e3) {
        const r3 = e3.split(".");
        return () => {
          let e4 = t3;
          for (let t4 = 0; t4 < r3.length && e4; t4++)
            e4 = e4[r3[t4]];
          return e4;
        };
      }
      function traverse(t3, n3) {
        if (!r2.isObject(t3) || t3.__v_skip)
          return t3;
        if ((n3 = n3 || /* @__PURE__ */ new Set()).has(t3))
          return t3;
        if (n3.add(t3), e2.isRef(t3))
          traverse(t3.value, n3);
        else if (r2.isArray(t3))
          for (let e3 = 0; e3 < t3.length; e3++)
            traverse(t3[e3], n3);
        else if (r2.isSet(t3) || r2.isMap(t3))
          t3.forEach((t4) => {
            traverse(t4, n3);
          });
        else if (r2.isPlainObject(t3))
          for (const e3 in t3)
            traverse(t3[e3], n3);
        return t3;
      }
      function invokeDirectiveHook(t3, r3, n3, i3) {
        const o3 = t3.dirs, a3 = r3 && r3.dirs;
        for (let s3 = 0; s3 < o3.length; s3++) {
          const l3 = o3[s3];
          a3 && (l3.oldValue = a3[s3].value);
          let p3 = l3.dir[i3];
          p3 && (e2.pauseTracking(), callWithAsyncErrorHandling(p3, n3, 8, [t3.el, l3, t3, r3]), e2.resetTracking());
        }
      }
      const b2 = Symbol("_leaveCb"), w2 = Symbol("_enterCb");
      function useTransitionState() {
        const t3 = { isMounted: false, isLeaving: false, isUnmounting: false, leavingVNodes: /* @__PURE__ */ new Map() };
        return T2(() => {
          t3.isMounted = true;
        }), N2(() => {
          t3.isUnmounting = true;
        }), t3;
      }
      const k2 = [Function, Array], S2 = { mode: String, appear: Boolean, persisted: Boolean, onBeforeEnter: k2, onEnter: k2, onAfterEnter: k2, onEnterCancelled: k2, onBeforeLeave: k2, onLeave: k2, onAfterLeave: k2, onLeaveCancelled: k2, onBeforeAppear: k2, onAppear: k2, onAfterAppear: k2, onAppearCancelled: k2 }, C2 = { name: "BaseTransition", props: S2, setup(t3, { slots: r3 }) {
        const n3 = getCurrentInstance2(), i3 = useTransitionState();
        let o3;
        return () => {
          const a3 = r3.default && getTransitionRawChildren(r3.default(), true);
          if (!a3 || !a3.length)
            return;
          let s3 = a3[0];
          if (a3.length > 1) {
            for (const t4 of a3)
              if (t4.type !== J2) {
                s3 = t4;
                break;
              }
          }
          const l3 = e2.toRaw(t3), { mode: p3 } = l3;
          if (i3.isLeaving)
            return emptyPlaceholder(s3);
          const c3 = getKeepAliveChild(s3);
          if (!c3)
            return emptyPlaceholder(s3);
          const d3 = resolveTransitionHooks(c3, l3, i3, n3);
          setTransitionHooks(c3, d3);
          const m3 = n3.subTree, u3 = m3 && getKeepAliveChild(m3);
          let h3 = false;
          const { getTransitionKey: g3 } = c3.type;
          if (g3) {
            const t4 = g3();
            void 0 === o3 ? o3 = t4 : t4 !== o3 && (o3 = t4, h3 = true);
          }
          if (u3 && u3.type !== J2 && (!isSameVNodeType(c3, u3) || h3)) {
            const t4 = resolveTransitionHooks(u3, l3, i3, n3);
            if (setTransitionHooks(u3, t4), "out-in" === p3)
              return i3.isLeaving = true, t4.afterLeave = () => {
                i3.isLeaving = false, false !== n3.update.active && n3.update();
              }, emptyPlaceholder(s3);
            "in-out" === p3 && c3.type !== J2 && (t4.delayLeave = (t5, e3, r4) => {
              getLeavingNodesForType(i3, u3)[String(u3.key)] = u3, t5[b2] = () => {
                e3(), t5[b2] = void 0, delete d3.delayedLeave;
              }, d3.delayedLeave = r4;
            });
          }
          return s3;
        };
      } };
      function getLeavingNodesForType(t3, e3) {
        const { leavingVNodes: r3 } = t3;
        let n3 = r3.get(e3.type);
        return n3 || (n3 = /* @__PURE__ */ Object.create(null), r3.set(e3.type, n3)), n3;
      }
      function resolveTransitionHooks(t3, e3, n3, i3) {
        const { appear: o3, mode: a3, persisted: s3 = false, onBeforeEnter: l3, onEnter: p3, onAfterEnter: c3, onEnterCancelled: d3, onBeforeLeave: m3, onLeave: u3, onAfterLeave: h3, onLeaveCancelled: g3, onBeforeAppear: x3, onAppear: v3, onAfterAppear: y3, onAppearCancelled: k3 } = e3, S3 = String(t3.key), C3 = getLeavingNodesForType(n3, t3), callHook2 = (t4, e4) => {
          t4 && callWithAsyncErrorHandling(t4, i3, 9, e4);
        }, callAsyncHook = (t4, e4) => {
          const n4 = e4[1];
          callHook2(t4, e4), r2.isArray(t4) ? t4.every((t5) => t5.length <= 1) && n4() : t4.length <= 1 && n4();
        }, _3 = { mode: a3, persisted: s3, beforeEnter(e4) {
          let r3 = l3;
          if (!n3.isMounted) {
            if (!o3)
              return;
            r3 = x3 || l3;
          }
          e4[b2] && e4[b2](true);
          const i4 = C3[S3];
          i4 && isSameVNodeType(t3, i4) && i4.el[b2] && i4.el[b2](), callHook2(r3, [e4]);
        }, enter(t4) {
          let e4 = p3, r3 = c3, i4 = d3;
          if (!n3.isMounted) {
            if (!o3)
              return;
            e4 = v3 || p3, r3 = y3 || c3, i4 = k3 || d3;
          }
          let a4 = false;
          const s4 = t4[w2] = (e5) => {
            a4 || (a4 = true, callHook2(e5 ? i4 : r3, [t4]), _3.delayedLeave && _3.delayedLeave(), t4[w2] = void 0);
          };
          e4 ? callAsyncHook(e4, [t4, s4]) : s4();
        }, leave(e4, r3) {
          const i4 = String(t3.key);
          if (e4[w2] && e4[w2](true), n3.isUnmounting)
            return r3();
          callHook2(m3, [e4]);
          let o4 = false;
          const a4 = e4[b2] = (n4) => {
            o4 || (o4 = true, r3(), callHook2(n4 ? g3 : h3, [e4]), e4[b2] = void 0, C3[i4] === t3 && delete C3[i4]);
          };
          C3[i4] = t3, u3 ? callAsyncHook(u3, [e4, a4]) : a4();
        }, clone: (t4) => resolveTransitionHooks(t4, e3, n3, i3) };
        return _3;
      }
      function emptyPlaceholder(t3) {
        if (isKeepAlive(t3))
          return (t3 = cloneVNode(t3)).children = null, t3;
      }
      function getKeepAliveChild(t3) {
        return isKeepAlive(t3) ? t3.children ? t3.children[0] : void 0 : t3;
      }
      function setTransitionHooks(t3, e3) {
        6 & t3.shapeFlag && t3.component ? setTransitionHooks(t3.component.subTree, e3) : 128 & t3.shapeFlag ? (t3.ssContent.transition = e3.clone(t3.ssContent), t3.ssFallback.transition = e3.clone(t3.ssFallback)) : t3.transition = e3;
      }
      function getTransitionRawChildren(t3, e3 = false, r3) {
        let n3 = [], i3 = 0;
        for (let o3 = 0; o3 < t3.length; o3++) {
          let a3 = t3[o3];
          const s3 = null == r3 ? a3.key : String(r3) + String(null != a3.key ? a3.key : o3);
          a3.type === K2 ? (128 & a3.patchFlag && i3++, n3 = n3.concat(getTransitionRawChildren(a3.children, e3, s3))) : (e3 || a3.type !== J2) && n3.push(null != s3 ? cloneVNode(a3, { key: s3 }) : a3);
        }
        if (i3 > 1)
          for (let t4 = 0; t4 < n3.length; t4++)
            n3[t4].patchFlag = -2;
        return n3;
      }
      function defineComponent2(t3, e3) {
        return r2.isFunction(t3) ? (() => r2.extend({ name: t3.name }, e3, { setup: t3 }))() : t3;
      }
      const isAsyncWrapper = (t3) => !!t3.type.__asyncLoader;
      function createInnerComp(t3, e3) {
        const { ref: r3, props: n3, children: i3, ce: o3 } = e3.vnode, a3 = createVNode(t3, n3, i3);
        return a3.ref = r3, a3.ce = o3, delete e3.vnode.ce, a3;
      }
      const isKeepAlive = (t3) => t3.type.__isKeepAlive, _2 = { name: "KeepAlive", __isKeepAlive: true, props: { include: [String, RegExp, Array], exclude: [String, RegExp, Array], max: [String, Number] }, setup(t3, { slots: e3 }) {
        const n3 = getCurrentInstance2(), i3 = n3.ctx;
        if (!i3.renderer)
          return () => {
            const t4 = e3.default && e3.default();
            return t4 && 1 === t4.length ? t4[0] : t4;
          };
        const o3 = /* @__PURE__ */ new Map(), a3 = /* @__PURE__ */ new Set();
        let s3 = null;
        const l3 = n3.suspense, { renderer: { p: p3, m: c3, um: d3, o: { createElement: m3 } } } = i3, u3 = m3("div");
        function unmount(t4) {
          resetShapeFlag(t4), d3(t4, n3, l3, true);
        }
        function pruneCache(t4) {
          o3.forEach((e4, r3) => {
            const n4 = getComponentName(e4.type);
            !n4 || t4 && t4(n4) || pruneCacheEntry(r3);
          });
        }
        function pruneCacheEntry(t4) {
          const e4 = o3.get(t4);
          s3 && isSameVNodeType(e4, s3) ? s3 && resetShapeFlag(s3) : unmount(e4), o3.delete(t4), a3.delete(t4);
        }
        i3.activate = (t4, e4, n4, i4, o4) => {
          const a4 = t4.component;
          c3(t4, e4, n4, 0, l3), p3(a4.vnode, t4, e4, n4, a4, l3, i4, t4.slotScopeIds, o4), H2(() => {
            a4.isDeactivated = false, a4.a && r2.invokeArrayFns(a4.a);
            const e5 = t4.props && t4.props.onVnodeMounted;
            e5 && invokeVNodeHook(e5, a4.parent, t4);
          }, l3);
        }, i3.deactivate = (t4) => {
          const e4 = t4.component;
          c3(t4, u3, null, 1, l3), H2(() => {
            e4.da && r2.invokeArrayFns(e4.da);
            const n4 = t4.props && t4.props.onVnodeUnmounted;
            n4 && invokeVNodeHook(n4, e4.parent, t4), e4.isDeactivated = true;
          }, l3);
        }, watch2(() => [t3.include, t3.exclude], ([t4, e4]) => {
          t4 && pruneCache((e5) => matches(t4, e5)), e4 && pruneCache((t5) => !matches(e4, t5));
        }, { flush: "post", deep: true });
        let h3 = null;
        const cacheSubtree = () => {
          null != h3 && o3.set(h3, getInnerChild(n3.subTree));
        };
        return T2(cacheSubtree), I2(cacheSubtree), N2(() => {
          o3.forEach((t4) => {
            const { subTree: e4, suspense: r3 } = n3, i4 = getInnerChild(e4);
            if (t4.type !== i4.type || t4.key !== i4.key)
              unmount(t4);
            else {
              resetShapeFlag(i4);
              const t5 = i4.component.da;
              t5 && H2(t5, r3);
            }
          });
        }), () => {
          if (h3 = null, !e3.default)
            return null;
          const r3 = e3.default(), n4 = r3[0];
          if (r3.length > 1)
            return s3 = null, r3;
          if (!(isVNode(n4) && (4 & n4.shapeFlag || 128 & n4.shapeFlag)))
            return s3 = null, n4;
          let i4 = getInnerChild(n4);
          const l4 = i4.type, p4 = getComponentName(isAsyncWrapper(i4) ? i4.type.__asyncResolved || {} : l4), { include: c4, exclude: d4, max: m4 } = t3;
          if (c4 && (!p4 || !matches(c4, p4)) || d4 && p4 && matches(d4, p4))
            return s3 = i4, n4;
          const u4 = null == i4.key ? l4 : i4.key, g3 = o3.get(u4);
          return i4.el && (i4 = cloneVNode(i4), 128 & n4.shapeFlag && (n4.ssContent = i4)), h3 = u4, g3 ? (i4.el = g3.el, i4.component = g3.component, i4.transition && setTransitionHooks(i4, i4.transition), i4.shapeFlag |= 512, a3.delete(u4), a3.add(u4)) : (a3.add(u4), m4 && a3.size > parseInt(m4, 10) && pruneCacheEntry(a3.values().next().value)), i4.shapeFlag |= 256, s3 = i4, isSuspense(n4.type) ? n4 : i4;
        };
      } };
      function matches(t3, e3) {
        return r2.isArray(t3) ? t3.some((t4) => matches(t4, e3)) : r2.isString(t3) ? t3.split(",").includes(e3) : !!r2.isRegExp(t3) && t3.test(e3);
      }
      function onActivated(t3, e3) {
        registerKeepAliveHook(t3, "a", e3);
      }
      function onDeactivated(t3, e3) {
        registerKeepAliveHook(t3, "da", e3);
      }
      function registerKeepAliveHook(t3, e3, r3 = nt2) {
        const n3 = t3.__wdc || (t3.__wdc = () => {
          let e4 = r3;
          for (; e4; ) {
            if (e4.isDeactivated)
              return;
            e4 = e4.parent;
          }
          return t3();
        });
        if (injectHook(e3, n3, r3), r3) {
          let t4 = r3.parent;
          for (; t4 && t4.parent; )
            isKeepAlive(t4.parent.vnode) && injectToKeepAliveRoot(n3, e3, r3, t4), t4 = t4.parent;
        }
      }
      function injectToKeepAliveRoot(t3, e3, n3, i3) {
        const o3 = injectHook(e3, t3, i3, true);
        R2(() => {
          r2.remove(i3[e3], o3);
        }, n3);
      }
      function resetShapeFlag(t3) {
        t3.shapeFlag &= -257, t3.shapeFlag &= -513;
      }
      function getInnerChild(t3) {
        return 128 & t3.shapeFlag ? t3.ssContent : t3;
      }
      function injectHook(t3, r3, n3 = nt2, i3 = false) {
        if (n3) {
          const o3 = n3[t3] || (n3[t3] = []), a3 = r3.__weh || (r3.__weh = (...i4) => {
            if (n3.isUnmounted)
              return;
            e2.pauseTracking(), setCurrentInstance(n3);
            const o4 = callWithAsyncErrorHandling(r3, n3, t3, i4);
            return unsetCurrentInstance(), e2.resetTracking(), o4;
          });
          return i3 ? o3.unshift(a3) : o3.push(a3), a3;
        }
      }
      const createHook = (t3) => (e3, r3 = nt2) => (!pt2 || "sp" === t3) && injectHook(t3, (...t4) => e3(...t4), r3), P2 = createHook("bm"), T2 = createHook("m"), A2 = createHook("bu"), I2 = createHook("u"), N2 = createHook("bum"), R2 = createHook("um"), O2 = createHook("sp"), L2 = createHook("rtg"), M2 = createHook("rtc");
      function onErrorCaptured(t3, e3 = nt2) {
        injectHook("ec", t3, e3);
      }
      function ensureValidVNode(t3) {
        return t3.some((t4) => !isVNode(t4) || t4.type !== J2 && !(t4.type === K2 && !ensureValidVNode(t4.children))) ? t3 : null;
      }
      const getPublicInstance = (t3) => t3 ? isStatefulComponent(t3) ? getExposeProxy(t3) || t3.proxy : getPublicInstance(t3.parent) : null, B2 = r2.extend(/* @__PURE__ */ Object.create(null), { $: (t3) => t3, $el: (t3) => t3.vnode.el, $data: (t3) => t3.data, $props: (t3) => t3.props, $attrs: (t3) => t3.attrs, $slots: (t3) => t3.slots, $refs: (t3) => t3.refs, $parent: (t3) => getPublicInstance(t3.parent), $root: (t3) => getPublicInstance(t3.root), $emit: (t3) => t3.emit, $options: (t3) => resolveMergedOptions(t3), $forceUpdate: (t3) => t3.f || (t3.f = () => queueJob(t3.update)), $nextTick: (t3) => t3.n || (t3.n = nextTick.bind(t3.proxy)), $watch: (t3) => instanceWatch.bind(t3) }), hasSetupBinding = (t3, e3) => t3 !== r2.EMPTY_OBJ && !t3.__isScriptSetup && r2.hasOwn(t3, e3), D2 = { get({ _: t3 }, n3) {
        const { ctx: i3, setupState: o3, data: a3, props: s3, accessCache: l3, type: p3, appContext: c3 } = t3;
        let d3;
        if ("$" !== n3[0]) {
          const e3 = l3[n3];
          if (void 0 !== e3)
            switch (e3) {
              case 1:
                return o3[n3];
              case 2:
                return a3[n3];
              case 4:
                return i3[n3];
              case 3:
                return s3[n3];
            }
          else {
            if (hasSetupBinding(o3, n3))
              return l3[n3] = 1, o3[n3];
            if (a3 !== r2.EMPTY_OBJ && r2.hasOwn(a3, n3))
              return l3[n3] = 2, a3[n3];
            if ((d3 = t3.propsOptions[0]) && r2.hasOwn(d3, n3))
              return l3[n3] = 3, s3[n3];
            if (i3 !== r2.EMPTY_OBJ && r2.hasOwn(i3, n3))
              return l3[n3] = 4, i3[n3];
            F2 && (l3[n3] = 0);
          }
        }
        const m3 = B2[n3];
        let u3, h3;
        return m3 ? ("$attrs" === n3 && e2.track(t3, "get", n3), m3(t3)) : (u3 = p3.__cssModules) && (u3 = u3[n3]) ? u3 : i3 !== r2.EMPTY_OBJ && r2.hasOwn(i3, n3) ? (l3[n3] = 4, i3[n3]) : (h3 = c3.config.globalProperties, r2.hasOwn(h3, n3) ? h3[n3] : void 0);
      }, set({ _: t3 }, e3, n3) {
        const { data: i3, setupState: o3, ctx: a3 } = t3;
        return hasSetupBinding(o3, e3) ? (o3[e3] = n3, true) : i3 !== r2.EMPTY_OBJ && r2.hasOwn(i3, e3) ? (i3[e3] = n3, true) : !r2.hasOwn(t3.props, e3) && (("$" !== e3[0] || !(e3.slice(1) in t3)) && (a3[e3] = n3, true));
      }, has({ _: { data: t3, setupState: e3, accessCache: n3, ctx: i3, appContext: o3, propsOptions: a3 } }, s3) {
        let l3;
        return !!n3[s3] || t3 !== r2.EMPTY_OBJ && r2.hasOwn(t3, s3) || hasSetupBinding(e3, s3) || (l3 = a3[0]) && r2.hasOwn(l3, s3) || r2.hasOwn(i3, s3) || r2.hasOwn(B2, s3) || r2.hasOwn(o3.config.globalProperties, s3);
      }, defineProperty(t3, e3, n3) {
        return null != n3.get ? t3._.accessCache[e3] = 0 : r2.hasOwn(n3, "value") && this.set(t3, e3, n3.value, null), Reflect.defineProperty(t3, e3, n3);
      } }, j2 = r2.extend({}, D2, { get(t3, e3) {
        if (e3 !== Symbol.unscopables)
          return D2.get(t3, e3, t3);
      }, has: (t3, e3) => "_" !== e3[0] && !r2.isGloballyAllowed(e3) });
      function getContext2() {
        const t3 = getCurrentInstance2();
        return t3.setupContext || (t3.setupContext = createSetupContext(t3));
      }
      function normalizePropsOrEmits(t3) {
        return r2.isArray(t3) ? t3.reduce((t4, e3) => (t4[e3] = null, t4), {}) : t3;
      }
      let F2 = true;
      function applyOptions(t3) {
        const n3 = resolveMergedOptions(t3), i3 = t3.proxy, o3 = t3.ctx;
        F2 = false, n3.beforeCreate && callHook(n3.beforeCreate, t3, "bc");
        const { data: a3, computed: s3, methods: l3, watch: p3, provide: c3, inject: d3, created: m3, beforeMount: u3, mounted: h3, beforeUpdate: g3, updated: x3, activated: v3, deactivated: y3, beforeDestroy: b3, beforeUnmount: w3, destroyed: k3, unmounted: S3, render: C3, renderTracked: _3, renderTriggered: B3, errorCaptured: D3, serverPrefetch: j3, expose: $3, inheritAttrs: V3, components: z3, directives: U3, filters: H3 } = n3;
        if (d3 && function(t4, n4, i4 = r2.NOOP) {
          r2.isArray(t4) && (t4 = normalizeInject(t4));
          for (const i5 in t4) {
            const o4 = t4[i5];
            let a4;
            a4 = r2.isObject(o4) ? "default" in o4 ? inject2(o4.from || i5, o4.default, true) : inject2(o4.from || i5) : inject2(o4), e2.isRef(a4) ? Object.defineProperty(n4, i5, { enumerable: true, configurable: true, get: () => a4.value, set: (t5) => a4.value = t5 }) : n4[i5] = a4;
          }
        }(d3, o3, null), l3)
          for (const t4 in l3) {
            const e3 = l3[t4];
            r2.isFunction(e3) && (o3[t4] = e3.bind(i3));
          }
        if (a3) {
          const n4 = a3.call(i3, i3);
          r2.isObject(n4) && (t3.data = e2.reactive(n4));
        }
        if (F2 = true, s3)
          for (const t4 in s3) {
            const e3 = s3[t4], n4 = r2.isFunction(e3) ? e3.bind(i3, i3) : r2.isFunction(e3.get) ? e3.get.bind(i3, i3) : r2.NOOP, a4 = !r2.isFunction(e3) && r2.isFunction(e3.set) ? e3.set.bind(i3) : r2.NOOP, l4 = computed({ get: n4, set: a4 });
            Object.defineProperty(o3, t4, { enumerable: true, configurable: true, get: () => l4.value, set: (t5) => l4.value = t5 });
          }
        if (p3)
          for (const t4 in p3)
            createWatcher(p3[t4], o3, i3, t4);
        if (c3) {
          const t4 = r2.isFunction(c3) ? c3.call(i3) : c3;
          Reflect.ownKeys(t4).forEach((e3) => {
            provide(e3, t4[e3]);
          });
        }
        function registerLifecycleHook(t4, e3) {
          r2.isArray(e3) ? e3.forEach((e4) => t4(e4.bind(i3))) : e3 && t4(e3.bind(i3));
        }
        if (m3 && callHook(m3, t3, "c"), registerLifecycleHook(P2, u3), registerLifecycleHook(T2, h3), registerLifecycleHook(A2, g3), registerLifecycleHook(I2, x3), registerLifecycleHook(onActivated, v3), registerLifecycleHook(onDeactivated, y3), registerLifecycleHook(onErrorCaptured, D3), registerLifecycleHook(M2, _3), registerLifecycleHook(L2, B3), registerLifecycleHook(N2, w3), registerLifecycleHook(R2, S3), registerLifecycleHook(O2, j3), r2.isArray($3))
          if ($3.length) {
            const e3 = t3.exposed || (t3.exposed = {});
            $3.forEach((t4) => {
              Object.defineProperty(e3, t4, { get: () => i3[t4], set: (e4) => i3[t4] = e4 });
            });
          } else
            t3.exposed || (t3.exposed = {});
        C3 && t3.render === r2.NOOP && (t3.render = C3), null != V3 && (t3.inheritAttrs = V3), z3 && (t3.components = z3), U3 && (t3.directives = U3);
      }
      function callHook(t3, e3, n3) {
        callWithAsyncErrorHandling(r2.isArray(t3) ? t3.map((t4) => t4.bind(e3.proxy)) : t3.bind(e3.proxy), e3, n3);
      }
      function createWatcher(t3, e3, n3, i3) {
        const o3 = i3.includes(".") ? createPathGetter(n3, i3) : () => n3[i3];
        if (r2.isString(t3)) {
          const n4 = e3[t3];
          r2.isFunction(n4) && watch2(o3, n4);
        } else if (r2.isFunction(t3))
          watch2(o3, t3.bind(n3));
        else if (r2.isObject(t3))
          if (r2.isArray(t3))
            t3.forEach((t4) => createWatcher(t4, e3, n3, i3));
          else {
            const i4 = r2.isFunction(t3.handler) ? t3.handler.bind(n3) : e3[t3.handler];
            r2.isFunction(i4) && watch2(o3, i4, t3);
          }
      }
      function resolveMergedOptions(t3) {
        const e3 = t3.type, { mixins: n3, extends: i3 } = e3, { mixins: o3, optionsCache: a3, config: { optionMergeStrategies: s3 } } = t3.appContext, l3 = a3.get(e3);
        let p3;
        return l3 ? p3 = l3 : o3.length || n3 || i3 ? (p3 = {}, o3.length && o3.forEach((t4) => mergeOptions2(p3, t4, s3, true)), mergeOptions2(p3, e3, s3)) : p3 = e3, r2.isObject(e3) && a3.set(e3, p3), p3;
      }
      function mergeOptions2(t3, e3, r3, n3 = false) {
        const { mixins: i3, extends: o3 } = e3;
        o3 && mergeOptions2(t3, o3, r3, true), i3 && i3.forEach((e4) => mergeOptions2(t3, e4, r3, true));
        for (const i4 in e3)
          if (n3 && "expose" === i4)
            ;
          else {
            const n4 = $2[i4] || r3 && r3[i4];
            t3[i4] = n4 ? n4(t3[i4], e3[i4]) : e3[i4];
          }
        return t3;
      }
      const $2 = { data: mergeDataFn, props: mergeEmitsOrPropsOptions, emits: mergeEmitsOrPropsOptions, methods: mergeObjectOptions, computed: mergeObjectOptions, beforeCreate: mergeAsArray2, created: mergeAsArray2, beforeMount: mergeAsArray2, mounted: mergeAsArray2, beforeUpdate: mergeAsArray2, updated: mergeAsArray2, beforeDestroy: mergeAsArray2, beforeUnmount: mergeAsArray2, destroyed: mergeAsArray2, unmounted: mergeAsArray2, activated: mergeAsArray2, deactivated: mergeAsArray2, errorCaptured: mergeAsArray2, serverPrefetch: mergeAsArray2, components: mergeObjectOptions, directives: mergeObjectOptions, watch: function(t3, e3) {
        if (!t3)
          return e3;
        if (!e3)
          return t3;
        const n3 = r2.extend(/* @__PURE__ */ Object.create(null), t3);
        for (const r3 in e3)
          n3[r3] = mergeAsArray2(t3[r3], e3[r3]);
        return n3;
      }, provide: mergeDataFn, inject: function(t3, e3) {
        return mergeObjectOptions(normalizeInject(t3), normalizeInject(e3));
      } };
      function mergeDataFn(t3, e3) {
        return e3 ? t3 ? function() {
          return r2.extend(r2.isFunction(t3) ? t3.call(this, this) : t3, r2.isFunction(e3) ? e3.call(this, this) : e3);
        } : e3 : t3;
      }
      function normalizeInject(t3) {
        if (r2.isArray(t3)) {
          const e3 = {};
          for (let r3 = 0; r3 < t3.length; r3++)
            e3[t3[r3]] = t3[r3];
          return e3;
        }
        return t3;
      }
      function mergeAsArray2(t3, e3) {
        return t3 ? [...new Set([].concat(t3, e3))] : e3;
      }
      function mergeObjectOptions(t3, e3) {
        return t3 ? r2.extend(/* @__PURE__ */ Object.create(null), t3, e3) : e3;
      }
      function mergeEmitsOrPropsOptions(t3, e3) {
        return t3 ? r2.isArray(t3) && r2.isArray(e3) ? [.../* @__PURE__ */ new Set([...t3, ...e3])] : r2.extend(/* @__PURE__ */ Object.create(null), normalizePropsOrEmits(t3), normalizePropsOrEmits(null != e3 ? e3 : {})) : e3;
      }
      function createAppContext() {
        return { app: null, config: { isNativeTag: r2.NO, performance: false, globalProperties: {}, optionMergeStrategies: {}, errorHandler: void 0, warnHandler: void 0, compilerOptions: {} }, mixins: [], components: {}, directives: {}, provides: /* @__PURE__ */ Object.create(null), optionsCache: /* @__PURE__ */ new WeakMap(), propsCache: /* @__PURE__ */ new WeakMap(), emitsCache: /* @__PURE__ */ new WeakMap() };
      }
      let V2 = 0;
      function createAppAPI(t3, e3) {
        return function(n3, i3 = null) {
          r2.isFunction(n3) || (n3 = r2.extend({}, n3)), null == i3 || r2.isObject(i3) || (i3 = null);
          const o3 = createAppContext(), a3 = /* @__PURE__ */ new WeakSet();
          let s3 = false;
          const l3 = o3.app = { _uid: V2++, _component: n3, _props: i3, _container: null, _context: o3, _instance: null, version: dt2, get config() {
            return o3.config;
          }, set config(t4) {
          }, use: (t4, ...e4) => (a3.has(t4) || (t4 && r2.isFunction(t4.install) ? (a3.add(t4), t4.install(l3, ...e4)) : r2.isFunction(t4) && (a3.add(t4), t4(l3, ...e4))), l3), mixin: (t4) => (o3.mixins.includes(t4) || o3.mixins.push(t4), l3), component: (t4, e4) => e4 ? (o3.components[t4] = e4, l3) : o3.components[t4], directive: (t4, e4) => e4 ? (o3.directives[t4] = e4, l3) : o3.directives[t4], mount(r3, a4, p3) {
            if (!s3) {
              const c3 = createVNode(n3, i3);
              return c3.appContext = o3, a4 && e3 ? e3(c3, r3) : t3(c3, r3, p3), s3 = true, l3._container = r3, r3.__vue_app__ = l3, getExposeProxy(c3.component) || c3.component.proxy;
            }
          }, unmount() {
            s3 && (t3(null, l3._container), delete l3._container.__vue_app__);
          }, provide: (t4, e4) => (o3.provides[t4] = e4, l3), runWithContext(t4) {
            z2 = l3;
            try {
              return t4();
            } finally {
              z2 = null;
            }
          } };
          return l3;
        };
      }
      let z2 = null;
      function provide(t3, e3) {
        if (nt2) {
          let r3 = nt2.provides;
          const n3 = nt2.parent && nt2.parent.provides;
          n3 === r3 && (r3 = nt2.provides = Object.create(n3)), r3[t3] = e3;
        } else
          ;
      }
      function inject2(t3, e3, n3 = false) {
        const i3 = nt2 || u2;
        if (i3 || z2) {
          const o3 = i3 ? null == i3.parent ? i3.vnode.appContext && i3.vnode.appContext.provides : i3.parent.provides : z2._context.provides;
          if (o3 && t3 in o3)
            return o3[t3];
          if (arguments.length > 1)
            return n3 && r2.isFunction(e3) ? e3.call(i3 && i3.proxy) : e3;
        }
      }
      function setFullProps(t3, n3, i3, o3) {
        const [a3, s3] = t3.propsOptions;
        let l3, p3 = false;
        if (n3)
          for (let e3 in n3) {
            if (r2.isReservedProp(e3))
              continue;
            const c3 = n3[e3];
            let d3;
            a3 && r2.hasOwn(a3, d3 = r2.camelize(e3)) ? s3 && s3.includes(d3) ? (l3 || (l3 = {}))[d3] = c3 : i3[d3] = c3 : isEmitListener(t3.emitsOptions, e3) || e3 in o3 && c3 === o3[e3] || (o3[e3] = c3, p3 = true);
          }
        if (s3) {
          const n4 = e2.toRaw(i3), o4 = l3 || r2.EMPTY_OBJ;
          for (let e3 = 0; e3 < s3.length; e3++) {
            const l4 = s3[e3];
            i3[l4] = resolvePropValue(a3, n4, l4, o4[l4], t3, !r2.hasOwn(o4, l4));
          }
        }
        return p3;
      }
      function resolvePropValue(t3, e3, n3, i3, o3, a3) {
        const s3 = t3[n3];
        if (null != s3) {
          const t4 = r2.hasOwn(s3, "default");
          if (t4 && void 0 === i3) {
            const t5 = s3.default;
            if (s3.type !== Function && !s3.skipFactory && r2.isFunction(t5)) {
              const { propsDefaults: r3 } = o3;
              n3 in r3 ? i3 = r3[n3] : (setCurrentInstance(o3), i3 = r3[n3] = t5.call(null, e3), unsetCurrentInstance());
            } else
              i3 = t5;
          }
          s3[0] && (a3 && !t4 ? i3 = false : !s3[1] || "" !== i3 && i3 !== r2.hyphenate(n3) || (i3 = true));
        }
        return i3;
      }
      function normalizePropsOptions(t3, e3, n3 = false) {
        const i3 = e3.propsCache, o3 = i3.get(t3);
        if (o3)
          return o3;
        const a3 = t3.props, s3 = {}, l3 = [];
        let p3 = false;
        if (!r2.isFunction(t3)) {
          const extendProps = (t4) => {
            p3 = true;
            const [n4, i4] = normalizePropsOptions(t4, e3, true);
            r2.extend(s3, n4), i4 && l3.push(...i4);
          };
          !n3 && e3.mixins.length && e3.mixins.forEach(extendProps), t3.extends && extendProps(t3.extends), t3.mixins && t3.mixins.forEach(extendProps);
        }
        if (!a3 && !p3)
          return r2.isObject(t3) && i3.set(t3, r2.EMPTY_ARR), r2.EMPTY_ARR;
        if (r2.isArray(a3))
          for (let t4 = 0; t4 < a3.length; t4++) {
            const e4 = r2.camelize(a3[t4]);
            validatePropName(e4) && (s3[e4] = r2.EMPTY_OBJ);
          }
        else if (a3)
          for (const t4 in a3) {
            const e4 = r2.camelize(t4);
            if (validatePropName(e4)) {
              const n4 = a3[t4], i4 = s3[e4] = r2.isArray(n4) || r2.isFunction(n4) ? { type: n4 } : r2.extend({}, n4);
              if (i4) {
                const t5 = getTypeIndex(Boolean, i4.type), n5 = getTypeIndex(String, i4.type);
                i4[0] = t5 > -1, i4[1] = n5 < 0 || t5 < n5, (t5 > -1 || r2.hasOwn(i4, "default")) && l3.push(e4);
              }
            }
          }
        const c3 = [s3, l3];
        return r2.isObject(t3) && i3.set(t3, c3), c3;
      }
      function validatePropName(t3) {
        return "$" !== t3[0];
      }
      function getType(t3) {
        const e3 = t3 && t3.toString().match(/^\s*(function|class) (\w+)/);
        return e3 ? e3[2] : null === t3 ? "null" : "";
      }
      function isSameType(t3, e3) {
        return getType(t3) === getType(e3);
      }
      function getTypeIndex(t3, e3) {
        return r2.isArray(e3) ? e3.findIndex((e4) => isSameType(e4, t3)) : r2.isFunction(e3) && isSameType(e3, t3) ? 0 : -1;
      }
      const isInternalKey = (t3) => "_" === t3[0] || "$stable" === t3, normalizeSlotValue = (t3) => r2.isArray(t3) ? t3.map(normalizeVNode) : [normalizeVNode(t3)], normalizeSlot2 = (t3, e3, r3) => {
        if (e3._n)
          return e3;
        const n3 = withCtx((...t4) => normalizeSlotValue(e3(...t4)), r3);
        return n3._c = false, n3;
      }, normalizeObjectSlots = (t3, e3, n3) => {
        const i3 = t3._ctx;
        for (const n4 in t3) {
          if (isInternalKey(n4))
            continue;
          const o3 = t3[n4];
          if (r2.isFunction(o3))
            e3[n4] = normalizeSlot2(0, o3, i3);
          else if (null != o3) {
            const t4 = normalizeSlotValue(o3);
            e3[n4] = () => t4;
          }
        }
      }, normalizeVNodeSlots = (t3, e3) => {
        const r3 = normalizeSlotValue(e3);
        t3.slots.default = () => r3;
      }, initSlots = (t3, n3) => {
        if (32 & t3.vnode.shapeFlag) {
          const i3 = n3._;
          i3 ? (t3.slots = e2.toRaw(n3), r2.def(n3, "_", i3)) : normalizeObjectSlots(n3, t3.slots = {});
        } else
          t3.slots = {}, n3 && normalizeVNodeSlots(t3, n3);
        r2.def(t3.slots, tt2, 1);
      }, updateSlots = (t3, e3, n3) => {
        const { vnode: i3, slots: o3 } = t3;
        let a3 = true, s3 = r2.EMPTY_OBJ;
        if (32 & i3.shapeFlag) {
          const t4 = e3._;
          t4 ? n3 && 1 === t4 ? a3 = false : (r2.extend(o3, e3), n3 || 1 !== t4 || delete o3._) : (a3 = !e3.$stable, normalizeObjectSlots(e3, o3)), s3 = e3;
        } else
          e3 && (normalizeVNodeSlots(t3, e3), s3 = { default: 1 });
        if (a3)
          for (const t4 in o3)
            isInternalKey(t4) || null != s3[t4] || delete o3[t4];
      };
      function setRef(t3, n3, i3, o3, a3 = false) {
        if (r2.isArray(t3))
          return void t3.forEach((t4, e3) => setRef(t4, n3 && (r2.isArray(n3) ? n3[e3] : n3), i3, o3, a3));
        if (isAsyncWrapper(o3) && !a3)
          return;
        const s3 = 4 & o3.shapeFlag ? getExposeProxy(o3.component) || o3.component.proxy : o3.el, l3 = a3 ? null : s3, { i: p3, r: c3 } = t3, d3 = n3 && n3.r, m3 = p3.refs === r2.EMPTY_OBJ ? p3.refs = {} : p3.refs, u3 = p3.setupState;
        if (null != d3 && d3 !== c3 && (r2.isString(d3) ? (m3[d3] = null, r2.hasOwn(u3, d3) && (u3[d3] = null)) : e2.isRef(d3) && (d3.value = null)), r2.isFunction(c3))
          callWithErrorHandling(c3, p3, 12, [l3, m3]);
        else {
          const n4 = r2.isString(c3), o4 = e2.isRef(c3);
          if (n4 || o4) {
            const doSet = () => {
              if (t3.f) {
                const e3 = n4 ? r2.hasOwn(u3, c3) ? u3[c3] : m3[c3] : c3.value;
                a3 ? r2.isArray(e3) && r2.remove(e3, s3) : r2.isArray(e3) ? e3.includes(s3) || e3.push(s3) : n4 ? (m3[c3] = [s3], r2.hasOwn(u3, c3) && (u3[c3] = m3[c3])) : (c3.value = [s3], t3.k && (m3[t3.k] = c3.value));
              } else
                n4 ? (m3[c3] = l3, r2.hasOwn(u3, c3) && (u3[c3] = l3)) : o4 && (c3.value = l3, t3.k && (m3[t3.k] = l3));
            };
            l3 ? (doSet.id = -1, H2(doSet, i3)) : doSet();
          }
        }
      }
      let U2 = false;
      const isSVGContainer = (t3) => /svg/.test(t3.namespaceURI) && "foreignObject" !== t3.tagName, isComment2 = (t3) => 8 === t3.nodeType;
      function createHydrationFunctions(t3) {
        const { mt: e3, p: n3, o: { patchProp: i3, createText: o3, nextSibling: a3, parentNode: s3, remove: l3, insert: p3, createComment: c3 } } = t3, hydrateNode = (r3, n4, i4, l4, c4, d3 = false) => {
          const m3 = isComment2(r3) && "[" === r3.data, onMismatch = () => handleMismatch(r3, n4, i4, l4, c4, m3), { type: u3, ref: h3, shapeFlag: g3, patchFlag: x3 } = n4;
          let v3 = r3.nodeType;
          n4.el = r3, -2 === x3 && (d3 = false, n4.dynamicChildren = null);
          let y3 = null;
          switch (u3) {
            case G2:
              3 !== v3 ? "" === n4.children ? (p3(n4.el = o3(""), s3(r3), r3), y3 = r3) : y3 = onMismatch() : (r3.data !== n4.children && (U2 = true, r3.data = n4.children), y3 = a3(r3));
              break;
            case J2:
              isTemplateNode2(r3) ? (y3 = a3(r3), replaceNode(n4.el = r3.content.firstChild, r3, i4)) : y3 = 8 !== v3 || m3 ? onMismatch() : a3(r3);
              break;
            case Y2:
              if (m3 && (v3 = (r3 = a3(r3)).nodeType), 1 === v3 || 3 === v3) {
                y3 = r3;
                const t4 = !n4.children.length;
                for (let e4 = 0; e4 < n4.staticCount; e4++)
                  t4 && (n4.children += 1 === y3.nodeType ? y3.outerHTML : y3.data), e4 === n4.staticCount - 1 && (n4.anchor = y3), y3 = a3(y3);
                return m3 ? a3(y3) : y3;
              }
              onMismatch();
              break;
            case K2:
              y3 = m3 ? hydrateFragment(r3, n4, i4, l4, c4, d3) : onMismatch();
              break;
            default:
              if (1 & g3)
                y3 = 1 === v3 && n4.type.toLowerCase() === r3.tagName.toLowerCase() || isTemplateNode2(r3) ? hydrateElement(r3, n4, i4, l4, c4, d3) : onMismatch();
              else if (6 & g3) {
                n4.slotScopeIds = c4;
                const t4 = s3(r3);
                if (y3 = m3 ? locateClosingAnchor(r3) : isComment2(r3) && "teleport start" === r3.data ? locateClosingAnchor(r3, r3.data, "teleport end") : a3(r3), e3(n4, t4, null, i4, l4, isSVGContainer(t4), d3), isAsyncWrapper(n4)) {
                  let e4;
                  m3 ? (e4 = createVNode(K2), e4.anchor = y3 ? y3.previousSibling : t4.lastChild) : e4 = 3 === r3.nodeType ? createTextVNode("") : createVNode("div"), e4.el = r3, n4.component.subTree = e4;
                }
              } else
                64 & g3 ? y3 = 8 !== v3 ? onMismatch() : n4.type.hydrate(r3, n4, i4, l4, c4, d3, t3, hydrateChildren) : 128 & g3 && (y3 = n4.type.hydrate(r3, n4, i4, l4, isSVGContainer(s3(r3)), c4, d3, t3, hydrateNode));
          }
          return null != h3 && setRef(h3, null, l4, n4), y3;
        }, hydrateElement = (t4, e4, n4, o4, a4, s4) => {
          s4 = s4 || !!e4.dynamicChildren;
          const { type: p4, props: c4, patchFlag: d3, shapeFlag: m3, dirs: u3, transition: h3 } = e4, g3 = "input" === p4 || "option" === p4;
          if (g3 || -1 !== d3) {
            u3 && invokeDirectiveHook(e4, null, n4, "created");
            let p5, x3 = false;
            if (isTemplateNode2(t4)) {
              x3 = needTransition(o4, h3) && n4 && n4.vnode.props && n4.vnode.props.appear;
              const r3 = t4.content.firstChild;
              x3 && h3.beforeEnter(r3), replaceNode(r3, t4, n4), e4.el = t4 = r3;
            }
            if (c4)
              if (g3 || !s4 || 48 & d3)
                for (const e5 in c4)
                  (g3 && (e5.endsWith("value") || "indeterminate" === e5) || r2.isOn(e5) && !r2.isReservedProp(e5) || "." === e5[0]) && i3(t4, e5, null, c4[e5], false, void 0, n4);
              else
                c4.onClick && i3(t4, "onClick", null, c4.onClick, false, void 0, n4);
            if ((p5 = c4 && c4.onVnodeBeforeMount) && invokeVNodeHook(p5, n4, e4), u3 && invokeDirectiveHook(e4, null, n4, "beforeMount"), ((p5 = c4 && c4.onVnodeMounted) || u3 || x3) && queueEffectWithSuspense(() => {
              p5 && invokeVNodeHook(p5, n4, e4), x3 && h3.enter(t4), u3 && invokeDirectiveHook(e4, null, n4, "mounted");
            }, o4), 16 & m3 && (!c4 || !c4.innerHTML && !c4.textContent)) {
              let r3 = hydrateChildren(t4.firstChild, e4, t4, n4, o4, a4, s4);
              for (; r3; ) {
                U2 = true;
                const t5 = r3;
                r3 = r3.nextSibling, l3(t5);
              }
            } else
              8 & m3 && t4.textContent !== e4.children && (U2 = true, t4.textContent = e4.children);
          }
          return t4.nextSibling;
        }, hydrateChildren = (t4, e4, r3, i4, o4, a4, s4) => {
          s4 = s4 || !!e4.dynamicChildren;
          const l4 = e4.children, p4 = l4.length;
          for (let e5 = 0; e5 < p4; e5++) {
            const p5 = s4 ? l4[e5] : l4[e5] = normalizeVNode(l4[e5]);
            if (t4)
              t4 = hydrateNode(t4, p5, i4, o4, a4, s4);
            else {
              if (p5.type === G2 && !p5.children)
                continue;
              U2 = true, n3(null, p5, r3, null, i4, o4, isSVGContainer(r3), a4);
            }
          }
          return t4;
        }, hydrateFragment = (t4, e4, r3, n4, i4, o4) => {
          const { slotScopeIds: l4 } = e4;
          l4 && (i4 = i4 ? i4.concat(l4) : l4);
          const d3 = s3(t4), m3 = hydrateChildren(a3(t4), e4, d3, r3, n4, i4, o4);
          return m3 && isComment2(m3) && "]" === m3.data ? a3(e4.anchor = m3) : (U2 = true, p3(e4.anchor = c3("]"), d3, m3), m3);
        }, handleMismatch = (t4, e4, r3, i4, o4, p4) => {
          if (U2 = true, e4.el = null, p4) {
            const e5 = locateClosingAnchor(t4);
            for (; ; ) {
              const r4 = a3(t4);
              if (!r4 || r4 === e5)
                break;
              l3(r4);
            }
          }
          const c4 = a3(t4), d3 = s3(t4);
          return l3(t4), n3(null, e4, d3, c4, r3, i4, isSVGContainer(d3), o4), c4;
        }, locateClosingAnchor = (t4, e4 = "[", r3 = "]") => {
          let n4 = 0;
          for (; t4; )
            if ((t4 = a3(t4)) && isComment2(t4) && (t4.data === e4 && n4++, t4.data === r3)) {
              if (0 === n4)
                return a3(t4);
              n4--;
            }
          return t4;
        }, replaceNode = (t4, e4, r3) => {
          const n4 = e4.parentNode;
          n4 && n4.replaceChild(t4, e4);
          let i4 = r3;
          for (; i4; )
            i4.vnode.el === e4 && (i4.vnode.el = i4.subTree.el = t4), i4 = i4.parent;
        }, isTemplateNode2 = (t4) => 1 === t4.nodeType && "template" === t4.tagName.toLowerCase();
        return [(t4, e4) => {
          if (!e4.hasChildNodes())
            return n3(null, t4, e4), flushPostFlushCbs(), void (e4._vnode = t4);
          U2 = false, hydrateNode(e4.firstChild, t4, null, null, null), flushPostFlushCbs(), e4._vnode = t4, U2 && console.error("Hydration completed but contains mismatches.");
        }, hydrateNode];
      }
      const H2 = queueEffectWithSuspense;
      function baseCreateRenderer(t3, n3) {
        r2.getGlobalThis().__VUE__ = true;
        const { insert: i3, remove: s3, patchProp: l3, createElement: p3, createText: c3, createComment: d3, setText: m3, setElementText: u3, parentNode: h3, nextSibling: g3, setScopeId: x3 = r2.NOOP, insertStaticContent: v3 } = t3, patch = (t4, e3, r3, n4 = null, i4 = null, o3 = null, a3 = false, s4 = null, l4 = !!e3.dynamicChildren) => {
          if (t4 === e3)
            return;
          t4 && !isSameVNodeType(t4, e3) && (n4 = getNextHostNode(t4), unmount(t4, i4, o3, true), t4 = null), -2 === e3.patchFlag && (l4 = false, e3.dynamicChildren = null);
          const { type: p4, ref: c4, shapeFlag: d4 } = e3;
          switch (p4) {
            case G2:
              processText(t4, e3, r3, n4);
              break;
            case J2:
              processCommentNode(t4, e3, r3, n4);
              break;
            case Y2:
              null == t4 && mountStaticNode(e3, r3, n4, a3);
              break;
            case K2:
              processFragment(t4, e3, r3, n4, i4, o3, a3, s4, l4);
              break;
            default:
              1 & d4 ? processElement(t4, e3, r3, n4, i4, o3, a3, s4, l4) : 6 & d4 ? processComponent(t4, e3, r3, n4, i4, o3, a3, s4, l4) : (64 & d4 || 128 & d4) && p4.process(t4, e3, r3, n4, i4, o3, a3, s4, l4, y3);
          }
          null != c4 && i4 && setRef(c4, t4 && t4.ref, o3, e3 || t4, !e3);
        }, processText = (t4, e3, r3, n4) => {
          if (null == t4)
            i3(e3.el = c3(e3.children), r3, n4);
          else {
            const r4 = e3.el = t4.el;
            e3.children !== t4.children && m3(r4, e3.children);
          }
        }, processCommentNode = (t4, e3, r3, n4) => {
          null == t4 ? i3(e3.el = d3(e3.children || ""), r3, n4) : e3.el = t4.el;
        }, mountStaticNode = (t4, e3, r3, n4) => {
          [t4.el, t4.anchor] = v3(t4.children, e3, r3, n4, t4.el, t4.anchor);
        }, processElement = (t4, e3, r3, n4, i4, o3, a3, s4, l4) => {
          a3 = a3 || "svg" === e3.type, null == t4 ? mountElement(e3, r3, n4, i4, o3, a3, s4, l4) : patchElement(t4, e3, i4, o3, a3, s4, l4);
        }, mountElement = (t4, e3, n4, o3, a3, s4, c4, d4) => {
          let m4, h4;
          const { type: g4, props: x4, shapeFlag: v4, transition: y4, dirs: b4 } = t4;
          if (m4 = t4.el = p3(t4.type, s4, x4 && x4.is, x4), 8 & v4 ? u3(m4, t4.children) : 16 & v4 && mountChildren(t4.children, m4, null, o3, a3, s4 && "foreignObject" !== g4, c4, d4), b4 && invokeDirectiveHook(t4, null, o3, "created"), setScopeId(m4, t4, t4.scopeId, c4, o3), x4) {
            for (const e4 in x4)
              "value" === e4 || r2.isReservedProp(e4) || l3(m4, e4, null, x4[e4], s4, t4.children, o3, a3, unmountChildren);
            "value" in x4 && l3(m4, "value", null, x4.value), (h4 = x4.onVnodeBeforeMount) && invokeVNodeHook(h4, o3, t4);
          }
          b4 && invokeDirectiveHook(t4, null, o3, "beforeMount");
          const w4 = needTransition(a3, y4);
          w4 && y4.beforeEnter(m4), i3(m4, e3, n4), ((h4 = x4 && x4.onVnodeMounted) || w4 || b4) && H2(() => {
            h4 && invokeVNodeHook(h4, o3, t4), w4 && y4.enter(m4), b4 && invokeDirectiveHook(t4, null, o3, "mounted");
          }, a3);
        }, setScopeId = (t4, e3, r3, n4, i4) => {
          if (r3 && x3(t4, r3), n4)
            for (let e4 = 0; e4 < n4.length; e4++)
              x3(t4, n4[e4]);
          if (i4) {
            if (e3 === i4.subTree) {
              const e4 = i4.vnode;
              setScopeId(t4, e4, e4.scopeId, e4.slotScopeIds, i4.parent);
            }
          }
        }, mountChildren = (t4, e3, r3, n4, i4, o3, a3, s4, l4 = 0) => {
          for (let p4 = l4; p4 < t4.length; p4++) {
            const l5 = t4[p4] = s4 ? cloneIfMounted(t4[p4]) : normalizeVNode(t4[p4]);
            patch(null, l5, e3, r3, n4, i4, o3, a3, s4);
          }
        }, patchElement = (t4, e3, n4, i4, o3, a3, s4) => {
          const p4 = e3.el = t4.el;
          let { patchFlag: c4, dynamicChildren: d4, dirs: m4 } = e3;
          c4 |= 16 & t4.patchFlag;
          const h4 = t4.props || r2.EMPTY_OBJ, g4 = e3.props || r2.EMPTY_OBJ;
          let x4;
          n4 && toggleRecurse(n4, false), (x4 = g4.onVnodeBeforeUpdate) && invokeVNodeHook(x4, n4, e3, t4), m4 && invokeDirectiveHook(e3, t4, n4, "beforeUpdate"), n4 && toggleRecurse(n4, true);
          const v4 = o3 && "foreignObject" !== e3.type;
          if (d4 ? patchBlockChildren(t4.dynamicChildren, d4, p4, n4, i4, v4, a3) : s4 || patchChildren(t4, e3, p4, null, n4, i4, v4, a3, false), c4 > 0) {
            if (16 & c4)
              patchProps(p4, e3, h4, g4, n4, i4, o3);
            else if (2 & c4 && h4.class !== g4.class && l3(p4, "class", null, g4.class, o3), 4 & c4 && l3(p4, "style", h4.style, g4.style, o3), 8 & c4) {
              const r3 = e3.dynamicProps;
              for (let e4 = 0; e4 < r3.length; e4++) {
                const a4 = r3[e4], s5 = h4[a4], c5 = g4[a4];
                c5 === s5 && "value" !== a4 || l3(p4, a4, s5, c5, o3, t4.children, n4, i4, unmountChildren);
              }
            }
            1 & c4 && t4.children !== e3.children && u3(p4, e3.children);
          } else
            s4 || null != d4 || patchProps(p4, e3, h4, g4, n4, i4, o3);
          ((x4 = g4.onVnodeUpdated) || m4) && H2(() => {
            x4 && invokeVNodeHook(x4, n4, e3, t4), m4 && invokeDirectiveHook(e3, t4, n4, "updated");
          }, i4);
        }, patchBlockChildren = (t4, e3, r3, n4, i4, o3, a3) => {
          for (let s4 = 0; s4 < e3.length; s4++) {
            const l4 = t4[s4], p4 = e3[s4], c4 = l4.el && (l4.type === K2 || !isSameVNodeType(l4, p4) || 70 & l4.shapeFlag) ? h3(l4.el) : r3;
            patch(l4, p4, c4, null, n4, i4, o3, a3, true);
          }
        }, patchProps = (t4, e3, n4, i4, o3, a3, s4) => {
          if (n4 !== i4) {
            if (n4 !== r2.EMPTY_OBJ)
              for (const p4 in n4)
                r2.isReservedProp(p4) || p4 in i4 || l3(t4, p4, n4[p4], null, s4, e3.children, o3, a3, unmountChildren);
            for (const p4 in i4) {
              if (r2.isReservedProp(p4))
                continue;
              const c4 = i4[p4], d4 = n4[p4];
              c4 !== d4 && "value" !== p4 && l3(t4, p4, d4, c4, s4, e3.children, o3, a3, unmountChildren);
            }
            "value" in i4 && l3(t4, "value", n4.value, i4.value);
          }
        }, processFragment = (t4, e3, r3, n4, o3, a3, s4, l4, p4) => {
          const d4 = e3.el = t4 ? t4.el : c3(""), m4 = e3.anchor = t4 ? t4.anchor : c3("");
          let { patchFlag: u4, dynamicChildren: h4, slotScopeIds: g4 } = e3;
          g4 && (l4 = l4 ? l4.concat(g4) : g4), null == t4 ? (i3(d4, r3, n4), i3(m4, r3, n4), mountChildren(e3.children, r3, m4, o3, a3, s4, l4, p4)) : u4 > 0 && 64 & u4 && h4 && t4.dynamicChildren ? (patchBlockChildren(t4.dynamicChildren, h4, r3, o3, a3, s4, l4), (null != e3.key || o3 && e3 === o3.subTree) && traverseStaticChildren(t4, e3, true)) : patchChildren(t4, e3, r3, m4, o3, a3, s4, l4, p4);
        }, processComponent = (t4, e3, r3, n4, i4, o3, a3, s4, l4) => {
          e3.slotScopeIds = s4, null == t4 ? 512 & e3.shapeFlag ? i4.ctx.activate(e3, r3, n4, a3, l4) : mountComponent(e3, r3, n4, i4, o3, a3, l4) : updateComponent(t4, e3, l4);
        }, mountComponent = (t4, e3, r3, n4, i4, o3, a3) => {
          const s4 = t4.component = createComponentInstance(t4, n4, i4);
          if (isKeepAlive(t4) && (s4.ctx.renderer = y3), setupComponent(s4), s4.asyncDep) {
            if (i4 && i4.registerDep(s4, setupRenderEffect), !t4.el) {
              const t5 = s4.subTree = createVNode(J2);
              processCommentNode(null, t5, e3, r3);
            }
          } else
            setupRenderEffect(s4, t4, e3, r3, i4, o3, a3);
        }, updateComponent = (t4, e3, r3) => {
          const n4 = e3.component = t4.component;
          if (function(t5, e4, r4) {
            const { props: n5, children: i4, component: o3 } = t5, { props: a3, children: s4, patchFlag: l4 } = e4, p4 = o3.emitsOptions;
            if (e4.dirs || e4.transition)
              return true;
            if (!(r4 && l4 >= 0))
              return !(!i4 && !s4 || s4 && s4.$stable) || n5 !== a3 && (n5 ? !a3 || hasPropsChanged(n5, a3, p4) : !!a3);
            if (1024 & l4)
              return true;
            if (16 & l4)
              return n5 ? hasPropsChanged(n5, a3, p4) : !!a3;
            if (8 & l4) {
              const t6 = e4.dynamicProps;
              for (let e5 = 0; e5 < t6.length; e5++) {
                const r5 = t6[e5];
                if (a3[r5] !== n5[r5] && !isEmitListener(p4, r5))
                  return true;
              }
            }
            return false;
          }(t4, e3, r3)) {
            if (n4.asyncDep && !n4.asyncResolved)
              return void updateComponentPreRender(n4, e3, r3);
            n4.next = e3, function(t5) {
              const e4 = o2.indexOf(t5);
              e4 > a2 && o2.splice(e4, 1);
            }(n4.update), n4.update();
          } else
            e3.el = t4.el, n4.vnode = e3;
        }, setupRenderEffect = (t4, n4, i4, o3, a3, s4, l4) => {
          const p4 = t4.effect = new e2.ReactiveEffect(() => {
            if (t4.isMounted) {
              let e3, { next: n5, bu: i5, u: o4, parent: p5, vnode: c5 } = t4, d4 = n5;
              toggleRecurse(t4, false), n5 ? (n5.el = c5.el, updateComponentPreRender(t4, n5, l4)) : n5 = c5, i5 && r2.invokeArrayFns(i5), (e3 = n5.props && n5.props.onVnodeBeforeUpdate) && invokeVNodeHook(e3, p5, n5, c5), toggleRecurse(t4, true);
              const m4 = renderComponentRoot(t4), u4 = t4.subTree;
              t4.subTree = m4, patch(u4, m4, h3(u4.el), getNextHostNode(u4), t4, a3, s4), n5.el = m4.el, null === d4 && updateHOCHostEl(t4, m4.el), o4 && H2(o4, a3), (e3 = n5.props && n5.props.onVnodeUpdated) && H2(() => invokeVNodeHook(e3, p5, n5, c5), a3);
            } else {
              let e3;
              const { el: l5, props: p5 } = n4, { bm: c5, m: d4, parent: m4 } = t4, u4 = isAsyncWrapper(n4);
              if (toggleRecurse(t4, false), c5 && r2.invokeArrayFns(c5), !u4 && (e3 = p5 && p5.onVnodeBeforeMount) && invokeVNodeHook(e3, m4, n4), toggleRecurse(t4, true), l5 && w3) {
                const hydrateSubTree = () => {
                  t4.subTree = renderComponentRoot(t4), w3(l5, t4.subTree, t4, a3, null);
                };
                u4 ? n4.type.__asyncLoader().then(() => !t4.isUnmounted && hydrateSubTree()) : hydrateSubTree();
              } else {
                const e4 = t4.subTree = renderComponentRoot(t4);
                patch(null, e4, i4, o3, t4, a3, s4), n4.el = e4.el;
              }
              if (d4 && H2(d4, a3), !u4 && (e3 = p5 && p5.onVnodeMounted)) {
                const t5 = n4;
                H2(() => invokeVNodeHook(e3, m4, t5), a3);
              }
              (256 & n4.shapeFlag || m4 && isAsyncWrapper(m4.vnode) && 256 & m4.vnode.shapeFlag) && t4.a && H2(t4.a, a3), t4.isMounted = true, n4 = i4 = o3 = null;
            }
          }, () => queueJob(c4), t4.scope), c4 = t4.update = () => p4.run();
          c4.id = t4.uid, toggleRecurse(t4, true), c4();
        }, updateComponentPreRender = (t4, n4, i4) => {
          n4.component = t4;
          const o3 = t4.vnode.props;
          t4.vnode = n4, t4.next = null, function(t5, n5, i5, o4) {
            const { props: a3, attrs: s4, vnode: { patchFlag: l4 } } = t5, p4 = e2.toRaw(a3), [c4] = t5.propsOptions;
            let d4 = false;
            if (!(o4 || l4 > 0) || 16 & l4) {
              let e3;
              setFullProps(t5, n5, a3, s4) && (d4 = true);
              for (const o5 in p4)
                n5 && (r2.hasOwn(n5, o5) || (e3 = r2.hyphenate(o5)) !== o5 && r2.hasOwn(n5, e3)) || (c4 ? !i5 || void 0 === i5[o5] && void 0 === i5[e3] || (a3[o5] = resolvePropValue(c4, p4, o5, void 0, t5, true)) : delete a3[o5]);
              if (s4 !== p4)
                for (const t6 in s4)
                  n5 && r2.hasOwn(n5, t6) || (delete s4[t6], d4 = true);
            } else if (8 & l4) {
              const e3 = t5.vnode.dynamicProps;
              for (let i6 = 0; i6 < e3.length; i6++) {
                let o5 = e3[i6];
                if (isEmitListener(t5.emitsOptions, o5))
                  continue;
                const l5 = n5[o5];
                if (c4)
                  if (r2.hasOwn(s4, o5))
                    l5 !== s4[o5] && (s4[o5] = l5, d4 = true);
                  else {
                    const e4 = r2.camelize(o5);
                    a3[e4] = resolvePropValue(c4, p4, e4, l5, t5, false);
                  }
                else
                  l5 !== s4[o5] && (s4[o5] = l5, d4 = true);
              }
            }
            d4 && e2.trigger(t5, "set", "$attrs");
          }(t4, n4.props, o3, i4), updateSlots(t4, n4.children, i4), e2.pauseTracking(), flushPreFlushCbs(t4), e2.resetTracking();
        }, patchChildren = (t4, e3, r3, n4, i4, o3, a3, s4, l4 = false) => {
          const p4 = t4 && t4.children, c4 = t4 ? t4.shapeFlag : 0, d4 = e3.children, { patchFlag: m4, shapeFlag: h4 } = e3;
          if (m4 > 0) {
            if (128 & m4)
              return void patchKeyedChildren(p4, d4, r3, n4, i4, o3, a3, s4, l4);
            if (256 & m4)
              return void patchUnkeyedChildren(p4, d4, r3, n4, i4, o3, a3, s4, l4);
          }
          8 & h4 ? (16 & c4 && unmountChildren(p4, i4, o3), d4 !== p4 && u3(r3, d4)) : 16 & c4 ? 16 & h4 ? patchKeyedChildren(p4, d4, r3, n4, i4, o3, a3, s4, l4) : unmountChildren(p4, i4, o3, true) : (8 & c4 && u3(r3, ""), 16 & h4 && mountChildren(d4, r3, n4, i4, o3, a3, s4, l4));
        }, patchUnkeyedChildren = (t4, e3, n4, i4, o3, a3, s4, l4, p4) => {
          t4 = t4 || r2.EMPTY_ARR, e3 = e3 || r2.EMPTY_ARR;
          const c4 = t4.length, d4 = e3.length, m4 = Math.min(c4, d4);
          let u4;
          for (u4 = 0; u4 < m4; u4++) {
            const r3 = e3[u4] = p4 ? cloneIfMounted(e3[u4]) : normalizeVNode(e3[u4]);
            patch(t4[u4], r3, n4, null, o3, a3, s4, l4, p4);
          }
          c4 > d4 ? unmountChildren(t4, o3, a3, true, false, m4) : mountChildren(e3, n4, i4, o3, a3, s4, l4, p4, m4);
        }, patchKeyedChildren = (t4, e3, n4, i4, o3, a3, s4, l4, p4) => {
          let c4 = 0;
          const d4 = e3.length;
          let m4 = t4.length - 1, u4 = d4 - 1;
          for (; c4 <= m4 && c4 <= u4; ) {
            const r3 = t4[c4], i5 = e3[c4] = p4 ? cloneIfMounted(e3[c4]) : normalizeVNode(e3[c4]);
            if (!isSameVNodeType(r3, i5))
              break;
            patch(r3, i5, n4, null, o3, a3, s4, l4, p4), c4++;
          }
          for (; c4 <= m4 && c4 <= u4; ) {
            const r3 = t4[m4], i5 = e3[u4] = p4 ? cloneIfMounted(e3[u4]) : normalizeVNode(e3[u4]);
            if (!isSameVNodeType(r3, i5))
              break;
            patch(r3, i5, n4, null, o3, a3, s4, l4, p4), m4--, u4--;
          }
          if (c4 > m4) {
            if (c4 <= u4) {
              const t5 = u4 + 1, r3 = t5 < d4 ? e3[t5].el : i4;
              for (; c4 <= u4; )
                patch(null, e3[c4] = p4 ? cloneIfMounted(e3[c4]) : normalizeVNode(e3[c4]), n4, r3, o3, a3, s4, l4, p4), c4++;
            }
          } else if (c4 > u4)
            for (; c4 <= m4; )
              unmount(t4[c4], o3, a3, true), c4++;
          else {
            const h4 = c4, g4 = c4, x4 = /* @__PURE__ */ new Map();
            for (c4 = g4; c4 <= u4; c4++) {
              const t5 = e3[c4] = p4 ? cloneIfMounted(e3[c4]) : normalizeVNode(e3[c4]);
              null != t5.key && x4.set(t5.key, c4);
            }
            let v4, y4 = 0;
            const b4 = u4 - g4 + 1;
            let w4 = false, k3 = 0;
            const S3 = new Array(b4);
            for (c4 = 0; c4 < b4; c4++)
              S3[c4] = 0;
            for (c4 = h4; c4 <= m4; c4++) {
              const r3 = t4[c4];
              if (y4 >= b4) {
                unmount(r3, o3, a3, true);
                continue;
              }
              let i5;
              if (null != r3.key)
                i5 = x4.get(r3.key);
              else
                for (v4 = g4; v4 <= u4; v4++)
                  if (0 === S3[v4 - g4] && isSameVNodeType(r3, e3[v4])) {
                    i5 = v4;
                    break;
                  }
              void 0 === i5 ? unmount(r3, o3, a3, true) : (S3[i5 - g4] = c4 + 1, i5 >= k3 ? k3 = i5 : w4 = true, patch(r3, e3[i5], n4, null, o3, a3, s4, l4, p4), y4++);
            }
            const C3 = w4 ? function(t5) {
              const e4 = t5.slice(), r3 = [0];
              let n5, i5, o4, a4, s5;
              const l5 = t5.length;
              for (n5 = 0; n5 < l5; n5++) {
                const l6 = t5[n5];
                if (0 !== l6) {
                  if (i5 = r3[r3.length - 1], t5[i5] < l6) {
                    e4[n5] = i5, r3.push(n5);
                    continue;
                  }
                  for (o4 = 0, a4 = r3.length - 1; o4 < a4; )
                    s5 = o4 + a4 >> 1, t5[r3[s5]] < l6 ? o4 = s5 + 1 : a4 = s5;
                  l6 < t5[r3[o4]] && (o4 > 0 && (e4[n5] = r3[o4 - 1]), r3[o4] = n5);
                }
              }
              o4 = r3.length, a4 = r3[o4 - 1];
              for (; o4-- > 0; )
                r3[o4] = a4, a4 = e4[a4];
              return r3;
            }(S3) : r2.EMPTY_ARR;
            for (v4 = C3.length - 1, c4 = b4 - 1; c4 >= 0; c4--) {
              const t5 = g4 + c4, r3 = e3[t5], m5 = t5 + 1 < d4 ? e3[t5 + 1].el : i4;
              0 === S3[c4] ? patch(null, r3, n4, m5, o3, a3, s4, l4, p4) : w4 && (v4 < 0 || c4 !== C3[v4] ? move(r3, n4, m5, 2) : v4--);
            }
          }
        }, move = (t4, e3, r3, n4, o3 = null) => {
          const { el: a3, type: s4, transition: l4, children: p4, shapeFlag: c4 } = t4;
          if (6 & c4)
            return void move(t4.component.subTree, e3, r3, n4);
          if (128 & c4)
            return void t4.suspense.move(e3, r3, n4);
          if (64 & c4)
            return void s4.move(t4, e3, r3, y3);
          if (s4 === K2) {
            i3(a3, e3, r3);
            for (let t5 = 0; t5 < p4.length; t5++)
              move(p4[t5], e3, r3, n4);
            return void i3(t4.anchor, e3, r3);
          }
          if (s4 === Y2)
            return void (({ el: t5, anchor: e4 }, r4, n5) => {
              let o4;
              for (; t5 && t5 !== e4; )
                o4 = g3(t5), i3(t5, r4, n5), t5 = o4;
              i3(e4, r4, n5);
            })(t4, e3, r3);
          if (2 !== n4 && 1 & c4 && l4)
            if (0 === n4)
              l4.beforeEnter(a3), i3(a3, e3, r3), H2(() => l4.enter(a3), o3);
            else {
              const { leave: t5, delayLeave: n5, afterLeave: o4 } = l4, remove2 = () => i3(a3, e3, r3), performLeave = () => {
                t5(a3, () => {
                  remove2(), o4 && o4();
                });
              };
              n5 ? n5(a3, remove2, performLeave) : performLeave();
            }
          else
            i3(a3, e3, r3);
        }, unmount = (t4, e3, r3, n4 = false, i4 = false) => {
          const { type: o3, props: a3, ref: s4, children: l4, dynamicChildren: p4, shapeFlag: c4, patchFlag: d4, dirs: m4 } = t4;
          if (null != s4 && setRef(s4, null, r3, t4, true), 256 & c4)
            return void e3.ctx.deactivate(t4);
          const u4 = 1 & c4 && m4, h4 = !isAsyncWrapper(t4);
          let g4;
          if (h4 && (g4 = a3 && a3.onVnodeBeforeUnmount) && invokeVNodeHook(g4, e3, t4), 6 & c4)
            unmountComponent(t4.component, r3, n4);
          else {
            if (128 & c4)
              return void t4.suspense.unmount(r3, n4);
            u4 && invokeDirectiveHook(t4, null, e3, "beforeUnmount"), 64 & c4 ? t4.type.remove(t4, e3, r3, i4, y3, n4) : p4 && (o3 !== K2 || d4 > 0 && 64 & d4) ? unmountChildren(p4, e3, r3, false, true) : (o3 === K2 && 384 & d4 || !i4 && 16 & c4) && unmountChildren(l4, e3, r3), n4 && remove(t4);
          }
          (h4 && (g4 = a3 && a3.onVnodeUnmounted) || u4) && H2(() => {
            g4 && invokeVNodeHook(g4, e3, t4), u4 && invokeDirectiveHook(t4, null, e3, "unmounted");
          }, r3);
        }, remove = (t4) => {
          const { type: e3, el: r3, anchor: n4, transition: i4 } = t4;
          if (e3 === K2)
            return void removeFragment(r3, n4);
          if (e3 === Y2)
            return void (({ el: t5, anchor: e4 }) => {
              let r4;
              for (; t5 && t5 !== e4; )
                r4 = g3(t5), s3(t5), t5 = r4;
              s3(e4);
            })(t4);
          const performRemove = () => {
            s3(r3), i4 && !i4.persisted && i4.afterLeave && i4.afterLeave();
          };
          if (1 & t4.shapeFlag && i4 && !i4.persisted) {
            const { leave: e4, delayLeave: n5 } = i4, performLeave = () => e4(r3, performRemove);
            n5 ? n5(t4.el, performRemove, performLeave) : performLeave();
          } else
            performRemove();
        }, removeFragment = (t4, e3) => {
          let r3;
          for (; t4 !== e3; )
            r3 = g3(t4), s3(t4), t4 = r3;
          s3(e3);
        }, unmountComponent = (t4, e3, n4) => {
          const { bum: i4, scope: o3, update: a3, subTree: s4, um: l4 } = t4;
          i4 && r2.invokeArrayFns(i4), o3.stop(), a3 && (a3.active = false, unmount(s4, t4, e3, n4)), l4 && H2(l4, e3), H2(() => {
            t4.isUnmounted = true;
          }, e3), e3 && e3.pendingBranch && !e3.isUnmounted && t4.asyncDep && !t4.asyncResolved && t4.suspenseId === e3.pendingId && (e3.deps--, 0 === e3.deps && e3.resolve());
        }, unmountChildren = (t4, e3, r3, n4 = false, i4 = false, o3 = 0) => {
          for (let a3 = o3; a3 < t4.length; a3++)
            unmount(t4[a3], e3, r3, n4, i4);
        }, getNextHostNode = (t4) => 6 & t4.shapeFlag ? getNextHostNode(t4.component.subTree) : 128 & t4.shapeFlag ? t4.suspense.next() : g3(t4.anchor || t4.el), render = (t4, e3, r3) => {
          null == t4 ? e3._vnode && unmount(e3._vnode, null, null, true) : patch(e3._vnode || null, t4, e3, null, null, null, r3), flushPreFlushCbs(), flushPostFlushCbs(), e3._vnode = t4;
        }, y3 = { p: patch, um: unmount, m: move, r: remove, mt: mountComponent, mc: mountChildren, pc: patchChildren, pbc: patchBlockChildren, n: getNextHostNode, o: t3 };
        let b3, w3;
        return n3 && ([b3, w3] = n3(y3)), { render, hydrate: b3, createApp: createAppAPI(render, b3) };
      }
      function toggleRecurse({ effect: t3, update: e3 }, r3) {
        t3.allowRecurse = e3.allowRecurse = r3;
      }
      function needTransition(t3, e3) {
        return (!t3 || t3 && !t3.pendingBranch) && e3 && !e3.persisted;
      }
      function traverseStaticChildren(t3, e3, n3 = false) {
        const i3 = t3.children, o3 = e3.children;
        if (r2.isArray(i3) && r2.isArray(o3))
          for (let t4 = 0; t4 < i3.length; t4++) {
            const e4 = i3[t4];
            let r3 = o3[t4];
            1 & r3.shapeFlag && !r3.dynamicChildren && ((r3.patchFlag <= 0 || 32 === r3.patchFlag) && (r3 = o3[t4] = cloneIfMounted(o3[t4]), r3.el = e4.el), n3 || traverseStaticChildren(e4, r3)), r3.type === G2 && (r3.el = e4.el);
          }
      }
      const isTeleportDisabled = (t3) => t3 && (t3.disabled || "" === t3.disabled), isTargetSVG = (t3) => "undefined" != typeof SVGElement && t3 instanceof SVGElement, resolveTarget = (t3, e3) => {
        const n3 = t3 && t3.to;
        if (r2.isString(n3)) {
          if (e3) {
            return e3(n3);
          }
          return null;
        }
        return n3;
      }, q2 = { name: "Teleport", __isTeleport: true, process(t3, e3, r3, n3, i3, o3, a3, s3, l3, p3) {
        const { mc: c3, pc: d3, pbc: m3, o: { insert: u3, querySelector: h3, createText: g3, createComment: x3 } } = p3, v3 = isTeleportDisabled(e3.props);
        let { shapeFlag: y3, children: b3, dynamicChildren: w3 } = e3;
        if (null == t3) {
          const t4 = e3.el = g3(""), p4 = e3.anchor = g3("");
          u3(t4, r3, n3), u3(p4, r3, n3);
          const d4 = e3.target = resolveTarget(e3.props, h3), m4 = e3.targetAnchor = g3("");
          d4 && (u3(m4, d4), a3 = a3 || isTargetSVG(d4));
          const mount = (t5, e4) => {
            16 & y3 && c3(b3, t5, e4, i3, o3, a3, s3, l3);
          };
          v3 ? mount(r3, p4) : d4 && mount(d4, m4);
        } else {
          e3.el = t3.el;
          const n4 = e3.anchor = t3.anchor, c4 = e3.target = t3.target, u4 = e3.targetAnchor = t3.targetAnchor, g4 = isTeleportDisabled(t3.props), x4 = g4 ? r3 : c4, y4 = g4 ? n4 : u4;
          if (a3 = a3 || isTargetSVG(c4), w3 ? (m3(t3.dynamicChildren, w3, x4, i3, o3, a3, s3), traverseStaticChildren(t3, e3, true)) : l3 || d3(t3, e3, x4, y4, i3, o3, a3, s3, false), v3)
            g4 ? e3.props && t3.props && e3.props.to !== t3.props.to && (e3.props.to = t3.props.to) : moveTeleport(e3, r3, n4, p3, 1);
          else if ((e3.props && e3.props.to) !== (t3.props && t3.props.to)) {
            const t4 = e3.target = resolveTarget(e3.props, h3);
            t4 && moveTeleport(e3, t4, null, p3, 0);
          } else
            g4 && moveTeleport(e3, c4, u4, p3, 1);
        }
        updateCssVars(e3);
      }, remove(t3, e3, r3, n3, { um: i3, o: { remove: o3 } }, a3) {
        const { shapeFlag: s3, children: l3, anchor: p3, targetAnchor: c3, target: d3, props: m3 } = t3;
        if (d3 && o3(c3), a3 && o3(p3), 16 & s3) {
          const t4 = a3 || !isTeleportDisabled(m3);
          for (let n4 = 0; n4 < l3.length; n4++) {
            const o4 = l3[n4];
            i3(o4, e3, r3, t4, !!o4.dynamicChildren);
          }
        }
      }, move: moveTeleport, hydrate: function(t3, e3, r3, n3, i3, o3, { o: { nextSibling: a3, parentNode: s3, querySelector: l3 } }, p3) {
        const c3 = e3.target = resolveTarget(e3.props, l3);
        if (c3) {
          const l4 = c3._lpa || c3.firstChild;
          if (16 & e3.shapeFlag)
            if (isTeleportDisabled(e3.props))
              e3.anchor = p3(a3(t3), e3, s3(t3), r3, n3, i3, o3), e3.targetAnchor = l4;
            else {
              e3.anchor = a3(t3);
              let s4 = l4;
              for (; s4; )
                if (s4 = a3(s4), s4 && 8 === s4.nodeType && "teleport anchor" === s4.data) {
                  e3.targetAnchor = s4, c3._lpa = e3.targetAnchor && a3(e3.targetAnchor);
                  break;
                }
              p3(l4, e3, c3, r3, n3, i3, o3);
            }
          updateCssVars(e3);
        }
        return e3.anchor && a3(e3.anchor);
      } };
      function moveTeleport(t3, e3, r3, { o: { insert: n3 }, m: i3 }, o3 = 2) {
        0 === o3 && n3(t3.targetAnchor, e3, r3);
        const { el: a3, anchor: s3, shapeFlag: l3, children: p3, props: c3 } = t3, d3 = 2 === o3;
        if (d3 && n3(a3, e3, r3), (!d3 || isTeleportDisabled(c3)) && 16 & l3)
          for (let t4 = 0; t4 < p3.length; t4++)
            i3(p3[t4], e3, r3, 2);
        d3 && n3(s3, e3, r3);
      }
      const W2 = q2;
      function updateCssVars(t3) {
        const e3 = t3.ctx;
        if (e3 && e3.ut) {
          let r3 = t3.children[0].el;
          for (; r3 && r3 !== t3.targetAnchor; )
            1 === r3.nodeType && r3.setAttribute("data-v-owner", e3.uid), r3 = r3.nextSibling;
          e3.ut();
        }
      }
      const K2 = Symbol.for("v-fgt"), G2 = Symbol.for("v-txt"), J2 = Symbol.for("v-cmt"), Y2 = Symbol.for("v-stc"), X2 = [];
      let Q2 = null;
      function openBlock(t3 = false) {
        X2.push(Q2 = t3 ? null : []);
      }
      function closeBlock() {
        X2.pop(), Q2 = X2[X2.length - 1] || null;
      }
      let Z2 = 1;
      function setBlockTracking(t3) {
        Z2 += t3;
      }
      function setupBlock(t3) {
        return t3.dynamicChildren = Z2 > 0 ? Q2 || r2.EMPTY_ARR : null, closeBlock(), Z2 > 0 && Q2 && Q2.push(t3), t3;
      }
      function createBlock(t3, e3, r3, n3, i3) {
        return setupBlock(createVNode(t3, e3, r3, n3, i3, true));
      }
      function isVNode(t3) {
        return !!t3 && true === t3.__v_isVNode;
      }
      function isSameVNodeType(t3, e3) {
        return t3.type === e3.type && t3.key === e3.key;
      }
      const tt2 = "__vInternal", normalizeKey2 = ({ key: t3 }) => null != t3 ? t3 : null, normalizeRef = ({ ref: t3, ref_key: n3, ref_for: i3 }) => ("number" == typeof t3 && (t3 = "" + t3), null != t3 ? r2.isString(t3) || e2.isRef(t3) || r2.isFunction(t3) ? { i: u2, r: t3, k: n3, f: !!i3 } : t3 : null);
      function createBaseVNode(t3, e3 = null, n3 = null, i3 = 0, o3 = null, a3 = t3 === K2 ? 0 : 1, s3 = false, l3 = false) {
        const p3 = { __v_isVNode: true, __v_skip: true, type: t3, props: e3, key: e3 && normalizeKey2(e3), ref: e3 && normalizeRef(e3), scopeId: h2, slotScopeIds: null, children: n3, component: null, suspense: null, ssContent: null, ssFallback: null, dirs: null, transition: null, el: null, anchor: null, target: null, targetAnchor: null, staticCount: 0, shapeFlag: a3, patchFlag: i3, dynamicProps: o3, dynamicChildren: null, appContext: null, ctx: u2 };
        return l3 ? (normalizeChildren(p3, n3), 128 & a3 && t3.normalize(p3)) : n3 && (p3.shapeFlag |= r2.isString(n3) ? 8 : 16), Z2 > 0 && !s3 && Q2 && (p3.patchFlag > 0 || 6 & a3) && 32 !== p3.patchFlag && Q2.push(p3), p3;
      }
      const createVNode = function(t3, n3 = null, i3 = null, o3 = 0, a3 = null, s3 = false) {
        t3 && t3 !== x2 || (t3 = J2);
        if (isVNode(t3)) {
          const e3 = cloneVNode(t3, n3, true);
          return i3 && normalizeChildren(e3, i3), Z2 > 0 && !s3 && Q2 && (6 & e3.shapeFlag ? Q2[Q2.indexOf(t3)] = e3 : Q2.push(e3)), e3.patchFlag |= -2, e3;
        }
        l3 = t3, r2.isFunction(l3) && "__vccOpts" in l3 && (t3 = t3.__vccOpts);
        var l3;
        if (n3) {
          n3 = guardReactiveProps(n3);
          let { class: t4, style: i4 } = n3;
          t4 && !r2.isString(t4) && (n3.class = r2.normalizeClass(t4)), r2.isObject(i4) && (e2.isProxy(i4) && !r2.isArray(i4) && (i4 = r2.extend({}, i4)), n3.style = r2.normalizeStyle(i4));
        }
        const p3 = r2.isString(t3) ? 1 : isSuspense(t3) ? 128 : ((t4) => t4.__isTeleport)(t3) ? 64 : r2.isObject(t3) ? 4 : r2.isFunction(t3) ? 2 : 0;
        return createBaseVNode(t3, n3, i3, o3, a3, p3, s3, true);
      };
      function guardReactiveProps(t3) {
        return t3 ? e2.isProxy(t3) || tt2 in t3 ? r2.extend({}, t3) : t3 : null;
      }
      function cloneVNode(t3, e3, n3 = false) {
        const { props: i3, ref: o3, patchFlag: a3, children: s3 } = t3, l3 = e3 ? mergeProps(i3 || {}, e3) : i3;
        return { __v_isVNode: true, __v_skip: true, type: t3.type, props: l3, key: l3 && normalizeKey2(l3), ref: e3 && e3.ref ? n3 && o3 ? r2.isArray(o3) ? o3.concat(normalizeRef(e3)) : [o3, normalizeRef(e3)] : normalizeRef(e3) : o3, scopeId: t3.scopeId, slotScopeIds: t3.slotScopeIds, children: s3, target: t3.target, targetAnchor: t3.targetAnchor, staticCount: t3.staticCount, shapeFlag: t3.shapeFlag, patchFlag: e3 && t3.type !== K2 ? -1 === a3 ? 16 : 16 | a3 : a3, dynamicProps: t3.dynamicProps, dynamicChildren: t3.dynamicChildren, appContext: t3.appContext, dirs: t3.dirs, transition: t3.transition, component: t3.component, suspense: t3.suspense, ssContent: t3.ssContent && cloneVNode(t3.ssContent), ssFallback: t3.ssFallback && cloneVNode(t3.ssFallback), el: t3.el, anchor: t3.anchor, ctx: t3.ctx, ce: t3.ce };
      }
      function createTextVNode(t3 = " ", e3 = 0) {
        return createVNode(G2, null, t3, e3);
      }
      function normalizeVNode(t3) {
        return null == t3 || "boolean" == typeof t3 ? createVNode(J2) : r2.isArray(t3) ? createVNode(K2, null, t3.slice()) : "object" == typeof t3 ? cloneIfMounted(t3) : createVNode(G2, null, String(t3));
      }
      function cloneIfMounted(t3) {
        return null === t3.el && -1 !== t3.patchFlag || t3.memo ? t3 : cloneVNode(t3);
      }
      function normalizeChildren(t3, e3) {
        let n3 = 0;
        const { shapeFlag: i3 } = t3;
        if (null == e3)
          e3 = null;
        else if (r2.isArray(e3))
          n3 = 16;
        else if ("object" == typeof e3) {
          if (65 & i3) {
            const r3 = e3.default;
            return void (r3 && (r3._c && (r3._d = false), normalizeChildren(t3, r3()), r3._c && (r3._d = true)));
          }
          {
            n3 = 32;
            const r3 = e3._;
            r3 || tt2 in e3 ? 3 === r3 && u2 && (1 === u2.slots._ ? e3._ = 1 : (e3._ = 2, t3.patchFlag |= 1024)) : e3._ctx = u2;
          }
        } else
          r2.isFunction(e3) ? (e3 = { default: e3, _ctx: u2 }, n3 = 32) : (e3 = String(e3), 64 & i3 ? (n3 = 16, e3 = [createTextVNode(e3)]) : n3 = 8);
        t3.children = e3, t3.shapeFlag |= n3;
      }
      function mergeProps(...t3) {
        const e3 = {};
        for (let n3 = 0; n3 < t3.length; n3++) {
          const i3 = t3[n3];
          for (const t4 in i3)
            if ("class" === t4)
              e3.class !== i3.class && (e3.class = r2.normalizeClass([e3.class, i3.class]));
            else if ("style" === t4)
              e3.style = r2.normalizeStyle([e3.style, i3.style]);
            else if (r2.isOn(t4)) {
              const n4 = e3[t4], o3 = i3[t4];
              !o3 || n4 === o3 || r2.isArray(n4) && n4.includes(o3) || (e3[t4] = n4 ? [].concat(n4, o3) : o3);
            } else
              "" !== t4 && (e3[t4] = i3[t4]);
        }
        return e3;
      }
      function invokeVNodeHook(t3, e3, r3, n3 = null) {
        callWithAsyncErrorHandling(t3, e3, 7, [r3, n3]);
      }
      const et2 = createAppContext();
      let rt2 = 0;
      function createComponentInstance(t3, n3, i3) {
        const o3 = t3.type, a3 = (n3 ? n3.appContext : t3.appContext) || et2, s3 = { uid: rt2++, vnode: t3, type: o3, parent: n3, appContext: a3, root: null, next: null, subTree: null, effect: null, update: null, scope: new e2.EffectScope(true), render: null, proxy: null, exposed: null, exposeProxy: null, withProxy: null, provides: n3 ? n3.provides : Object.create(a3.provides), accessCache: null, renderCache: [], components: null, directives: null, propsOptions: normalizePropsOptions(o3, a3), emitsOptions: normalizeEmitsOptions(o3, a3), emit: null, emitted: null, propsDefaults: r2.EMPTY_OBJ, inheritAttrs: o3.inheritAttrs, ctx: r2.EMPTY_OBJ, data: r2.EMPTY_OBJ, props: r2.EMPTY_OBJ, attrs: r2.EMPTY_OBJ, slots: r2.EMPTY_OBJ, refs: r2.EMPTY_OBJ, setupState: r2.EMPTY_OBJ, setupContext: null, attrsProxy: null, slotsProxy: null, suspense: i3, suspenseId: i3 ? i3.pendingId : 0, asyncDep: null, asyncResolved: false, isMounted: false, isUnmounted: false, isDeactivated: false, bc: null, c: null, bm: null, m: null, bu: null, u: null, um: null, bum: null, da: null, a: null, rtg: null, rtc: null, ec: null, sp: null };
        return s3.ctx = { _: s3 }, s3.root = n3 ? n3.root : s3, s3.emit = emit.bind(null, s3), t3.ce && t3.ce(s3), s3;
      }
      let nt2 = null;
      const getCurrentInstance2 = () => nt2 || u2;
      let it2, ot2, at2 = "__VUE_INSTANCE_SETTERS__";
      (ot2 = r2.getGlobalThis()[at2]) || (ot2 = r2.getGlobalThis()[at2] = []), ot2.push((t3) => nt2 = t3), it2 = (t3) => {
        ot2.length > 1 ? ot2.forEach((e3) => e3(t3)) : ot2[0](t3);
      };
      const setCurrentInstance = (t3) => {
        it2(t3), t3.scope.on();
      }, unsetCurrentInstance = () => {
        nt2 && nt2.scope.off(), it2(null);
      };
      function isStatefulComponent(t3) {
        return 4 & t3.vnode.shapeFlag;
      }
      let st2, lt2, pt2 = false;
      function setupComponent(t3, n3 = false) {
        pt2 = n3;
        const { props: i3, children: o3 } = t3.vnode, a3 = isStatefulComponent(t3);
        !function(t4, n4, i4, o4 = false) {
          const a4 = {}, s4 = {};
          r2.def(s4, tt2, 1), t4.propsDefaults = /* @__PURE__ */ Object.create(null), setFullProps(t4, n4, a4, s4);
          for (const e3 in t4.propsOptions[0])
            e3 in a4 || (a4[e3] = void 0);
          i4 ? t4.props = o4 ? a4 : e2.shallowReactive(a4) : t4.type.props ? t4.props = a4 : t4.props = s4, t4.attrs = s4;
        }(t3, i3, a3, n3), initSlots(t3, o3);
        const s3 = a3 ? function(t4, n4) {
          const i4 = t4.type;
          t4.accessCache = /* @__PURE__ */ Object.create(null), t4.proxy = e2.markRaw(new Proxy(t4.ctx, D2));
          const { setup: o4 } = i4;
          if (o4) {
            const i5 = t4.setupContext = o4.length > 1 ? createSetupContext(t4) : null;
            setCurrentInstance(t4), e2.pauseTracking();
            const a4 = callWithErrorHandling(o4, t4, 0, [t4.props, i5]);
            if (e2.resetTracking(), unsetCurrentInstance(), r2.isPromise(a4)) {
              if (a4.then(unsetCurrentInstance, unsetCurrentInstance), n4)
                return a4.then((e3) => {
                  handleSetupResult(t4, e3, n4);
                }).catch((e3) => {
                  handleError(e3, t4, 0);
                });
              t4.asyncDep = a4;
            } else
              handleSetupResult(t4, a4, n4);
          } else
            finishComponentSetup(t4, n4);
        }(t3, n3) : void 0;
        return pt2 = false, s3;
      }
      function handleSetupResult(t3, n3, i3) {
        r2.isFunction(n3) ? t3.type.__ssrInlineRender ? t3.ssrRender = n3 : t3.render = n3 : r2.isObject(n3) && (t3.setupState = e2.proxyRefs(n3)), finishComponentSetup(t3, i3);
      }
      function finishComponentSetup(t3, n3, i3) {
        const o3 = t3.type;
        if (!t3.render) {
          if (!n3 && st2 && !o3.render) {
            const e3 = o3.template || resolveMergedOptions(t3).template;
            if (e3) {
              const { isCustomElement: n4, compilerOptions: i4 } = t3.appContext.config, { delimiters: a3, compilerOptions: s3 } = o3, l3 = r2.extend(r2.extend({ isCustomElement: n4, delimiters: a3 }, i4), s3);
              o3.render = st2(e3, l3);
            }
          }
          t3.render = o3.render || r2.NOOP, lt2 && lt2(t3);
        }
        setCurrentInstance(t3), e2.pauseTracking();
        try {
          applyOptions(t3);
        } finally {
          e2.resetTracking(), unsetCurrentInstance();
        }
      }
      function createSetupContext(t3) {
        const expose = (e3) => {
          t3.exposed = e3 || {};
        };
        return { get attrs() {
          return function(t4) {
            return t4.attrsProxy || (t4.attrsProxy = new Proxy(t4.attrs, { get: (r3, n3) => (e2.track(t4, "get", "$attrs"), r3[n3]) }));
          }(t3);
        }, slots: t3.slots, emit: t3.emit, expose };
      }
      function getExposeProxy(t3) {
        if (t3.exposed)
          return t3.exposeProxy || (t3.exposeProxy = new Proxy(e2.proxyRefs(e2.markRaw(t3.exposed)), { get: (e3, r3) => r3 in e3 ? e3[r3] : r3 in B2 ? B2[r3](t3) : void 0, has: (t4, e3) => e3 in t4 || e3 in B2 }));
      }
      function getComponentName(t3, e3 = true) {
        return r2.isFunction(t3) ? t3.displayName || t3.name : t3.name || e3 && t3.__name;
      }
      const computed = (t3, r3) => e2.computed(t3, r3, pt2);
      const ct2 = Symbol.for("v-scx"), useSSRContext = () => inject2(ct2);
      function isMemoSame(t3, e3) {
        const n3 = t3.memo;
        if (n3.length != e3.length)
          return false;
        for (let t4 = 0; t4 < n3.length; t4++)
          if (r2.hasChanged(n3[t4], e3[t4]))
            return false;
        return Z2 > 0 && Q2 && Q2.push(t3), true;
      }
      const dt2 = "3.3.12", mt2 = { createComponentInstance, setupComponent, renderComponentRoot, setCurrentRenderingInstance, isVNode, normalizeVNode };
      t2.EffectScope = e2.EffectScope, t2.ReactiveEffect = e2.ReactiveEffect, t2.customRef = e2.customRef, t2.effect = e2.effect, t2.effectScope = e2.effectScope, t2.getCurrentScope = e2.getCurrentScope, t2.isProxy = e2.isProxy, t2.isReactive = e2.isReactive, t2.isReadonly = e2.isReadonly, t2.isRef = e2.isRef, t2.isShallow = e2.isShallow, t2.markRaw = e2.markRaw, t2.onScopeDispose = e2.onScopeDispose, t2.proxyRefs = e2.proxyRefs, t2.reactive = e2.reactive, t2.readonly = e2.readonly, t2.ref = e2.ref, t2.shallowReactive = e2.shallowReactive, t2.shallowReadonly = e2.shallowReadonly, t2.shallowRef = e2.shallowRef, t2.stop = e2.stop, t2.toRaw = e2.toRaw, t2.toRef = e2.toRef, t2.toRefs = e2.toRefs, t2.toValue = e2.toValue, t2.triggerRef = e2.triggerRef, t2.unref = e2.unref, t2.camelize = r2.camelize, t2.capitalize = r2.capitalize, t2.normalizeClass = r2.normalizeClass, t2.normalizeProps = r2.normalizeProps, t2.normalizeStyle = r2.normalizeStyle, t2.toDisplayString = r2.toDisplayString, t2.toHandlerKey = r2.toHandlerKey, t2.BaseTransition = C2, t2.BaseTransitionPropsValidators = S2, t2.Comment = J2, t2.Fragment = K2, t2.KeepAlive = _2, t2.Static = Y2, t2.Suspense = v2, t2.Teleport = W2, t2.Text = G2, t2.assertNumber = function(t3, e3) {
      }, t2.callWithAsyncErrorHandling = callWithAsyncErrorHandling, t2.callWithErrorHandling = callWithErrorHandling, t2.cloneVNode = cloneVNode, t2.compatUtils = null, t2.computed = computed, t2.createBlock = createBlock, t2.createCommentVNode = function(t3 = "", e3 = false) {
        return e3 ? (openBlock(), createBlock(J2, null, t3)) : createVNode(J2, null, t3);
      }, t2.createElementBlock = function(t3, e3, r3, n3, i3, o3) {
        return setupBlock(createBaseVNode(t3, e3, r3, n3, i3, o3, true));
      }, t2.createElementVNode = createBaseVNode, t2.createHydrationRenderer = function(t3) {
        return baseCreateRenderer(t3, createHydrationFunctions);
      }, t2.createPropsRestProxy = function(t3, e3) {
        const r3 = {};
        for (const n3 in t3)
          e3.includes(n3) || Object.defineProperty(r3, n3, { enumerable: true, get: () => t3[n3] });
        return r3;
      }, t2.createRenderer = function(t3) {
        return baseCreateRenderer(t3);
      }, t2.createSlots = function(t3, e3) {
        for (let n3 = 0; n3 < e3.length; n3++) {
          const i3 = e3[n3];
          if (r2.isArray(i3))
            for (let e4 = 0; e4 < i3.length; e4++)
              t3[i3[e4].name] = i3[e4].fn;
          else
            i3 && (t3[i3.name] = i3.key ? (...t4) => {
              const e4 = i3.fn(...t4);
              return e4 && (e4.key = i3.key), e4;
            } : i3.fn);
        }
        return t3;
      }, t2.createStaticVNode = function(t3, e3) {
        const r3 = createVNode(Y2, null, t3);
        return r3.staticCount = e3, r3;
      }, t2.createTextVNode = createTextVNode, t2.createVNode = createVNode, t2.defineAsyncComponent = function(t3) {
        r2.isFunction(t3) && (t3 = { loader: t3 });
        const { loader: n3, loadingComponent: i3, errorComponent: o3, delay: a3 = 200, timeout: s3, suspensible: l3 = true, onError: p3 } = t3;
        let c3, d3 = null, m3 = 0;
        const load = () => {
          let t4;
          return d3 || (t4 = d3 = n3().catch((t5) => {
            if (t5 = t5 instanceof Error ? t5 : new Error(String(t5)), p3)
              return new Promise((e3, r3) => {
                p3(t5, () => e3((m3++, d3 = null, load())), () => r3(t5), m3 + 1);
              });
            throw t5;
          }).then((e3) => t4 !== d3 && d3 ? d3 : (e3 && (e3.__esModule || "Module" === e3[Symbol.toStringTag]) && (e3 = e3.default), c3 = e3, e3)));
        };
        return defineComponent2({ name: "AsyncComponentWrapper", __asyncLoader: load, get __asyncResolved() {
          return c3;
        }, setup() {
          const t4 = nt2;
          if (c3)
            return () => createInnerComp(c3, t4);
          const onError = (e3) => {
            d3 = null, handleError(e3, t4, 13, !o3);
          };
          if (l3 && t4.suspense || pt2)
            return load().then((e3) => () => createInnerComp(e3, t4)).catch((t5) => (onError(t5), () => o3 ? createVNode(o3, { error: t5 }) : null));
          const r3 = e2.ref(false), n4 = e2.ref(), p4 = e2.ref(!!a3);
          return a3 && setTimeout(() => {
            p4.value = false;
          }, a3), null != s3 && setTimeout(() => {
            if (!r3.value && !n4.value) {
              const t5 = new Error(`Async component timed out after ${s3}ms.`);
              onError(t5), n4.value = t5;
            }
          }, s3), load().then(() => {
            r3.value = true, t4.parent && isKeepAlive(t4.parent.vnode) && queueJob(t4.parent.update);
          }).catch((t5) => {
            onError(t5), n4.value = t5;
          }), () => r3.value && c3 ? createInnerComp(c3, t4) : n4.value && o3 ? createVNode(o3, { error: n4.value }) : i3 && !p4.value ? createVNode(i3) : void 0;
        } });
      }, t2.defineComponent = defineComponent2, t2.defineEmits = function() {
        return null;
      }, t2.defineExpose = function(t3) {
      }, t2.defineModel = function() {
      }, t2.defineOptions = function(t3) {
      }, t2.defineProps = function() {
        return null;
      }, t2.defineSlots = function() {
        return null;
      }, t2.getCurrentInstance = getCurrentInstance2, t2.getTransitionRawChildren = getTransitionRawChildren, t2.guardReactiveProps = guardReactiveProps, t2.h = function(t3, e3, n3) {
        const i3 = arguments.length;
        return 2 === i3 ? r2.isObject(e3) && !r2.isArray(e3) ? isVNode(e3) ? createVNode(t3, null, [e3]) : createVNode(t3, e3) : createVNode(t3, null, e3) : (i3 > 3 ? n3 = Array.prototype.slice.call(arguments, 2) : 3 === i3 && isVNode(n3) && (n3 = [n3]), createVNode(t3, e3, n3));
      }, t2.handleError = handleError, t2.hasInjectionContext = function() {
        return !!(nt2 || u2 || z2);
      }, t2.initCustomFormatter = function() {
      }, t2.inject = inject2, t2.isMemoSame = isMemoSame, t2.isRuntimeOnly = () => !st2, t2.isVNode = isVNode, t2.mergeDefaults = function(t3, e3) {
        const n3 = normalizePropsOrEmits(t3);
        for (const t4 in e3) {
          if (t4.startsWith("__skip"))
            continue;
          let i3 = n3[t4];
          i3 ? r2.isArray(i3) || r2.isFunction(i3) ? i3 = n3[t4] = { type: i3, default: e3[t4] } : i3.default = e3[t4] : null === i3 && (i3 = n3[t4] = { default: e3[t4] }), i3 && e3[`__skip_${t4}`] && (i3.skipFactory = true);
        }
        return n3;
      }, t2.mergeModels = function(t3, e3) {
        return t3 && e3 ? r2.isArray(t3) && r2.isArray(e3) ? t3.concat(e3) : r2.extend({}, normalizePropsOrEmits(t3), normalizePropsOrEmits(e3)) : t3 || e3;
      }, t2.mergeProps = mergeProps, t2.nextTick = nextTick, t2.onActivated = onActivated, t2.onBeforeMount = P2, t2.onBeforeUnmount = N2, t2.onBeforeUpdate = A2, t2.onDeactivated = onDeactivated, t2.onErrorCaptured = onErrorCaptured, t2.onMounted = T2, t2.onRenderTracked = M2, t2.onRenderTriggered = L2, t2.onServerPrefetch = O2, t2.onUnmounted = R2, t2.onUpdated = I2, t2.openBlock = openBlock, t2.popScopeId = function() {
        h2 = null;
      }, t2.provide = provide, t2.pushScopeId = function(t3) {
        h2 = t3;
      }, t2.queuePostFlushCb = queuePostFlushCb, t2.registerRuntimeCompiler = function(t3) {
        st2 = t3, lt2 = (t4) => {
          t4.render._rc && (t4.withProxy = new Proxy(t4.ctx, j2));
        };
      }, t2.renderList = function(t3, e3, n3, i3) {
        let o3;
        const a3 = n3 && n3[i3];
        if (r2.isArray(t3) || r2.isString(t3)) {
          o3 = new Array(t3.length);
          for (let r3 = 0, n4 = t3.length; r3 < n4; r3++)
            o3[r3] = e3(t3[r3], r3, void 0, a3 && a3[r3]);
        } else if ("number" == typeof t3) {
          o3 = new Array(t3);
          for (let r3 = 0; r3 < t3; r3++)
            o3[r3] = e3(r3 + 1, r3, void 0, a3 && a3[r3]);
        } else if (r2.isObject(t3))
          if (t3[Symbol.iterator])
            o3 = Array.from(t3, (t4, r3) => e3(t4, r3, void 0, a3 && a3[r3]));
          else {
            const r3 = Object.keys(t3);
            o3 = new Array(r3.length);
            for (let n4 = 0, i4 = r3.length; n4 < i4; n4++) {
              const i5 = r3[n4];
              o3[n4] = e3(t3[i5], i5, n4, a3 && a3[n4]);
            }
          }
        else
          o3 = [];
        return n3 && (n3[i3] = o3), o3;
      }, t2.renderSlot = function(t3, e3, r3 = {}, n3, i3) {
        if (u2.isCE || u2.parent && isAsyncWrapper(u2.parent) && u2.parent.isCE)
          return "default" !== e3 && (r3.name = e3), createVNode("slot", r3, n3 && n3());
        let o3 = t3[e3];
        o3 && o3._c && (o3._d = false), openBlock();
        const a3 = o3 && ensureValidVNode(o3(r3)), s3 = createBlock(K2, { key: r3.key || a3 && a3.key || `_${e3}` }, a3 || (n3 ? n3() : []), a3 && 1 === t3._ ? 64 : -2);
        return !i3 && s3.scopeId && (s3.slotScopeIds = [s3.scopeId + "-s"]), o3 && o3._c && (o3._d = true), s3;
      }, t2.resolveComponent = function(t3, e3) {
        return resolveAsset(g2, t3, true, e3) || t3;
      }, t2.resolveDirective = function(t3) {
        return resolveAsset("directives", t3);
      }, t2.resolveDynamicComponent = function(t3) {
        return r2.isString(t3) ? resolveAsset(g2, t3, false) || t3 : t3 || x2;
      }, t2.resolveFilter = null, t2.resolveTransitionHooks = resolveTransitionHooks, t2.setBlockTracking = setBlockTracking, t2.setDevtoolsHook = function(e3, r3) {
        t2.devtools = e3, t2.devtools ? (t2.devtools.enabled = true, m2.forEach(({ event: e4, args: r4 }) => t2.devtools.emit(e4, ...r4)), m2 = []) : m2 = [];
      }, t2.setTransitionHooks = setTransitionHooks, t2.ssrContextKey = ct2, t2.ssrUtils = mt2, t2.toHandlers = function(t3, e3) {
        const n3 = {};
        for (const i3 in t3)
          n3[e3 && /[A-Z]/.test(i3) ? `on:${i3}` : r2.toHandlerKey(i3)] = t3[i3];
        return n3;
      }, t2.transformVNodeArgs = function(t3) {
      }, t2.useAttrs = function() {
        return getContext2().attrs;
      }, t2.useModel = function(t3, r3, n3) {
        const i3 = getCurrentInstance2();
        if (n3 && n3.local) {
          const n4 = e2.ref(t3[r3]);
          return watch2(() => t3[r3], (t4) => n4.value = t4), watch2(n4, (e3) => {
            e3 !== t3[r3] && i3.emit(`update:${r3}`, e3);
          }), n4;
        }
        return { __v_isRef: true, get value() {
          return t3[r3];
        }, set value(t4) {
          i3.emit(`update:${r3}`, t4);
        } };
      }, t2.useSSRContext = useSSRContext, t2.useSlots = function() {
        return getContext2().slots;
      }, t2.useTransitionState = useTransitionState, t2.version = dt2, t2.warn = function(t3, ...e3) {
      }, t2.watch = watch2, t2.watchEffect = function(t3, e3) {
        return doWatch(t3, null, e3);
      }, t2.watchPostEffect = function(t3, e3) {
        return doWatch(t3, null, { flush: "post" });
      }, t2.watchSyncEffect = function(t3, e3) {
        return doWatch(t3, null, { flush: "sync" });
      }, t2.withAsyncContext = function(t3) {
        const e3 = getCurrentInstance2();
        let n3 = t3();
        return unsetCurrentInstance(), r2.isPromise(n3) && (n3 = n3.catch((t4) => {
          throw setCurrentInstance(e3), t4;
        })), [n3, () => setCurrentInstance(e3)];
      }, t2.withCtx = withCtx, t2.withDefaults = function(t3, e3) {
        return null;
      }, t2.withDirectives = function(t3, e3) {
        const n3 = u2;
        if (null === n3)
          return t3;
        const i3 = getExposeProxy(n3) || n3.proxy, o3 = t3.dirs || (t3.dirs = []);
        for (let t4 = 0; t4 < e3.length; t4++) {
          let [n4, a3, s3, l3 = r2.EMPTY_OBJ] = e3[t4];
          n4 && (r2.isFunction(n4) && (n4 = { mounted: n4, updated: n4 }), n4.deep && traverse(a3), o3.push({ dir: n4, instance: i3, value: a3, oldValue: void 0, arg: s3, modifiers: l3 }));
        }
        return t3;
      }, t2.withMemo = function(t3, e3, r3, n3) {
        const i3 = r3[n3];
        if (i3 && isMemoSame(i3, t3))
          return i3;
        const o3 = e3();
        return o3.memo = t3.slice(), r3[n3] = o3;
      }, t2.withScopeId = (t3) => withCtx;
    }(Re), Ne.exports = Re;
    var Qr = Ne.exports;
    !function(t2) {
      Object.defineProperty(t2, "__esModule", { value: true });
      var e2 = Qr, r2 = gr;
      const n2 = "undefined" != typeof document ? document : null, i2 = n2 && n2.createElement("template"), o2 = { insert: (t3, e3, r3) => {
        e3.insertBefore(t3, r3 || null);
      }, remove: (t3) => {
        const e3 = t3.parentNode;
        e3 && e3.removeChild(t3);
      }, createElement: (t3, e3, r3, i3) => {
        const o3 = e3 ? n2.createElementNS("http://www.w3.org/2000/svg", t3) : n2.createElement(t3, r3 ? { is: r3 } : void 0);
        return "select" === t3 && i3 && null != i3.multiple && o3.setAttribute("multiple", i3.multiple), o3;
      }, createText: (t3) => n2.createTextNode(t3), createComment: (t3) => n2.createComment(t3), setText: (t3, e3) => {
        t3.nodeValue = e3;
      }, setElementText: (t3, e3) => {
        t3.textContent = e3;
      }, parentNode: (t3) => t3.parentNode, nextSibling: (t3) => t3.nextSibling, querySelector: (t3) => n2.querySelector(t3), setScopeId(t3, e3) {
        t3.setAttribute(e3, "");
      }, insertStaticContent(t3, e3, r3, n3, o3, a3) {
        const s3 = r3 ? r3.previousSibling : e3.lastChild;
        if (o3 && (o3 === a3 || o3.nextSibling))
          for (; e3.insertBefore(o3.cloneNode(true), r3), o3 !== a3 && (o3 = o3.nextSibling); )
            ;
        else {
          i2.innerHTML = n3 ? `<svg>${t3}</svg>` : t3;
          const o4 = i2.content;
          if (n3) {
            const t4 = o4.firstChild;
            for (; t4.firstChild; )
              o4.appendChild(t4.firstChild);
            o4.removeChild(t4);
          }
          e3.insertBefore(o4, r3);
        }
        return [s3 ? s3.nextSibling : e3.firstChild, r3 ? r3.previousSibling : e3.lastChild];
      } }, a2 = "transition", s2 = "animation", l2 = Symbol("_vtc"), Transition = (t3, { slots: r3 }) => e2.h(e2.BaseTransition, resolveTransitionProps(t3), r3);
      Transition.displayName = "Transition";
      const p2 = { name: String, type: String, css: { type: Boolean, default: true }, duration: [String, Number, Object], enterFromClass: String, enterActiveClass: String, enterToClass: String, appearFromClass: String, appearActiveClass: String, appearToClass: String, leaveFromClass: String, leaveActiveClass: String, leaveToClass: String }, c2 = Transition.props = r2.extend({}, e2.BaseTransitionPropsValidators, p2), callHook = (t3, e3 = []) => {
        r2.isArray(t3) ? t3.forEach((t4) => t4(...e3)) : t3 && t3(...e3);
      }, hasExplicitCallback = (t3) => !!t3 && (r2.isArray(t3) ? t3.some((t4) => t4.length > 1) : t3.length > 1);
      function resolveTransitionProps(t3) {
        const e3 = {};
        for (const r3 in t3)
          r3 in p2 || (e3[r3] = t3[r3]);
        if (false === t3.css)
          return e3;
        const { name: n3 = "v", type: i3, duration: o3, enterFromClass: a3 = `${n3}-enter-from`, enterActiveClass: s3 = `${n3}-enter-active`, enterToClass: l3 = `${n3}-enter-to`, appearFromClass: c3 = a3, appearActiveClass: d3 = s3, appearToClass: m3 = l3, leaveFromClass: u3 = `${n3}-leave-from`, leaveActiveClass: h3 = `${n3}-leave-active`, leaveToClass: g3 = `${n3}-leave-to` } = t3, x3 = function(t4) {
          if (null == t4)
            return null;
          if (r2.isObject(t4))
            return [NumberOf(t4.enter), NumberOf(t4.leave)];
          {
            const e4 = NumberOf(t4);
            return [e4, e4];
          }
        }(o3), v3 = x3 && x3[0], y3 = x3 && x3[1], { onBeforeEnter: b3, onEnter: w3, onEnterCancelled: k3, onLeave: S3, onLeaveCancelled: C3, onBeforeAppear: _3 = b3, onAppear: P3 = w3, onAppearCancelled: T3 = k3 } = e3, finishEnter = (t4, e4, r3) => {
          removeTransitionClass(t4, e4 ? m3 : l3), removeTransitionClass(t4, e4 ? d3 : s3), r3 && r3();
        }, finishLeave = (t4, e4) => {
          t4._isLeaving = false, removeTransitionClass(t4, u3), removeTransitionClass(t4, g3), removeTransitionClass(t4, h3), e4 && e4();
        }, makeEnterHook = (t4) => (e4, r3) => {
          const n4 = t4 ? P3 : w3, resolve = () => finishEnter(e4, t4, r3);
          callHook(n4, [e4, resolve]), nextFrame(() => {
            removeTransitionClass(e4, t4 ? c3 : a3), addTransitionClass(e4, t4 ? m3 : l3), hasExplicitCallback(n4) || whenTransitionEnds(e4, i3, v3, resolve);
          });
        };
        return r2.extend(e3, { onBeforeEnter(t4) {
          callHook(b3, [t4]), addTransitionClass(t4, a3), addTransitionClass(t4, s3);
        }, onBeforeAppear(t4) {
          callHook(_3, [t4]), addTransitionClass(t4, c3), addTransitionClass(t4, d3);
        }, onEnter: makeEnterHook(false), onAppear: makeEnterHook(true), onLeave(t4, e4) {
          t4._isLeaving = true;
          const resolve = () => finishLeave(t4, e4);
          addTransitionClass(t4, u3), forceReflow(), addTransitionClass(t4, h3), nextFrame(() => {
            t4._isLeaving && (removeTransitionClass(t4, u3), addTransitionClass(t4, g3), hasExplicitCallback(S3) || whenTransitionEnds(t4, i3, y3, resolve));
          }), callHook(S3, [t4, resolve]);
        }, onEnterCancelled(t4) {
          finishEnter(t4, false), callHook(k3, [t4]);
        }, onAppearCancelled(t4) {
          finishEnter(t4, true), callHook(T3, [t4]);
        }, onLeaveCancelled(t4) {
          finishLeave(t4), callHook(C3, [t4]);
        } });
      }
      function NumberOf(t3) {
        return r2.toNumber(t3);
      }
      function addTransitionClass(t3, e3) {
        e3.split(/\s+/).forEach((e4) => e4 && t3.classList.add(e4)), (t3[l2] || (t3[l2] = /* @__PURE__ */ new Set())).add(e3);
      }
      function removeTransitionClass(t3, e3) {
        e3.split(/\s+/).forEach((e4) => e4 && t3.classList.remove(e4));
        const r3 = t3[l2];
        r3 && (r3.delete(e3), r3.size || (t3[l2] = void 0));
      }
      function nextFrame(t3) {
        requestAnimationFrame(() => {
          requestAnimationFrame(t3);
        });
      }
      let d2 = 0;
      function whenTransitionEnds(t3, e3, r3, n3) {
        const i3 = t3._endId = ++d2, resolveIfNotStale = () => {
          i3 === t3._endId && n3();
        };
        if (r3)
          return setTimeout(resolveIfNotStale, r3);
        const { type: o3, timeout: a3, propCount: s3 } = getTransitionInfo(t3, e3);
        if (!o3)
          return n3();
        const l3 = o3 + "end";
        let p3 = 0;
        const end = () => {
          t3.removeEventListener(l3, onEnd), resolveIfNotStale();
        }, onEnd = (e4) => {
          e4.target === t3 && ++p3 >= s3 && end();
        };
        setTimeout(() => {
          p3 < s3 && end();
        }, a3 + 1), t3.addEventListener(l3, onEnd);
      }
      function getTransitionInfo(t3, e3) {
        const r3 = window.getComputedStyle(t3), getStyleProperties = (t4) => (r3[t4] || "").split(", "), n3 = getStyleProperties(`${a2}Delay`), i3 = getStyleProperties(`${a2}Duration`), o3 = getTimeout(n3, i3), l3 = getStyleProperties(`${s2}Delay`), p3 = getStyleProperties(`${s2}Duration`), c3 = getTimeout(l3, p3);
        let d3 = null, m3 = 0, u3 = 0;
        e3 === a2 ? o3 > 0 && (d3 = a2, m3 = o3, u3 = i3.length) : e3 === s2 ? c3 > 0 && (d3 = s2, m3 = c3, u3 = p3.length) : (m3 = Math.max(o3, c3), d3 = m3 > 0 ? o3 > c3 ? a2 : s2 : null, u3 = d3 ? d3 === a2 ? i3.length : p3.length : 0);
        return { type: d3, timeout: m3, propCount: u3, hasTransform: d3 === a2 && /\b(transform|all)(,|$)/.test(getStyleProperties(`${a2}Property`).toString()) };
      }
      function getTimeout(t3, e3) {
        for (; t3.length < e3.length; )
          t3 = t3.concat(t3);
        return Math.max(...e3.map((e4, r3) => toMs(e4) + toMs(t3[r3])));
      }
      function toMs(t3) {
        return "auto" === t3 ? 0 : 1e3 * Number(t3.slice(0, -1).replace(",", "."));
      }
      function forceReflow() {
        return document.body.offsetHeight;
      }
      const m2 = Symbol("_vod"), u2 = { beforeMount(t3, { value: e3 }, { transition: r3 }) {
        t3[m2] = "none" === t3.style.display ? "" : t3.style.display, r3 && e3 ? r3.beforeEnter(t3) : setDisplay(t3, e3);
      }, mounted(t3, { value: e3 }, { transition: r3 }) {
        r3 && e3 && r3.enter(t3);
      }, updated(t3, { value: e3, oldValue: r3 }, { transition: n3 }) {
        !e3 != !r3 && (n3 ? e3 ? (n3.beforeEnter(t3), setDisplay(t3, true), n3.enter(t3)) : n3.leave(t3, () => {
          setDisplay(t3, false);
        }) : setDisplay(t3, e3));
      }, beforeUnmount(t3, { value: e3 }) {
        setDisplay(t3, e3);
      } };
      function setDisplay(t3, e3) {
        t3.style.display = e3 ? t3[m2] : "none";
      }
      const h2 = Symbol("");
      const g2 = /\s*!important$/;
      function setStyle(t3, n3, i3) {
        if (r2.isArray(i3))
          i3.forEach((e3) => setStyle(t3, n3, e3));
        else if (null == i3 && (i3 = ""), n3.startsWith("--"))
          t3.setProperty(n3, i3);
        else {
          const o3 = function(t4, n4) {
            const i4 = v2[n4];
            if (i4)
              return i4;
            let o4 = e2.camelize(n4);
            if ("filter" !== o4 && o4 in t4)
              return v2[n4] = o4;
            o4 = r2.capitalize(o4);
            for (let e3 = 0; e3 < x2.length; e3++) {
              const r3 = x2[e3] + o4;
              if (r3 in t4)
                return v2[n4] = r3;
            }
            return n4;
          }(t3, n3);
          g2.test(i3) ? t3.setProperty(r2.hyphenate(o3), i3.replace(g2, ""), "important") : t3[o3] = i3;
        }
      }
      const x2 = ["Webkit", "Moz", "ms"], v2 = {};
      const y2 = "http://www.w3.org/1999/xlink";
      function addEventListener2(t3, e3, r3, n3) {
        t3.addEventListener(e3, r3, n3);
      }
      const b2 = Symbol("_vei");
      function patchEvent(t3, n3, i3, o3, a3 = null) {
        const s3 = t3[b2] || (t3[b2] = {}), l3 = s3[n3];
        if (o3 && l3)
          l3.value = o3;
        else {
          const [i4, p3] = function(t4) {
            let e3;
            if (w2.test(t4)) {
              let r3;
              for (e3 = {}; r3 = t4.match(w2); )
                t4 = t4.slice(0, t4.length - r3[0].length), e3[r3[0].toLowerCase()] = true;
            }
            const n4 = ":" === t4[2] ? t4.slice(3) : r2.hyphenate(t4.slice(2));
            return [n4, e3];
          }(n3);
          if (o3) {
            const l4 = s3[n3] = function(t4, n4) {
              const invoker = (t5) => {
                if (t5._vts) {
                  if (t5._vts <= invoker.attached)
                    return;
                } else
                  t5._vts = Date.now();
                e2.callWithAsyncErrorHandling(function(t6, e3) {
                  if (r2.isArray(e3)) {
                    const r3 = t6.stopImmediatePropagation;
                    return t6.stopImmediatePropagation = () => {
                      r3.call(t6), t6._stopped = true;
                    }, e3.map((t7) => (e4) => !e4._stopped && t7 && t7(e4));
                  }
                  return e3;
                }(t5, invoker.value), n4, 5, [t5]);
              };
              return invoker.value = t4, invoker.attached = getNow(), invoker;
            }(o3, a3);
            addEventListener2(t3, i4, l4, p3);
          } else
            l3 && (!function(t4, e3, r3, n4) {
              t4.removeEventListener(e3, r3, n4);
            }(t3, i4, l3, p3), s3[n3] = void 0);
        }
      }
      const w2 = /(?:Once|Passive|Capture)$/;
      let k2 = 0;
      const S2 = Promise.resolve(), getNow = () => k2 || (S2.then(() => k2 = 0), k2 = Date.now());
      const isNativeOn = (t3) => 111 === t3.charCodeAt(0) && 110 === t3.charCodeAt(1) && t3.charCodeAt(2) > 96 && t3.charCodeAt(2) < 123;
      function defineCustomElement(t3, r3) {
        const n3 = e2.defineComponent(t3);
        class VueCustomElement extends VueElement {
          constructor(t4) {
            super(n3, t4, r3);
          }
        }
        return VueCustomElement.def = n3, VueCustomElement;
      }
      const C2 = "undefined" != typeof HTMLElement ? HTMLElement : class {
      };
      class VueElement extends C2 {
        constructor(t3, e3 = {}, r3) {
          super(), this._def = t3, this._props = e3, this._instance = null, this._connected = false, this._resolved = false, this._numberProps = null, this._ob = null, this.shadowRoot && r3 ? r3(this._createVNode(), this.shadowRoot) : (this.attachShadow({ mode: "open" }), this._def.__asyncLoader || this._resolveProps(this._def));
        }
        connectedCallback() {
          this._connected = true, this._instance || (this._resolved ? this._update() : this._resolveDef());
        }
        disconnectedCallback() {
          this._connected = false, this._ob && (this._ob.disconnect(), this._ob = null), e2.nextTick(() => {
            this._connected || (render(null, this.shadowRoot), this._instance = null);
          });
        }
        _resolveDef() {
          this._resolved = true;
          for (let t4 = 0; t4 < this.attributes.length; t4++)
            this._setAttr(this.attributes[t4].name);
          this._ob = new MutationObserver((t4) => {
            for (const e3 of t4)
              this._setAttr(e3.attributeName);
          }), this._ob.observe(this, { attributes: true });
          const resolve = (t4, e3 = false) => {
            const { props: n3, styles: i3 } = t4;
            let o3;
            if (n3 && !r2.isArray(n3))
              for (const t5 in n3) {
                const e4 = n3[t5];
                (e4 === Number || e4 && e4.type === Number) && (t5 in this._props && (this._props[t5] = r2.toNumber(this._props[t5])), (o3 || (o3 = /* @__PURE__ */ Object.create(null)))[r2.camelize(t5)] = true);
              }
            this._numberProps = o3, e3 && this._resolveProps(t4), this._applyStyles(i3), this._update();
          }, t3 = this._def.__asyncLoader;
          t3 ? t3().then((t4) => resolve(t4, true)) : resolve(this._def);
        }
        _resolveProps(t3) {
          const { props: e3 } = t3, n3 = r2.isArray(e3) ? e3 : Object.keys(e3 || {});
          for (const t4 of Object.keys(this))
            "_" !== t4[0] && n3.includes(t4) && this._setProp(t4, this[t4], true, false);
          for (const t4 of n3.map(r2.camelize))
            Object.defineProperty(this, t4, { get() {
              return this._getProp(t4);
            }, set(e4) {
              this._setProp(t4, e4);
            } });
        }
        _setAttr(t3) {
          let e3 = this.getAttribute(t3);
          const n3 = r2.camelize(t3);
          this._numberProps && this._numberProps[n3] && (e3 = r2.toNumber(e3)), this._setProp(n3, e3, false);
        }
        _getProp(t3) {
          return this._props[t3];
        }
        _setProp(t3, e3, n3 = true, i3 = true) {
          e3 !== this._props[t3] && (this._props[t3] = e3, i3 && this._instance && this._update(), n3 && (true === e3 ? this.setAttribute(r2.hyphenate(t3), "") : "string" == typeof e3 || "number" == typeof e3 ? this.setAttribute(r2.hyphenate(t3), e3 + "") : e3 || this.removeAttribute(r2.hyphenate(t3))));
        }
        _update() {
          render(this._createVNode(), this.shadowRoot);
        }
        _createVNode() {
          const t3 = e2.createVNode(this._def, r2.extend({}, this._props));
          return this._instance || (t3.ce = (t4) => {
            this._instance = t4, t4.isCE = true;
            const dispatch = (t5, e4) => {
              this.dispatchEvent(new CustomEvent(t5, { detail: e4 }));
            };
            t4.emit = (t5, ...e4) => {
              dispatch(t5, e4), r2.hyphenate(t5) !== t5 && dispatch(r2.hyphenate(t5), e4);
            };
            let e3 = this;
            for (; e3 = e3 && (e3.parentNode || e3.host); )
              if (e3 instanceof VueElement) {
                t4.parent = e3._instance, t4.provides = e3._instance.provides;
                break;
              }
          }), t3;
        }
        _applyStyles(t3) {
          t3 && t3.forEach((t4) => {
            const e3 = document.createElement("style");
            e3.textContent = t4, this.shadowRoot.appendChild(e3);
          });
        }
      }
      const _2 = /* @__PURE__ */ new WeakMap(), P2 = /* @__PURE__ */ new WeakMap(), T2 = Symbol("_moveCb"), A2 = Symbol("_enterCb"), I2 = { name: "TransitionGroup", props: r2.extend({}, c2, { tag: String, moveClass: String }), setup(t3, { slots: r3 }) {
        const n3 = e2.getCurrentInstance(), i3 = e2.useTransitionState();
        let o3, a3;
        return e2.onUpdated(() => {
          if (!o3.length)
            return;
          const e3 = t3.moveClass || `${t3.name || "v"}-move`;
          if (!function(t4, e4, r5) {
            const n4 = t4.cloneNode(), i4 = t4[l2];
            i4 && i4.forEach((t5) => {
              t5.split(/\s+/).forEach((t6) => t6 && n4.classList.remove(t6));
            });
            r5.split(/\s+/).forEach((t5) => t5 && n4.classList.add(t5)), n4.style.display = "none";
            const o4 = 1 === e4.nodeType ? e4 : e4.parentNode;
            o4.appendChild(n4);
            const { hasTransform: a4 } = getTransitionInfo(n4);
            return o4.removeChild(n4), a4;
          }(o3[0].el, n3.vnode.el, e3))
            return;
          o3.forEach(callPendingCbs), o3.forEach(recordPosition);
          const r4 = o3.filter(applyTranslation);
          forceReflow(), r4.forEach((t4) => {
            const r5 = t4.el, n4 = r5.style;
            addTransitionClass(r5, e3), n4.transform = n4.webkitTransform = n4.transitionDuration = "";
            const i4 = r5[T2] = (t5) => {
              t5 && t5.target !== r5 || t5 && !/transform$/.test(t5.propertyName) || (r5.removeEventListener("transitionend", i4), r5[T2] = null, removeTransitionClass(r5, e3));
            };
            r5.addEventListener("transitionend", i4);
          });
        }), () => {
          const s3 = e2.toRaw(t3), l3 = resolveTransitionProps(s3);
          let p3 = s3.tag || e2.Fragment;
          o3 = a3, a3 = r3.default ? e2.getTransitionRawChildren(r3.default()) : [];
          for (let t4 = 0; t4 < a3.length; t4++) {
            const r4 = a3[t4];
            null != r4.key && e2.setTransitionHooks(r4, e2.resolveTransitionHooks(r4, l3, i3, n3));
          }
          if (o3)
            for (let t4 = 0; t4 < o3.length; t4++) {
              const r4 = o3[t4];
              e2.setTransitionHooks(r4, e2.resolveTransitionHooks(r4, l3, i3, n3)), _2.set(r4, r4.el.getBoundingClientRect());
            }
          return e2.createVNode(p3, null, a3);
        };
      } }, N2 = I2;
      function callPendingCbs(t3) {
        const e3 = t3.el;
        e3[T2] && e3[T2](), e3[A2] && e3[A2]();
      }
      function recordPosition(t3) {
        P2.set(t3, t3.el.getBoundingClientRect());
      }
      function applyTranslation(t3) {
        const e3 = _2.get(t3), r3 = P2.get(t3), n3 = e3.left - r3.left, i3 = e3.top - r3.top;
        if (n3 || i3) {
          const e4 = t3.el.style;
          return e4.transform = e4.webkitTransform = `translate(${n3}px,${i3}px)`, e4.transitionDuration = "0s", t3;
        }
      }
      const getModelAssigner = (t3) => {
        const e3 = t3.props["onUpdate:modelValue"] || false;
        return r2.isArray(e3) ? (t4) => r2.invokeArrayFns(e3, t4) : e3;
      };
      function onCompositionStart(t3) {
        t3.target.composing = true;
      }
      function onCompositionEnd(t3) {
        const e3 = t3.target;
        e3.composing && (e3.composing = false, e3.dispatchEvent(new Event("input")));
      }
      const R2 = Symbol("_assign"), O2 = { created(t3, { modifiers: { lazy: e3, trim: n3, number: i3 } }, o3) {
        t3[R2] = getModelAssigner(o3);
        const a3 = i3 || o3.props && "number" === o3.props.type;
        addEventListener2(t3, e3 ? "change" : "input", (e4) => {
          if (e4.target.composing)
            return;
          let i4 = t3.value;
          n3 && (i4 = i4.trim()), a3 && (i4 = r2.looseToNumber(i4)), t3[R2](i4);
        }), n3 && addEventListener2(t3, "change", () => {
          t3.value = t3.value.trim();
        }), e3 || (addEventListener2(t3, "compositionstart", onCompositionStart), addEventListener2(t3, "compositionend", onCompositionEnd), addEventListener2(t3, "change", onCompositionEnd));
      }, mounted(t3, { value: e3 }) {
        t3.value = null == e3 ? "" : e3;
      }, beforeUpdate(t3, { value: e3, modifiers: { lazy: n3, trim: i3, number: o3 } }, a3) {
        if (t3[R2] = getModelAssigner(a3), t3.composing)
          return;
        const s3 = null == e3 ? "" : e3;
        if ((o3 || "number" === t3.type ? r2.looseToNumber(t3.value) : t3.value) !== s3) {
          if (document.activeElement === t3 && "range" !== t3.type) {
            if (n3)
              return;
            if (i3 && t3.value.trim() === s3)
              return;
          }
          t3.value = s3;
        }
      } }, L2 = { deep: true, created(t3, e3, n3) {
        t3[R2] = getModelAssigner(n3), addEventListener2(t3, "change", () => {
          const e4 = t3._modelValue, n4 = getValue(t3), i3 = t3.checked, o3 = t3[R2];
          if (r2.isArray(e4)) {
            const t4 = r2.looseIndexOf(e4, n4), a3 = -1 !== t4;
            if (i3 && !a3)
              o3(e4.concat(n4));
            else if (!i3 && a3) {
              const r3 = [...e4];
              r3.splice(t4, 1), o3(r3);
            }
          } else if (r2.isSet(e4)) {
            const t4 = new Set(e4);
            i3 ? t4.add(n4) : t4.delete(n4), o3(t4);
          } else
            o3(getCheckboxValue(t3, i3));
        });
      }, mounted: setChecked, beforeUpdate(t3, e3, r3) {
        t3[R2] = getModelAssigner(r3), setChecked(t3, e3, r3);
      } };
      function setChecked(t3, { value: e3, oldValue: n3 }, i3) {
        t3._modelValue = e3, r2.isArray(e3) ? t3.checked = r2.looseIndexOf(e3, i3.props.value) > -1 : r2.isSet(e3) ? t3.checked = e3.has(i3.props.value) : e3 !== n3 && (t3.checked = r2.looseEqual(e3, getCheckboxValue(t3, true)));
      }
      const M2 = { created(t3, { value: e3 }, n3) {
        t3.checked = r2.looseEqual(e3, n3.props.value), t3[R2] = getModelAssigner(n3), addEventListener2(t3, "change", () => {
          t3[R2](getValue(t3));
        });
      }, beforeUpdate(t3, { value: e3, oldValue: n3 }, i3) {
        t3[R2] = getModelAssigner(i3), e3 !== n3 && (t3.checked = r2.looseEqual(e3, i3.props.value));
      } }, B2 = { deep: true, created(t3, { value: e3, modifiers: { number: n3 } }, i3) {
        const o3 = r2.isSet(e3);
        addEventListener2(t3, "change", () => {
          const e4 = Array.prototype.filter.call(t3.options, (t4) => t4.selected).map((t4) => n3 ? r2.looseToNumber(getValue(t4)) : getValue(t4));
          t3[R2](t3.multiple ? o3 ? new Set(e4) : e4 : e4[0]);
        }), t3[R2] = getModelAssigner(i3);
      }, mounted(t3, { value: e3 }) {
        setSelected(t3, e3);
      }, beforeUpdate(t3, e3, r3) {
        t3[R2] = getModelAssigner(r3);
      }, updated(t3, { value: e3 }) {
        setSelected(t3, e3);
      } };
      function setSelected(t3, e3) {
        const n3 = t3.multiple;
        if (!n3 || r2.isArray(e3) || r2.isSet(e3)) {
          for (let i3 = 0, o3 = t3.options.length; i3 < o3; i3++) {
            const o4 = t3.options[i3], a3 = getValue(o4);
            if (n3)
              r2.isArray(e3) ? o4.selected = r2.looseIndexOf(e3, a3) > -1 : o4.selected = e3.has(a3);
            else if (r2.looseEqual(getValue(o4), e3))
              return void (t3.selectedIndex !== i3 && (t3.selectedIndex = i3));
          }
          n3 || -1 === t3.selectedIndex || (t3.selectedIndex = -1);
        }
      }
      function getValue(t3) {
        return "_value" in t3 ? t3._value : t3.value;
      }
      function getCheckboxValue(t3, e3) {
        const r3 = e3 ? "_trueValue" : "_falseValue";
        return r3 in t3 ? t3[r3] : e3;
      }
      const D2 = { created(t3, e3, r3) {
        callModelHook(t3, e3, r3, null, "created");
      }, mounted(t3, e3, r3) {
        callModelHook(t3, e3, r3, null, "mounted");
      }, beforeUpdate(t3, e3, r3, n3) {
        callModelHook(t3, e3, r3, n3, "beforeUpdate");
      }, updated(t3, e3, r3, n3) {
        callModelHook(t3, e3, r3, n3, "updated");
      } };
      function resolveDynamicModel(t3, e3) {
        switch (t3) {
          case "SELECT":
            return B2;
          case "TEXTAREA":
            return O2;
          default:
            switch (e3) {
              case "checkbox":
                return L2;
              case "radio":
                return M2;
              default:
                return O2;
            }
        }
      }
      function callModelHook(t3, e3, r3, n3, i3) {
        const o3 = resolveDynamicModel(t3.tagName, r3.props && r3.props.type)[i3];
        o3 && o3(t3, e3, r3, n3);
      }
      const j2 = ["ctrl", "shift", "alt", "meta"], F2 = { stop: (t3) => t3.stopPropagation(), prevent: (t3) => t3.preventDefault(), self: (t3) => t3.target !== t3.currentTarget, ctrl: (t3) => !t3.ctrlKey, shift: (t3) => !t3.shiftKey, alt: (t3) => !t3.altKey, meta: (t3) => !t3.metaKey, left: (t3) => "button" in t3 && 0 !== t3.button, middle: (t3) => "button" in t3 && 1 !== t3.button, right: (t3) => "button" in t3 && 2 !== t3.button, exact: (t3, e3) => j2.some((r3) => t3[`${r3}Key`] && !e3.includes(r3)) }, $2 = { esc: "escape", space: " ", up: "arrow-up", left: "arrow-left", right: "arrow-right", down: "arrow-down", delete: "backspace" }, V2 = r2.extend({ patchProp: (t3, e3, n3, i3, o3 = false, a3, s3, p3, c3) => {
        "class" === e3 ? function(t4, e4, r3) {
          const n4 = t4[l2];
          n4 && (e4 = (e4 ? [e4, ...n4] : [...n4]).join(" ")), null == e4 ? t4.removeAttribute("class") : r3 ? t4.setAttribute("class", e4) : t4.className = e4;
        }(t3, i3, o3) : "style" === e3 ? function(t4, e4, n4) {
          const i4 = t4.style, o4 = r2.isString(n4);
          if (n4 && !o4) {
            if (e4 && !r2.isString(e4))
              for (const t5 in e4)
                null == n4[t5] && setStyle(i4, t5, "");
            for (const t5 in n4)
              setStyle(i4, t5, n4[t5]);
          } else {
            const r3 = i4.display;
            if (o4) {
              if (e4 !== n4) {
                const t5 = i4[h2];
                t5 && (n4 += ";" + t5), i4.cssText = n4;
              }
            } else
              e4 && t4.removeAttribute("style");
            m2 in t4 && (i4.display = r3);
          }
        }(t3, n3, i3) : r2.isOn(e3) ? r2.isModelListener(e3) || patchEvent(t3, e3, 0, i3, s3) : ("." === e3[0] ? (e3 = e3.slice(1), 1) : "^" === e3[0] ? (e3 = e3.slice(1), 0) : function(t4, e4, n4, i4) {
          if (i4)
            return "innerHTML" === e4 || "textContent" === e4 || !!(e4 in t4 && isNativeOn(e4) && r2.isFunction(n4));
          if ("spellcheck" === e4 || "draggable" === e4 || "translate" === e4)
            return false;
          if ("form" === e4)
            return false;
          if ("list" === e4 && "INPUT" === t4.tagName)
            return false;
          if ("type" === e4 && "TEXTAREA" === t4.tagName)
            return false;
          if ("width" === e4 || "height" === e4) {
            const e5 = t4.tagName;
            if ("IMG" === e5 || "VIDEO" === e5 || "CANVAS" === e5 || "SOURCE" === e5)
              return false;
          }
          if (isNativeOn(e4) && r2.isString(n4))
            return false;
          return e4 in t4;
        }(t3, e3, i3, o3)) ? function(t4, e4, n4, i4, o4, a4, s4) {
          if ("innerHTML" === e4 || "textContent" === e4)
            return i4 && s4(i4, o4, a4), void (t4[e4] = null == n4 ? "" : n4);
          const l3 = t4.tagName;
          if ("value" === e4 && "PROGRESS" !== l3 && !l3.includes("-")) {
            t4._value = n4;
            const r3 = null == n4 ? "" : n4;
            return ("OPTION" === l3 ? t4.getAttribute("value") : t4.value) !== r3 && (t4.value = r3), void (null == n4 && t4.removeAttribute(e4));
          }
          let p4 = false;
          if ("" === n4 || null == n4) {
            const i5 = typeof t4[e4];
            "boolean" === i5 ? n4 = r2.includeBooleanAttr(n4) : null == n4 && "string" === i5 ? (n4 = "", p4 = true) : "number" === i5 && (n4 = 0, p4 = true);
          }
          try {
            t4[e4] = n4;
          } catch (t5) {
          }
          p4 && t4.removeAttribute(e4);
        }(t3, e3, i3, a3, s3, p3, c3) : ("true-value" === e3 ? t3._trueValue = i3 : "false-value" === e3 && (t3._falseValue = i3), function(t4, e4, n4, i4, o4) {
          if (i4 && e4.startsWith("xlink:"))
            null == n4 ? t4.removeAttributeNS(y2, e4.slice(6, e4.length)) : t4.setAttributeNS(y2, e4, n4);
          else {
            const i5 = r2.isSpecialBooleanAttr(e4);
            null == n4 || i5 && !r2.includeBooleanAttr(n4) ? t4.removeAttribute(e4) : t4.setAttribute(e4, i5 ? "" : n4);
          }
        }(t3, e3, i3, o3));
      } }, o2);
      let z2, U2 = false;
      function ensureRenderer() {
        return z2 || (z2 = e2.createRenderer(V2));
      }
      function ensureHydrationRenderer() {
        return z2 = U2 ? z2 : e2.createHydrationRenderer(V2), U2 = true, z2;
      }
      const render = (...t3) => {
        ensureRenderer().render(...t3);
      }, hydrate = (...t3) => {
        ensureHydrationRenderer().hydrate(...t3);
      };
      function normalizeContainer(t3) {
        if (r2.isString(t3)) {
          return document.querySelector(t3);
        }
        return t3;
      }
      let H2 = false;
      t2.Transition = Transition, t2.TransitionGroup = N2, t2.VueElement = VueElement, t2.createApp = (...t3) => {
        const e3 = ensureRenderer().createApp(...t3), { mount: n3 } = e3;
        return e3.mount = (t4) => {
          const i3 = normalizeContainer(t4);
          if (!i3)
            return;
          const o3 = e3._component;
          r2.isFunction(o3) || o3.render || o3.template || (o3.template = i3.innerHTML), i3.innerHTML = "";
          const a3 = n3(i3, false, i3 instanceof SVGElement);
          return i3 instanceof Element && (i3.removeAttribute("v-cloak"), i3.setAttribute("data-v-app", "")), a3;
        }, e3;
      }, t2.createSSRApp = (...t3) => {
        const e3 = ensureHydrationRenderer().createApp(...t3), { mount: r3 } = e3;
        return e3.mount = (t4) => {
          const e4 = normalizeContainer(t4);
          if (e4)
            return r3(e4, true, e4 instanceof SVGElement);
        }, e3;
      }, t2.defineCustomElement = defineCustomElement, t2.defineSSRCustomElement = (t3) => defineCustomElement(t3, hydrate), t2.hydrate = hydrate, t2.initDirectivesForSSR = () => {
        H2 || (H2 = true, O2.getSSRProps = ({ value: t3 }) => ({ value: t3 }), M2.getSSRProps = ({ value: t3 }, e3) => {
          if (e3.props && r2.looseEqual(e3.props.value, t3))
            return { checked: true };
        }, L2.getSSRProps = ({ value: t3 }, e3) => {
          if (r2.isArray(t3)) {
            if (e3.props && r2.looseIndexOf(t3, e3.props.value) > -1)
              return { checked: true };
          } else if (r2.isSet(t3)) {
            if (e3.props && t3.has(e3.props.value))
              return { checked: true };
          } else if (t3)
            return { checked: true };
        }, D2.getSSRProps = (t3, e3) => {
          if ("string" != typeof e3.type)
            return;
          const r3 = resolveDynamicModel(e3.type.toUpperCase(), e3.props && e3.props.type);
          return r3.getSSRProps ? r3.getSSRProps(t3, e3) : void 0;
        }, u2.getSSRProps = ({ value: t3 }) => {
          if (!t3)
            return { style: { display: "none" } };
        });
      }, t2.render = render, t2.useCssModule = function(t3 = "$style") {
        {
          const n3 = e2.getCurrentInstance();
          if (!n3)
            return r2.EMPTY_OBJ;
          const i3 = n3.type.__cssModules;
          if (!i3)
            return r2.EMPTY_OBJ;
          const o3 = i3[t3];
          return o3 || r2.EMPTY_OBJ;
        }
      }, t2.useCssVars = function(t3) {
      }, t2.vModelCheckbox = L2, t2.vModelDynamic = D2, t2.vModelRadio = M2, t2.vModelSelect = B2, t2.vModelText = O2, t2.vShow = u2, t2.withKeys = (t3, e3) => t3._withKeys || (t3._withKeys = (n3) => {
        if (!("key" in n3))
          return;
        const i3 = r2.hyphenate(n3.key);
        return e3.some((t4) => t4 === i3 || $2[t4] === i3) ? t3(n3) : void 0;
      }), t2.withModifiers = (t3, e3) => t3._withMods || (t3._withMods = (r3, ...n3) => {
        for (let t4 = 0; t4 < e3.length; t4++) {
          const n4 = F2[e3[t4]];
          if (n4 && n4(r3, e3))
            return;
        }
        return t3(r3, ...n3);
      }), Object.keys(e2).forEach(function(r3) {
        "default" === r3 || Object.prototype.hasOwnProperty.call(t2, r3) || (t2[r3] = e2[r3]);
      });
    }(Ie), Ae.exports = Ie;
    var Zr = Ae.exports;
    const tn = _mergeNamespaces({ __proto__: null, compile: () => {
    } }, [Zr]);
    var en = {}, rn = { exports: {} }, nn = {}, on = { exports: {} }, an = {}, sn = {};
    function _objectWithoutPropertiesLoose(t2, e2) {
      if (null == t2)
        return {};
      var r2, n2, i2 = {}, o2 = Object.keys(t2);
      for (n2 = 0; n2 < o2.length; n2++)
        r2 = o2[n2], e2.indexOf(r2) >= 0 || (i2[r2] = t2[r2]);
      return i2;
    }
    Object.defineProperty(sn, "__esModule", { value: true });
    class Position {
      constructor(t2, e2, r2) {
        this.line = void 0, this.column = void 0, this.index = void 0, this.line = t2, this.column = e2, this.index = r2;
      }
    }
    class SourceLocation {
      constructor(t2, e2) {
        this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = t2, this.end = e2;
      }
    }
    function createPositionWithColumnOffset(t2, e2) {
      const { line: r2, column: n2, index: i2 } = t2;
      return new Position(r2, n2 + e2, i2 + e2);
    }
    const ln = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED";
    var pn = { ImportMetaOutsideModule: { message: `globalThis._importMeta_ may appear only with 'sourceType: "module"'`, code: ln }, ImportOutsideModule: { message: `'import' and 'export' may appear only with 'sourceType: "module"'`, code: ln } };
    const cn = { ArrayPattern: "array destructuring pattern", AssignmentExpression: "assignment expression", AssignmentPattern: "assignment expression", ArrowFunctionExpression: "arrow function expression", ConditionalExpression: "conditional expression", CatchClause: "catch clause", ForOfStatement: "for-of statement", ForInStatement: "for-in statement", ForStatement: "for-loop", FormalParameters: "function parameter list", Identifier: "identifier", ImportSpecifier: "import specifier", ImportDefaultSpecifier: "import default specifier", ImportNamespaceSpecifier: "import namespace specifier", ObjectPattern: "object destructuring pattern", ParenthesizedExpression: "parenthesized expression", RestElement: "rest element", UpdateExpression: { true: "prefix operation", false: "postfix operation" }, VariableDeclarator: "variable declaration", YieldExpression: "yield expression" }, toNodeDescription = ({ type: t2, prefix: e2 }) => "UpdateExpression" === t2 ? cn.UpdateExpression[String(e2)] : cn[t2];
    var dn = { AccessorIsGenerator: ({ kind: t2 }) => `A ${t2}ter cannot be a generator.`, ArgumentsInClass: "'arguments' is only allowed in functions and class methods.", AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.", AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.", AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.", AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.", AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.", AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.", AwaitNotInAsyncFunction: "'await' is only allowed within async functions.", BadGetterArity: "A 'get' accessor must not have any formal parameters.", BadSetterArity: "A 'set' accessor must have exactly one formal parameter.", BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.", ConstructorClassField: "Classes may not have a field named 'constructor'.", ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.", ConstructorIsAccessor: "Class constructor may not be an accessor.", ConstructorIsAsync: "Constructor can't be an async function.", ConstructorIsGenerator: "Constructor can't be a generator.", DeclarationMissingInitializer: ({ kind: t2 }) => `Missing initializer in ${t2} declaration.`, DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.", DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.", DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.", DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?", DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.", DecoratorSemicolon: "Decorators must not be followed by a semicolon.", DecoratorStaticBlock: "Decorators can't be used with a static block.", DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.', DeletePrivateField: "Deleting a private field is not allowed.", DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.", DuplicateConstructor: "Duplicate constructor in the same class.", DuplicateDefaultExport: "Only one default export allowed per module.", DuplicateExport: ({ exportName: t2 }) => `\`${t2}\` has already been exported. Exported identifiers must be unique.`, DuplicateProto: "Redefinition of __proto__ property.", DuplicateRegExpFlags: "Duplicate regular expression flag.", DynamicImportPhaseRequiresImportExpressions: ({ phase: t2 }) => `'import.${t2}(...)' can only be parsed when using the 'createImportExpressions' option.`, ElementAfterRest: "Rest element must be last element.", EscapedCharNotAnIdentifier: "Invalid Unicode escape.", ExportBindingIsString: ({ localName: t2, exportName: e2 }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${t2}' as '${e2}' } from 'some-module'\`?`, ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.", ForInOfLoopInitializer: ({ type: t2 }) => `'${"ForInStatement" === t2 ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`, ForInUsing: "For-in loop may not start with 'using' declaration.", ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.", ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.", GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.", IllegalBreakContinue: ({ type: t2 }) => `Unsyntactic ${"BreakStatement" === t2 ? "break" : "continue"}.`, IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.", IllegalReturn: "'return' outside of function.", ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedAssertSyntax: true` option in the import attributes plugin to suppress this error.", ImportBindingIsString: ({ importName: t2 }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${t2}" as foo }\`?`, ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.", ImportCallArity: ({ maxArgumentCount: t2 }) => `\`import()\` requires exactly ${1 === t2 ? "one argument" : "one or two arguments"}.`, ImportCallNotNewExpression: "Cannot use new with import(...).", ImportCallSpreadArgument: "`...` is not allowed in `import()`.", ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.", ImportReflectionHasAssertion: "`import module x` cannot have assertions.", ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.', IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.", InvalidBigIntLiteral: "Invalid BigIntLiteral.", InvalidCodePoint: "Code point out of bounds.", InvalidCoverInitializedName: "Invalid shorthand property initializer.", InvalidDecimal: "Invalid decimal.", InvalidDigit: ({ radix: t2 }) => `Expected number in radix ${t2}.`, InvalidEscapeSequence: "Bad character escape sequence.", InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.", InvalidEscapedReservedWord: ({ reservedWord: t2 }) => `Escape sequence in keyword ${t2}.`, InvalidIdentifier: ({ identifierName: t2 }) => `Invalid identifier ${t2}.`, InvalidLhs: ({ ancestor: t2 }) => `Invalid left-hand side in ${toNodeDescription(t2)}.`, InvalidLhsBinding: ({ ancestor: t2 }) => `Binding invalid left-hand side in ${toNodeDescription(t2)}.`, InvalidLhsOptionalChaining: ({ ancestor: t2 }) => `Invalid optional chaining in the left-hand side of ${toNodeDescription(t2)}.`, InvalidNumber: "Invalid number.", InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.", InvalidOrUnexpectedToken: ({ unexpected: t2 }) => `Unexpected character '${t2}'.`, InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.", InvalidPrivateFieldResolution: ({ identifierName: t2 }) => `Private name #${t2} is not defined.`, InvalidPropertyBindingPattern: "Binding member expression.", InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.", InvalidRestAssignmentPattern: "Invalid rest operator's argument.", LabelRedeclaration: ({ labelName: t2 }) => `Label '${t2}' is already declared.`, LetInLexicalBinding: "'let' is disallowed as a lexically bound name.", LineTerminatorBeforeArrow: "No line break is allowed before '=>'.", MalformedRegExpFlags: "Invalid regular expression flag.", MissingClassName: "A class name is required.", MissingEqInAssignment: "Only '=' operator can be used for specifying default value.", MissingSemicolon: "Missing semicolon.", MissingPlugin: ({ missingPlugin: t2 }) => `This experimental syntax requires enabling the parser plugin: ${t2.map((t3) => JSON.stringify(t3)).join(", ")}.`, MissingOneOfPlugins: ({ missingPlugin: t2 }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${t2.map((t3) => JSON.stringify(t3)).join(", ")}.`, MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.", MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.", ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.", ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.", ModuleAttributesWithDuplicateKeys: ({ key: t2 }) => `Duplicate key "${t2}" is not allowed in module attributes.`, ModuleExportNameHasLoneSurrogate: ({ surrogateCharCode: t2 }) => `An export name cannot include a lone surrogate, found '\\u${t2.toString(16)}'.`, ModuleExportUndefined: ({ localName: t2 }) => `Export '${t2}' is not defined.`, MultipleDefaultsInSwitch: "Multiple default clauses.", NewlineAfterThrow: "Illegal newline after throw.", NoCatchOrFinally: "Missing catch or finally clause.", NumberIdentifier: "Identifier directly after number.", NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.", ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.", OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.", OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.", OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.", ParamDupe: "Argument name clash.", PatternHasAccessor: "Object pattern can't contain getter or setter.", PatternHasMethod: "Object pattern can't contain methods.", PrivateInExpectedIn: ({ identifierName: t2 }) => `Private names are only allowed in property accesses (\`obj.#${t2}\`) or in \`in\` expressions (\`#${t2} in obj\`).`, PrivateNameRedeclaration: ({ identifierName: t2 }) => `Duplicate private name #${t2}.`, RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", RecordNoProto: "'__proto__' is not allowed in Record expressions.", RestTrailingComma: "Unexpected trailing comma after rest element.", SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.", SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.", SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.', StaticPrototype: "Classes may not have static property named prototype.", SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?", SuperPrivateField: "Private fields can't be accessed on super.", TrailingDecorator: "Decorators must be attached to a class element.", TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.", UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.', UnexpectedDigitAfterHash: "Unexpected digit after hash token.", UnexpectedImportExport: "'import' and 'export' may only appear at the top level.", UnexpectedKeyword: ({ keyword: t2 }) => `Unexpected keyword '${t2}'.`, UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.", UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.", UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.", UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.", UnexpectedPrivateField: "Unexpected private name.", UnexpectedReservedWord: ({ reservedWord: t2 }) => `Unexpected reserved word '${t2}'.`, UnexpectedSuper: "'super' is only allowed in object methods and classes.", UnexpectedToken: ({ expected: t2, unexpected: e2 }) => `Unexpected token${e2 ? ` '${e2}'.` : ""}${t2 ? `, expected "${t2}"` : ""}`, UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.", UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.", UnsupportedBind: "Binding should be performed on object property.", UnsupportedDecoratorExport: "A decorated export must export a class declaration.", UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.", UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.", UnsupportedMetaProperty: ({ target: t2, onlyValidPropertyName: e2 }) => `The only valid meta property for ${t2} is ${t2}.${e2}.`, UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.", UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.", UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).", UnterminatedComment: "Unterminated comment.", UnterminatedRegExp: "Unterminated regular expression.", UnterminatedString: "Unterminated string constant.", UnterminatedTemplate: "Unterminated template.", UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.", VarRedeclaration: ({ identifierName: t2 }) => `Identifier '${t2}' has already been declared.`, YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.", YieldInParameter: "Yield expression is not allowed in formal parameters.", ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0." };
    const mn = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]);
    var un = { PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.", PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.', PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.", PipeTopicUnconfiguredToken: ({ token: t2 }) => `Invalid topic token ${t2}. In order to use ${t2} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${t2}" }.`, PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.", PipeUnparenthesizedBody: ({ type: t2 }) => `Hack-style pipe body cannot be an unparenthesized ${toNodeDescription({ type: t2 })}; please wrap it in parentheses.`, PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.', PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.", PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.", PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.", PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.", PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.' };
    const hn = ["toMessage"], gn = ["message"];
    function defineHidden(t2, e2, r2) {
      Object.defineProperty(t2, e2, { enumerable: false, configurable: true, value: r2 });
    }
    function toParseErrorConstructor(t2) {
      let { toMessage: e2 } = t2, r2 = _objectWithoutPropertiesLoose(t2, hn);
      return function constructor({ loc: t3, details: n2 }) {
        const i2 = new SyntaxError();
        return Object.assign(i2, r2, { loc: t3, pos: t3.index }), "missingPlugin" in n2 && Object.assign(i2, { missingPlugin: n2.missingPlugin }), defineHidden(i2, "clone", function(e3 = {}) {
          var r3;
          const { line: i3, column: o2, index: a2 } = null != (r3 = e3.loc) ? r3 : t3;
          return constructor({ loc: new Position(i3, o2, a2), details: Object.assign({}, n2, e3.details) });
        }), defineHidden(i2, "details", n2), Object.defineProperty(i2, "message", { configurable: true, get() {
          const r3 = `${e2(n2)} (${t3.line}:${t3.column})`;
          return this.message = r3, r3;
        }, set(t4) {
          Object.defineProperty(this, "message", { value: t4, writable: true });
        } }), i2;
      };
    }
    function ParseErrorEnum(t2, e2) {
      if (Array.isArray(t2))
        return (e3) => ParseErrorEnum(e3, t2[0]);
      const r2 = {};
      for (const n2 of Object.keys(t2)) {
        const i2 = t2[n2], o2 = "string" == typeof i2 ? { message: () => i2 } : "function" == typeof i2 ? { message: i2 } : i2, { message: a2 } = o2, s2 = _objectWithoutPropertiesLoose(o2, gn), l2 = "string" == typeof a2 ? () => a2 : a2;
        r2[n2] = toParseErrorConstructor(Object.assign({ code: "BABEL_PARSER_SYNTAX_ERROR", reasonCode: n2, toMessage: l2 }, e2 ? { syntaxPlugin: e2 } : {}, s2));
      }
      return r2;
    }
    const xn = Object.assign({}, ParseErrorEnum(pn), ParseErrorEnum(dn), ParseErrorEnum({ StrictDelete: "Deleting local variable in strict mode.", StrictEvalArguments: ({ referenceName: t2 }) => `Assigning to '${t2}' in strict mode.`, StrictEvalArgumentsBinding: ({ bindingName: t2 }) => `Binding '${t2}' in strict mode.`, StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.", StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.", StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.", StrictWith: "'with' in strict mode." }), ParseErrorEnum`pipelineOperator`(un)), { defineProperty: vn } = Object, toUnenumerable = (t2, e2) => vn(t2, e2, { enumerable: false, value: t2[e2] });
    function toESTreeLocation(t2) {
      return t2.loc.start && toUnenumerable(t2.loc.start, "index"), t2.loc.end && toUnenumerable(t2.loc.end, "index"), t2;
    }
    class TokContext {
      constructor(t2, e2) {
        this.token = void 0, this.preserveSpace = void 0, this.token = t2, this.preserveSpace = !!e2;
      }
    }
    const yn = { brace: new TokContext("{"), j_oTag: new TokContext("<tag"), j_cTag: new TokContext("</tag"), j_expr: new TokContext("<tag>...</tag>", true) };
    yn.template = new TokContext("`", true);
    const bn = true, wn = true, kn = true, Sn = true, Cn = true;
    class ExportedTokenType {
      constructor(t2, e2 = {}) {
        this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop = void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.label = t2, this.keyword = e2.keyword, this.beforeExpr = !!e2.beforeExpr, this.startsExpr = !!e2.startsExpr, this.rightAssociative = !!e2.rightAssociative, this.isLoop = !!e2.isLoop, this.isAssign = !!e2.isAssign, this.prefix = !!e2.prefix, this.postfix = !!e2.postfix, this.binop = null != e2.binop ? e2.binop : null, this.updateContext = null;
      }
    }
    const En = /* @__PURE__ */ new Map();
    function createKeyword(t2, e2 = {}) {
      e2.keyword = t2;
      const r2 = createToken(t2, e2);
      return En.set(t2, r2), r2;
    }
    function createBinop(t2, e2) {
      return createToken(t2, { beforeExpr: bn, binop: e2 });
    }
    let _n = -1;
    const Pn = [], Tn = [], An = [], In = [], Nn = [], Rn = [];
    function createToken(t2, e2 = {}) {
      var r2, n2, i2, o2;
      return ++_n, Tn.push(t2), An.push(null != (r2 = e2.binop) ? r2 : -1), In.push(null != (n2 = e2.beforeExpr) && n2), Nn.push(null != (i2 = e2.startsExpr) && i2), Rn.push(null != (o2 = e2.prefix) && o2), Pn.push(new ExportedTokenType(t2, e2)), _n;
    }
    function createKeywordLike(t2, e2 = {}) {
      var r2, n2, i2, o2;
      return ++_n, En.set(t2, _n), Tn.push(t2), An.push(null != (r2 = e2.binop) ? r2 : -1), In.push(null != (n2 = e2.beforeExpr) && n2), Nn.push(null != (i2 = e2.startsExpr) && i2), Rn.push(null != (o2 = e2.prefix) && o2), Pn.push(new ExportedTokenType("name", e2)), _n;
    }
    const On = { bracketL: createToken("[", { beforeExpr: bn, startsExpr: wn }), bracketHashL: createToken("#[", { beforeExpr: bn, startsExpr: wn }), bracketBarL: createToken("[|", { beforeExpr: bn, startsExpr: wn }), bracketR: createToken("]"), bracketBarR: createToken("|]"), braceL: createToken("{", { beforeExpr: bn, startsExpr: wn }), braceBarL: createToken("{|", { beforeExpr: bn, startsExpr: wn }), braceHashL: createToken("#{", { beforeExpr: bn, startsExpr: wn }), braceR: createToken("}"), braceBarR: createToken("|}"), parenL: createToken("(", { beforeExpr: bn, startsExpr: wn }), parenR: createToken(")"), comma: createToken(",", { beforeExpr: bn }), semi: createToken(";", { beforeExpr: bn }), colon: createToken(":", { beforeExpr: bn }), doubleColon: createToken("::", { beforeExpr: bn }), dot: createToken("."), question: createToken("?", { beforeExpr: bn }), questionDot: createToken("?."), arrow: createToken("=>", { beforeExpr: bn }), template: createToken("template"), ellipsis: createToken("...", { beforeExpr: bn }), backQuote: createToken("`", { startsExpr: wn }), dollarBraceL: createToken("${", { beforeExpr: bn, startsExpr: wn }), templateTail: createToken("...`", { startsExpr: wn }), templateNonTail: createToken("...${", { beforeExpr: bn, startsExpr: wn }), at: createToken("@"), hash: createToken("#", { startsExpr: wn }), interpreterDirective: createToken("#!..."), eq: createToken("=", { beforeExpr: bn, isAssign: Sn }), assign: createToken("_=", { beforeExpr: bn, isAssign: Sn }), slashAssign: createToken("_=", { beforeExpr: bn, isAssign: Sn }), xorAssign: createToken("_=", { beforeExpr: bn, isAssign: Sn }), moduloAssign: createToken("_=", { beforeExpr: bn, isAssign: Sn }), incDec: createToken("++/--", { prefix: Cn, postfix: true, startsExpr: wn }), bang: createToken("!", { beforeExpr: bn, prefix: Cn, startsExpr: wn }), tilde: createToken("~", { beforeExpr: bn, prefix: Cn, startsExpr: wn }), doubleCaret: createToken("^^", { startsExpr: wn }), doubleAt: createToken("@@", { startsExpr: wn }), pipeline: createBinop("|>", 0), nullishCoalescing: createBinop("??", 1), logicalOR: createBinop("||", 1), logicalAND: createBinop("&&", 2), bitwiseOR: createBinop("|", 3), bitwiseXOR: createBinop("^", 4), bitwiseAND: createBinop("&", 5), equality: createBinop("==/!=/===/!==", 6), lt: createBinop("</>/<=/>=", 7), gt: createBinop("</>/<=/>=", 7), relational: createBinop("</>/<=/>=", 7), bitShift: createBinop("<</>>/>>>", 8), bitShiftL: createBinop("<</>>/>>>", 8), bitShiftR: createBinop("<</>>/>>>", 8), plusMin: createToken("+/-", { beforeExpr: bn, binop: 9, prefix: Cn, startsExpr: wn }), modulo: createToken("%", { binop: 10, startsExpr: wn }), star: createToken("*", { binop: 10 }), slash: createBinop("/", 10), exponent: createToken("**", { beforeExpr: bn, binop: 11, rightAssociative: true }), _in: createKeyword("in", { beforeExpr: bn, binop: 7 }), _instanceof: createKeyword("instanceof", { beforeExpr: bn, binop: 7 }), _break: createKeyword("break"), _case: createKeyword("case", { beforeExpr: bn }), _catch: createKeyword("catch"), _continue: createKeyword("continue"), _debugger: createKeyword("debugger"), _default: createKeyword("default", { beforeExpr: bn }), _else: createKeyword("else", { beforeExpr: bn }), _finally: createKeyword("finally"), _function: createKeyword("function", { startsExpr: wn }), _if: createKeyword("if"), _return: createKeyword("return", { beforeExpr: bn }), _switch: createKeyword("switch"), _throw: createKeyword("throw", { beforeExpr: bn, prefix: Cn, startsExpr: wn }), _try: createKeyword("try"), _var: createKeyword("var"), _const: createKeyword("const"), _with: createKeyword("with"), _new: createKeyword("new", { beforeExpr: bn, startsExpr: wn }), _this: createKeyword("this", { startsExpr: wn }), _super: createKeyword("super", { startsExpr: wn }), _class: createKeyword("class", { startsExpr: wn }), _extends: createKeyword("extends", { beforeExpr: bn }), _export: createKeyword("export"), _import: createKeyword("import", { startsExpr: wn }), _null: createKeyword("null", { startsExpr: wn }), _true: createKeyword("true", { startsExpr: wn }), _false: createKeyword("false", { startsExpr: wn }), _typeof: createKeyword("typeof", { beforeExpr: bn, prefix: Cn, startsExpr: wn }), _void: createKeyword("void", { beforeExpr: bn, prefix: Cn, startsExpr: wn }), _delete: createKeyword("delete", { beforeExpr: bn, prefix: Cn, startsExpr: wn }), _do: createKeyword("do", { isLoop: kn, beforeExpr: bn }), _for: createKeyword("for", { isLoop: kn }), _while: createKeyword("while", { isLoop: kn }), _as: createKeywordLike("as", { startsExpr: wn }), _assert: createKeywordLike("assert", { startsExpr: wn }), _async: createKeywordLike("async", { startsExpr: wn }), _await: createKeywordLike("await", { startsExpr: wn }), _defer: createKeywordLike("defer", { startsExpr: wn }), _from: createKeywordLike("from", { startsExpr: wn }), _get: createKeywordLike("get", { startsExpr: wn }), _let: createKeywordLike("let", { startsExpr: wn }), _meta: createKeywordLike("meta", { startsExpr: wn }), _of: createKeywordLike("of", { startsExpr: wn }), _sent: createKeywordLike("sent", { startsExpr: wn }), _set: createKeywordLike("set", { startsExpr: wn }), _source: createKeywordLike("source", { startsExpr: wn }), _static: createKeywordLike("static", { startsExpr: wn }), _using: createKeywordLike("using", { startsExpr: wn }), _yield: createKeywordLike("yield", { startsExpr: wn }), _asserts: createKeywordLike("asserts", { startsExpr: wn }), _checks: createKeywordLike("checks", { startsExpr: wn }), _exports: createKeywordLike("exports", { startsExpr: wn }), _global: createKeywordLike("global", { startsExpr: wn }), _implements: createKeywordLike("implements", { startsExpr: wn }), _intrinsic: createKeywordLike("intrinsic", { startsExpr: wn }), _infer: createKeywordLike("infer", { startsExpr: wn }), _is: createKeywordLike("is", { startsExpr: wn }), _mixins: createKeywordLike("mixins", { startsExpr: wn }), _proto: createKeywordLike("proto", { startsExpr: wn }), _require: createKeywordLike("require", { startsExpr: wn }), _satisfies: createKeywordLike("satisfies", { startsExpr: wn }), _keyof: createKeywordLike("keyof", { startsExpr: wn }), _readonly: createKeywordLike("readonly", { startsExpr: wn }), _unique: createKeywordLike("unique", { startsExpr: wn }), _abstract: createKeywordLike("abstract", { startsExpr: wn }), _declare: createKeywordLike("declare", { startsExpr: wn }), _enum: createKeywordLike("enum", { startsExpr: wn }), _module: createKeywordLike("module", { startsExpr: wn }), _namespace: createKeywordLike("namespace", { startsExpr: wn }), _interface: createKeywordLike("interface", { startsExpr: wn }), _type: createKeywordLike("type", { startsExpr: wn }), _opaque: createKeywordLike("opaque", { startsExpr: wn }), name: createToken("name", { startsExpr: wn }), string: createToken("string", { startsExpr: wn }), num: createToken("num", { startsExpr: wn }), bigint: createToken("bigint", { startsExpr: wn }), decimal: createToken("decimal", { startsExpr: wn }), regexp: createToken("regexp", { startsExpr: wn }), privateName: createToken("#name", { startsExpr: wn }), eof: createToken("eof"), jsxName: createToken("jsxName"), jsxText: createToken("jsxText", { beforeExpr: true }), jsxTagStart: createToken("jsxTagStart", { startsExpr: true }), jsxTagEnd: createToken("jsxTagEnd"), placeholder: createToken("%%", { startsExpr: true }) };
    function tokenIsIdentifier(t2) {
      return t2 >= 93 && t2 <= 132;
    }
    function tokenIsKeywordOrIdentifier(t2) {
      return t2 >= 58 && t2 <= 132;
    }
    function tokenIsLiteralPropertyName(t2) {
      return t2 >= 58 && t2 <= 136;
    }
    function tokenCanStartExpression(t2) {
      return Nn[t2];
    }
    function tokenIsFlowInterfaceOrTypeOrOpaque(t2) {
      return t2 >= 129 && t2 <= 131;
    }
    function tokenIsKeyword(t2) {
      return t2 >= 58 && t2 <= 92;
    }
    function tokenLabelName(t2) {
      return Tn[t2];
    }
    function tokenOperatorPrecedence(t2) {
      return An[t2];
    }
    function tokenIsTemplate(t2) {
      return t2 >= 24 && t2 <= 25;
    }
    function getExportedToken(t2) {
      return Pn[t2];
    }
    Pn[8].updateContext = (t2) => {
      t2.pop();
    }, Pn[5].updateContext = Pn[7].updateContext = Pn[23].updateContext = (t2) => {
      t2.push(yn.brace);
    }, Pn[22].updateContext = (t2) => {
      t2[t2.length - 1] === yn.template ? t2.pop() : t2.push(yn.template);
    }, Pn[142].updateContext = (t2) => {
      t2.push(yn.j_expr, yn.j_oTag);
    };
    let Ln = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC", Mn = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65";
    const Bn = new RegExp("[" + Ln + "]"), Dn = new RegExp("[" + Ln + Mn + "]");
    Ln = Mn = null;
    const jn = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], Fn = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
    function isInAstralSet(t2, e2) {
      let r2 = 65536;
      for (let n2 = 0, i2 = e2.length; n2 < i2; n2 += 2) {
        if (r2 += e2[n2], r2 > t2)
          return false;
        if (r2 += e2[n2 + 1], r2 >= t2)
          return true;
      }
      return false;
    }
    function isIdentifierStart(t2) {
      return t2 < 65 ? 36 === t2 : t2 <= 90 || (t2 < 97 ? 95 === t2 : t2 <= 122 || (t2 <= 65535 ? t2 >= 170 && Bn.test(String.fromCharCode(t2)) : isInAstralSet(t2, jn)));
    }
    function isIdentifierChar(t2) {
      return t2 < 48 ? 36 === t2 : t2 < 58 || !(t2 < 65) && (t2 <= 90 || (t2 < 97 ? 95 === t2 : t2 <= 122 || (t2 <= 65535 ? t2 >= 170 && Dn.test(String.fromCharCode(t2)) : isInAstralSet(t2, jn) || isInAstralSet(t2, Fn))));
    }
    const $n = ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"], Vn = ["eval", "arguments"], zn = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"]), Un = new Set($n), Hn = new Set(Vn);
    function isReservedWord(t2, e2) {
      return e2 && "await" === t2 || "enum" === t2;
    }
    function isStrictReservedWord(t2, e2) {
      return isReservedWord(t2, e2) || Un.has(t2);
    }
    function isStrictBindOnlyReservedWord(t2) {
      return Hn.has(t2);
    }
    function isStrictBindReservedWord(t2, e2) {
      return isStrictReservedWord(t2, e2) || isStrictBindOnlyReservedWord(t2);
    }
    const qn = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
    class Scope {
      constructor(t2) {
        this.var = /* @__PURE__ */ new Set(), this.lexical = /* @__PURE__ */ new Set(), this.functions = /* @__PURE__ */ new Set(), this.flags = t2;
      }
    }
    class ScopeHandler {
      constructor(t2, e2) {
        this.parser = void 0, this.scopeStack = [], this.inModule = void 0, this.undefinedExports = /* @__PURE__ */ new Map(), this.parser = t2, this.inModule = e2;
      }
      get inTopLevel() {
        return (1 & this.currentScope().flags) > 0;
      }
      get inFunction() {
        return (2 & this.currentVarScopeFlags()) > 0;
      }
      get allowSuper() {
        return (16 & this.currentThisScopeFlags()) > 0;
      }
      get allowDirectSuper() {
        return (32 & this.currentThisScopeFlags()) > 0;
      }
      get inClass() {
        return (64 & this.currentThisScopeFlags()) > 0;
      }
      get inClassAndNotInNonArrowFunction() {
        const t2 = this.currentThisScopeFlags();
        return (64 & t2) > 0 && 0 == (2 & t2);
      }
      get inStaticBlock() {
        for (let t2 = this.scopeStack.length - 1; ; t2--) {
          const { flags: e2 } = this.scopeStack[t2];
          if (128 & e2)
            return true;
          if (451 & e2)
            return false;
        }
      }
      get inNonArrowFunction() {
        return (2 & this.currentThisScopeFlags()) > 0;
      }
      get treatFunctionsAsVar() {
        return this.treatFunctionsAsVarInScope(this.currentScope());
      }
      createScope(t2) {
        return new Scope(t2);
      }
      enter(t2) {
        this.scopeStack.push(this.createScope(t2));
      }
      exit() {
        return this.scopeStack.pop().flags;
      }
      treatFunctionsAsVarInScope(t2) {
        return !!(130 & t2.flags || !this.parser.inModule && 1 & t2.flags);
      }
      declareName(t2, e2, r2) {
        let n2 = this.currentScope();
        if (8 & e2 || 16 & e2)
          this.checkRedeclarationInScope(n2, t2, e2, r2), 16 & e2 ? n2.functions.add(t2) : n2.lexical.add(t2), 8 & e2 && this.maybeExportDefined(n2, t2);
        else if (4 & e2)
          for (let i2 = this.scopeStack.length - 1; i2 >= 0 && (n2 = this.scopeStack[i2], this.checkRedeclarationInScope(n2, t2, e2, r2), n2.var.add(t2), this.maybeExportDefined(n2, t2), !(387 & n2.flags)); --i2)
            ;
        this.parser.inModule && 1 & n2.flags && this.undefinedExports.delete(t2);
      }
      maybeExportDefined(t2, e2) {
        this.parser.inModule && 1 & t2.flags && this.undefinedExports.delete(e2);
      }
      checkRedeclarationInScope(t2, e2, r2, n2) {
        this.isRedeclaredInScope(t2, e2, r2) && this.parser.raise(xn.VarRedeclaration, { at: n2, identifierName: e2 });
      }
      isRedeclaredInScope(t2, e2, r2) {
        return !!(1 & r2) && (8 & r2 ? t2.lexical.has(e2) || t2.functions.has(e2) || t2.var.has(e2) : 16 & r2 ? t2.lexical.has(e2) || !this.treatFunctionsAsVarInScope(t2) && t2.var.has(e2) : t2.lexical.has(e2) && !(8 & t2.flags && t2.lexical.values().next().value === e2) || !this.treatFunctionsAsVarInScope(t2) && t2.functions.has(e2));
      }
      checkLocalExport(t2) {
        const { name: e2 } = t2, r2 = this.scopeStack[0];
        r2.lexical.has(e2) || r2.var.has(e2) || r2.functions.has(e2) || this.undefinedExports.set(e2, t2.loc.start);
      }
      currentScope() {
        return this.scopeStack[this.scopeStack.length - 1];
      }
      currentVarScopeFlags() {
        for (let t2 = this.scopeStack.length - 1; ; t2--) {
          const { flags: e2 } = this.scopeStack[t2];
          if (387 & e2)
            return e2;
        }
      }
      currentThisScopeFlags() {
        for (let t2 = this.scopeStack.length - 1; ; t2--) {
          const { flags: e2 } = this.scopeStack[t2];
          if (451 & e2 && !(4 & e2))
            return e2;
        }
      }
    }
    class FlowScope extends Scope {
      constructor(...t2) {
        super(...t2), this.declareFunctions = /* @__PURE__ */ new Set();
      }
    }
    class FlowScopeHandler extends ScopeHandler {
      createScope(t2) {
        return new FlowScope(t2);
      }
      declareName(t2, e2, r2) {
        const n2 = this.currentScope();
        if (2048 & e2)
          return this.checkRedeclarationInScope(n2, t2, e2, r2), this.maybeExportDefined(n2, t2), void n2.declareFunctions.add(t2);
        super.declareName(t2, e2, r2);
      }
      isRedeclaredInScope(t2, e2, r2) {
        return !!super.isRedeclaredInScope(t2, e2, r2) || !!(2048 & r2) && (!t2.declareFunctions.has(e2) && (t2.lexical.has(e2) || t2.functions.has(e2)));
      }
      checkLocalExport(t2) {
        this.scopeStack[0].declareFunctions.has(t2.name) || super.checkLocalExport(t2);
      }
    }
    class BaseParser {
      constructor() {
        this.sawUnambiguousESM = false, this.ambiguousScriptDifferentAst = false;
      }
      hasPlugin(t2) {
        if ("string" == typeof t2)
          return this.plugins.has(t2);
        {
          const [e2, r2] = t2;
          if (!this.hasPlugin(e2))
            return false;
          const n2 = this.plugins.get(e2);
          for (const t3 of Object.keys(r2))
            if ((null == n2 ? void 0 : n2[t3]) !== r2[t3])
              return false;
          return true;
        }
      }
      getPluginOption(t2, e2) {
        var r2;
        return null == (r2 = this.plugins.get(t2)) ? void 0 : r2[e2];
      }
    }
    function setTrailingComments(t2, e2) {
      void 0 === t2.trailingComments ? t2.trailingComments = e2 : t2.trailingComments.unshift(...e2);
    }
    function setInnerComments(t2, e2) {
      void 0 === t2.innerComments ? t2.innerComments = e2 : t2.innerComments.unshift(...e2);
    }
    function adjustInnerComments(t2, e2, r2) {
      let n2 = null, i2 = e2.length;
      for (; null === n2 && i2 > 0; )
        n2 = e2[--i2];
      null === n2 || n2.start > r2.start ? setInnerComments(t2, r2.comments) : setTrailingComments(n2, r2.comments);
    }
    class CommentsParser extends BaseParser {
      addComment(t2) {
        this.filename && (t2.loc.filename = this.filename), this.state.comments.push(t2);
      }
      processComment(t2) {
        const { commentStack: e2 } = this.state, r2 = e2.length;
        if (0 === r2)
          return;
        let n2 = r2 - 1;
        const i2 = e2[n2];
        i2.start === t2.end && (i2.leadingNode = t2, n2--);
        const { start: o2 } = t2;
        for (; n2 >= 0; n2--) {
          const r3 = e2[n2], i3 = r3.end;
          if (!(i3 > o2)) {
            i3 === o2 && (r3.trailingNode = t2);
            break;
          }
          r3.containingNode = t2, this.finalizeComment(r3), e2.splice(n2, 1);
        }
      }
      finalizeComment(t2) {
        const { comments: e2 } = t2;
        if (null !== t2.leadingNode || null !== t2.trailingNode)
          null !== t2.leadingNode && setTrailingComments(t2.leadingNode, e2), null !== t2.trailingNode && function(t3, e3) {
            void 0 === t3.leadingComments ? t3.leadingComments = e3 : t3.leadingComments.unshift(...e3);
          }(t2.trailingNode, e2);
        else {
          const { containingNode: r2, start: n2 } = t2;
          if (44 === this.input.charCodeAt(n2 - 1))
            switch (r2.type) {
              case "ObjectExpression":
              case "ObjectPattern":
              case "RecordExpression":
                adjustInnerComments(r2, r2.properties, t2);
                break;
              case "CallExpression":
              case "OptionalCallExpression":
                adjustInnerComments(r2, r2.arguments, t2);
                break;
              case "FunctionDeclaration":
              case "FunctionExpression":
              case "ArrowFunctionExpression":
              case "ObjectMethod":
              case "ClassMethod":
              case "ClassPrivateMethod":
                adjustInnerComments(r2, r2.params, t2);
                break;
              case "ArrayExpression":
              case "ArrayPattern":
              case "TupleExpression":
                adjustInnerComments(r2, r2.elements, t2);
                break;
              case "ExportNamedDeclaration":
              case "ImportDeclaration":
                adjustInnerComments(r2, r2.specifiers, t2);
                break;
              default:
                setInnerComments(r2, e2);
            }
          else
            setInnerComments(r2, e2);
        }
      }
      finalizeRemainingComments() {
        const { commentStack: t2 } = this.state;
        for (let e2 = t2.length - 1; e2 >= 0; e2--)
          this.finalizeComment(t2[e2]);
        this.state.commentStack = [];
      }
      resetPreviousNodeTrailingComments(t2) {
        const { commentStack: e2 } = this.state, { length: r2 } = e2;
        if (0 === r2)
          return;
        const n2 = e2[r2 - 1];
        n2.leadingNode === t2 && (n2.leadingNode = null);
      }
      resetPreviousIdentifierLeadingComments(t2) {
        const { commentStack: e2 } = this.state, { length: r2 } = e2;
        0 !== r2 && (e2[r2 - 1].trailingNode === t2 ? e2[r2 - 1].trailingNode = null : r2 >= 2 && e2[r2 - 2].trailingNode === t2 && (e2[r2 - 2].trailingNode = null));
      }
      takeSurroundingComments(t2, e2, r2) {
        const { commentStack: n2 } = this.state, i2 = n2.length;
        if (0 === i2)
          return;
        let o2 = i2 - 1;
        for (; o2 >= 0; o2--) {
          const i3 = n2[o2], a2 = i3.end;
          if (i3.start === r2)
            i3.leadingNode = t2;
          else if (a2 === e2)
            i3.trailingNode = t2;
          else if (a2 < e2)
            break;
        }
      }
    }
    const Wn = /\r\n?|[\n\u2028\u2029]/, Kn = new RegExp(Wn.source, "g");
    function isNewLine(t2) {
      switch (t2) {
        case 10:
        case 13:
        case 8232:
        case 8233:
          return true;
        default:
          return false;
      }
    }
    const Gn = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, Jn = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g, Yn = new RegExp("(?=(" + Jn.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
    function isWhitespace(t2) {
      switch (t2) {
        case 9:
        case 11:
        case 12:
        case 32:
        case 160:
        case 5760:
        case 8192:
        case 8193:
        case 8194:
        case 8195:
        case 8196:
        case 8197:
        case 8198:
        case 8199:
        case 8200:
        case 8201:
        case 8202:
        case 8239:
        case 8287:
        case 12288:
        case 65279:
          return true;
        default:
          return false;
      }
    }
    class State {
      constructor() {
        this.strict = void 0, this.curLine = void 0, this.lineStart = void 0, this.startLoc = void 0, this.endLoc = void 0, this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.maybeInArrowParameters = false, this.inType = false, this.noAnonFunctionType = false, this.hasFlowComment = false, this.isAmbientContext = false, this.inAbstractClass = false, this.inDisallowConditionalTypesContext = false, this.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null }, this.soloAwait = false, this.inFSharpPipelineDirectBody = false, this.labels = [], this.comments = [], this.commentStack = [], this.pos = 0, this.type = 139, this.value = null, this.start = 0, this.end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.lastTokStart = 0, this.context = [yn.brace], this.canStartJSXElement = true, this.containsEsc = false, this.firstInvalidTemplateEscapePos = null, this.strictErrors = /* @__PURE__ */ new Map(), this.tokensLength = 0;
      }
      init({ strictMode: t2, sourceType: e2, startLine: r2, startColumn: n2 }) {
        this.strict = false !== t2 && (true === t2 || "module" === e2), this.curLine = r2, this.lineStart = -n2, this.startLoc = this.endLoc = new Position(r2, n2, 0);
      }
      curPosition() {
        return new Position(this.curLine, this.pos - this.lineStart, this.pos);
      }
      clone(t2) {
        const e2 = new State(), r2 = Object.keys(this);
        for (let n2 = 0, i2 = r2.length; n2 < i2; n2++) {
          const i3 = r2[n2];
          let o2 = this[i3];
          !t2 && Array.isArray(o2) && (o2 = o2.slice()), e2[i3] = o2;
        }
        return e2;
      }
    }
    var _isDigit = function(t2) {
      return t2 >= 48 && t2 <= 57;
    };
    const Xn = { decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]), hex: /* @__PURE__ */ new Set([46, 88, 95, 120]) }, Qn = { bin: (t2) => 48 === t2 || 49 === t2, oct: (t2) => t2 >= 48 && t2 <= 55, dec: (t2) => t2 >= 48 && t2 <= 57, hex: (t2) => t2 >= 48 && t2 <= 57 || t2 >= 65 && t2 <= 70 || t2 >= 97 && t2 <= 102 };
    function readStringContents(t2, e2, r2, n2, i2, o2) {
      const a2 = r2, s2 = n2, l2 = i2;
      let p2 = "", c2 = null, d2 = r2;
      const { length: m2 } = e2;
      for (; ; ) {
        if (r2 >= m2) {
          o2.unterminated(a2, s2, l2), p2 += e2.slice(d2, r2);
          break;
        }
        const u2 = e2.charCodeAt(r2);
        if (isStringEnd(t2, u2, e2, r2)) {
          p2 += e2.slice(d2, r2);
          break;
        }
        if (92 === u2) {
          p2 += e2.slice(d2, r2);
          const a3 = readEscapedChar(e2, r2, n2, i2, "template" === t2, o2);
          null !== a3.ch || c2 ? p2 += a3.ch : c2 = { pos: r2, lineStart: n2, curLine: i2 }, { pos: r2, lineStart: n2, curLine: i2 } = a3, d2 = r2;
        } else
          8232 === u2 || 8233 === u2 ? (++i2, n2 = ++r2) : 10 === u2 || 13 === u2 ? "template" === t2 ? (p2 += e2.slice(d2, r2) + "\n", ++r2, 13 === u2 && 10 === e2.charCodeAt(r2) && ++r2, ++i2, d2 = n2 = r2) : o2.unterminated(a2, s2, l2) : ++r2;
      }
      return { pos: r2, str: p2, firstInvalidLoc: c2, lineStart: n2, curLine: i2, containsInvalid: !!c2 };
    }
    function isStringEnd(t2, e2, r2, n2) {
      return "template" === t2 ? 96 === e2 || 36 === e2 && 123 === r2.charCodeAt(n2 + 1) : e2 === ("double" === t2 ? 34 : 39);
    }
    function readEscapedChar(t2, e2, r2, n2, i2, o2) {
      const a2 = !i2;
      e2++;
      const res = (t3) => ({ pos: e2, ch: t3, lineStart: r2, curLine: n2 }), s2 = t2.charCodeAt(e2++);
      switch (s2) {
        case 110:
          return res("\n");
        case 114:
          return res("\r");
        case 120: {
          let i3;
          return { code: i3, pos: e2 } = readHexChar(t2, e2, r2, n2, 2, false, a2, o2), res(null === i3 ? null : String.fromCharCode(i3));
        }
        case 117: {
          let i3;
          return { code: i3, pos: e2 } = readCodePoint(t2, e2, r2, n2, a2, o2), res(null === i3 ? null : String.fromCodePoint(i3));
        }
        case 116:
          return res("	");
        case 98:
          return res("\b");
        case 118:
          return res("\v");
        case 102:
          return res("\f");
        case 13:
          10 === t2.charCodeAt(e2) && ++e2;
        case 10:
          r2 = e2, ++n2;
        case 8232:
        case 8233:
          return res("");
        case 56:
        case 57:
          if (i2)
            return res(null);
          o2.strictNumericEscape(e2 - 1, r2, n2);
        default:
          if (s2 >= 48 && s2 <= 55) {
            const a3 = e2 - 1;
            let s3 = t2.slice(a3, e2 + 2).match(/^[0-7]+/)[0], l2 = parseInt(s3, 8);
            l2 > 255 && (s3 = s3.slice(0, -1), l2 = parseInt(s3, 8)), e2 += s3.length - 1;
            const p2 = t2.charCodeAt(e2);
            if ("0" !== s3 || 56 === p2 || 57 === p2) {
              if (i2)
                return res(null);
              o2.strictNumericEscape(a3, r2, n2);
            }
            return res(String.fromCharCode(l2));
          }
          return res(String.fromCharCode(s2));
      }
    }
    function readHexChar(t2, e2, r2, n2, i2, o2, a2, s2) {
      const l2 = e2;
      let p2;
      return { n: p2, pos: e2 } = readInt(t2, e2, r2, n2, 16, i2, o2, false, s2, !a2), null === p2 && (a2 ? s2.invalidEscapeSequence(l2, r2, n2) : e2 = l2 - 1), { code: p2, pos: e2 };
    }
    function readInt(t2, e2, r2, n2, i2, o2, a2, s2, l2, p2) {
      const c2 = e2, d2 = 16 === i2 ? Xn.hex : Xn.decBinOct, m2 = 16 === i2 ? Qn.hex : 10 === i2 ? Qn.dec : 8 === i2 ? Qn.oct : Qn.bin;
      let u2 = false, h2 = 0;
      for (let c3 = 0, g2 = null == o2 ? 1 / 0 : o2; c3 < g2; ++c3) {
        const o3 = t2.charCodeAt(e2);
        let c4;
        if (95 !== o3 || "bail" === s2) {
          if (c4 = o3 >= 97 ? o3 - 97 + 10 : o3 >= 65 ? o3 - 65 + 10 : _isDigit(o3) ? o3 - 48 : 1 / 0, c4 >= i2) {
            if (c4 <= 9 && p2)
              return { n: null, pos: e2 };
            if (c4 <= 9 && l2.invalidDigit(e2, r2, n2, i2))
              c4 = 0;
            else {
              if (!a2)
                break;
              c4 = 0, u2 = true;
            }
          }
          ++e2, h2 = h2 * i2 + c4;
        } else {
          const i3 = t2.charCodeAt(e2 - 1), o4 = t2.charCodeAt(e2 + 1);
          if (s2) {
            if (Number.isNaN(o4) || !m2(o4) || d2.has(i3) || d2.has(o4)) {
              if (p2)
                return { n: null, pos: e2 };
              l2.unexpectedNumericSeparator(e2, r2, n2);
            }
          } else {
            if (p2)
              return { n: null, pos: e2 };
            l2.numericSeparatorInEscapeSequence(e2, r2, n2);
          }
          ++e2;
        }
      }
      return e2 === c2 || null != o2 && e2 - c2 !== o2 || u2 ? { n: null, pos: e2 } : { n: h2, pos: e2 };
    }
    function readCodePoint(t2, e2, r2, n2, i2, o2) {
      let a2;
      if (123 === t2.charCodeAt(e2)) {
        if (++e2, { code: a2, pos: e2 } = readHexChar(t2, e2, r2, n2, t2.indexOf("}", e2) - e2, true, i2, o2), ++e2, null !== a2 && a2 > 1114111) {
          if (!i2)
            return { code: null, pos: e2 };
          o2.invalidCodePoint(e2, r2, n2);
        }
      } else
        ({ code: a2, pos: e2 } = readHexChar(t2, e2, r2, n2, 4, false, i2, o2));
      return { code: a2, pos: e2 };
    }
    const Zn = ["at"], ti = ["at"];
    function buildPosition(t2, e2, r2) {
      return new Position(r2, t2 - e2, t2);
    }
    const ei = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]);
    class Token {
      constructor(t2) {
        this.type = t2.type, this.value = t2.value, this.start = t2.start, this.end = t2.end, this.loc = new SourceLocation(t2.startLoc, t2.endLoc);
      }
    }
    class Tokenizer extends CommentsParser {
      constructor(t2, e2) {
        super(), this.isLookahead = void 0, this.tokens = [], this.errorHandlers_readInt = { invalidDigit: (t3, e3, r2, n2) => !!this.options.errorRecovery && (this.raise(xn.InvalidDigit, { at: buildPosition(t3, e3, r2), radix: n2 }), true), numericSeparatorInEscapeSequence: this.errorBuilder(xn.NumericSeparatorInEscapeSequence), unexpectedNumericSeparator: this.errorBuilder(xn.UnexpectedNumericSeparator) }, this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, { invalidEscapeSequence: this.errorBuilder(xn.InvalidEscapeSequence), invalidCodePoint: this.errorBuilder(xn.InvalidCodePoint) }), this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, { strictNumericEscape: (t3, e3, r2) => {
          this.recordStrictModeErrors(xn.StrictNumericEscape, { at: buildPosition(t3, e3, r2) });
        }, unterminated: (t3, e3, r2) => {
          throw this.raise(xn.UnterminatedString, { at: buildPosition(t3 - 1, e3, r2) });
        } }), this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, { strictNumericEscape: this.errorBuilder(xn.StrictNumericEscape), unterminated: (t3, e3, r2) => {
          throw this.raise(xn.UnterminatedTemplate, { at: buildPosition(t3, e3, r2) });
        } }), this.state = new State(), this.state.init(t2), this.input = e2, this.length = e2.length, this.isLookahead = false;
      }
      pushToken(t2) {
        this.tokens.length = this.state.tokensLength, this.tokens.push(t2), ++this.state.tokensLength;
      }
      next() {
        this.checkKeywordEscapes(), this.options.tokens && this.pushToken(new Token(this.state)), this.state.lastTokStart = this.state.start, this.state.lastTokEndLoc = this.state.endLoc, this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
      }
      eat(t2) {
        return !!this.match(t2) && (this.next(), true);
      }
      match(t2) {
        return this.state.type === t2;
      }
      createLookaheadState(t2) {
        return { pos: t2.pos, value: null, type: t2.type, start: t2.start, end: t2.end, context: [this.curContext()], inType: t2.inType, startLoc: t2.startLoc, lastTokEndLoc: t2.lastTokEndLoc, curLine: t2.curLine, lineStart: t2.lineStart, curPosition: t2.curPosition };
      }
      lookahead() {
        const t2 = this.state;
        this.state = this.createLookaheadState(t2), this.isLookahead = true, this.nextToken(), this.isLookahead = false;
        const e2 = this.state;
        return this.state = t2, e2;
      }
      nextTokenStart() {
        return this.nextTokenStartSince(this.state.pos);
      }
      nextTokenStartSince(t2) {
        return Gn.lastIndex = t2, Gn.test(this.input) ? Gn.lastIndex : t2;
      }
      lookaheadCharCode() {
        return this.input.charCodeAt(this.nextTokenStart());
      }
      nextTokenInLineStart() {
        return this.nextTokenInLineStartSince(this.state.pos);
      }
      nextTokenInLineStartSince(t2) {
        return Jn.lastIndex = t2, Jn.test(this.input) ? Jn.lastIndex : t2;
      }
      lookaheadInLineCharCode() {
        return this.input.charCodeAt(this.nextTokenInLineStart());
      }
      codePointAtPos(t2) {
        let e2 = this.input.charCodeAt(t2);
        if (55296 == (64512 & e2) && ++t2 < this.input.length) {
          const r2 = this.input.charCodeAt(t2);
          56320 == (64512 & r2) && (e2 = 65536 + ((1023 & e2) << 10) + (1023 & r2));
        }
        return e2;
      }
      setStrict(t2) {
        this.state.strict = t2, t2 && (this.state.strictErrors.forEach(([t3, e2]) => this.raise(t3, { at: e2 })), this.state.strictErrors.clear());
      }
      curContext() {
        return this.state.context[this.state.context.length - 1];
      }
      nextToken() {
        this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.pos >= this.length ? this.finishToken(139) : this.getTokenFromCode(this.codePointAtPos(this.state.pos));
      }
      skipBlockComment(t2) {
        let e2;
        this.isLookahead || (e2 = this.state.curPosition());
        const r2 = this.state.pos, n2 = this.input.indexOf(t2, r2 + 2);
        if (-1 === n2)
          throw this.raise(xn.UnterminatedComment, { at: this.state.curPosition() });
        for (this.state.pos = n2 + t2.length, Kn.lastIndex = r2 + 2; Kn.test(this.input) && Kn.lastIndex <= n2; )
          ++this.state.curLine, this.state.lineStart = Kn.lastIndex;
        if (this.isLookahead)
          return;
        const i2 = { type: "CommentBlock", value: this.input.slice(r2 + 2, n2), start: r2, end: n2 + t2.length, loc: new SourceLocation(e2, this.state.curPosition()) };
        return this.options.tokens && this.pushToken(i2), i2;
      }
      skipLineComment(t2) {
        const e2 = this.state.pos;
        let r2;
        this.isLookahead || (r2 = this.state.curPosition());
        let n2 = this.input.charCodeAt(this.state.pos += t2);
        if (this.state.pos < this.length)
          for (; !isNewLine(n2) && ++this.state.pos < this.length; )
            n2 = this.input.charCodeAt(this.state.pos);
        if (this.isLookahead)
          return;
        const i2 = this.state.pos, o2 = { type: "CommentLine", value: this.input.slice(e2 + t2, i2), start: e2, end: i2, loc: new SourceLocation(r2, this.state.curPosition()) };
        return this.options.tokens && this.pushToken(o2), o2;
      }
      skipSpace() {
        const t2 = this.state.pos, e2 = [];
        t:
          for (; this.state.pos < this.length; ) {
            const r2 = this.input.charCodeAt(this.state.pos);
            switch (r2) {
              case 32:
              case 160:
              case 9:
                ++this.state.pos;
                break;
              case 13:
                10 === this.input.charCodeAt(this.state.pos + 1) && ++this.state.pos;
              case 10:
              case 8232:
              case 8233:
                ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
                break;
              case 47:
                switch (this.input.charCodeAt(this.state.pos + 1)) {
                  case 42: {
                    const t3 = this.skipBlockComment("*/");
                    void 0 !== t3 && (this.addComment(t3), this.options.attachComment && e2.push(t3));
                    break;
                  }
                  case 47: {
                    const t3 = this.skipLineComment(2);
                    void 0 !== t3 && (this.addComment(t3), this.options.attachComment && e2.push(t3));
                    break;
                  }
                  default:
                    break t;
                }
                break;
              default:
                if (isWhitespace(r2))
                  ++this.state.pos;
                else if (45 === r2 && !this.inModule && this.options.annexB) {
                  const r3 = this.state.pos;
                  if (45 !== this.input.charCodeAt(r3 + 1) || 62 !== this.input.charCodeAt(r3 + 2) || !(0 === t2 || this.state.lineStart > t2))
                    break t;
                  {
                    const t3 = this.skipLineComment(3);
                    void 0 !== t3 && (this.addComment(t3), this.options.attachComment && e2.push(t3));
                  }
                } else {
                  if (60 !== r2 || this.inModule || !this.options.annexB)
                    break t;
                  {
                    const t3 = this.state.pos;
                    if (33 !== this.input.charCodeAt(t3 + 1) || 45 !== this.input.charCodeAt(t3 + 2) || 45 !== this.input.charCodeAt(t3 + 3))
                      break t;
                    {
                      const t4 = this.skipLineComment(4);
                      void 0 !== t4 && (this.addComment(t4), this.options.attachComment && e2.push(t4));
                    }
                  }
                }
            }
          }
        if (e2.length > 0) {
          const r2 = { start: t2, end: this.state.pos, comments: e2, leadingNode: null, trailingNode: null, containingNode: null };
          this.state.commentStack.push(r2);
        }
      }
      finishToken(t2, e2) {
        this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
        const r2 = this.state.type;
        this.state.type = t2, this.state.value = e2, this.isLookahead || this.updateContext(r2);
      }
      replaceToken(t2) {
        this.state.type = t2, this.updateContext();
      }
      readToken_numberSign() {
        if (0 === this.state.pos && this.readToken_interpreter())
          return;
        const t2 = this.state.pos + 1, e2 = this.codePointAtPos(t2);
        if (e2 >= 48 && e2 <= 57)
          throw this.raise(xn.UnexpectedDigitAfterHash, { at: this.state.curPosition() });
        if (123 === e2 || 91 === e2 && this.hasPlugin("recordAndTuple")) {
          if (this.expectPlugin("recordAndTuple"), "bar" === this.getPluginOption("recordAndTuple", "syntaxType"))
            throw this.raise(123 === e2 ? xn.RecordExpressionHashIncorrectStartSyntaxType : xn.TupleExpressionHashIncorrectStartSyntaxType, { at: this.state.curPosition() });
          this.state.pos += 2, 123 === e2 ? this.finishToken(7) : this.finishToken(1);
        } else
          isIdentifierStart(e2) ? (++this.state.pos, this.finishToken(138, this.readWord1(e2))) : 92 === e2 ? (++this.state.pos, this.finishToken(138, this.readWord1())) : this.finishOp(27, 1);
      }
      readToken_dot() {
        const t2 = this.input.charCodeAt(this.state.pos + 1);
        t2 >= 48 && t2 <= 57 ? this.readNumber(true) : 46 === t2 && 46 === this.input.charCodeAt(this.state.pos + 2) ? (this.state.pos += 3, this.finishToken(21)) : (++this.state.pos, this.finishToken(16));
      }
      readToken_slash() {
        61 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(31, 2) : this.finishOp(56, 1);
      }
      readToken_interpreter() {
        if (0 !== this.state.pos || this.length < 2)
          return false;
        let t2 = this.input.charCodeAt(this.state.pos + 1);
        if (33 !== t2)
          return false;
        const e2 = this.state.pos;
        for (this.state.pos += 1; !isNewLine(t2) && ++this.state.pos < this.length; )
          t2 = this.input.charCodeAt(this.state.pos);
        const r2 = this.input.slice(e2 + 2, this.state.pos);
        return this.finishToken(28, r2), true;
      }
      readToken_mult_modulo(t2) {
        let e2 = 42 === t2 ? 55 : 54, r2 = 1, n2 = this.input.charCodeAt(this.state.pos + 1);
        42 === t2 && 42 === n2 && (r2++, n2 = this.input.charCodeAt(this.state.pos + 2), e2 = 57), 61 !== n2 || this.state.inType || (r2++, e2 = 37 === t2 ? 33 : 30), this.finishOp(e2, r2);
      }
      readToken_pipe_amp(t2) {
        const e2 = this.input.charCodeAt(this.state.pos + 1);
        if (e2 !== t2) {
          if (124 === t2) {
            if (62 === e2)
              return void this.finishOp(39, 2);
            if (this.hasPlugin("recordAndTuple") && 125 === e2) {
              if ("bar" !== this.getPluginOption("recordAndTuple", "syntaxType"))
                throw this.raise(xn.RecordExpressionBarIncorrectEndSyntaxType, { at: this.state.curPosition() });
              return this.state.pos += 2, void this.finishToken(9);
            }
            if (this.hasPlugin("recordAndTuple") && 93 === e2) {
              if ("bar" !== this.getPluginOption("recordAndTuple", "syntaxType"))
                throw this.raise(xn.TupleExpressionBarIncorrectEndSyntaxType, { at: this.state.curPosition() });
              return this.state.pos += 2, void this.finishToken(4);
            }
          }
          61 !== e2 ? this.finishOp(124 === t2 ? 43 : 45, 1) : this.finishOp(30, 2);
        } else
          61 === this.input.charCodeAt(this.state.pos + 2) ? this.finishOp(30, 3) : this.finishOp(124 === t2 ? 41 : 42, 2);
      }
      readToken_caret() {
        const t2 = this.input.charCodeAt(this.state.pos + 1);
        if (61 !== t2 || this.state.inType)
          if (94 === t2 && this.hasPlugin(["pipelineOperator", { proposal: "hack", topicToken: "^^" }])) {
            this.finishOp(37, 2);
            94 === this.input.codePointAt(this.state.pos) && this.unexpected();
          } else
            this.finishOp(44, 1);
        else
          this.finishOp(32, 2);
      }
      readToken_atSign() {
        64 === this.input.charCodeAt(this.state.pos + 1) && this.hasPlugin(["pipelineOperator", { proposal: "hack", topicToken: "@@" }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
      }
      readToken_plus_min(t2) {
        const e2 = this.input.charCodeAt(this.state.pos + 1);
        e2 !== t2 ? 61 === e2 ? this.finishOp(30, 2) : this.finishOp(53, 1) : this.finishOp(34, 2);
      }
      readToken_lt() {
        const { pos: t2 } = this.state, e2 = this.input.charCodeAt(t2 + 1);
        if (60 === e2)
          return 61 === this.input.charCodeAt(t2 + 2) ? void this.finishOp(30, 3) : void this.finishOp(51, 2);
        61 !== e2 ? this.finishOp(47, 1) : this.finishOp(49, 2);
      }
      readToken_gt() {
        const { pos: t2 } = this.state, e2 = this.input.charCodeAt(t2 + 1);
        if (62 === e2) {
          const e3 = 62 === this.input.charCodeAt(t2 + 2) ? 3 : 2;
          return 61 === this.input.charCodeAt(t2 + e3) ? void this.finishOp(30, e3 + 1) : void this.finishOp(52, e3);
        }
        61 !== e2 ? this.finishOp(48, 1) : this.finishOp(49, 2);
      }
      readToken_eq_excl(t2) {
        const e2 = this.input.charCodeAt(this.state.pos + 1);
        if (61 !== e2)
          return 61 === t2 && 62 === e2 ? (this.state.pos += 2, void this.finishToken(19)) : void this.finishOp(61 === t2 ? 29 : 35, 1);
        this.finishOp(46, 61 === this.input.charCodeAt(this.state.pos + 2) ? 3 : 2);
      }
      readToken_question() {
        const t2 = this.input.charCodeAt(this.state.pos + 1), e2 = this.input.charCodeAt(this.state.pos + 2);
        63 === t2 ? 61 === e2 ? this.finishOp(30, 3) : this.finishOp(40, 2) : 46 !== t2 || e2 >= 48 && e2 <= 57 ? (++this.state.pos, this.finishToken(17)) : (this.state.pos += 2, this.finishToken(18));
      }
      getTokenFromCode(t2) {
        switch (t2) {
          case 46:
            return void this.readToken_dot();
          case 40:
            return ++this.state.pos, void this.finishToken(10);
          case 41:
            return ++this.state.pos, void this.finishToken(11);
          case 59:
            return ++this.state.pos, void this.finishToken(13);
          case 44:
            return ++this.state.pos, void this.finishToken(12);
          case 91:
            if (this.hasPlugin("recordAndTuple") && 124 === this.input.charCodeAt(this.state.pos + 1)) {
              if ("bar" !== this.getPluginOption("recordAndTuple", "syntaxType"))
                throw this.raise(xn.TupleExpressionBarIncorrectStartSyntaxType, { at: this.state.curPosition() });
              this.state.pos += 2, this.finishToken(2);
            } else
              ++this.state.pos, this.finishToken(0);
            return;
          case 93:
            return ++this.state.pos, void this.finishToken(3);
          case 123:
            if (this.hasPlugin("recordAndTuple") && 124 === this.input.charCodeAt(this.state.pos + 1)) {
              if ("bar" !== this.getPluginOption("recordAndTuple", "syntaxType"))
                throw this.raise(xn.RecordExpressionBarIncorrectStartSyntaxType, { at: this.state.curPosition() });
              this.state.pos += 2, this.finishToken(6);
            } else
              ++this.state.pos, this.finishToken(5);
            return;
          case 125:
            return ++this.state.pos, void this.finishToken(8);
          case 58:
            return void (this.hasPlugin("functionBind") && 58 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(15, 2) : (++this.state.pos, this.finishToken(14)));
          case 63:
            return void this.readToken_question();
          case 96:
            return void this.readTemplateToken();
          case 48: {
            const t3 = this.input.charCodeAt(this.state.pos + 1);
            if (120 === t3 || 88 === t3)
              return void this.readRadixNumber(16);
            if (111 === t3 || 79 === t3)
              return void this.readRadixNumber(8);
            if (98 === t3 || 66 === t3)
              return void this.readRadixNumber(2);
          }
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
            return void this.readNumber(false);
          case 34:
          case 39:
            return void this.readString(t2);
          case 47:
            return void this.readToken_slash();
          case 37:
          case 42:
            return void this.readToken_mult_modulo(t2);
          case 124:
          case 38:
            return void this.readToken_pipe_amp(t2);
          case 94:
            return void this.readToken_caret();
          case 43:
          case 45:
            return void this.readToken_plus_min(t2);
          case 60:
            return void this.readToken_lt();
          case 62:
            return void this.readToken_gt();
          case 61:
          case 33:
            return void this.readToken_eq_excl(t2);
          case 126:
            return void this.finishOp(36, 1);
          case 64:
            return void this.readToken_atSign();
          case 35:
            return void this.readToken_numberSign();
          case 92:
            return void this.readWord();
          default:
            if (isIdentifierStart(t2))
              return void this.readWord(t2);
        }
        throw this.raise(xn.InvalidOrUnexpectedToken, { at: this.state.curPosition(), unexpected: String.fromCodePoint(t2) });
      }
      finishOp(t2, e2) {
        const r2 = this.input.slice(this.state.pos, this.state.pos + e2);
        this.state.pos += e2, this.finishToken(t2, r2);
      }
      readRegexp() {
        const t2 = this.state.startLoc, e2 = this.state.start + 1;
        let r2, n2, { pos: i2 } = this.state;
        for (; ; ++i2) {
          if (i2 >= this.length)
            throw this.raise(xn.UnterminatedRegExp, { at: createPositionWithColumnOffset(t2, 1) });
          const e3 = this.input.charCodeAt(i2);
          if (isNewLine(e3))
            throw this.raise(xn.UnterminatedRegExp, { at: createPositionWithColumnOffset(t2, 1) });
          if (r2)
            r2 = false;
          else {
            if (91 === e3)
              n2 = true;
            else if (93 === e3 && n2)
              n2 = false;
            else if (47 === e3 && !n2)
              break;
            r2 = 92 === e3;
          }
        }
        const o2 = this.input.slice(e2, i2);
        ++i2;
        let a2 = "";
        const nextPos = () => createPositionWithColumnOffset(t2, i2 + 2 - e2);
        for (; i2 < this.length; ) {
          const t3 = this.codePointAtPos(i2), e3 = String.fromCharCode(t3);
          if (ei.has(t3))
            118 === t3 ? a2.includes("u") && this.raise(xn.IncompatibleRegExpUVFlags, { at: nextPos() }) : 117 === t3 && a2.includes("v") && this.raise(xn.IncompatibleRegExpUVFlags, { at: nextPos() }), a2.includes(e3) && this.raise(xn.DuplicateRegExpFlags, { at: nextPos() });
          else {
            if (!isIdentifierChar(t3) && 92 !== t3)
              break;
            this.raise(xn.MalformedRegExpFlags, { at: nextPos() });
          }
          ++i2, a2 += e3;
        }
        this.state.pos = i2, this.finishToken(137, { pattern: o2, flags: a2 });
      }
      readInt(t2, e2, r2 = false, n2 = true) {
        const { n: i2, pos: o2 } = readInt(this.input, this.state.pos, this.state.lineStart, this.state.curLine, t2, e2, r2, n2, this.errorHandlers_readInt, false);
        return this.state.pos = o2, i2;
      }
      readRadixNumber(t2) {
        const e2 = this.state.curPosition();
        let r2 = false;
        this.state.pos += 2;
        const n2 = this.readInt(t2);
        null == n2 && this.raise(xn.InvalidDigit, { at: createPositionWithColumnOffset(e2, 2), radix: t2 });
        const i2 = this.input.charCodeAt(this.state.pos);
        if (110 === i2)
          ++this.state.pos, r2 = true;
        else if (109 === i2)
          throw this.raise(xn.InvalidDecimal, { at: e2 });
        if (isIdentifierStart(this.codePointAtPos(this.state.pos)))
          throw this.raise(xn.NumberIdentifier, { at: this.state.curPosition() });
        if (r2) {
          const t3 = this.input.slice(e2.index, this.state.pos).replace(/[_n]/g, "");
          this.finishToken(135, t3);
        } else
          this.finishToken(134, n2);
      }
      readNumber(t2) {
        const e2 = this.state.pos, r2 = this.state.curPosition();
        let n2 = false, i2 = false, o2 = false, a2 = false, s2 = false;
        t2 || null !== this.readInt(10) || this.raise(xn.InvalidNumber, { at: this.state.curPosition() });
        const l2 = this.state.pos - e2 >= 2 && 48 === this.input.charCodeAt(e2);
        if (l2) {
          const t3 = this.input.slice(e2, this.state.pos);
          if (this.recordStrictModeErrors(xn.StrictOctalLiteral, { at: r2 }), !this.state.strict) {
            const e3 = t3.indexOf("_");
            e3 > 0 && this.raise(xn.ZeroDigitNumericSeparator, { at: createPositionWithColumnOffset(r2, e3) });
          }
          s2 = l2 && !/[89]/.test(t3);
        }
        let p2 = this.input.charCodeAt(this.state.pos);
        if (46 !== p2 || s2 || (++this.state.pos, this.readInt(10), n2 = true, p2 = this.input.charCodeAt(this.state.pos)), 69 !== p2 && 101 !== p2 || s2 || (p2 = this.input.charCodeAt(++this.state.pos), 43 !== p2 && 45 !== p2 || ++this.state.pos, null === this.readInt(10) && this.raise(xn.InvalidOrMissingExponent, { at: r2 }), n2 = true, a2 = true, p2 = this.input.charCodeAt(this.state.pos)), 110 === p2 && ((n2 || l2) && this.raise(xn.InvalidBigIntLiteral, { at: r2 }), ++this.state.pos, i2 = true), 109 === p2 && (this.expectPlugin("decimal", this.state.curPosition()), (a2 || l2) && this.raise(xn.InvalidDecimal, { at: r2 }), ++this.state.pos, o2 = true), isIdentifierStart(this.codePointAtPos(this.state.pos)))
          throw this.raise(xn.NumberIdentifier, { at: this.state.curPosition() });
        const c2 = this.input.slice(e2, this.state.pos).replace(/[_mn]/g, "");
        if (i2)
          return void this.finishToken(135, c2);
        if (o2)
          return void this.finishToken(136, c2);
        const d2 = s2 ? parseInt(c2, 8) : parseFloat(c2);
        this.finishToken(134, d2);
      }
      readCodePoint(t2) {
        const { code: e2, pos: r2 } = readCodePoint(this.input, this.state.pos, this.state.lineStart, this.state.curLine, t2, this.errorHandlers_readCodePoint);
        return this.state.pos = r2, e2;
      }
      readString(t2) {
        const { str: e2, pos: r2, curLine: n2, lineStart: i2 } = readStringContents(34 === t2 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
        this.state.pos = r2 + 1, this.state.lineStart = i2, this.state.curLine = n2, this.finishToken(133, e2);
      }
      readTemplateContinuation() {
        this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
      }
      readTemplateToken() {
        const t2 = this.input[this.state.pos], { str: e2, firstInvalidLoc: r2, pos: n2, curLine: i2, lineStart: o2 } = readStringContents("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
        this.state.pos = n2 + 1, this.state.lineStart = o2, this.state.curLine = i2, r2 && (this.state.firstInvalidTemplateEscapePos = new Position(r2.curLine, r2.pos - r2.lineStart, r2.pos)), 96 === this.input.codePointAt(n2) ? this.finishToken(24, r2 ? null : t2 + e2 + "`") : (this.state.pos++, this.finishToken(25, r2 ? null : t2 + e2 + "${"));
      }
      recordStrictModeErrors(t2, { at: e2 }) {
        const r2 = e2.index;
        this.state.strict && !this.state.strictErrors.has(r2) ? this.raise(t2, { at: e2 }) : this.state.strictErrors.set(r2, [t2, e2]);
      }
      readWord1(t2) {
        this.state.containsEsc = false;
        let e2 = "";
        const r2 = this.state.pos;
        let n2 = this.state.pos;
        for (void 0 !== t2 && (this.state.pos += t2 <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
          const t3 = this.codePointAtPos(this.state.pos);
          if (isIdentifierChar(t3))
            this.state.pos += t3 <= 65535 ? 1 : 2;
          else {
            if (92 !== t3)
              break;
            {
              this.state.containsEsc = true, e2 += this.input.slice(n2, this.state.pos);
              const t4 = this.state.curPosition(), i2 = this.state.pos === r2 ? isIdentifierStart : isIdentifierChar;
              if (117 !== this.input.charCodeAt(++this.state.pos)) {
                this.raise(xn.MissingUnicodeEscape, { at: this.state.curPosition() }), n2 = this.state.pos - 1;
                continue;
              }
              ++this.state.pos;
              const o2 = this.readCodePoint(true);
              null !== o2 && (i2(o2) || this.raise(xn.EscapedCharNotAnIdentifier, { at: t4 }), e2 += String.fromCodePoint(o2)), n2 = this.state.pos;
            }
          }
        }
        return e2 + this.input.slice(n2, this.state.pos);
      }
      readWord(t2) {
        const e2 = this.readWord1(t2), r2 = En.get(e2);
        void 0 !== r2 ? this.finishToken(r2, tokenLabelName(r2)) : this.finishToken(132, e2);
      }
      checkKeywordEscapes() {
        const { type: t2 } = this.state;
        tokenIsKeyword(t2) && this.state.containsEsc && this.raise(xn.InvalidEscapedReservedWord, { at: this.state.startLoc, reservedWord: tokenLabelName(t2) });
      }
      raise(t2, e2) {
        const { at: r2 } = e2, n2 = _objectWithoutPropertiesLoose(e2, Zn), i2 = t2({ loc: r2 instanceof Position ? r2 : r2.loc.start, details: n2 });
        if (!this.options.errorRecovery)
          throw i2;
        return this.isLookahead || this.state.errors.push(i2), i2;
      }
      raiseOverwrite(t2, e2) {
        const { at: r2 } = e2, n2 = _objectWithoutPropertiesLoose(e2, ti), i2 = r2 instanceof Position ? r2 : r2.loc.start, o2 = i2.index, a2 = this.state.errors;
        for (let e3 = a2.length - 1; e3 >= 0; e3--) {
          const r3 = a2[e3];
          if (r3.loc.index === o2)
            return a2[e3] = t2({ loc: i2, details: n2 });
          if (r3.loc.index < o2)
            break;
        }
        return this.raise(t2, e2);
      }
      updateContext(t2) {
      }
      unexpected(t2, e2) {
        throw this.raise(xn.UnexpectedToken, { expected: e2 ? tokenLabelName(e2) : null, at: null != t2 ? t2 : this.state.startLoc });
      }
      expectPlugin(t2, e2) {
        if (this.hasPlugin(t2))
          return true;
        throw this.raise(xn.MissingPlugin, { at: null != e2 ? e2 : this.state.startLoc, missingPlugin: [t2] });
      }
      expectOnePlugin(t2) {
        if (!t2.some((t3) => this.hasPlugin(t3)))
          throw this.raise(xn.MissingOneOfPlugins, { at: this.state.startLoc, missingPlugin: t2 });
      }
      errorBuilder(t2) {
        return (e2, r2, n2) => {
          this.raise(t2, { at: buildPosition(e2, r2, n2) });
        };
      }
    }
    class ClassScope {
      constructor() {
        this.privateNames = /* @__PURE__ */ new Set(), this.loneAccessors = /* @__PURE__ */ new Map(), this.undefinedPrivateNames = /* @__PURE__ */ new Map();
      }
    }
    class ClassScopeHandler {
      constructor(t2) {
        this.parser = void 0, this.stack = [], this.undefinedPrivateNames = /* @__PURE__ */ new Map(), this.parser = t2;
      }
      current() {
        return this.stack[this.stack.length - 1];
      }
      enter() {
        this.stack.push(new ClassScope());
      }
      exit() {
        const t2 = this.stack.pop(), e2 = this.current();
        for (const [r2, n2] of Array.from(t2.undefinedPrivateNames))
          e2 ? e2.undefinedPrivateNames.has(r2) || e2.undefinedPrivateNames.set(r2, n2) : this.parser.raise(xn.InvalidPrivateFieldResolution, { at: n2, identifierName: r2 });
      }
      declarePrivateName(t2, e2, r2) {
        const { privateNames: n2, loneAccessors: i2, undefinedPrivateNames: o2 } = this.current();
        let a2 = n2.has(t2);
        if (3 & e2) {
          const r3 = a2 && i2.get(t2);
          if (r3) {
            a2 = (3 & r3) === (3 & e2) || (4 & r3) !== (4 & e2), a2 || i2.delete(t2);
          } else
            a2 || i2.set(t2, e2);
        }
        a2 && this.parser.raise(xn.PrivateNameRedeclaration, { at: r2, identifierName: t2 }), n2.add(t2), o2.delete(t2);
      }
      usePrivateName(t2, e2) {
        let r2;
        for (r2 of this.stack)
          if (r2.privateNames.has(t2))
            return;
        r2 ? r2.undefinedPrivateNames.set(t2, e2) : this.parser.raise(xn.InvalidPrivateFieldResolution, { at: e2, identifierName: t2 });
      }
    }
    class ExpressionScope {
      constructor(t2 = 0) {
        this.type = t2;
      }
      canBeArrowParameterDeclaration() {
        return 2 === this.type || 1 === this.type;
      }
      isCertainlyParameterDeclaration() {
        return 3 === this.type;
      }
    }
    class ArrowHeadParsingScope extends ExpressionScope {
      constructor(t2) {
        super(t2), this.declarationErrors = /* @__PURE__ */ new Map();
      }
      recordDeclarationError(t2, { at: e2 }) {
        const r2 = e2.index;
        this.declarationErrors.set(r2, [t2, e2]);
      }
      clearDeclarationError(t2) {
        this.declarationErrors.delete(t2);
      }
      iterateErrors(t2) {
        this.declarationErrors.forEach(t2);
      }
    }
    class ExpressionScopeHandler {
      constructor(t2) {
        this.parser = void 0, this.stack = [new ExpressionScope()], this.parser = t2;
      }
      enter(t2) {
        this.stack.push(t2);
      }
      exit() {
        this.stack.pop();
      }
      recordParameterInitializerError(t2, { at: e2 }) {
        const r2 = { at: e2.loc.start }, { stack: n2 } = this;
        let i2 = n2.length - 1, o2 = n2[i2];
        for (; !o2.isCertainlyParameterDeclaration(); ) {
          if (!o2.canBeArrowParameterDeclaration())
            return;
          o2.recordDeclarationError(t2, r2), o2 = n2[--i2];
        }
        this.parser.raise(t2, r2);
      }
      recordArrowParameterBindingError(t2, { at: e2 }) {
        const { stack: r2 } = this, n2 = r2[r2.length - 1], i2 = { at: e2.loc.start };
        if (n2.isCertainlyParameterDeclaration())
          this.parser.raise(t2, i2);
        else {
          if (!n2.canBeArrowParameterDeclaration())
            return;
          n2.recordDeclarationError(t2, i2);
        }
      }
      recordAsyncArrowParametersError({ at: t2 }) {
        const { stack: e2 } = this;
        let r2 = e2.length - 1, n2 = e2[r2];
        for (; n2.canBeArrowParameterDeclaration(); )
          2 === n2.type && n2.recordDeclarationError(xn.AwaitBindingIdentifier, { at: t2 }), n2 = e2[--r2];
      }
      validateAsPattern() {
        const { stack: t2 } = this, e2 = t2[t2.length - 1];
        e2.canBeArrowParameterDeclaration() && e2.iterateErrors(([e3, r2]) => {
          this.parser.raise(e3, { at: r2 });
          let n2 = t2.length - 2, i2 = t2[n2];
          for (; i2.canBeArrowParameterDeclaration(); )
            i2.clearDeclarationError(r2.index), i2 = t2[--n2];
        });
      }
    }
    function newExpressionScope() {
      return new ExpressionScope();
    }
    class ProductionParameterHandler {
      constructor() {
        this.stacks = [];
      }
      enter(t2) {
        this.stacks.push(t2);
      }
      exit() {
        this.stacks.pop();
      }
      currentFlags() {
        return this.stacks[this.stacks.length - 1];
      }
      get hasAwait() {
        return (2 & this.currentFlags()) > 0;
      }
      get hasYield() {
        return (1 & this.currentFlags()) > 0;
      }
      get hasReturn() {
        return (4 & this.currentFlags()) > 0;
      }
      get hasIn() {
        return (8 & this.currentFlags()) > 0;
      }
    }
    function functionFlags(t2, e2) {
      return (t2 ? 2 : 0) | (e2 ? 1 : 0);
    }
    class UtilParser extends Tokenizer {
      addExtra(t2, e2, r2, n2 = true) {
        if (!t2)
          return;
        const i2 = t2.extra = t2.extra || {};
        n2 ? i2[e2] = r2 : Object.defineProperty(i2, e2, { enumerable: n2, value: r2 });
      }
      isContextual(t2) {
        return this.state.type === t2 && !this.state.containsEsc;
      }
      isUnparsedContextual(t2, e2) {
        const r2 = t2 + e2.length;
        if (this.input.slice(t2, r2) === e2) {
          const t3 = this.input.charCodeAt(r2);
          return !(isIdentifierChar(t3) || 55296 == (64512 & t3));
        }
        return false;
      }
      isLookaheadContextual(t2) {
        const e2 = this.nextTokenStart();
        return this.isUnparsedContextual(e2, t2);
      }
      eatContextual(t2) {
        return !!this.isContextual(t2) && (this.next(), true);
      }
      expectContextual(t2, e2) {
        if (!this.eatContextual(t2)) {
          if (null != e2)
            throw this.raise(e2, { at: this.state.startLoc });
          this.unexpected(null, t2);
        }
      }
      canInsertSemicolon() {
        return this.match(139) || this.match(8) || this.hasPrecedingLineBreak();
      }
      hasPrecedingLineBreak() {
        return Wn.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
      }
      hasFollowingLineBreak() {
        return Yn.lastIndex = this.state.end, Yn.test(this.input);
      }
      isLineTerminator() {
        return this.eat(13) || this.canInsertSemicolon();
      }
      semicolon(t2 = true) {
        (t2 ? this.isLineTerminator() : this.eat(13)) || this.raise(xn.MissingSemicolon, { at: this.state.lastTokEndLoc });
      }
      expect(t2, e2) {
        this.eat(t2) || this.unexpected(e2, t2);
      }
      tryParse(t2, e2 = this.state.clone()) {
        const r2 = { node: null };
        try {
          const n2 = t2((t3 = null) => {
            throw r2.node = t3, r2;
          });
          if (this.state.errors.length > e2.errors.length) {
            const t3 = this.state;
            return this.state = e2, this.state.tokensLength = t3.tokensLength, { node: n2, error: t3.errors[e2.errors.length], thrown: false, aborted: false, failState: t3 };
          }
          return { node: n2, error: null, thrown: false, aborted: false, failState: null };
        } catch (t3) {
          const n2 = this.state;
          if (this.state = e2, t3 instanceof SyntaxError)
            return { node: null, error: t3, thrown: true, aborted: false, failState: n2 };
          if (t3 === r2)
            return { node: r2.node, error: null, thrown: false, aborted: true, failState: n2 };
          throw t3;
        }
      }
      checkExpressionErrors(t2, e2) {
        if (!t2)
          return false;
        const { shorthandAssignLoc: r2, doubleProtoLoc: n2, privateKeyLoc: i2, optionalParametersLoc: o2 } = t2;
        if (!e2)
          return !!(r2 || n2 || o2 || i2);
        null != r2 && this.raise(xn.InvalidCoverInitializedName, { at: r2 }), null != n2 && this.raise(xn.DuplicateProto, { at: n2 }), null != i2 && this.raise(xn.UnexpectedPrivateField, { at: i2 }), null != o2 && this.unexpected(o2);
      }
      isLiteralPropertyName() {
        return tokenIsLiteralPropertyName(this.state.type);
      }
      isPrivateName(t2) {
        return "PrivateName" === t2.type;
      }
      getPrivateNameSV(t2) {
        return t2.id.name;
      }
      hasPropertyAsPrivateName(t2) {
        return ("MemberExpression" === t2.type || "OptionalMemberExpression" === t2.type) && this.isPrivateName(t2.property);
      }
      isObjectProperty(t2) {
        return "ObjectProperty" === t2.type;
      }
      isObjectMethod(t2) {
        return "ObjectMethod" === t2.type;
      }
      initializeScopes(t2 = "module" === this.options.sourceType) {
        const e2 = this.state.labels;
        this.state.labels = [];
        const r2 = this.exportedIdentifiers;
        this.exportedIdentifiers = /* @__PURE__ */ new Set();
        const n2 = this.inModule;
        this.inModule = t2;
        const i2 = this.scope, o2 = this.getScopeHandler();
        this.scope = new o2(this, t2);
        const a2 = this.prodParam;
        this.prodParam = new ProductionParameterHandler();
        const s2 = this.classScope;
        this.classScope = new ClassScopeHandler(this);
        const l2 = this.expressionScope;
        return this.expressionScope = new ExpressionScopeHandler(this), () => {
          this.state.labels = e2, this.exportedIdentifiers = r2, this.inModule = n2, this.scope = i2, this.prodParam = a2, this.classScope = s2, this.expressionScope = l2;
        };
      }
      enterInitialScopes() {
        let t2 = 0;
        this.inModule && (t2 |= 2), this.scope.enter(1), this.prodParam.enter(t2);
      }
      checkDestructuringPrivate(t2) {
        const { privateKeyLoc: e2 } = t2;
        null !== e2 && this.expectPlugin("destructuringPrivate", e2);
      }
    }
    class ExpressionErrors {
      constructor() {
        this.shorthandAssignLoc = null, this.doubleProtoLoc = null, this.privateKeyLoc = null, this.optionalParametersLoc = null;
      }
    }
    let ri = class {
      constructor(t2, e2, r2) {
        this.type = "", this.start = e2, this.end = 0, this.loc = new SourceLocation(r2), null != t2 && t2.options.ranges && (this.range = [e2, 0]), null != t2 && t2.filename && (this.loc.filename = t2.filename);
      }
    };
    const ni = ri.prototype;
    function cloneIdentifier(t2) {
      const { type: e2, start: r2, end: n2, loc: i2, range: o2, extra: a2, name: s2 } = t2, l2 = Object.create(ni);
      return l2.type = e2, l2.start = r2, l2.end = n2, l2.loc = i2, l2.range = o2, l2.extra = a2, l2.name = s2, "Placeholder" === e2 && (l2.expectedNode = t2.expectedNode), l2;
    }
    function cloneStringLiteral(t2) {
      const { type: e2, start: r2, end: n2, loc: i2, range: o2, extra: a2 } = t2;
      if ("Placeholder" === e2)
        return function(t3) {
          return cloneIdentifier(t3);
        }(t2);
      const s2 = Object.create(ni);
      return s2.type = e2, s2.start = r2, s2.end = n2, s2.loc = i2, s2.range = o2, void 0 !== t2.raw ? s2.raw = t2.raw : s2.extra = a2, s2.value = t2.value, s2;
    }
    ni.__clone = function() {
      const t2 = new ri(void 0, this.start, this.loc.start), e2 = Object.keys(this);
      for (let r2 = 0, n2 = e2.length; r2 < n2; r2++) {
        const n3 = e2[r2];
        "leadingComments" !== n3 && "trailingComments" !== n3 && "innerComments" !== n3 && (t2[n3] = this[n3]);
      }
      return t2;
    };
    class NodeUtils extends UtilParser {
      startNode() {
        return new ri(this, this.state.start, this.state.startLoc);
      }
      startNodeAt(t2) {
        return new ri(this, t2.index, t2);
      }
      startNodeAtNode(t2) {
        return this.startNodeAt(t2.loc.start);
      }
      finishNode(t2, e2) {
        return this.finishNodeAt(t2, e2, this.state.lastTokEndLoc);
      }
      finishNodeAt(t2, e2, r2) {
        return t2.type = e2, t2.end = r2.index, t2.loc.end = r2, this.options.ranges && (t2.range[1] = r2.index), this.options.attachComment && this.processComment(t2), t2;
      }
      resetStartLocation(t2, e2) {
        t2.start = e2.index, t2.loc.start = e2, this.options.ranges && (t2.range[0] = e2.index);
      }
      resetEndLocation(t2, e2 = this.state.lastTokEndLoc) {
        t2.end = e2.index, t2.loc.end = e2, this.options.ranges && (t2.range[1] = e2.index);
      }
      resetStartLocationFromNode(t2, e2) {
        this.resetStartLocation(t2, e2.loc.start);
      }
    }
    const ii = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]), oi = ParseErrorEnum`flow`({ AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.", AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.", AssignReservedType: ({ reservedType: t2 }) => `Cannot overwrite reserved type ${t2}.`, DeclareClassElement: "The `declare` modifier can only appear on class fields.", DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.", DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.", EnumBooleanMemberNotInitialized: ({ memberName: t2, enumName: e2 }) => `Boolean enum members need to be initialized. Use either \`${t2} = true,\` or \`${t2} = false,\` in enum \`${e2}\`.`, EnumDuplicateMemberName: ({ memberName: t2, enumName: e2 }) => `Enum member names need to be unique, but the name \`${t2}\` has already been used before in enum \`${e2}\`.`, EnumInconsistentMemberValues: ({ enumName: t2 }) => `Enum \`${t2}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`, EnumInvalidExplicitType: ({ invalidEnumType: t2, enumName: e2 }) => `Enum type \`${t2}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${e2}\`.`, EnumInvalidExplicitTypeUnknownSupplied: ({ enumName: t2 }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${t2}\`.`, EnumInvalidMemberInitializerPrimaryType: ({ enumName: t2, memberName: e2, explicitType: r2 }) => `Enum \`${t2}\` has type \`${r2}\`, so the initializer of \`${e2}\` needs to be a ${r2} literal.`, EnumInvalidMemberInitializerSymbolType: ({ enumName: t2, memberName: e2 }) => `Symbol enum members cannot be initialized. Use \`${e2},\` in enum \`${t2}\`.`, EnumInvalidMemberInitializerUnknownType: ({ enumName: t2, memberName: e2 }) => `The enum member initializer for \`${e2}\` needs to be a literal (either a boolean, number, or string) in enum \`${t2}\`.`, EnumInvalidMemberName: ({ enumName: t2, memberName: e2, suggestion: r2 }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${e2}\`, consider using \`${r2}\`, in enum \`${t2}\`.`, EnumNumberMemberNotInitialized: ({ enumName: t2, memberName: e2 }) => `Number enum members need to be initialized, e.g. \`${e2} = 1\` in enum \`${t2}\`.`, EnumStringMemberInconsistentlyInitialized: ({ enumName: t2 }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${t2}\`.`, GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.", ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.", ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.", InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.", InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.", InexactVariance: "Explicit inexact syntax cannot have variance.", InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.", MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.", NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.", NestedFlowComment: "Cannot have a flow comment inside another flow comment.", PatternIsOptional: Object.assign({ message: "A binding pattern parameter cannot be optional in an implementation signature." }, { reasonCode: "OptionalBindingPattern" }), SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.", SpreadVariance: "Spread properties cannot have variance.", ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.", ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.", ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.", ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.", ThisParamNoDefault: "The `this` parameter may not have a default value.", TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.", UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.", UnexpectedReservedType: ({ reservedType: t2 }) => `Unexpected reserved type ${t2}.`, UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.", UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.", UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.", UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".', UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.", UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.", UnsupportedDeclareExportKind: ({ unsupportedExportKind: t2, suggestion: e2 }) => `\`declare export ${t2}\` is not supported. Use \`${e2}\` instead.`, UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.", UnterminatedFlowComment: "Unterminated flow-comment." });
    function hasTypeImportKind(t2) {
      return "type" === t2.importKind || "typeof" === t2.importKind;
    }
    const ai = { const: "declare export var", let: "declare export var", type: "export type", interface: "export interface" };
    const si = /\*?\s*@((?:no)?flow)\b/;
    const li = { __proto__: null, quot: '"', amp: "&", apos: "'", lt: "<", gt: ">", nbsp: "\xA0", iexcl: "\xA1", cent: "\xA2", pound: "\xA3", curren: "\xA4", yen: "\xA5", brvbar: "\xA6", sect: "\xA7", uml: "\xA8", copy: "\xA9", ordf: "\xAA", laquo: "\xAB", not: "\xAC", shy: "\xAD", reg: "\xAE", macr: "\xAF", deg: "\xB0", plusmn: "\xB1", sup2: "\xB2", sup3: "\xB3", acute: "\xB4", micro: "\xB5", para: "\xB6", middot: "\xB7", cedil: "\xB8", sup1: "\xB9", ordm: "\xBA", raquo: "\xBB", frac14: "\xBC", frac12: "\xBD", frac34: "\xBE", iquest: "\xBF", Agrave: "\xC0", Aacute: "\xC1", Acirc: "\xC2", Atilde: "\xC3", Auml: "\xC4", Aring: "\xC5", AElig: "\xC6", Ccedil: "\xC7", Egrave: "\xC8", Eacute: "\xC9", Ecirc: "\xCA", Euml: "\xCB", Igrave: "\xCC", Iacute: "\xCD", Icirc: "\xCE", Iuml: "\xCF", ETH: "\xD0", Ntilde: "\xD1", Ograve: "\xD2", Oacute: "\xD3", Ocirc: "\xD4", Otilde: "\xD5", Ouml: "\xD6", times: "\xD7", Oslash: "\xD8", Ugrave: "\xD9", Uacute: "\xDA", Ucirc: "\xDB", Uuml: "\xDC", Yacute: "\xDD", THORN: "\xDE", szlig: "\xDF", agrave: "\xE0", aacute: "\xE1", acirc: "\xE2", atilde: "\xE3", auml: "\xE4", aring: "\xE5", aelig: "\xE6", ccedil: "\xE7", egrave: "\xE8", eacute: "\xE9", ecirc: "\xEA", euml: "\xEB", igrave: "\xEC", iacute: "\xED", icirc: "\xEE", iuml: "\xEF", eth: "\xF0", ntilde: "\xF1", ograve: "\xF2", oacute: "\xF3", ocirc: "\xF4", otilde: "\xF5", ouml: "\xF6", divide: "\xF7", oslash: "\xF8", ugrave: "\xF9", uacute: "\xFA", ucirc: "\xFB", uuml: "\xFC", yacute: "\xFD", thorn: "\xFE", yuml: "\xFF", OElig: "\u0152", oelig: "\u0153", Scaron: "\u0160", scaron: "\u0161", Yuml: "\u0178", fnof: "\u0192", circ: "\u02C6", tilde: "\u02DC", Alpha: "\u0391", Beta: "\u0392", Gamma: "\u0393", Delta: "\u0394", Epsilon: "\u0395", Zeta: "\u0396", Eta: "\u0397", Theta: "\u0398", Iota: "\u0399", Kappa: "\u039A", Lambda: "\u039B", Mu: "\u039C", Nu: "\u039D", Xi: "\u039E", Omicron: "\u039F", Pi: "\u03A0", Rho: "\u03A1", Sigma: "\u03A3", Tau: "\u03A4", Upsilon: "\u03A5", Phi: "\u03A6", Chi: "\u03A7", Psi: "\u03A8", Omega: "\u03A9", alpha: "\u03B1", beta: "\u03B2", gamma: "\u03B3", delta: "\u03B4", epsilon: "\u03B5", zeta: "\u03B6", eta: "\u03B7", theta: "\u03B8", iota: "\u03B9", kappa: "\u03BA", lambda: "\u03BB", mu: "\u03BC", nu: "\u03BD", xi: "\u03BE", omicron: "\u03BF", pi: "\u03C0", rho: "\u03C1", sigmaf: "\u03C2", sigma: "\u03C3", tau: "\u03C4", upsilon: "\u03C5", phi: "\u03C6", chi: "\u03C7", psi: "\u03C8", omega: "\u03C9", thetasym: "\u03D1", upsih: "\u03D2", piv: "\u03D6", ensp: "\u2002", emsp: "\u2003", thinsp: "\u2009", zwnj: "\u200C", zwj: "\u200D", lrm: "\u200E", rlm: "\u200F", ndash: "\u2013", mdash: "\u2014", lsquo: "\u2018", rsquo: "\u2019", sbquo: "\u201A", ldquo: "\u201C", rdquo: "\u201D", bdquo: "\u201E", dagger: "\u2020", Dagger: "\u2021", bull: "\u2022", hellip: "\u2026", permil: "\u2030", prime: "\u2032", Prime: "\u2033", lsaquo: "\u2039", rsaquo: "\u203A", oline: "\u203E", frasl: "\u2044", euro: "\u20AC", image: "\u2111", weierp: "\u2118", real: "\u211C", trade: "\u2122", alefsym: "\u2135", larr: "\u2190", uarr: "\u2191", rarr: "\u2192", darr: "\u2193", harr: "\u2194", crarr: "\u21B5", lArr: "\u21D0", uArr: "\u21D1", rArr: "\u21D2", dArr: "\u21D3", hArr: "\u21D4", forall: "\u2200", part: "\u2202", exist: "\u2203", empty: "\u2205", nabla: "\u2207", isin: "\u2208", notin: "\u2209", ni: "\u220B", prod: "\u220F", sum: "\u2211", minus: "\u2212", lowast: "\u2217", radic: "\u221A", prop: "\u221D", infin: "\u221E", ang: "\u2220", and: "\u2227", or: "\u2228", cap: "\u2229", cup: "\u222A", int: "\u222B", there4: "\u2234", sim: "\u223C", cong: "\u2245", asymp: "\u2248", ne: "\u2260", equiv: "\u2261", le: "\u2264", ge: "\u2265", sub: "\u2282", sup: "\u2283", nsub: "\u2284", sube: "\u2286", supe: "\u2287", oplus: "\u2295", otimes: "\u2297", perp: "\u22A5", sdot: "\u22C5", lceil: "\u2308", rceil: "\u2309", lfloor: "\u230A", rfloor: "\u230B", lang: "\u2329", rang: "\u232A", loz: "\u25CA", spades: "\u2660", clubs: "\u2663", hearts: "\u2665", diams: "\u2666" }, pi = ParseErrorEnum`jsx`({ AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.", MissingClosingTagElement: ({ openingTagName: t2 }) => `Expected corresponding JSX closing tag for <${t2}>.`, MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.", UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?", UnexpectedToken: ({ unexpected: t2, HTMLEntity: e2 }) => `Unexpected token \`${t2}\`. Did you mean \`${e2}\` or \`{'${t2}'}\`?`, UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.", UnterminatedJsxContent: "Unterminated JSX contents.", UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?" });
    function isFragment(t2) {
      return !!t2 && ("JSXOpeningFragment" === t2.type || "JSXClosingFragment" === t2.type);
    }
    function getQualifiedJSXName(t2) {
      if ("JSXIdentifier" === t2.type)
        return t2.name;
      if ("JSXNamespacedName" === t2.type)
        return t2.namespace.name + ":" + t2.name.name;
      if ("JSXMemberExpression" === t2.type)
        return getQualifiedJSXName(t2.object) + "." + getQualifiedJSXName(t2.property);
      throw new Error("Node had unexpected type: " + t2.type);
    }
    class TypeScriptScope extends Scope {
      constructor(...t2) {
        super(...t2), this.types = /* @__PURE__ */ new Set(), this.enums = /* @__PURE__ */ new Set(), this.constEnums = /* @__PURE__ */ new Set(), this.classes = /* @__PURE__ */ new Set(), this.exportOnlyBindings = /* @__PURE__ */ new Set();
      }
    }
    class TypeScriptScopeHandler extends ScopeHandler {
      constructor(...t2) {
        super(...t2), this.importsStack = [];
      }
      createScope(t2) {
        return this.importsStack.push(/* @__PURE__ */ new Set()), new TypeScriptScope(t2);
      }
      enter(t2) {
        256 == t2 && this.importsStack.push(/* @__PURE__ */ new Set()), super.enter(t2);
      }
      exit() {
        const t2 = super.exit();
        return 256 == t2 && this.importsStack.pop(), t2;
      }
      hasImport(t2, e2) {
        const r2 = this.importsStack.length;
        if (this.importsStack[r2 - 1].has(t2))
          return true;
        if (!e2 && r2 > 1) {
          for (let e3 = 0; e3 < r2 - 1; e3++)
            if (this.importsStack[e3].has(t2))
              return true;
        }
        return false;
      }
      declareName(t2, e2, r2) {
        if (4096 & e2)
          return this.hasImport(t2, true) && this.parser.raise(xn.VarRedeclaration, { at: r2, identifierName: t2 }), void this.importsStack[this.importsStack.length - 1].add(t2);
        const n2 = this.currentScope();
        if (1024 & e2)
          return this.maybeExportDefined(n2, t2), void n2.exportOnlyBindings.add(t2);
        super.declareName(t2, e2, r2), 2 & e2 && (1 & e2 || (this.checkRedeclarationInScope(n2, t2, e2, r2), this.maybeExportDefined(n2, t2)), n2.types.add(t2)), 256 & e2 && n2.enums.add(t2), 512 & e2 && n2.constEnums.add(t2), 128 & e2 && n2.classes.add(t2);
      }
      isRedeclaredInScope(t2, e2, r2) {
        if (t2.enums.has(e2)) {
          if (256 & r2) {
            return !!(512 & r2) !== t2.constEnums.has(e2);
          }
          return true;
        }
        return 128 & r2 && t2.classes.has(e2) ? !!t2.lexical.has(e2) && !!(1 & r2) : !!(2 & r2 && t2.types.has(e2)) || super.isRedeclaredInScope(t2, e2, r2);
      }
      checkLocalExport(t2) {
        const { name: e2 } = t2;
        if (this.hasImport(e2))
          return;
        for (let t3 = this.scopeStack.length - 1; t3 >= 0; t3--) {
          const r2 = this.scopeStack[t3];
          if (r2.types.has(e2) || r2.exportOnlyBindings.has(e2))
            return;
        }
        super.checkLocalExport(t2);
      }
    }
    const unwrapParenthesizedExpression = (t2) => "ParenthesizedExpression" === t2.type ? unwrapParenthesizedExpression(t2.expression) : t2;
    class LValParser extends NodeUtils {
      toAssignable(t2, e2 = false) {
        var r2, n2;
        let i2;
        switch (("ParenthesizedExpression" === t2.type || null != (r2 = t2.extra) && r2.parenthesized) && (i2 = unwrapParenthesizedExpression(t2), e2 ? "Identifier" === i2.type ? this.expressionScope.recordArrowParameterBindingError(xn.InvalidParenthesizedAssignment, { at: t2 }) : "MemberExpression" === i2.type || this.isOptionalMemberExpression(i2) || this.raise(xn.InvalidParenthesizedAssignment, { at: t2 }) : this.raise(xn.InvalidParenthesizedAssignment, { at: t2 })), t2.type) {
          case "Identifier":
          case "ObjectPattern":
          case "ArrayPattern":
          case "AssignmentPattern":
          case "RestElement":
            break;
          case "ObjectExpression":
            t2.type = "ObjectPattern";
            for (let r3 = 0, n3 = t2.properties.length, i3 = n3 - 1; r3 < n3; r3++) {
              var o2;
              const n4 = t2.properties[r3], a2 = r3 === i3;
              this.toAssignableObjectExpressionProp(n4, a2, e2), a2 && "RestElement" === n4.type && null != (o2 = t2.extra) && o2.trailingCommaLoc && this.raise(xn.RestTrailingComma, { at: t2.extra.trailingCommaLoc });
            }
            break;
          case "ObjectProperty": {
            const { key: r3, value: n3 } = t2;
            this.isPrivateName(r3) && this.classScope.usePrivateName(this.getPrivateNameSV(r3), r3.loc.start), this.toAssignable(n3, e2);
            break;
          }
          case "SpreadElement":
            throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
          case "ArrayExpression":
            t2.type = "ArrayPattern", this.toAssignableList(t2.elements, null == (n2 = t2.extra) ? void 0 : n2.trailingCommaLoc, e2);
            break;
          case "AssignmentExpression":
            "=" !== t2.operator && this.raise(xn.MissingEqInAssignment, { at: t2.left.loc.end }), t2.type = "AssignmentPattern", delete t2.operator, this.toAssignable(t2.left, e2);
            break;
          case "ParenthesizedExpression":
            this.toAssignable(i2, e2);
        }
      }
      toAssignableObjectExpressionProp(t2, e2, r2) {
        if ("ObjectMethod" === t2.type)
          this.raise("get" === t2.kind || "set" === t2.kind ? xn.PatternHasAccessor : xn.PatternHasMethod, { at: t2.key });
        else if ("SpreadElement" === t2.type) {
          t2.type = "RestElement";
          const n2 = t2.argument;
          this.checkToRestConversion(n2, false), this.toAssignable(n2, r2), e2 || this.raise(xn.RestTrailingComma, { at: t2 });
        } else
          this.toAssignable(t2, r2);
      }
      toAssignableList(t2, e2, r2) {
        const n2 = t2.length - 1;
        for (let i2 = 0; i2 <= n2; i2++) {
          const o2 = t2[i2];
          if (o2) {
            if ("SpreadElement" === o2.type) {
              o2.type = "RestElement";
              const t3 = o2.argument;
              this.checkToRestConversion(t3, true), this.toAssignable(t3, r2);
            } else
              this.toAssignable(o2, r2);
            "RestElement" === o2.type && (i2 < n2 ? this.raise(xn.RestTrailingComma, { at: o2 }) : e2 && this.raise(xn.RestTrailingComma, { at: e2 }));
          }
        }
      }
      isAssignable(t2, e2) {
        switch (t2.type) {
          case "Identifier":
          case "ObjectPattern":
          case "ArrayPattern":
          case "AssignmentPattern":
          case "RestElement":
            return true;
          case "ObjectExpression": {
            const e3 = t2.properties.length - 1;
            return t2.properties.every((t3, r2) => "ObjectMethod" !== t3.type && (r2 === e3 || "SpreadElement" !== t3.type) && this.isAssignable(t3));
          }
          case "ObjectProperty":
            return this.isAssignable(t2.value);
          case "SpreadElement":
            return this.isAssignable(t2.argument);
          case "ArrayExpression":
            return t2.elements.every((t3) => null === t3 || this.isAssignable(t3));
          case "AssignmentExpression":
            return "=" === t2.operator;
          case "ParenthesizedExpression":
            return this.isAssignable(t2.expression);
          case "MemberExpression":
          case "OptionalMemberExpression":
            return !e2;
          default:
            return false;
        }
      }
      toReferencedList(t2, e2) {
        return t2;
      }
      toReferencedListDeep(t2, e2) {
        this.toReferencedList(t2, e2);
        for (const e3 of t2)
          "ArrayExpression" === (null == e3 ? void 0 : e3.type) && this.toReferencedListDeep(e3.elements);
      }
      parseSpread(t2) {
        const e2 = this.startNode();
        return this.next(), e2.argument = this.parseMaybeAssignAllowIn(t2, void 0), this.finishNode(e2, "SpreadElement");
      }
      parseRestBinding() {
        const t2 = this.startNode();
        return this.next(), t2.argument = this.parseBindingAtom(), this.finishNode(t2, "RestElement");
      }
      parseBindingAtom() {
        switch (this.state.type) {
          case 0: {
            const t2 = this.startNode();
            return this.next(), t2.elements = this.parseBindingList(3, 93, 1), this.finishNode(t2, "ArrayPattern");
          }
          case 5:
            return this.parseObjectLike(8, true);
        }
        return this.parseIdentifier();
      }
      parseBindingList(t2, e2, r2) {
        const n2 = 1 & r2, i2 = [];
        let o2 = true;
        for (; !this.eat(t2); )
          if (o2 ? o2 = false : this.expect(12), n2 && this.match(12))
            i2.push(null);
          else {
            if (this.eat(t2))
              break;
            if (this.match(21)) {
              if (i2.push(this.parseAssignableListItemTypes(this.parseRestBinding(), r2)), !this.checkCommaAfterRest(e2)) {
                this.expect(t2);
                break;
              }
            } else {
              const t3 = [];
              for (this.match(26) && this.hasPlugin("decorators") && this.raise(xn.UnsupportedParameterDecorator, { at: this.state.startLoc }); this.match(26); )
                t3.push(this.parseDecorator());
              i2.push(this.parseAssignableListItem(r2, t3));
            }
          }
        return i2;
      }
      parseBindingRestProperty(t2) {
        return this.next(), t2.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(t2, "RestElement");
      }
      parseBindingProperty() {
        const t2 = this.startNode(), { type: e2, startLoc: r2 } = this.state;
        return 21 === e2 ? this.parseBindingRestProperty(t2) : (138 === e2 ? (this.expectPlugin("destructuringPrivate", r2), this.classScope.usePrivateName(this.state.value, r2), t2.key = this.parsePrivateName()) : this.parsePropertyName(t2), t2.method = false, this.parseObjPropValue(t2, r2, false, false, true, false));
      }
      parseAssignableListItem(t2, e2) {
        const r2 = this.parseMaybeDefault();
        this.parseAssignableListItemTypes(r2, t2);
        const n2 = this.parseMaybeDefault(r2.loc.start, r2);
        return e2.length && (r2.decorators = e2), n2;
      }
      parseAssignableListItemTypes(t2, e2) {
        return t2;
      }
      parseMaybeDefault(t2, e2) {
        var r2;
        if (null != t2 || (t2 = this.state.startLoc), e2 = null != (r2 = e2) ? r2 : this.parseBindingAtom(), !this.eat(29))
          return e2;
        const n2 = this.startNodeAt(t2);
        return n2.left = e2, n2.right = this.parseMaybeAssignAllowIn(), this.finishNode(n2, "AssignmentPattern");
      }
      isValidLVal(t2, e2, r2) {
        return n2 = { AssignmentPattern: "left", RestElement: "argument", ObjectProperty: "value", ParenthesizedExpression: "expression", ArrayPattern: "elements", ObjectPattern: "properties" }, i2 = t2, Object.hasOwnProperty.call(n2, i2) && n2[i2];
        var n2, i2;
      }
      isOptionalMemberExpression(t2) {
        return "OptionalMemberExpression" === t2.type;
      }
      checkLVal(t2, { in: e2, binding: r2 = 64, checkClashes: n2 = false, strictModeChanged: i2 = false, hasParenthesizedAncestor: o2 = false }) {
        var a2;
        const s2 = t2.type;
        if (this.isObjectMethod(t2))
          return;
        const l2 = this.isOptionalMemberExpression(t2);
        if (l2 || "MemberExpression" === s2)
          return l2 && (this.expectPlugin("optionalChainingAssign", t2.loc.start), "AssignmentExpression" !== e2.type && this.raise(xn.InvalidLhsOptionalChaining, { at: t2, ancestor: e2 })), void (64 !== r2 && this.raise(xn.InvalidPropertyBindingPattern, { at: t2 }));
        if ("Identifier" === s2) {
          this.checkIdentifier(t2, r2, i2);
          const { name: e3 } = t2;
          return void (n2 && (n2.has(e3) ? this.raise(xn.ParamDupe, { at: t2 }) : n2.add(e3)));
        }
        const p2 = this.isValidLVal(s2, !(o2 || null != (a2 = t2.extra) && a2.parenthesized) && "AssignmentExpression" === e2.type, r2);
        if (true === p2)
          return;
        if (false === p2) {
          const n3 = 64 === r2 ? xn.InvalidLhs : xn.InvalidLhsBinding;
          return void this.raise(n3, { at: t2, ancestor: e2 });
        }
        const [c2, d2] = Array.isArray(p2) ? p2 : [p2, "ParenthesizedExpression" === s2], m2 = "ArrayPattern" === s2 || "ObjectPattern" === s2 ? { type: s2 } : e2;
        for (const e3 of [].concat(t2[c2]))
          e3 && this.checkLVal(e3, { in: m2, binding: r2, checkClashes: n2, strictModeChanged: i2, hasParenthesizedAncestor: d2 });
      }
      checkIdentifier(t2, e2, r2 = false) {
        this.state.strict && (r2 ? isStrictBindReservedWord(t2.name, this.inModule) : isStrictBindOnlyReservedWord(t2.name)) && (64 === e2 ? this.raise(xn.StrictEvalArguments, { at: t2, referenceName: t2.name }) : this.raise(xn.StrictEvalArgumentsBinding, { at: t2, bindingName: t2.name })), 8192 & e2 && "let" === t2.name && this.raise(xn.LetInLexicalBinding, { at: t2 }), 64 & e2 || this.declareNameFromIdentifier(t2, e2);
      }
      declareNameFromIdentifier(t2, e2) {
        this.scope.declareName(t2.name, e2, t2.loc.start);
      }
      checkToRestConversion(t2, e2) {
        switch (t2.type) {
          case "ParenthesizedExpression":
            this.checkToRestConversion(t2.expression, e2);
            break;
          case "Identifier":
          case "MemberExpression":
            break;
          case "ArrayExpression":
          case "ObjectExpression":
            if (e2)
              break;
          default:
            this.raise(xn.InvalidRestAssignmentPattern, { at: t2 });
        }
      }
      checkCommaAfterRest(t2) {
        return !!this.match(12) && (this.raise(this.lookaheadCharCode() === t2 ? xn.RestTrailingComma : xn.ElementAfterRest, { at: this.state.startLoc }), true);
      }
    }
    function assert$1(t2) {
      if (!t2)
        throw new Error("Assert fail");
    }
    const ci = ParseErrorEnum`typescript`({ AbstractMethodHasImplementation: ({ methodName: t2 }) => `Method '${t2}' cannot have an implementation because it is marked abstract.`, AbstractPropertyHasInitializer: ({ propertyName: t2 }) => `Property '${t2}' cannot have an initializer because it is marked abstract.`, AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.", AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.", AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.", ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.", ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.", ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.", ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.", DeclareAccessor: ({ kind: t2 }) => `'declare' is not allowed in ${t2}ters.`, DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.", DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.", DuplicateAccessibilityModifier: ({ modifier: t2 }) => "Accessibility modifier already seen.", DuplicateModifier: ({ modifier: t2 }) => `Duplicate modifier: '${t2}'.`, EmptyHeritageClauseType: ({ token: t2 }) => `'${t2}' list cannot be empty.`, EmptyTypeArguments: "Type argument list cannot be empty.", EmptyTypeParameters: "Type parameter list cannot be empty.", ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.", ImportAliasHasImportType: "An import alias can not use 'import type'.", ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier", IncompatibleModifiers: ({ modifiers: t2 }) => `'${t2[0]}' modifier cannot be used with '${t2[1]}' modifier.`, IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.", IndexSignatureHasAccessibility: ({ modifier: t2 }) => `Index signatures cannot have an accessibility modifier ('${t2}').`, IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.", IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.", IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.", InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.", InvalidModifierOnTypeMember: ({ modifier: t2 }) => `'${t2}' modifier cannot appear on a type member.`, InvalidModifierOnTypeParameter: ({ modifier: t2 }) => `'${t2}' modifier cannot appear on a type parameter.`, InvalidModifierOnTypeParameterPositions: ({ modifier: t2 }) => `'${t2}' modifier can only appear on a type parameter of a class, interface or type alias.`, InvalidModifiersOrder: ({ orderedModifiers: t2 }) => `'${t2[0]}' modifier must precede '${t2[1]}' modifier.`, InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.", InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.", MissingInterfaceName: "'interface' declarations must be followed by an identifier.", NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.", NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.", OptionalTypeBeforeRequired: "A required element cannot follow an optional element.", OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.", PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.", PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.", PrivateElementHasAccessibility: ({ modifier: t2 }) => `Private elements cannot have an accessibility modifier ('${t2}').`, ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.", ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.", ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.", SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.", SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.", SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.", SingleTypeParameterWithoutTrailingComma: ({ typeParameterName: t2 }) => `Single type parameter ${t2} should have a trailing comma. Example usage: <${t2},>.`, StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.", TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).", TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.", TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.", TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.", UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.", UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.", UnexpectedTypeAnnotation: "Did not expect a type annotation here.", UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.", UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.", UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.", UnsupportedSignatureParameterKind: ({ type: t2 }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${t2}.` });
    function tsIsAccessModifier(t2) {
      return "private" === t2 || "public" === t2 || "protected" === t2;
    }
    function tsIsVarianceAnnotations(t2) {
      return "in" === t2 || "out" === t2;
    }
    function isPossiblyLiteralEnum(t2) {
      if ("MemberExpression" !== t2.type)
        return false;
      const { computed: e2, property: r2 } = t2;
      return (!e2 || "StringLiteral" === r2.type || !("TemplateLiteral" !== r2.type || r2.expressions.length > 0)) && isUncomputedMemberExpressionChain(t2.object);
    }
    function isValidAmbientConstInitializer(t2, e2) {
      var r2;
      const { type: n2 } = t2;
      if (null != (r2 = t2.extra) && r2.parenthesized)
        return false;
      if (e2) {
        if ("Literal" === n2) {
          const { value: e3 } = t2;
          if ("string" == typeof e3 || "boolean" == typeof e3)
            return true;
        }
      } else if ("StringLiteral" === n2 || "BooleanLiteral" === n2)
        return true;
      return !(!isNumber(t2, e2) && !function(t3, e3) {
        if ("UnaryExpression" === t3.type) {
          const { operator: r3, argument: n3 } = t3;
          if ("-" === r3 && isNumber(n3, e3))
            return true;
        }
        return false;
      }(t2, e2)) || ("TemplateLiteral" === n2 && 0 === t2.expressions.length || !!isPossiblyLiteralEnum(t2));
    }
    function isNumber(t2, e2) {
      return e2 ? "Literal" === t2.type && ("number" == typeof t2.value || "bigint" in t2) : "NumericLiteral" === t2.type || "BigIntLiteral" === t2.type;
    }
    function isUncomputedMemberExpressionChain(t2) {
      return "Identifier" === t2.type || "MemberExpression" === t2.type && !t2.computed && isUncomputedMemberExpressionChain(t2.object);
    }
    const di = ParseErrorEnum`placeholders`({ ClassNameIsRequired: "A class name is required.", UnexpectedSpace: "Unexpected space in placeholder." });
    function hasPlugin(t2, e2) {
      const [r2, n2] = "string" == typeof e2 ? [e2, {}] : e2, i2 = Object.keys(n2), o2 = 0 === i2.length;
      return t2.some((t3) => {
        if ("string" == typeof t3)
          return o2 && t3 === r2;
        {
          const [e3, o3] = t3;
          if (e3 !== r2)
            return false;
          for (const t4 of i2)
            if (o3[t4] !== n2[t4])
              return false;
          return true;
        }
      });
    }
    function getPluginOption(t2, e2, r2) {
      const n2 = t2.find((t3) => Array.isArray(t3) ? t3[0] === e2 : t3 === e2);
      return n2 && Array.isArray(n2) && n2.length > 1 ? n2[1][r2] : null;
    }
    const mi = ["minimal", "fsharp", "hack", "smart"], ui = ["^^", "@@", "^", "%", "#"], hi = ["hash", "bar"];
    const fi = { estree: (t2) => class extends t2 {
      parse() {
        const t3 = toESTreeLocation(super.parse());
        return this.options.tokens && (t3.tokens = t3.tokens.map(toESTreeLocation)), t3;
      }
      parseRegExpLiteral({ pattern: t3, flags: e2 }) {
        let r2 = null;
        try {
          r2 = new RegExp(t3, e2);
        } catch (t4) {
        }
        const n2 = this.estreeParseLiteral(r2);
        return n2.regex = { pattern: t3, flags: e2 }, n2;
      }
      parseBigIntLiteral(t3) {
        let e2;
        try {
          e2 = BigInt(t3);
        } catch (t4) {
          e2 = null;
        }
        const r2 = this.estreeParseLiteral(e2);
        return r2.bigint = String(r2.value || t3), r2;
      }
      parseDecimalLiteral(t3) {
        const e2 = this.estreeParseLiteral(null);
        return e2.decimal = String(e2.value || t3), e2;
      }
      estreeParseLiteral(t3) {
        return this.parseLiteral(t3, "Literal");
      }
      parseStringLiteral(t3) {
        return this.estreeParseLiteral(t3);
      }
      parseNumericLiteral(t3) {
        return this.estreeParseLiteral(t3);
      }
      parseNullLiteral() {
        return this.estreeParseLiteral(null);
      }
      parseBooleanLiteral(t3) {
        return this.estreeParseLiteral(t3);
      }
      directiveToStmt(t3) {
        const e2 = t3.value;
        delete t3.value, e2.type = "Literal", e2.raw = e2.extra.raw, e2.value = e2.extra.expressionValue;
        const r2 = t3;
        return r2.type = "ExpressionStatement", r2.expression = e2, r2.directive = e2.extra.rawValue, delete e2.extra, r2;
      }
      initFunction(t3, e2) {
        super.initFunction(t3, e2), t3.expression = false;
      }
      checkDeclaration(t3) {
        null != t3 && this.isObjectProperty(t3) ? this.checkDeclaration(t3.value) : super.checkDeclaration(t3);
      }
      getObjectOrClassMethodParams(t3) {
        return t3.value.params;
      }
      isValidDirective(t3) {
        var e2;
        return "ExpressionStatement" === t3.type && "Literal" === t3.expression.type && "string" == typeof t3.expression.value && !(null != (e2 = t3.expression.extra) && e2.parenthesized);
      }
      parseBlockBody(t3, e2, r2, n2, i2) {
        super.parseBlockBody(t3, e2, r2, n2, i2);
        const o2 = t3.directives.map((t4) => this.directiveToStmt(t4));
        t3.body = o2.concat(t3.body), delete t3.directives;
      }
      pushClassMethod(t3, e2, r2, n2, i2, o2) {
        this.parseMethod(e2, r2, n2, i2, o2, "ClassMethod", true), e2.typeParameters && (e2.value.typeParameters = e2.typeParameters, delete e2.typeParameters), t3.body.push(e2);
      }
      parsePrivateName() {
        const t3 = super.parsePrivateName();
        return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(t3) : t3;
      }
      convertPrivateNameToPrivateIdentifier(t3) {
        const e2 = super.getPrivateNameSV(t3);
        return delete t3.id, t3.name = e2, t3.type = "PrivateIdentifier", t3;
      }
      isPrivateName(t3) {
        return this.getPluginOption("estree", "classFeatures") ? "PrivateIdentifier" === t3.type : super.isPrivateName(t3);
      }
      getPrivateNameSV(t3) {
        return this.getPluginOption("estree", "classFeatures") ? t3.name : super.getPrivateNameSV(t3);
      }
      parseLiteral(t3, e2) {
        const r2 = super.parseLiteral(t3, e2);
        return r2.raw = r2.extra.raw, delete r2.extra, r2;
      }
      parseFunctionBody(t3, e2, r2 = false) {
        super.parseFunctionBody(t3, e2, r2), t3.expression = "BlockStatement" !== t3.body.type;
      }
      parseMethod(t3, e2, r2, n2, i2, o2, a2 = false) {
        let s2 = this.startNode();
        return s2.kind = t3.kind, s2 = super.parseMethod(s2, e2, r2, n2, i2, o2, a2), s2.type = "FunctionExpression", delete s2.kind, t3.value = s2, "ClassPrivateMethod" === o2 && (t3.computed = false), this.finishNode(t3, "MethodDefinition");
      }
      parseClassProperty(...t3) {
        const e2 = super.parseClassProperty(...t3);
        return this.getPluginOption("estree", "classFeatures") ? (e2.type = "PropertyDefinition", e2) : e2;
      }
      parseClassPrivateProperty(...t3) {
        const e2 = super.parseClassPrivateProperty(...t3);
        return this.getPluginOption("estree", "classFeatures") ? (e2.type = "PropertyDefinition", e2.computed = false, e2) : e2;
      }
      parseObjectMethod(t3, e2, r2, n2, i2) {
        const o2 = super.parseObjectMethod(t3, e2, r2, n2, i2);
        return o2 && (o2.type = "Property", "method" === o2.kind && (o2.kind = "init"), o2.shorthand = false), o2;
      }
      parseObjectProperty(t3, e2, r2, n2) {
        const i2 = super.parseObjectProperty(t3, e2, r2, n2);
        return i2 && (i2.kind = "init", i2.type = "Property"), i2;
      }
      isValidLVal(t3, e2, r2) {
        return "Property" === t3 ? "value" : super.isValidLVal(t3, e2, r2);
      }
      isAssignable(t3, e2) {
        return null != t3 && this.isObjectProperty(t3) ? this.isAssignable(t3.value, e2) : super.isAssignable(t3, e2);
      }
      toAssignable(t3, e2 = false) {
        if (null != t3 && this.isObjectProperty(t3)) {
          const { key: r2, value: n2 } = t3;
          this.isPrivateName(r2) && this.classScope.usePrivateName(this.getPrivateNameSV(r2), r2.loc.start), this.toAssignable(n2, e2);
        } else
          super.toAssignable(t3, e2);
      }
      toAssignableObjectExpressionProp(t3, e2, r2) {
        "get" === t3.kind || "set" === t3.kind ? this.raise(xn.PatternHasAccessor, { at: t3.key }) : t3.method ? this.raise(xn.PatternHasMethod, { at: t3.key }) : super.toAssignableObjectExpressionProp(t3, e2, r2);
      }
      finishCallExpression(t3, e2) {
        const r2 = super.finishCallExpression(t3, e2);
        if ("Import" === r2.callee.type) {
          var n2, i2;
          if (r2.type = "ImportExpression", r2.source = r2.arguments[0], this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions"))
            r2.options = null != (n2 = r2.arguments[1]) ? n2 : null, r2.attributes = null != (i2 = r2.arguments[1]) ? i2 : null;
          delete r2.arguments, delete r2.callee;
        }
        return r2;
      }
      toReferencedArguments(t3) {
        "ImportExpression" !== t3.type && super.toReferencedArguments(t3);
      }
      parseExport(t3, e2) {
        const r2 = this.state.lastTokStartLoc, n2 = super.parseExport(t3, e2);
        switch (n2.type) {
          case "ExportAllDeclaration":
            n2.exported = null;
            break;
          case "ExportNamedDeclaration":
            1 === n2.specifiers.length && "ExportNamespaceSpecifier" === n2.specifiers[0].type && (n2.type = "ExportAllDeclaration", n2.exported = n2.specifiers[0].exported, delete n2.specifiers);
          case "ExportDefaultDeclaration": {
            var i2;
            const { declaration: t4 } = n2;
            "ClassDeclaration" === (null == t4 ? void 0 : t4.type) && (null == (i2 = t4.decorators) ? void 0 : i2.length) > 0 && t4.start === n2.start && this.resetStartLocation(n2, r2);
          }
        }
        return n2;
      }
      parseSubscript(t3, e2, r2, n2) {
        const i2 = super.parseSubscript(t3, e2, r2, n2);
        if (n2.optionalChainMember) {
          if ("OptionalMemberExpression" !== i2.type && "OptionalCallExpression" !== i2.type || (i2.type = i2.type.substring(8)), n2.stop) {
            const t4 = this.startNodeAtNode(i2);
            return t4.expression = i2, this.finishNode(t4, "ChainExpression");
          }
        } else
          "MemberExpression" !== i2.type && "CallExpression" !== i2.type || (i2.optional = false);
        return i2;
      }
      isOptionalMemberExpression(t3) {
        return "ChainExpression" === t3.type ? "MemberExpression" === t3.expression.type : super.isOptionalMemberExpression(t3);
      }
      hasPropertyAsPrivateName(t3) {
        return "ChainExpression" === t3.type && (t3 = t3.expression), super.hasPropertyAsPrivateName(t3);
      }
      isObjectProperty(t3) {
        return "Property" === t3.type && "init" === t3.kind && !t3.method;
      }
      isObjectMethod(t3) {
        return t3.method || "get" === t3.kind || "set" === t3.kind;
      }
      finishNodeAt(t3, e2, r2) {
        return toESTreeLocation(super.finishNodeAt(t3, e2, r2));
      }
      resetStartLocation(t3, e2) {
        super.resetStartLocation(t3, e2), toESTreeLocation(t3);
      }
      resetEndLocation(t3, e2 = this.state.lastTokEndLoc) {
        super.resetEndLocation(t3, e2), toESTreeLocation(t3);
      }
    }, jsx: (t2) => class extends t2 {
      jsxReadToken() {
        let t3 = "", e2 = this.state.pos;
        for (; ; ) {
          if (this.state.pos >= this.length)
            throw this.raise(pi.UnterminatedJsxContent, { at: this.state.startLoc });
          const r2 = this.input.charCodeAt(this.state.pos);
          switch (r2) {
            case 60:
            case 123:
              return this.state.pos === this.state.start ? void (60 === r2 && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(142)) : super.getTokenFromCode(r2)) : (t3 += this.input.slice(e2, this.state.pos), void this.finishToken(141, t3));
            case 38:
              t3 += this.input.slice(e2, this.state.pos), t3 += this.jsxReadEntity(), e2 = this.state.pos;
              break;
            default:
              isNewLine(r2) ? (t3 += this.input.slice(e2, this.state.pos), t3 += this.jsxReadNewLine(true), e2 = this.state.pos) : ++this.state.pos;
          }
        }
      }
      jsxReadNewLine(t3) {
        const e2 = this.input.charCodeAt(this.state.pos);
        let r2;
        return ++this.state.pos, 13 === e2 && 10 === this.input.charCodeAt(this.state.pos) ? (++this.state.pos, r2 = t3 ? "\n" : "\r\n") : r2 = String.fromCharCode(e2), ++this.state.curLine, this.state.lineStart = this.state.pos, r2;
      }
      jsxReadString(t3) {
        let e2 = "", r2 = ++this.state.pos;
        for (; ; ) {
          if (this.state.pos >= this.length)
            throw this.raise(xn.UnterminatedString, { at: this.state.startLoc });
          const n2 = this.input.charCodeAt(this.state.pos);
          if (n2 === t3)
            break;
          38 === n2 ? (e2 += this.input.slice(r2, this.state.pos), e2 += this.jsxReadEntity(), r2 = this.state.pos) : isNewLine(n2) ? (e2 += this.input.slice(r2, this.state.pos), e2 += this.jsxReadNewLine(false), r2 = this.state.pos) : ++this.state.pos;
        }
        e2 += this.input.slice(r2, this.state.pos++), this.finishToken(133, e2);
      }
      jsxReadEntity() {
        const t3 = ++this.state.pos;
        if (35 === this.codePointAtPos(this.state.pos)) {
          ++this.state.pos;
          let t4 = 10;
          120 === this.codePointAtPos(this.state.pos) && (t4 = 16, ++this.state.pos);
          const e2 = this.readInt(t4, void 0, false, "bail");
          if (null !== e2 && 59 === this.codePointAtPos(this.state.pos))
            return ++this.state.pos, String.fromCodePoint(e2);
        } else {
          let e2 = 0, r2 = false;
          for (; e2++ < 10 && this.state.pos < this.length && !(r2 = 59 == this.codePointAtPos(this.state.pos)); )
            ++this.state.pos;
          if (r2) {
            const e3 = this.input.slice(t3, this.state.pos), r3 = li[e3];
            if (++this.state.pos, r3)
              return r3;
          }
        }
        return this.state.pos = t3, "&";
      }
      jsxReadWord() {
        let t3;
        const e2 = this.state.pos;
        do {
          t3 = this.input.charCodeAt(++this.state.pos);
        } while (isIdentifierChar(t3) || 45 === t3);
        this.finishToken(140, this.input.slice(e2, this.state.pos));
      }
      jsxParseIdentifier() {
        const t3 = this.startNode();
        return this.match(140) ? t3.name = this.state.value : tokenIsKeyword(this.state.type) ? t3.name = tokenLabelName(this.state.type) : this.unexpected(), this.next(), this.finishNode(t3, "JSXIdentifier");
      }
      jsxParseNamespacedName() {
        const t3 = this.state.startLoc, e2 = this.jsxParseIdentifier();
        if (!this.eat(14))
          return e2;
        const r2 = this.startNodeAt(t3);
        return r2.namespace = e2, r2.name = this.jsxParseIdentifier(), this.finishNode(r2, "JSXNamespacedName");
      }
      jsxParseElementName() {
        const t3 = this.state.startLoc;
        let e2 = this.jsxParseNamespacedName();
        if ("JSXNamespacedName" === e2.type)
          return e2;
        for (; this.eat(16); ) {
          const r2 = this.startNodeAt(t3);
          r2.object = e2, r2.property = this.jsxParseIdentifier(), e2 = this.finishNode(r2, "JSXMemberExpression");
        }
        return e2;
      }
      jsxParseAttributeValue() {
        let t3;
        switch (this.state.type) {
          case 5:
            return t3 = this.startNode(), this.setContext(yn.brace), this.next(), t3 = this.jsxParseExpressionContainer(t3, yn.j_oTag), "JSXEmptyExpression" === t3.expression.type && this.raise(pi.AttributeIsEmpty, { at: t3 }), t3;
          case 142:
          case 133:
            return this.parseExprAtom();
          default:
            throw this.raise(pi.UnsupportedJsxValue, { at: this.state.startLoc });
        }
      }
      jsxParseEmptyExpression() {
        const t3 = this.startNodeAt(this.state.lastTokEndLoc);
        return this.finishNodeAt(t3, "JSXEmptyExpression", this.state.startLoc);
      }
      jsxParseSpreadChild(t3) {
        return this.next(), t3.expression = this.parseExpression(), this.setContext(yn.j_expr), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(t3, "JSXSpreadChild");
      }
      jsxParseExpressionContainer(t3, e2) {
        if (this.match(8))
          t3.expression = this.jsxParseEmptyExpression();
        else {
          const e3 = this.parseExpression();
          t3.expression = e3;
        }
        return this.setContext(e2), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(t3, "JSXExpressionContainer");
      }
      jsxParseAttribute() {
        const t3 = this.startNode();
        return this.match(5) ? (this.setContext(yn.brace), this.next(), this.expect(21), t3.argument = this.parseMaybeAssignAllowIn(), this.setContext(yn.j_oTag), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(t3, "JSXSpreadAttribute")) : (t3.name = this.jsxParseNamespacedName(), t3.value = this.eat(29) ? this.jsxParseAttributeValue() : null, this.finishNode(t3, "JSXAttribute"));
      }
      jsxParseOpeningElementAt(t3) {
        const e2 = this.startNodeAt(t3);
        return this.eat(143) ? this.finishNode(e2, "JSXOpeningFragment") : (e2.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(e2));
      }
      jsxParseOpeningElementAfterName(t3) {
        const e2 = [];
        for (; !this.match(56) && !this.match(143); )
          e2.push(this.jsxParseAttribute());
        return t3.attributes = e2, t3.selfClosing = this.eat(56), this.expect(143), this.finishNode(t3, "JSXOpeningElement");
      }
      jsxParseClosingElementAt(t3) {
        const e2 = this.startNodeAt(t3);
        return this.eat(143) ? this.finishNode(e2, "JSXClosingFragment") : (e2.name = this.jsxParseElementName(), this.expect(143), this.finishNode(e2, "JSXClosingElement"));
      }
      jsxParseElementAt(t3) {
        const e2 = this.startNodeAt(t3), r2 = [], n2 = this.jsxParseOpeningElementAt(t3);
        let i2 = null;
        if (!n2.selfClosing) {
          t:
            for (; ; )
              switch (this.state.type) {
                case 142:
                  if (t3 = this.state.startLoc, this.next(), this.eat(56)) {
                    i2 = this.jsxParseClosingElementAt(t3);
                    break t;
                  }
                  r2.push(this.jsxParseElementAt(t3));
                  break;
                case 141:
                  r2.push(this.parseExprAtom());
                  break;
                case 5: {
                  const t4 = this.startNode();
                  this.setContext(yn.brace), this.next(), this.match(21) ? r2.push(this.jsxParseSpreadChild(t4)) : r2.push(this.jsxParseExpressionContainer(t4, yn.j_expr));
                  break;
                }
                default:
                  this.unexpected();
              }
          isFragment(n2) && !isFragment(i2) && null !== i2 ? this.raise(pi.MissingClosingTagFragment, { at: i2 }) : !isFragment(n2) && isFragment(i2) ? this.raise(pi.MissingClosingTagElement, { at: i2, openingTagName: getQualifiedJSXName(n2.name) }) : isFragment(n2) || isFragment(i2) || getQualifiedJSXName(i2.name) !== getQualifiedJSXName(n2.name) && this.raise(pi.MissingClosingTagElement, { at: i2, openingTagName: getQualifiedJSXName(n2.name) });
        }
        if (isFragment(n2) ? (e2.openingFragment = n2, e2.closingFragment = i2) : (e2.openingElement = n2, e2.closingElement = i2), e2.children = r2, this.match(47))
          throw this.raise(pi.UnwrappedAdjacentJSXElements, { at: this.state.startLoc });
        return isFragment(n2) ? this.finishNode(e2, "JSXFragment") : this.finishNode(e2, "JSXElement");
      }
      jsxParseElement() {
        const t3 = this.state.startLoc;
        return this.next(), this.jsxParseElementAt(t3);
      }
      setContext(t3) {
        const { context: e2 } = this.state;
        e2[e2.length - 1] = t3;
      }
      parseExprAtom(t3) {
        return this.match(141) ? this.parseLiteral(this.state.value, "JSXText") : this.match(142) ? this.jsxParseElement() : this.match(47) && 33 !== this.input.charCodeAt(this.state.pos) ? (this.replaceToken(142), this.jsxParseElement()) : super.parseExprAtom(t3);
      }
      skipSpace() {
        this.curContext().preserveSpace || super.skipSpace();
      }
      getTokenFromCode(t3) {
        const e2 = this.curContext();
        if (e2 !== yn.j_expr) {
          if (e2 === yn.j_oTag || e2 === yn.j_cTag) {
            if (isIdentifierStart(t3))
              return void this.jsxReadWord();
            if (62 === t3)
              return ++this.state.pos, void this.finishToken(143);
            if ((34 === t3 || 39 === t3) && e2 === yn.j_oTag)
              return void this.jsxReadString(t3);
          }
          if (60 === t3 && this.state.canStartJSXElement && 33 !== this.input.charCodeAt(this.state.pos + 1))
            return ++this.state.pos, void this.finishToken(142);
          super.getTokenFromCode(t3);
        } else
          this.jsxReadToken();
      }
      updateContext(t3) {
        const { context: e2, type: r2 } = this.state;
        if (56 === r2 && 142 === t3)
          e2.splice(-2, 2, yn.j_cTag), this.state.canStartJSXElement = false;
        else if (142 === r2)
          e2.push(yn.j_oTag);
        else if (143 === r2) {
          const r3 = e2[e2.length - 1];
          r3 === yn.j_oTag && 56 === t3 || r3 === yn.j_cTag ? (e2.pop(), this.state.canStartJSXElement = e2[e2.length - 1] === yn.j_expr) : (this.setContext(yn.j_expr), this.state.canStartJSXElement = true);
        } else
          this.state.canStartJSXElement = In[r2];
      }
    }, flow: (t2) => class extends t2 {
      constructor(...t3) {
        super(...t3), this.flowPragma = void 0;
      }
      getScopeHandler() {
        return FlowScopeHandler;
      }
      shouldParseTypes() {
        return this.getPluginOption("flow", "all") || "flow" === this.flowPragma;
      }
      shouldParseEnums() {
        return !!this.getPluginOption("flow", "enums");
      }
      finishToken(t3, e2) {
        133 !== t3 && 13 !== t3 && 28 !== t3 && void 0 === this.flowPragma && (this.flowPragma = null), super.finishToken(t3, e2);
      }
      addComment(t3) {
        if (void 0 === this.flowPragma) {
          const e2 = si.exec(t3.value);
          if (e2)
            if ("flow" === e2[1])
              this.flowPragma = "flow";
            else {
              if ("noflow" !== e2[1])
                throw new Error("Unexpected flow pragma");
              this.flowPragma = "noflow";
            }
          else
            ;
        }
        super.addComment(t3);
      }
      flowParseTypeInitialiser(t3) {
        const e2 = this.state.inType;
        this.state.inType = true, this.expect(t3 || 14);
        const r2 = this.flowParseType();
        return this.state.inType = e2, r2;
      }
      flowParsePredicate() {
        const t3 = this.startNode(), e2 = this.state.startLoc;
        return this.next(), this.expectContextual(110), this.state.lastTokStart > e2.index + 1 && this.raise(oi.UnexpectedSpaceBetweenModuloChecks, { at: e2 }), this.eat(10) ? (t3.value = super.parseExpression(), this.expect(11), this.finishNode(t3, "DeclaredPredicate")) : this.finishNode(t3, "InferredPredicate");
      }
      flowParseTypeAndPredicateInitialiser() {
        const t3 = this.state.inType;
        this.state.inType = true, this.expect(14);
        let e2 = null, r2 = null;
        return this.match(54) ? (this.state.inType = t3, r2 = this.flowParsePredicate()) : (e2 = this.flowParseType(), this.state.inType = t3, this.match(54) && (r2 = this.flowParsePredicate())), [e2, r2];
      }
      flowParseDeclareClass(t3) {
        return this.next(), this.flowParseInterfaceish(t3, true), this.finishNode(t3, "DeclareClass");
      }
      flowParseDeclareFunction(t3) {
        this.next();
        const e2 = t3.id = this.parseIdentifier(), r2 = this.startNode(), n2 = this.startNode();
        this.match(47) ? r2.typeParameters = this.flowParseTypeParameterDeclaration() : r2.typeParameters = null, this.expect(10);
        const i2 = this.flowParseFunctionTypeParams();
        return r2.params = i2.params, r2.rest = i2.rest, r2.this = i2._this, this.expect(11), [r2.returnType, t3.predicate] = this.flowParseTypeAndPredicateInitialiser(), n2.typeAnnotation = this.finishNode(r2, "FunctionTypeAnnotation"), e2.typeAnnotation = this.finishNode(n2, "TypeAnnotation"), this.resetEndLocation(e2), this.semicolon(), this.scope.declareName(t3.id.name, 2048, t3.id.loc.start), this.finishNode(t3, "DeclareFunction");
      }
      flowParseDeclare(t3, e2) {
        return this.match(80) ? this.flowParseDeclareClass(t3) : this.match(68) ? this.flowParseDeclareFunction(t3) : this.match(74) ? this.flowParseDeclareVariable(t3) : this.eatContextual(127) ? this.match(16) ? this.flowParseDeclareModuleExports(t3) : (e2 && this.raise(oi.NestedDeclareModule, { at: this.state.lastTokStartLoc }), this.flowParseDeclareModule(t3)) : this.isContextual(130) ? this.flowParseDeclareTypeAlias(t3) : this.isContextual(131) ? this.flowParseDeclareOpaqueType(t3) : this.isContextual(129) ? this.flowParseDeclareInterface(t3) : this.match(82) ? this.flowParseDeclareExportDeclaration(t3, e2) : void this.unexpected();
      }
      flowParseDeclareVariable(t3) {
        return this.next(), t3.id = this.flowParseTypeAnnotatableIdentifier(true), this.scope.declareName(t3.id.name, 5, t3.id.loc.start), this.semicolon(), this.finishNode(t3, "DeclareVariable");
      }
      flowParseDeclareModule(t3) {
        this.scope.enter(0), this.match(133) ? t3.id = super.parseExprAtom() : t3.id = this.parseIdentifier();
        const e2 = t3.body = this.startNode(), r2 = e2.body = [];
        for (this.expect(5); !this.match(8); ) {
          let t4 = this.startNode();
          this.match(83) ? (this.next(), this.isContextual(130) || this.match(87) || this.raise(oi.InvalidNonTypeImportInDeclareModule, { at: this.state.lastTokStartLoc }), super.parseImport(t4)) : (this.expectContextual(125, oi.UnsupportedStatementInDeclareModule), t4 = this.flowParseDeclare(t4, true)), r2.push(t4);
        }
        this.scope.exit(), this.expect(8), this.finishNode(e2, "BlockStatement");
        let n2 = null, i2 = false;
        return r2.forEach((t4) => {
          !function(t5) {
            return "DeclareExportAllDeclaration" === t5.type || "DeclareExportDeclaration" === t5.type && (!t5.declaration || "TypeAlias" !== t5.declaration.type && "InterfaceDeclaration" !== t5.declaration.type);
          }(t4) ? "DeclareModuleExports" === t4.type && (i2 && this.raise(oi.DuplicateDeclareModuleExports, { at: t4 }), "ES" === n2 && this.raise(oi.AmbiguousDeclareModuleKind, { at: t4 }), n2 = "CommonJS", i2 = true) : ("CommonJS" === n2 && this.raise(oi.AmbiguousDeclareModuleKind, { at: t4 }), n2 = "ES");
        }), t3.kind = n2 || "CommonJS", this.finishNode(t3, "DeclareModule");
      }
      flowParseDeclareExportDeclaration(t3, e2) {
        if (this.expect(82), this.eat(65))
          return this.match(68) || this.match(80) ? t3.declaration = this.flowParseDeclare(this.startNode()) : (t3.declaration = this.flowParseType(), this.semicolon()), t3.default = true, this.finishNode(t3, "DeclareExportDeclaration");
        if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !e2) {
          const t4 = this.state.value;
          throw this.raise(oi.UnsupportedDeclareExportKind, { at: this.state.startLoc, unsupportedExportKind: t4, suggestion: ai[t4] });
        }
        return this.match(74) || this.match(68) || this.match(80) || this.isContextual(131) ? (t3.declaration = this.flowParseDeclare(this.startNode()), t3.default = false, this.finishNode(t3, "DeclareExportDeclaration")) : this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131) ? ("ExportNamedDeclaration" === (t3 = this.parseExport(t3, null)).type && (t3.type = "ExportDeclaration", t3.default = false, delete t3.exportKind), t3.type = "Declare" + t3.type, t3) : void this.unexpected();
      }
      flowParseDeclareModuleExports(t3) {
        return this.next(), this.expectContextual(111), t3.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(t3, "DeclareModuleExports");
      }
      flowParseDeclareTypeAlias(t3) {
        this.next();
        const e2 = this.flowParseTypeAlias(t3);
        return e2.type = "DeclareTypeAlias", e2;
      }
      flowParseDeclareOpaqueType(t3) {
        this.next();
        const e2 = this.flowParseOpaqueType(t3, true);
        return e2.type = "DeclareOpaqueType", e2;
      }
      flowParseDeclareInterface(t3) {
        return this.next(), this.flowParseInterfaceish(t3, false), this.finishNode(t3, "DeclareInterface");
      }
      flowParseInterfaceish(t3, e2) {
        if (t3.id = this.flowParseRestrictedIdentifier(!e2, true), this.scope.declareName(t3.id.name, e2 ? 17 : 8201, t3.id.loc.start), this.match(47) ? t3.typeParameters = this.flowParseTypeParameterDeclaration() : t3.typeParameters = null, t3.extends = [], this.eat(81))
          do {
            t3.extends.push(this.flowParseInterfaceExtends());
          } while (!e2 && this.eat(12));
        if (e2) {
          if (t3.implements = [], t3.mixins = [], this.eatContextual(117))
            do {
              t3.mixins.push(this.flowParseInterfaceExtends());
            } while (this.eat(12));
          if (this.eatContextual(113))
            do {
              t3.implements.push(this.flowParseInterfaceExtends());
            } while (this.eat(12));
        }
        t3.body = this.flowParseObjectType({ allowStatic: e2, allowExact: false, allowSpread: false, allowProto: e2, allowInexact: false });
      }
      flowParseInterfaceExtends() {
        const t3 = this.startNode();
        return t3.id = this.flowParseQualifiedTypeIdentifier(), this.match(47) ? t3.typeParameters = this.flowParseTypeParameterInstantiation() : t3.typeParameters = null, this.finishNode(t3, "InterfaceExtends");
      }
      flowParseInterface(t3) {
        return this.flowParseInterfaceish(t3, false), this.finishNode(t3, "InterfaceDeclaration");
      }
      checkNotUnderscore(t3) {
        "_" === t3 && this.raise(oi.UnexpectedReservedUnderscore, { at: this.state.startLoc });
      }
      checkReservedType(t3, e2, r2) {
        ii.has(t3) && this.raise(r2 ? oi.AssignReservedType : oi.UnexpectedReservedType, { at: e2, reservedType: t3 });
      }
      flowParseRestrictedIdentifier(t3, e2) {
        return this.checkReservedType(this.state.value, this.state.startLoc, e2), this.parseIdentifier(t3);
      }
      flowParseTypeAlias(t3) {
        return t3.id = this.flowParseRestrictedIdentifier(false, true), this.scope.declareName(t3.id.name, 8201, t3.id.loc.start), this.match(47) ? t3.typeParameters = this.flowParseTypeParameterDeclaration() : t3.typeParameters = null, t3.right = this.flowParseTypeInitialiser(29), this.semicolon(), this.finishNode(t3, "TypeAlias");
      }
      flowParseOpaqueType(t3, e2) {
        return this.expectContextual(130), t3.id = this.flowParseRestrictedIdentifier(true, true), this.scope.declareName(t3.id.name, 8201, t3.id.loc.start), this.match(47) ? t3.typeParameters = this.flowParseTypeParameterDeclaration() : t3.typeParameters = null, t3.supertype = null, this.match(14) && (t3.supertype = this.flowParseTypeInitialiser(14)), t3.impltype = null, e2 || (t3.impltype = this.flowParseTypeInitialiser(29)), this.semicolon(), this.finishNode(t3, "OpaqueType");
      }
      flowParseTypeParameter(t3 = false) {
        const e2 = this.state.startLoc, r2 = this.startNode(), n2 = this.flowParseVariance(), i2 = this.flowParseTypeAnnotatableIdentifier();
        return r2.name = i2.name, r2.variance = n2, r2.bound = i2.typeAnnotation, this.match(29) ? (this.eat(29), r2.default = this.flowParseType()) : t3 && this.raise(oi.MissingTypeParamDefault, { at: e2 }), this.finishNode(r2, "TypeParameter");
      }
      flowParseTypeParameterDeclaration() {
        const t3 = this.state.inType, e2 = this.startNode();
        e2.params = [], this.state.inType = true, this.match(47) || this.match(142) ? this.next() : this.unexpected();
        let r2 = false;
        do {
          const t4 = this.flowParseTypeParameter(r2);
          e2.params.push(t4), t4.default && (r2 = true), this.match(48) || this.expect(12);
        } while (!this.match(48));
        return this.expect(48), this.state.inType = t3, this.finishNode(e2, "TypeParameterDeclaration");
      }
      flowParseTypeParameterInstantiation() {
        const t3 = this.startNode(), e2 = this.state.inType;
        t3.params = [], this.state.inType = true, this.expect(47);
        const r2 = this.state.noAnonFunctionType;
        for (this.state.noAnonFunctionType = false; !this.match(48); )
          t3.params.push(this.flowParseType()), this.match(48) || this.expect(12);
        return this.state.noAnonFunctionType = r2, this.expect(48), this.state.inType = e2, this.finishNode(t3, "TypeParameterInstantiation");
      }
      flowParseTypeParameterInstantiationCallOrNew() {
        const t3 = this.startNode(), e2 = this.state.inType;
        for (t3.params = [], this.state.inType = true, this.expect(47); !this.match(48); )
          t3.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
        return this.expect(48), this.state.inType = e2, this.finishNode(t3, "TypeParameterInstantiation");
      }
      flowParseInterfaceType() {
        const t3 = this.startNode();
        if (this.expectContextual(129), t3.extends = [], this.eat(81))
          do {
            t3.extends.push(this.flowParseInterfaceExtends());
          } while (this.eat(12));
        return t3.body = this.flowParseObjectType({ allowStatic: false, allowExact: false, allowSpread: false, allowProto: false, allowInexact: false }), this.finishNode(t3, "InterfaceTypeAnnotation");
      }
      flowParseObjectPropertyKey() {
        return this.match(134) || this.match(133) ? super.parseExprAtom() : this.parseIdentifier(true);
      }
      flowParseObjectTypeIndexer(t3, e2, r2) {
        return t3.static = e2, 14 === this.lookahead().type ? (t3.id = this.flowParseObjectPropertyKey(), t3.key = this.flowParseTypeInitialiser()) : (t3.id = null, t3.key = this.flowParseType()), this.expect(3), t3.value = this.flowParseTypeInitialiser(), t3.variance = r2, this.finishNode(t3, "ObjectTypeIndexer");
      }
      flowParseObjectTypeInternalSlot(t3, e2) {
        return t3.static = e2, t3.id = this.flowParseObjectPropertyKey(), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? (t3.method = true, t3.optional = false, t3.value = this.flowParseObjectTypeMethodish(this.startNodeAt(t3.loc.start))) : (t3.method = false, this.eat(17) && (t3.optional = true), t3.value = this.flowParseTypeInitialiser()), this.finishNode(t3, "ObjectTypeInternalSlot");
      }
      flowParseObjectTypeMethodish(t3) {
        for (t3.params = [], t3.rest = null, t3.typeParameters = null, t3.this = null, this.match(47) && (t3.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(10), this.match(78) && (t3.this = this.flowParseFunctionTypeParam(true), t3.this.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); )
          t3.params.push(this.flowParseFunctionTypeParam(false)), this.match(11) || this.expect(12);
        return this.eat(21) && (t3.rest = this.flowParseFunctionTypeParam(false)), this.expect(11), t3.returnType = this.flowParseTypeInitialiser(), this.finishNode(t3, "FunctionTypeAnnotation");
      }
      flowParseObjectTypeCallProperty(t3, e2) {
        const r2 = this.startNode();
        return t3.static = e2, t3.value = this.flowParseObjectTypeMethodish(r2), this.finishNode(t3, "ObjectTypeCallProperty");
      }
      flowParseObjectType({ allowStatic: t3, allowExact: e2, allowSpread: r2, allowProto: n2, allowInexact: i2 }) {
        const o2 = this.state.inType;
        this.state.inType = true;
        const a2 = this.startNode();
        let s2, l2;
        a2.callProperties = [], a2.properties = [], a2.indexers = [], a2.internalSlots = [];
        let p2 = false;
        for (e2 && this.match(6) ? (this.expect(6), s2 = 9, l2 = true) : (this.expect(5), s2 = 8, l2 = false), a2.exact = l2; !this.match(s2); ) {
          let e3 = false, o3 = null, s3 = null;
          const c3 = this.startNode();
          if (n2 && this.isContextual(118)) {
            const e4 = this.lookahead();
            14 !== e4.type && 17 !== e4.type && (this.next(), o3 = this.state.startLoc, t3 = false);
          }
          if (t3 && this.isContextual(106)) {
            const t4 = this.lookahead();
            14 !== t4.type && 17 !== t4.type && (this.next(), e3 = true);
          }
          const d2 = this.flowParseVariance();
          if (this.eat(0))
            null != o3 && this.unexpected(o3), this.eat(0) ? (d2 && this.unexpected(d2.loc.start), a2.internalSlots.push(this.flowParseObjectTypeInternalSlot(c3, e3))) : a2.indexers.push(this.flowParseObjectTypeIndexer(c3, e3, d2));
          else if (this.match(10) || this.match(47))
            null != o3 && this.unexpected(o3), d2 && this.unexpected(d2.loc.start), a2.callProperties.push(this.flowParseObjectTypeCallProperty(c3, e3));
          else {
            let t4 = "init";
            if (this.isContextual(99) || this.isContextual(104)) {
              tokenIsLiteralPropertyName(this.lookahead().type) && (t4 = this.state.value, this.next());
            }
            const n3 = this.flowParseObjectTypeProperty(c3, e3, o3, d2, t4, r2, null != i2 ? i2 : !l2);
            null === n3 ? (p2 = true, s3 = this.state.lastTokStartLoc) : a2.properties.push(n3);
          }
          this.flowObjectTypeSemicolon(), !s3 || this.match(8) || this.match(9) || this.raise(oi.UnexpectedExplicitInexactInObject, { at: s3 });
        }
        this.expect(s2), r2 && (a2.inexact = p2);
        const c2 = this.finishNode(a2, "ObjectTypeAnnotation");
        return this.state.inType = o2, c2;
      }
      flowParseObjectTypeProperty(t3, e2, r2, n2, i2, o2, a2) {
        if (this.eat(21)) {
          return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (o2 ? a2 || this.raise(oi.InexactInsideExact, { at: this.state.lastTokStartLoc }) : this.raise(oi.InexactInsideNonObject, { at: this.state.lastTokStartLoc }), n2 && this.raise(oi.InexactVariance, { at: n2 }), null) : (o2 || this.raise(oi.UnexpectedSpreadType, { at: this.state.lastTokStartLoc }), null != r2 && this.unexpected(r2), n2 && this.raise(oi.SpreadVariance, { at: n2 }), t3.argument = this.flowParseType(), this.finishNode(t3, "ObjectTypeSpreadProperty"));
        }
        {
          t3.key = this.flowParseObjectPropertyKey(), t3.static = e2, t3.proto = null != r2, t3.kind = i2;
          let a3 = false;
          return this.match(47) || this.match(10) ? (t3.method = true, null != r2 && this.unexpected(r2), n2 && this.unexpected(n2.loc.start), t3.value = this.flowParseObjectTypeMethodish(this.startNodeAt(t3.loc.start)), "get" !== i2 && "set" !== i2 || this.flowCheckGetterSetterParams(t3), !o2 && "constructor" === t3.key.name && t3.value.this && this.raise(oi.ThisParamBannedInConstructor, { at: t3.value.this })) : ("init" !== i2 && this.unexpected(), t3.method = false, this.eat(17) && (a3 = true), t3.value = this.flowParseTypeInitialiser(), t3.variance = n2), t3.optional = a3, this.finishNode(t3, "ObjectTypeProperty");
        }
      }
      flowCheckGetterSetterParams(t3) {
        const e2 = "get" === t3.kind ? 0 : 1, r2 = t3.value.params.length + (t3.value.rest ? 1 : 0);
        t3.value.this && this.raise("get" === t3.kind ? oi.GetterMayNotHaveThisParam : oi.SetterMayNotHaveThisParam, { at: t3.value.this }), r2 !== e2 && this.raise("get" === t3.kind ? xn.BadGetterArity : xn.BadSetterArity, { at: t3 }), "set" === t3.kind && t3.value.rest && this.raise(xn.BadSetterRestParameter, { at: t3 });
      }
      flowObjectTypeSemicolon() {
        this.eat(13) || this.eat(12) || this.match(8) || this.match(9) || this.unexpected();
      }
      flowParseQualifiedTypeIdentifier(t3, e2) {
        null != t3 || (t3 = this.state.startLoc);
        let r2 = e2 || this.flowParseRestrictedIdentifier(true);
        for (; this.eat(16); ) {
          const e3 = this.startNodeAt(t3);
          e3.qualification = r2, e3.id = this.flowParseRestrictedIdentifier(true), r2 = this.finishNode(e3, "QualifiedTypeIdentifier");
        }
        return r2;
      }
      flowParseGenericType(t3, e2) {
        const r2 = this.startNodeAt(t3);
        return r2.typeParameters = null, r2.id = this.flowParseQualifiedTypeIdentifier(t3, e2), this.match(47) && (r2.typeParameters = this.flowParseTypeParameterInstantiation()), this.finishNode(r2, "GenericTypeAnnotation");
      }
      flowParseTypeofType() {
        const t3 = this.startNode();
        return this.expect(87), t3.argument = this.flowParsePrimaryType(), this.finishNode(t3, "TypeofTypeAnnotation");
      }
      flowParseTupleType() {
        const t3 = this.startNode();
        for (t3.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (t3.types.push(this.flowParseType()), !this.match(3)); )
          this.expect(12);
        return this.expect(3), this.finishNode(t3, "TupleTypeAnnotation");
      }
      flowParseFunctionTypeParam(t3) {
        let e2 = null, r2 = false, n2 = null;
        const i2 = this.startNode(), o2 = this.lookahead(), a2 = 78 === this.state.type;
        return 14 === o2.type || 17 === o2.type ? (a2 && !t3 && this.raise(oi.ThisParamMustBeFirst, { at: i2 }), e2 = this.parseIdentifier(a2), this.eat(17) && (r2 = true, a2 && this.raise(oi.ThisParamMayNotBeOptional, { at: i2 })), n2 = this.flowParseTypeInitialiser()) : n2 = this.flowParseType(), i2.name = e2, i2.optional = r2, i2.typeAnnotation = n2, this.finishNode(i2, "FunctionTypeParam");
      }
      reinterpretTypeAsFunctionTypeParam(t3) {
        const e2 = this.startNodeAt(t3.loc.start);
        return e2.name = null, e2.optional = false, e2.typeAnnotation = t3, this.finishNode(e2, "FunctionTypeParam");
      }
      flowParseFunctionTypeParams(t3 = []) {
        let e2 = null, r2 = null;
        for (this.match(78) && (r2 = this.flowParseFunctionTypeParam(true), r2.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); )
          t3.push(this.flowParseFunctionTypeParam(false)), this.match(11) || this.expect(12);
        return this.eat(21) && (e2 = this.flowParseFunctionTypeParam(false)), { params: t3, rest: e2, _this: r2 };
      }
      flowIdentToTypeAnnotation(t3, e2, r2) {
        switch (r2.name) {
          case "any":
            return this.finishNode(e2, "AnyTypeAnnotation");
          case "bool":
          case "boolean":
            return this.finishNode(e2, "BooleanTypeAnnotation");
          case "mixed":
            return this.finishNode(e2, "MixedTypeAnnotation");
          case "empty":
            return this.finishNode(e2, "EmptyTypeAnnotation");
          case "number":
            return this.finishNode(e2, "NumberTypeAnnotation");
          case "string":
            return this.finishNode(e2, "StringTypeAnnotation");
          case "symbol":
            return this.finishNode(e2, "SymbolTypeAnnotation");
          default:
            return this.checkNotUnderscore(r2.name), this.flowParseGenericType(t3, r2);
        }
      }
      flowParsePrimaryType() {
        const t3 = this.state.startLoc, e2 = this.startNode();
        let r2, n2, i2 = false;
        const o2 = this.state.noAnonFunctionType;
        switch (this.state.type) {
          case 5:
            return this.flowParseObjectType({ allowStatic: false, allowExact: false, allowSpread: true, allowProto: false, allowInexact: true });
          case 6:
            return this.flowParseObjectType({ allowStatic: false, allowExact: true, allowSpread: true, allowProto: false, allowInexact: false });
          case 0:
            return this.state.noAnonFunctionType = false, n2 = this.flowParseTupleType(), this.state.noAnonFunctionType = o2, n2;
          case 47:
            return e2.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), r2 = this.flowParseFunctionTypeParams(), e2.params = r2.params, e2.rest = r2.rest, e2.this = r2._this, this.expect(11), this.expect(19), e2.returnType = this.flowParseType(), this.finishNode(e2, "FunctionTypeAnnotation");
          case 10:
            if (this.next(), !this.match(11) && !this.match(21))
              if (tokenIsIdentifier(this.state.type) || this.match(78)) {
                const t4 = this.lookahead().type;
                i2 = 17 !== t4 && 14 !== t4;
              } else
                i2 = true;
            if (i2) {
              if (this.state.noAnonFunctionType = false, n2 = this.flowParseType(), this.state.noAnonFunctionType = o2, this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && 19 === this.lookahead().type))
                return this.expect(11), n2;
              this.eat(12);
            }
            return r2 = n2 ? this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(n2)]) : this.flowParseFunctionTypeParams(), e2.params = r2.params, e2.rest = r2.rest, e2.this = r2._this, this.expect(11), this.expect(19), e2.returnType = this.flowParseType(), e2.typeParameters = null, this.finishNode(e2, "FunctionTypeAnnotation");
          case 133:
            return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
          case 85:
          case 86:
            return e2.value = this.match(85), this.next(), this.finishNode(e2, "BooleanLiteralTypeAnnotation");
          case 53:
            if ("-" === this.state.value) {
              if (this.next(), this.match(134))
                return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", e2);
              if (this.match(135))
                return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", e2);
              throw this.raise(oi.UnexpectedSubtractionOperand, { at: this.state.startLoc });
            }
            return void this.unexpected();
          case 134:
            return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
          case 135:
            return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
          case 88:
            return this.next(), this.finishNode(e2, "VoidTypeAnnotation");
          case 84:
            return this.next(), this.finishNode(e2, "NullLiteralTypeAnnotation");
          case 78:
            return this.next(), this.finishNode(e2, "ThisTypeAnnotation");
          case 55:
            return this.next(), this.finishNode(e2, "ExistsTypeAnnotation");
          case 87:
            return this.flowParseTypeofType();
          default:
            if (tokenIsKeyword(this.state.type)) {
              const t4 = tokenLabelName(this.state.type);
              return this.next(), super.createIdentifier(e2, t4);
            }
            if (tokenIsIdentifier(this.state.type))
              return this.isContextual(129) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(t3, e2, this.parseIdentifier());
        }
        this.unexpected();
      }
      flowParsePostfixType() {
        const t3 = this.state.startLoc;
        let e2 = this.flowParsePrimaryType(), r2 = false;
        for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
          const n2 = this.startNodeAt(t3), i2 = this.eat(18);
          r2 = r2 || i2, this.expect(0), !i2 && this.match(3) ? (n2.elementType = e2, this.next(), e2 = this.finishNode(n2, "ArrayTypeAnnotation")) : (n2.objectType = e2, n2.indexType = this.flowParseType(), this.expect(3), r2 ? (n2.optional = i2, e2 = this.finishNode(n2, "OptionalIndexedAccessType")) : e2 = this.finishNode(n2, "IndexedAccessType"));
        }
        return e2;
      }
      flowParsePrefixType() {
        const t3 = this.startNode();
        return this.eat(17) ? (t3.typeAnnotation = this.flowParsePrefixType(), this.finishNode(t3, "NullableTypeAnnotation")) : this.flowParsePostfixType();
      }
      flowParseAnonFunctionWithoutParens() {
        const t3 = this.flowParsePrefixType();
        if (!this.state.noAnonFunctionType && this.eat(19)) {
          const e2 = this.startNodeAt(t3.loc.start);
          return e2.params = [this.reinterpretTypeAsFunctionTypeParam(t3)], e2.rest = null, e2.this = null, e2.returnType = this.flowParseType(), e2.typeParameters = null, this.finishNode(e2, "FunctionTypeAnnotation");
        }
        return t3;
      }
      flowParseIntersectionType() {
        const t3 = this.startNode();
        this.eat(45);
        const e2 = this.flowParseAnonFunctionWithoutParens();
        for (t3.types = [e2]; this.eat(45); )
          t3.types.push(this.flowParseAnonFunctionWithoutParens());
        return 1 === t3.types.length ? e2 : this.finishNode(t3, "IntersectionTypeAnnotation");
      }
      flowParseUnionType() {
        const t3 = this.startNode();
        this.eat(43);
        const e2 = this.flowParseIntersectionType();
        for (t3.types = [e2]; this.eat(43); )
          t3.types.push(this.flowParseIntersectionType());
        return 1 === t3.types.length ? e2 : this.finishNode(t3, "UnionTypeAnnotation");
      }
      flowParseType() {
        const t3 = this.state.inType;
        this.state.inType = true;
        const e2 = this.flowParseUnionType();
        return this.state.inType = t3, e2;
      }
      flowParseTypeOrImplicitInstantiation() {
        if (132 === this.state.type && "_" === this.state.value) {
          const t3 = this.state.startLoc, e2 = this.parseIdentifier();
          return this.flowParseGenericType(t3, e2);
        }
        return this.flowParseType();
      }
      flowParseTypeAnnotation() {
        const t3 = this.startNode();
        return t3.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(t3, "TypeAnnotation");
      }
      flowParseTypeAnnotatableIdentifier(t3) {
        const e2 = t3 ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
        return this.match(14) && (e2.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(e2)), e2;
      }
      typeCastToParameter(t3) {
        return t3.expression.typeAnnotation = t3.typeAnnotation, this.resetEndLocation(t3.expression, t3.typeAnnotation.loc.end), t3.expression;
      }
      flowParseVariance() {
        let t3 = null;
        return this.match(53) ? (t3 = this.startNode(), "+" === this.state.value ? t3.kind = "plus" : t3.kind = "minus", this.next(), this.finishNode(t3, "Variance")) : t3;
      }
      parseFunctionBody(t3, e2, r2 = false) {
        e2 ? this.forwardNoArrowParamsConversionAt(t3, () => super.parseFunctionBody(t3, true, r2)) : super.parseFunctionBody(t3, false, r2);
      }
      parseFunctionBodyAndFinish(t3, e2, r2 = false) {
        if (this.match(14)) {
          const e3 = this.startNode();
          [e3.typeAnnotation, t3.predicate] = this.flowParseTypeAndPredicateInitialiser(), t3.returnType = e3.typeAnnotation ? this.finishNode(e3, "TypeAnnotation") : null;
        }
        return super.parseFunctionBodyAndFinish(t3, e2, r2);
      }
      parseStatementLike(t3) {
        if (this.state.strict && this.isContextual(129)) {
          if (tokenIsKeywordOrIdentifier(this.lookahead().type)) {
            const t4 = this.startNode();
            return this.next(), this.flowParseInterface(t4);
          }
        } else if (this.shouldParseEnums() && this.isContextual(126)) {
          const t4 = this.startNode();
          return this.next(), this.flowParseEnumDeclaration(t4);
        }
        const e2 = super.parseStatementLike(t3);
        return void 0 !== this.flowPragma || this.isValidDirective(e2) || (this.flowPragma = null), e2;
      }
      parseExpressionStatement(t3, e2, r2) {
        if ("Identifier" === e2.type) {
          if ("declare" === e2.name) {
            if (this.match(80) || tokenIsIdentifier(this.state.type) || this.match(68) || this.match(74) || this.match(82))
              return this.flowParseDeclare(t3);
          } else if (tokenIsIdentifier(this.state.type)) {
            if ("interface" === e2.name)
              return this.flowParseInterface(t3);
            if ("type" === e2.name)
              return this.flowParseTypeAlias(t3);
            if ("opaque" === e2.name)
              return this.flowParseOpaqueType(t3, false);
          }
        }
        return super.parseExpressionStatement(t3, e2, r2);
      }
      shouldParseExportDeclaration() {
        const { type: t3 } = this.state;
        return tokenIsFlowInterfaceOrTypeOrOpaque(t3) || this.shouldParseEnums() && 126 === t3 ? !this.state.containsEsc : super.shouldParseExportDeclaration();
      }
      isExportDefaultSpecifier() {
        const { type: t3 } = this.state;
        return tokenIsFlowInterfaceOrTypeOrOpaque(t3) || this.shouldParseEnums() && 126 === t3 ? this.state.containsEsc : super.isExportDefaultSpecifier();
      }
      parseExportDefaultExpression() {
        if (this.shouldParseEnums() && this.isContextual(126)) {
          const t3 = this.startNode();
          return this.next(), this.flowParseEnumDeclaration(t3);
        }
        return super.parseExportDefaultExpression();
      }
      parseConditional(t3, e2, r2) {
        if (!this.match(17))
          return t3;
        if (this.state.maybeInArrowParameters) {
          const e3 = this.lookaheadCharCode();
          if (44 === e3 || 61 === e3 || 58 === e3 || 41 === e3)
            return this.setOptionalParametersError(r2), t3;
        }
        this.expect(17);
        const n2 = this.state.clone(), i2 = this.state.noArrowAt, o2 = this.startNodeAt(e2);
        let { consequent: a2, failed: s2 } = this.tryParseConditionalConsequent(), [l2, p2] = this.getArrowLikeExpressions(a2);
        if (s2 || p2.length > 0) {
          const t4 = [...i2];
          if (p2.length > 0) {
            this.state = n2, this.state.noArrowAt = t4;
            for (let e3 = 0; e3 < p2.length; e3++)
              t4.push(p2[e3].start);
            ({ consequent: a2, failed: s2 } = this.tryParseConditionalConsequent()), [l2, p2] = this.getArrowLikeExpressions(a2);
          }
          s2 && l2.length > 1 && this.raise(oi.AmbiguousConditionalArrow, { at: n2.startLoc }), s2 && 1 === l2.length && (this.state = n2, t4.push(l2[0].start), this.state.noArrowAt = t4, { consequent: a2, failed: s2 } = this.tryParseConditionalConsequent());
        }
        return this.getArrowLikeExpressions(a2, true), this.state.noArrowAt = i2, this.expect(14), o2.test = t3, o2.consequent = a2, o2.alternate = this.forwardNoArrowParamsConversionAt(o2, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(o2, "ConditionalExpression");
      }
      tryParseConditionalConsequent() {
        this.state.noArrowParamsConversionAt.push(this.state.start);
        const t3 = this.parseMaybeAssignAllowIn(), e2 = !this.match(14);
        return this.state.noArrowParamsConversionAt.pop(), { consequent: t3, failed: e2 };
      }
      getArrowLikeExpressions(t3, e2) {
        const r2 = [t3], n2 = [];
        for (; 0 !== r2.length; ) {
          const t4 = r2.pop();
          "ArrowFunctionExpression" === t4.type ? (t4.typeParameters || !t4.returnType ? this.finishArrowValidation(t4) : n2.push(t4), r2.push(t4.body)) : "ConditionalExpression" === t4.type && (r2.push(t4.consequent), r2.push(t4.alternate));
        }
        return e2 ? (n2.forEach((t4) => this.finishArrowValidation(t4)), [n2, []]) : function(t4, e3) {
          const r3 = [], n3 = [];
          for (let i2 = 0; i2 < t4.length; i2++)
            (e3(t4[i2], i2, t4) ? r3 : n3).push(t4[i2]);
          return [r3, n3];
        }(n2, (t4) => t4.params.every((t5) => this.isAssignable(t5, true)));
      }
      finishArrowValidation(t3) {
        var e2;
        this.toAssignableList(t3.params, null == (e2 = t3.extra) ? void 0 : e2.trailingCommaLoc, false), this.scope.enter(6), super.checkParams(t3, false, true), this.scope.exit();
      }
      forwardNoArrowParamsConversionAt(t3, e2) {
        let r2;
        return -1 !== this.state.noArrowParamsConversionAt.indexOf(t3.start) ? (this.state.noArrowParamsConversionAt.push(this.state.start), r2 = e2(), this.state.noArrowParamsConversionAt.pop()) : r2 = e2(), r2;
      }
      parseParenItem(t3, e2) {
        if (t3 = super.parseParenItem(t3, e2), this.eat(17) && (t3.optional = true, this.resetEndLocation(t3)), this.match(14)) {
          const r2 = this.startNodeAt(e2);
          return r2.expression = t3, r2.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(r2, "TypeCastExpression");
        }
        return t3;
      }
      assertModuleNodeAllowed(t3) {
        "ImportDeclaration" === t3.type && ("type" === t3.importKind || "typeof" === t3.importKind) || "ExportNamedDeclaration" === t3.type && "type" === t3.exportKind || "ExportAllDeclaration" === t3.type && "type" === t3.exportKind || super.assertModuleNodeAllowed(t3);
      }
      parseExportDeclaration(t3) {
        if (this.isContextual(130)) {
          t3.exportKind = "type";
          const e2 = this.startNode();
          return this.next(), this.match(5) ? (t3.specifiers = this.parseExportSpecifiers(true), super.parseExportFrom(t3), null) : this.flowParseTypeAlias(e2);
        }
        if (this.isContextual(131)) {
          t3.exportKind = "type";
          const e2 = this.startNode();
          return this.next(), this.flowParseOpaqueType(e2, false);
        }
        if (this.isContextual(129)) {
          t3.exportKind = "type";
          const e2 = this.startNode();
          return this.next(), this.flowParseInterface(e2);
        }
        if (this.shouldParseEnums() && this.isContextual(126)) {
          t3.exportKind = "value";
          const e2 = this.startNode();
          return this.next(), this.flowParseEnumDeclaration(e2);
        }
        return super.parseExportDeclaration(t3);
      }
      eatExportStar(t3) {
        return !!super.eatExportStar(t3) || !(!this.isContextual(130) || 55 !== this.lookahead().type) && (t3.exportKind = "type", this.next(), this.next(), true);
      }
      maybeParseExportNamespaceSpecifier(t3) {
        const { startLoc: e2 } = this.state, r2 = super.maybeParseExportNamespaceSpecifier(t3);
        return r2 && "type" === t3.exportKind && this.unexpected(e2), r2;
      }
      parseClassId(t3, e2, r2) {
        super.parseClassId(t3, e2, r2), this.match(47) && (t3.typeParameters = this.flowParseTypeParameterDeclaration());
      }
      parseClassMember(t3, e2, r2) {
        const { startLoc: n2 } = this.state;
        if (this.isContextual(125)) {
          if (super.parseClassMemberFromModifier(t3, e2))
            return;
          e2.declare = true;
        }
        super.parseClassMember(t3, e2, r2), e2.declare && ("ClassProperty" !== e2.type && "ClassPrivateProperty" !== e2.type && "PropertyDefinition" !== e2.type ? this.raise(oi.DeclareClassElement, { at: n2 }) : e2.value && this.raise(oi.DeclareClassFieldInitializer, { at: e2.value }));
      }
      isIterator(t3) {
        return "iterator" === t3 || "asyncIterator" === t3;
      }
      readIterator() {
        const t3 = super.readWord1(), e2 = "@@" + t3;
        this.isIterator(t3) && this.state.inType || this.raise(xn.InvalidIdentifier, { at: this.state.curPosition(), identifierName: e2 }), this.finishToken(132, e2);
      }
      getTokenFromCode(t3) {
        const e2 = this.input.charCodeAt(this.state.pos + 1);
        123 === t3 && 124 === e2 ? this.finishOp(6, 2) : !this.state.inType || 62 !== t3 && 60 !== t3 ? this.state.inType && 63 === t3 ? 46 === e2 ? this.finishOp(18, 2) : this.finishOp(17, 1) : !function(t4, e3, r2) {
          return 64 === t4 && 64 === e3 && isIdentifierStart(r2);
        }(t3, e2, this.input.charCodeAt(this.state.pos + 2)) ? super.getTokenFromCode(t3) : (this.state.pos += 2, this.readIterator()) : this.finishOp(62 === t3 ? 48 : 47, 1);
      }
      isAssignable(t3, e2) {
        return "TypeCastExpression" === t3.type ? this.isAssignable(t3.expression, e2) : super.isAssignable(t3, e2);
      }
      toAssignable(t3, e2 = false) {
        e2 || "AssignmentExpression" !== t3.type || "TypeCastExpression" !== t3.left.type || (t3.left = this.typeCastToParameter(t3.left)), super.toAssignable(t3, e2);
      }
      toAssignableList(t3, e2, r2) {
        for (let e3 = 0; e3 < t3.length; e3++) {
          const r3 = t3[e3];
          "TypeCastExpression" === (null == r3 ? void 0 : r3.type) && (t3[e3] = this.typeCastToParameter(r3));
        }
        super.toAssignableList(t3, e2, r2);
      }
      toReferencedList(t3, e2) {
        for (let n2 = 0; n2 < t3.length; n2++) {
          var r2;
          const i2 = t3[n2];
          !i2 || "TypeCastExpression" !== i2.type || null != (r2 = i2.extra) && r2.parenthesized || !(t3.length > 1) && e2 || this.raise(oi.TypeCastInPattern, { at: i2.typeAnnotation });
        }
        return t3;
      }
      parseArrayLike(t3, e2, r2, n2) {
        const i2 = super.parseArrayLike(t3, e2, r2, n2);
        return e2 && !this.state.maybeInArrowParameters && this.toReferencedList(i2.elements), i2;
      }
      isValidLVal(t3, e2, r2) {
        return "TypeCastExpression" === t3 || super.isValidLVal(t3, e2, r2);
      }
      parseClassProperty(t3) {
        return this.match(14) && (t3.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(t3);
      }
      parseClassPrivateProperty(t3) {
        return this.match(14) && (t3.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(t3);
      }
      isClassMethod() {
        return this.match(47) || super.isClassMethod();
      }
      isClassProperty() {
        return this.match(14) || super.isClassProperty();
      }
      isNonstaticConstructor(t3) {
        return !this.match(14) && super.isNonstaticConstructor(t3);
      }
      pushClassMethod(t3, e2, r2, n2, i2, o2) {
        if (e2.variance && this.unexpected(e2.variance.loc.start), delete e2.variance, this.match(47) && (e2.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassMethod(t3, e2, r2, n2, i2, o2), e2.params && i2) {
          const t4 = e2.params;
          t4.length > 0 && this.isThisParam(t4[0]) && this.raise(oi.ThisParamBannedInConstructor, { at: e2 });
        } else if ("MethodDefinition" === e2.type && i2 && e2.value.params) {
          const t4 = e2.value.params;
          t4.length > 0 && this.isThisParam(t4[0]) && this.raise(oi.ThisParamBannedInConstructor, { at: e2 });
        }
      }
      pushClassPrivateMethod(t3, e2, r2, n2) {
        e2.variance && this.unexpected(e2.variance.loc.start), delete e2.variance, this.match(47) && (e2.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassPrivateMethod(t3, e2, r2, n2);
      }
      parseClassSuper(t3) {
        if (super.parseClassSuper(t3), t3.superClass && this.match(47) && (t3.superTypeParameters = this.flowParseTypeParameterInstantiation()), this.isContextual(113)) {
          this.next();
          const e2 = t3.implements = [];
          do {
            const t4 = this.startNode();
            t4.id = this.flowParseRestrictedIdentifier(true), this.match(47) ? t4.typeParameters = this.flowParseTypeParameterInstantiation() : t4.typeParameters = null, e2.push(this.finishNode(t4, "ClassImplements"));
          } while (this.eat(12));
        }
      }
      checkGetterSetterParams(t3) {
        super.checkGetterSetterParams(t3);
        const e2 = this.getObjectOrClassMethodParams(t3);
        if (e2.length > 0) {
          const r2 = e2[0];
          this.isThisParam(r2) && "get" === t3.kind ? this.raise(oi.GetterMayNotHaveThisParam, { at: r2 }) : this.isThisParam(r2) && this.raise(oi.SetterMayNotHaveThisParam, { at: r2 });
        }
      }
      parsePropertyNamePrefixOperator(t3) {
        t3.variance = this.flowParseVariance();
      }
      parseObjPropValue(t3, e2, r2, n2, i2, o2, a2) {
        let s2;
        t3.variance && this.unexpected(t3.variance.loc.start), delete t3.variance, this.match(47) && !o2 && (s2 = this.flowParseTypeParameterDeclaration(), this.match(10) || this.unexpected());
        const l2 = super.parseObjPropValue(t3, e2, r2, n2, i2, o2, a2);
        return s2 && ((l2.value || l2).typeParameters = s2), l2;
      }
      parseAssignableListItemTypes(t3) {
        return this.eat(17) && ("Identifier" !== t3.type && this.raise(oi.PatternIsOptional, { at: t3 }), this.isThisParam(t3) && this.raise(oi.ThisParamMayNotBeOptional, { at: t3 }), t3.optional = true), this.match(14) ? t3.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(t3) && this.raise(oi.ThisParamAnnotationRequired, { at: t3 }), this.match(29) && this.isThisParam(t3) && this.raise(oi.ThisParamNoDefault, { at: t3 }), this.resetEndLocation(t3), t3;
      }
      parseMaybeDefault(t3, e2) {
        const r2 = super.parseMaybeDefault(t3, e2);
        return "AssignmentPattern" === r2.type && r2.typeAnnotation && r2.right.start < r2.typeAnnotation.start && this.raise(oi.TypeBeforeInitializer, { at: r2.typeAnnotation }), r2;
      }
      checkImportReflection(t3) {
        super.checkImportReflection(t3), t3.module && "value" !== t3.importKind && this.raise(oi.ImportReflectionHasImportType, { at: t3.specifiers[0].loc.start });
      }
      parseImportSpecifierLocal(t3, e2, r2) {
        e2.local = hasTypeImportKind(t3) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier(), t3.specifiers.push(this.finishImportSpecifier(e2, r2));
      }
      isPotentialImportPhase(t3) {
        if (super.isPotentialImportPhase(t3))
          return true;
        if (this.isContextual(130)) {
          if (!t3)
            return true;
          const e2 = this.lookaheadCharCode();
          return 123 === e2 || 42 === e2;
        }
        return !t3 && this.isContextual(87);
      }
      applyImportPhase(t3, e2, r2, n2) {
        if (super.applyImportPhase(t3, e2, r2, n2), e2) {
          if (!r2 && this.match(65))
            return;
          t3.exportKind = "type" === r2 ? r2 : "value";
        } else
          "type" === r2 && this.match(55) && this.unexpected(), t3.importKind = "type" === r2 || "typeof" === r2 ? r2 : "value";
      }
      parseImportSpecifier(t3, e2, r2, n2, i2) {
        const o2 = t3.imported;
        let a2 = null;
        "Identifier" === o2.type && ("type" === o2.name ? a2 = "type" : "typeof" === o2.name && (a2 = "typeof"));
        let s2 = false;
        if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
          const e3 = this.parseIdentifier(true);
          null === a2 || tokenIsKeywordOrIdentifier(this.state.type) ? (t3.imported = o2, t3.importKind = null, t3.local = this.parseIdentifier()) : (t3.imported = e3, t3.importKind = a2, t3.local = cloneIdentifier(e3));
        } else {
          if (null !== a2 && tokenIsKeywordOrIdentifier(this.state.type))
            t3.imported = this.parseIdentifier(true), t3.importKind = a2;
          else {
            if (e2)
              throw this.raise(xn.ImportBindingIsString, { at: t3, importName: o2.value });
            t3.imported = o2, t3.importKind = null;
          }
          this.eatContextual(93) ? t3.local = this.parseIdentifier() : (s2 = true, t3.local = cloneIdentifier(t3.imported));
        }
        const l2 = hasTypeImportKind(t3);
        return r2 && l2 && this.raise(oi.ImportTypeShorthandOnlyInPureImport, { at: t3 }), (r2 || l2) && this.checkReservedType(t3.local.name, t3.local.loc.start, true), !s2 || r2 || l2 || this.checkReservedWord(t3.local.name, t3.loc.start, true, true), this.finishImportSpecifier(t3, "ImportSpecifier");
      }
      parseBindingAtom() {
        return 78 === this.state.type ? this.parseIdentifier(true) : super.parseBindingAtom();
      }
      parseFunctionParams(t3, e2) {
        const r2 = t3.kind;
        "get" !== r2 && "set" !== r2 && this.match(47) && (t3.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(t3, e2);
      }
      parseVarId(t3, e2) {
        super.parseVarId(t3, e2), this.match(14) && (t3.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(t3.id));
      }
      parseAsyncArrowFromCallExpression(t3, e2) {
        if (this.match(14)) {
          const e3 = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = true, t3.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = e3;
        }
        return super.parseAsyncArrowFromCallExpression(t3, e2);
      }
      shouldParseAsyncArrow() {
        return this.match(14) || super.shouldParseAsyncArrow();
      }
      parseMaybeAssign(t3, e2) {
        var r2;
        let n2, i2 = null;
        if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
          if (i2 = this.state.clone(), n2 = this.tryParse(() => super.parseMaybeAssign(t3, e2), i2), !n2.error)
            return n2.node;
          const { context: r3 } = this.state, o3 = r3[r3.length - 1];
          o3 !== yn.j_oTag && o3 !== yn.j_expr || r3.pop();
        }
        if (null != (r2 = n2) && r2.error || this.match(47)) {
          var o2, a2;
          let r3;
          i2 = i2 || this.state.clone();
          const s2 = this.tryParse((n3) => {
            var i3;
            r3 = this.flowParseTypeParameterDeclaration();
            const o3 = this.forwardNoArrowParamsConversionAt(r3, () => {
              const n4 = super.parseMaybeAssign(t3, e2);
              return this.resetStartLocationFromNode(n4, r3), n4;
            });
            null != (i3 = o3.extra) && i3.parenthesized && n3();
            const a3 = this.maybeUnwrapTypeCastExpression(o3);
            return "ArrowFunctionExpression" !== a3.type && n3(), a3.typeParameters = r3, this.resetStartLocationFromNode(a3, r3), o3;
          }, i2);
          let l2 = null;
          if (s2.node && "ArrowFunctionExpression" === this.maybeUnwrapTypeCastExpression(s2.node).type) {
            if (!s2.error && !s2.aborted)
              return s2.node.async && this.raise(oi.UnexpectedTypeParameterBeforeAsyncArrowFunction, { at: r3 }), s2.node;
            l2 = s2.node;
          }
          if (null != (o2 = n2) && o2.node)
            return this.state = n2.failState, n2.node;
          if (l2)
            return this.state = s2.failState, l2;
          if (null != (a2 = n2) && a2.thrown)
            throw n2.error;
          if (s2.thrown)
            throw s2.error;
          throw this.raise(oi.UnexpectedTokenAfterTypeParameter, { at: r3 });
        }
        return super.parseMaybeAssign(t3, e2);
      }
      parseArrow(t3) {
        if (this.match(14)) {
          const e2 = this.tryParse(() => {
            const e3 = this.state.noAnonFunctionType;
            this.state.noAnonFunctionType = true;
            const r2 = this.startNode();
            return [r2.typeAnnotation, t3.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = e3, this.canInsertSemicolon() && this.unexpected(), this.match(19) || this.unexpected(), r2;
          });
          if (e2.thrown)
            return null;
          e2.error && (this.state = e2.failState), t3.returnType = e2.node.typeAnnotation ? this.finishNode(e2.node, "TypeAnnotation") : null;
        }
        return super.parseArrow(t3);
      }
      shouldParseArrow(t3) {
        return this.match(14) || super.shouldParseArrow(t3);
      }
      setArrowFunctionParameters(t3, e2) {
        -1 !== this.state.noArrowParamsConversionAt.indexOf(t3.start) ? t3.params = e2 : super.setArrowFunctionParameters(t3, e2);
      }
      checkParams(t3, e2, r2, n2 = true) {
        if (!r2 || -1 === this.state.noArrowParamsConversionAt.indexOf(t3.start)) {
          for (let e3 = 0; e3 < t3.params.length; e3++)
            this.isThisParam(t3.params[e3]) && e3 > 0 && this.raise(oi.ThisParamMustBeFirst, { at: t3.params[e3] });
          super.checkParams(t3, e2, r2, n2);
        }
      }
      parseParenAndDistinguishExpression(t3) {
        return super.parseParenAndDistinguishExpression(t3 && -1 === this.state.noArrowAt.indexOf(this.state.start));
      }
      parseSubscripts(t3, e2, r2) {
        if ("Identifier" === t3.type && "async" === t3.name && -1 !== this.state.noArrowAt.indexOf(e2.index)) {
          this.next();
          const r3 = this.startNodeAt(e2);
          r3.callee = t3, r3.arguments = super.parseCallExpressionArguments(11, false), t3 = this.finishNode(r3, "CallExpression");
        } else if ("Identifier" === t3.type && "async" === t3.name && this.match(47)) {
          const n2 = this.state.clone(), i2 = this.tryParse((t4) => this.parseAsyncArrowWithTypeParameters(e2) || t4(), n2);
          if (!i2.error && !i2.aborted)
            return i2.node;
          const o2 = this.tryParse(() => super.parseSubscripts(t3, e2, r2), n2);
          if (o2.node && !o2.error)
            return o2.node;
          if (i2.node)
            return this.state = i2.failState, i2.node;
          if (o2.node)
            return this.state = o2.failState, o2.node;
          throw i2.error || o2.error;
        }
        return super.parseSubscripts(t3, e2, r2);
      }
      parseSubscript(t3, e2, r2, n2) {
        if (this.match(18) && this.isLookaheadToken_lt()) {
          if (n2.optionalChainMember = true, r2)
            return n2.stop = true, t3;
          this.next();
          const i2 = this.startNodeAt(e2);
          return i2.callee = t3, i2.typeArguments = this.flowParseTypeParameterInstantiation(), this.expect(10), i2.arguments = this.parseCallExpressionArguments(11, false), i2.optional = true, this.finishCallExpression(i2, true);
        }
        if (!r2 && this.shouldParseTypes() && this.match(47)) {
          const r3 = this.startNodeAt(e2);
          r3.callee = t3;
          const i2 = this.tryParse(() => (r3.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(10), r3.arguments = super.parseCallExpressionArguments(11, false), n2.optionalChainMember && (r3.optional = false), this.finishCallExpression(r3, n2.optionalChainMember)));
          if (i2.node)
            return i2.error && (this.state = i2.failState), i2.node;
        }
        return super.parseSubscript(t3, e2, r2, n2);
      }
      parseNewCallee(t3) {
        super.parseNewCallee(t3);
        let e2 = null;
        this.shouldParseTypes() && this.match(47) && (e2 = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), t3.typeArguments = e2;
      }
      parseAsyncArrowWithTypeParameters(t3) {
        const e2 = this.startNodeAt(t3);
        if (this.parseFunctionParams(e2, false), this.parseArrow(e2))
          return super.parseArrowExpression(e2, void 0, true);
      }
      readToken_mult_modulo(t3) {
        const e2 = this.input.charCodeAt(this.state.pos + 1);
        if (42 === t3 && 47 === e2 && this.state.hasFlowComment)
          return this.state.hasFlowComment = false, this.state.pos += 2, void this.nextToken();
        super.readToken_mult_modulo(t3);
      }
      readToken_pipe_amp(t3) {
        const e2 = this.input.charCodeAt(this.state.pos + 1);
        124 !== t3 || 125 !== e2 ? super.readToken_pipe_amp(t3) : this.finishOp(9, 2);
      }
      parseTopLevel(t3, e2) {
        const r2 = super.parseTopLevel(t3, e2);
        return this.state.hasFlowComment && this.raise(oi.UnterminatedFlowComment, { at: this.state.curPosition() }), r2;
      }
      skipBlockComment() {
        if (!this.hasPlugin("flowComments") || !this.skipFlowComment())
          return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
        {
          if (this.state.hasFlowComment)
            throw this.raise(oi.NestedFlowComment, { at: this.state.startLoc });
          this.hasFlowCommentCompletion();
          const t3 = this.skipFlowComment();
          t3 && (this.state.pos += t3, this.state.hasFlowComment = true);
        }
      }
      skipFlowComment() {
        const { pos: t3 } = this.state;
        let e2 = 2;
        for (; [32, 9].includes(this.input.charCodeAt(t3 + e2)); )
          e2++;
        const r2 = this.input.charCodeAt(e2 + t3), n2 = this.input.charCodeAt(e2 + t3 + 1);
        return 58 === r2 && 58 === n2 ? e2 + 2 : "flow-include" === this.input.slice(e2 + t3, e2 + t3 + 12) ? e2 + 12 : 58 === r2 && 58 !== n2 && e2;
      }
      hasFlowCommentCompletion() {
        if (-1 === this.input.indexOf("*/", this.state.pos))
          throw this.raise(xn.UnterminatedComment, { at: this.state.curPosition() });
      }
      flowEnumErrorBooleanMemberNotInitialized(t3, { enumName: e2, memberName: r2 }) {
        this.raise(oi.EnumBooleanMemberNotInitialized, { at: t3, memberName: r2, enumName: e2 });
      }
      flowEnumErrorInvalidMemberInitializer(t3, e2) {
        return this.raise(e2.explicitType ? "symbol" === e2.explicitType ? oi.EnumInvalidMemberInitializerSymbolType : oi.EnumInvalidMemberInitializerPrimaryType : oi.EnumInvalidMemberInitializerUnknownType, Object.assign({ at: t3 }, e2));
      }
      flowEnumErrorNumberMemberNotInitialized(t3, { enumName: e2, memberName: r2 }) {
        this.raise(oi.EnumNumberMemberNotInitialized, { at: t3, enumName: e2, memberName: r2 });
      }
      flowEnumErrorStringMemberInconsistentlyInitialized(t3, { enumName: e2 }) {
        this.raise(oi.EnumStringMemberInconsistentlyInitialized, { at: t3, enumName: e2 });
      }
      flowEnumMemberInit() {
        const t3 = this.state.startLoc, endOfInit = () => this.match(12) || this.match(8);
        switch (this.state.type) {
          case 134: {
            const e2 = this.parseNumericLiteral(this.state.value);
            return endOfInit() ? { type: "number", loc: e2.loc.start, value: e2 } : { type: "invalid", loc: t3 };
          }
          case 133: {
            const e2 = this.parseStringLiteral(this.state.value);
            return endOfInit() ? { type: "string", loc: e2.loc.start, value: e2 } : { type: "invalid", loc: t3 };
          }
          case 85:
          case 86: {
            const e2 = this.parseBooleanLiteral(this.match(85));
            return endOfInit() ? { type: "boolean", loc: e2.loc.start, value: e2 } : { type: "invalid", loc: t3 };
          }
          default:
            return { type: "invalid", loc: t3 };
        }
      }
      flowEnumMemberRaw() {
        const t3 = this.state.startLoc;
        return { id: this.parseIdentifier(true), init: this.eat(29) ? this.flowEnumMemberInit() : { type: "none", loc: t3 } };
      }
      flowEnumCheckExplicitTypeMismatch(t3, e2, r2) {
        const { explicitType: n2 } = e2;
        null !== n2 && n2 !== r2 && this.flowEnumErrorInvalidMemberInitializer(t3, e2);
      }
      flowEnumMembers({ enumName: t3, explicitType: e2 }) {
        const r2 = /* @__PURE__ */ new Set(), n2 = { booleanMembers: [], numberMembers: [], stringMembers: [], defaultedMembers: [] };
        let i2 = false;
        for (; !this.match(8); ) {
          if (this.eat(21)) {
            i2 = true;
            break;
          }
          const o2 = this.startNode(), { id: a2, init: s2 } = this.flowEnumMemberRaw(), l2 = a2.name;
          if ("" === l2)
            continue;
          /^[a-z]/.test(l2) && this.raise(oi.EnumInvalidMemberName, { at: a2, memberName: l2, suggestion: l2[0].toUpperCase() + l2.slice(1), enumName: t3 }), r2.has(l2) && this.raise(oi.EnumDuplicateMemberName, { at: a2, memberName: l2, enumName: t3 }), r2.add(l2);
          const p2 = { enumName: t3, explicitType: e2, memberName: l2 };
          switch (o2.id = a2, s2.type) {
            case "boolean":
              this.flowEnumCheckExplicitTypeMismatch(s2.loc, p2, "boolean"), o2.init = s2.value, n2.booleanMembers.push(this.finishNode(o2, "EnumBooleanMember"));
              break;
            case "number":
              this.flowEnumCheckExplicitTypeMismatch(s2.loc, p2, "number"), o2.init = s2.value, n2.numberMembers.push(this.finishNode(o2, "EnumNumberMember"));
              break;
            case "string":
              this.flowEnumCheckExplicitTypeMismatch(s2.loc, p2, "string"), o2.init = s2.value, n2.stringMembers.push(this.finishNode(o2, "EnumStringMember"));
              break;
            case "invalid":
              throw this.flowEnumErrorInvalidMemberInitializer(s2.loc, p2);
            case "none":
              switch (e2) {
                case "boolean":
                  this.flowEnumErrorBooleanMemberNotInitialized(s2.loc, p2);
                  break;
                case "number":
                  this.flowEnumErrorNumberMemberNotInitialized(s2.loc, p2);
                  break;
                default:
                  n2.defaultedMembers.push(this.finishNode(o2, "EnumDefaultedMember"));
              }
          }
          this.match(8) || this.expect(12);
        }
        return { members: n2, hasUnknownMembers: i2 };
      }
      flowEnumStringMembers(t3, e2, { enumName: r2 }) {
        if (0 === t3.length)
          return e2;
        if (0 === e2.length)
          return t3;
        if (e2.length > t3.length) {
          for (const e3 of t3)
            this.flowEnumErrorStringMemberInconsistentlyInitialized(e3, { enumName: r2 });
          return e2;
        }
        for (const t4 of e2)
          this.flowEnumErrorStringMemberInconsistentlyInitialized(t4, { enumName: r2 });
        return t3;
      }
      flowEnumParseExplicitType({ enumName: t3 }) {
        if (!this.eatContextual(102))
          return null;
        if (!tokenIsIdentifier(this.state.type))
          throw this.raise(oi.EnumInvalidExplicitTypeUnknownSupplied, { at: this.state.startLoc, enumName: t3 });
        const { value: e2 } = this.state;
        return this.next(), "boolean" !== e2 && "number" !== e2 && "string" !== e2 && "symbol" !== e2 && this.raise(oi.EnumInvalidExplicitType, { at: this.state.startLoc, enumName: t3, invalidEnumType: e2 }), e2;
      }
      flowEnumBody(t3, e2) {
        const r2 = e2.name, n2 = e2.loc.start, i2 = this.flowEnumParseExplicitType({ enumName: r2 });
        this.expect(5);
        const { members: o2, hasUnknownMembers: a2 } = this.flowEnumMembers({ enumName: r2, explicitType: i2 });
        switch (t3.hasUnknownMembers = a2, i2) {
          case "boolean":
            return t3.explicitType = true, t3.members = o2.booleanMembers, this.expect(8), this.finishNode(t3, "EnumBooleanBody");
          case "number":
            return t3.explicitType = true, t3.members = o2.numberMembers, this.expect(8), this.finishNode(t3, "EnumNumberBody");
          case "string":
            return t3.explicitType = true, t3.members = this.flowEnumStringMembers(o2.stringMembers, o2.defaultedMembers, { enumName: r2 }), this.expect(8), this.finishNode(t3, "EnumStringBody");
          case "symbol":
            return t3.members = o2.defaultedMembers, this.expect(8), this.finishNode(t3, "EnumSymbolBody");
          default: {
            const empty = () => (t3.members = [], this.expect(8), this.finishNode(t3, "EnumStringBody"));
            t3.explicitType = false;
            const e3 = o2.booleanMembers.length, i3 = o2.numberMembers.length, a3 = o2.stringMembers.length, s2 = o2.defaultedMembers.length;
            if (e3 || i3 || a3 || s2) {
              if (e3 || i3) {
                if (!i3 && !a3 && e3 >= s2) {
                  for (const t4 of o2.defaultedMembers)
                    this.flowEnumErrorBooleanMemberNotInitialized(t4.loc.start, { enumName: r2, memberName: t4.id.name });
                  return t3.members = o2.booleanMembers, this.expect(8), this.finishNode(t3, "EnumBooleanBody");
                }
                if (!e3 && !a3 && i3 >= s2) {
                  for (const t4 of o2.defaultedMembers)
                    this.flowEnumErrorNumberMemberNotInitialized(t4.loc.start, { enumName: r2, memberName: t4.id.name });
                  return t3.members = o2.numberMembers, this.expect(8), this.finishNode(t3, "EnumNumberBody");
                }
                return this.raise(oi.EnumInconsistentMemberValues, { at: n2, enumName: r2 }), empty();
              }
              return t3.members = this.flowEnumStringMembers(o2.stringMembers, o2.defaultedMembers, { enumName: r2 }), this.expect(8), this.finishNode(t3, "EnumStringBody");
            }
            return empty();
          }
        }
      }
      flowParseEnumDeclaration(t3) {
        const e2 = this.parseIdentifier();
        return t3.id = e2, t3.body = this.flowEnumBody(this.startNode(), e2), this.finishNode(t3, "EnumDeclaration");
      }
      isLookaheadToken_lt() {
        const t3 = this.nextTokenStart();
        if (60 === this.input.charCodeAt(t3)) {
          const e2 = this.input.charCodeAt(t3 + 1);
          return 60 !== e2 && 61 !== e2;
        }
        return false;
      }
      maybeUnwrapTypeCastExpression(t3) {
        return "TypeCastExpression" === t3.type ? t3.expression : t3;
      }
    }, typescript: (t2) => class extends t2 {
      constructor(...t3) {
        super(...t3), this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, { allowedModifiers: ["in", "out"], disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"], errorTemplate: ci.InvalidModifierOnTypeParameter }), this.tsParseConstModifier = this.tsParseModifiers.bind(this, { allowedModifiers: ["const"], disallowedModifiers: ["in", "out"], errorTemplate: ci.InvalidModifierOnTypeParameterPositions }), this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, { allowedModifiers: ["in", "out", "const"], disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"], errorTemplate: ci.InvalidModifierOnTypeParameter });
      }
      getScopeHandler() {
        return TypeScriptScopeHandler;
      }
      tsIsIdentifier() {
        return tokenIsIdentifier(this.state.type);
      }
      tsTokenCanFollowModifier() {
        return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(138) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
      }
      tsNextTokenCanFollowModifier() {
        return this.next(), this.tsTokenCanFollowModifier();
      }
      tsParseModifier(t3, e2) {
        if (!tokenIsIdentifier(this.state.type) && 58 !== this.state.type && 75 !== this.state.type)
          return;
        const r2 = this.state.value;
        if (-1 !== t3.indexOf(r2)) {
          if (e2 && this.tsIsStartOfStaticBlocks())
            return;
          if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)))
            return r2;
        }
      }
      tsParseModifiers({ allowedModifiers: t3, disallowedModifiers: e2, stopOnStartOfClassStaticBlock: r2, errorTemplate: n2 = ci.InvalidModifierOnTypeMember }, i2) {
        const enforceOrder = (t4, e3, r3, n3) => {
          e3 === r3 && i2[n3] && this.raise(ci.InvalidModifiersOrder, { at: t4, orderedModifiers: [r3, n3] });
        }, incompatible = (t4, e3, r3, n3) => {
          (i2[r3] && e3 === n3 || i2[n3] && e3 === r3) && this.raise(ci.IncompatibleModifiers, { at: t4, modifiers: [r3, n3] });
        };
        for (; ; ) {
          const { startLoc: o2 } = this.state, a2 = this.tsParseModifier(t3.concat(null != e2 ? e2 : []), r2);
          if (!a2)
            break;
          tsIsAccessModifier(a2) ? i2.accessibility ? this.raise(ci.DuplicateAccessibilityModifier, { at: o2, modifier: a2 }) : (enforceOrder(o2, a2, a2, "override"), enforceOrder(o2, a2, a2, "static"), enforceOrder(o2, a2, a2, "readonly"), i2.accessibility = a2) : tsIsVarianceAnnotations(a2) ? (i2[a2] && this.raise(ci.DuplicateModifier, { at: o2, modifier: a2 }), i2[a2] = true, enforceOrder(o2, a2, "in", "out")) : (Object.hasOwnProperty.call(i2, a2) ? this.raise(ci.DuplicateModifier, { at: o2, modifier: a2 }) : (enforceOrder(o2, a2, "static", "readonly"), enforceOrder(o2, a2, "static", "override"), enforceOrder(o2, a2, "override", "readonly"), enforceOrder(o2, a2, "abstract", "override"), incompatible(o2, a2, "declare", "override"), incompatible(o2, a2, "static", "abstract")), i2[a2] = true), null != e2 && e2.includes(a2) && this.raise(n2, { at: o2, modifier: a2 });
        }
      }
      tsIsListTerminator(t3) {
        switch (t3) {
          case "EnumMembers":
          case "TypeMembers":
            return this.match(8);
          case "HeritageClauseElement":
            return this.match(5);
          case "TupleElementTypes":
            return this.match(3);
          case "TypeParametersOrArguments":
            return this.match(48);
        }
      }
      tsParseList(t3, e2) {
        const r2 = [];
        for (; !this.tsIsListTerminator(t3); )
          r2.push(e2());
        return r2;
      }
      tsParseDelimitedList(t3, e2, r2) {
        return function(t4) {
          if (null == t4)
            throw new Error(`Unexpected ${t4} value.`);
          return t4;
        }(this.tsParseDelimitedListWorker(t3, e2, true, r2));
      }
      tsParseDelimitedListWorker(t3, e2, r2, n2) {
        const i2 = [];
        let o2 = -1;
        for (; !this.tsIsListTerminator(t3); ) {
          o2 = -1;
          const n3 = e2();
          if (null == n3)
            return;
          if (i2.push(n3), !this.eat(12)) {
            if (this.tsIsListTerminator(t3))
              break;
            return void (r2 && this.expect(12));
          }
          o2 = this.state.lastTokStart;
        }
        return n2 && (n2.value = o2), i2;
      }
      tsParseBracketedList(t3, e2, r2, n2, i2) {
        n2 || (r2 ? this.expect(0) : this.expect(47));
        const o2 = this.tsParseDelimitedList(t3, e2, i2);
        return r2 ? this.expect(3) : this.expect(48), o2;
      }
      tsParseImportType() {
        const t3 = this.startNode();
        return this.expect(83), this.expect(10), this.match(133) || this.raise(ci.UnsupportedImportTypeArgument, { at: this.state.startLoc }), t3.argument = super.parseExprAtom(), this.expect(11), this.eat(16) && (t3.qualifier = this.tsParseEntityName()), this.match(47) && (t3.typeParameters = this.tsParseTypeArguments()), this.finishNode(t3, "TSImportType");
      }
      tsParseEntityName(t3 = true) {
        let e2 = this.parseIdentifier(t3);
        for (; this.eat(16); ) {
          const r2 = this.startNodeAtNode(e2);
          r2.left = e2, r2.right = this.parseIdentifier(t3), e2 = this.finishNode(r2, "TSQualifiedName");
        }
        return e2;
      }
      tsParseTypeReference() {
        const t3 = this.startNode();
        return t3.typeName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (t3.typeParameters = this.tsParseTypeArguments()), this.finishNode(t3, "TSTypeReference");
      }
      tsParseThisTypePredicate(t3) {
        this.next();
        const e2 = this.startNodeAtNode(t3);
        return e2.parameterName = t3, e2.typeAnnotation = this.tsParseTypeAnnotation(false), e2.asserts = false, this.finishNode(e2, "TSTypePredicate");
      }
      tsParseThisTypeNode() {
        const t3 = this.startNode();
        return this.next(), this.finishNode(t3, "TSThisType");
      }
      tsParseTypeQuery() {
        const t3 = this.startNode();
        return this.expect(87), this.match(83) ? t3.exprName = this.tsParseImportType() : t3.exprName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (t3.typeParameters = this.tsParseTypeArguments()), this.finishNode(t3, "TSTypeQuery");
      }
      tsParseTypeParameter(t3) {
        const e2 = this.startNode();
        return t3(e2), e2.name = this.tsParseTypeParameterName(), e2.constraint = this.tsEatThenParseType(81), e2.default = this.tsEatThenParseType(29), this.finishNode(e2, "TSTypeParameter");
      }
      tsTryParseTypeParameters(t3) {
        if (this.match(47))
          return this.tsParseTypeParameters(t3);
      }
      tsParseTypeParameters(t3) {
        const e2 = this.startNode();
        this.match(47) || this.match(142) ? this.next() : this.unexpected();
        const r2 = { value: -1 };
        return e2.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, t3), false, true, r2), 0 === e2.params.length && this.raise(ci.EmptyTypeParameters, { at: e2 }), -1 !== r2.value && this.addExtra(e2, "trailingComma", r2.value), this.finishNode(e2, "TSTypeParameterDeclaration");
      }
      tsFillSignature(t3, e2) {
        const r2 = 19 === t3, n2 = "typeAnnotation";
        e2.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier), this.expect(10), e2.parameters = this.tsParseBindingListForSignature(), (r2 || this.match(t3)) && (e2[n2] = this.tsParseTypeOrTypePredicateAnnotation(t3));
      }
      tsParseBindingListForSignature() {
        const t3 = super.parseBindingList(11, 41, 2);
        for (const e2 of t3) {
          const { type: t4 } = e2;
          "AssignmentPattern" !== t4 && "TSParameterProperty" !== t4 || this.raise(ci.UnsupportedSignatureParameterKind, { at: e2, type: t4 });
        }
        return t3;
      }
      tsParseTypeMemberSemicolon() {
        this.eat(12) || this.isLineTerminator() || this.expect(13);
      }
      tsParseSignatureMember(t3, e2) {
        return this.tsFillSignature(14, e2), this.tsParseTypeMemberSemicolon(), this.finishNode(e2, t3);
      }
      tsIsUnambiguouslyIndexSignature() {
        return this.next(), !!tokenIsIdentifier(this.state.type) && (this.next(), this.match(14));
      }
      tsTryParseIndexSignature(t3) {
        if (!this.match(0) || !this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))
          return;
        this.expect(0);
        const e2 = this.parseIdentifier();
        e2.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(e2), this.expect(3), t3.parameters = [e2];
        const r2 = this.tsTryParseTypeAnnotation();
        return r2 && (t3.typeAnnotation = r2), this.tsParseTypeMemberSemicolon(), this.finishNode(t3, "TSIndexSignature");
      }
      tsParsePropertyOrMethodSignature(t3, e2) {
        this.eat(17) && (t3.optional = true);
        const r2 = t3;
        if (this.match(10) || this.match(47)) {
          e2 && this.raise(ci.ReadonlyForMethodSignature, { at: t3 });
          const n2 = r2;
          n2.kind && this.match(47) && this.raise(ci.AccesorCannotHaveTypeParameters, { at: this.state.curPosition() }), this.tsFillSignature(14, n2), this.tsParseTypeMemberSemicolon();
          const i2 = "parameters", o2 = "typeAnnotation";
          if ("get" === n2.kind)
            n2[i2].length > 0 && (this.raise(xn.BadGetterArity, { at: this.state.curPosition() }), this.isThisParam(n2[i2][0]) && this.raise(ci.AccesorCannotDeclareThisParameter, { at: this.state.curPosition() }));
          else if ("set" === n2.kind) {
            if (1 !== n2[i2].length)
              this.raise(xn.BadSetterArity, { at: this.state.curPosition() });
            else {
              const t4 = n2[i2][0];
              this.isThisParam(t4) && this.raise(ci.AccesorCannotDeclareThisParameter, { at: this.state.curPosition() }), "Identifier" === t4.type && t4.optional && this.raise(ci.SetAccesorCannotHaveOptionalParameter, { at: this.state.curPosition() }), "RestElement" === t4.type && this.raise(ci.SetAccesorCannotHaveRestParameter, { at: this.state.curPosition() });
            }
            n2[o2] && this.raise(ci.SetAccesorCannotHaveReturnType, { at: n2[o2] });
          } else
            n2.kind = "method";
          return this.finishNode(n2, "TSMethodSignature");
        }
        {
          const t4 = r2;
          e2 && (t4.readonly = true);
          const n2 = this.tsTryParseTypeAnnotation();
          return n2 && (t4.typeAnnotation = n2), this.tsParseTypeMemberSemicolon(), this.finishNode(t4, "TSPropertySignature");
        }
      }
      tsParseTypeMember() {
        const t3 = this.startNode();
        if (this.match(10) || this.match(47))
          return this.tsParseSignatureMember("TSCallSignatureDeclaration", t3);
        if (this.match(77)) {
          const e3 = this.startNode();
          return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", t3) : (t3.key = this.createIdentifier(e3, "new"), this.tsParsePropertyOrMethodSignature(t3, false));
        }
        this.tsParseModifiers({ allowedModifiers: ["readonly"], disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"] }, t3);
        const e2 = this.tsTryParseIndexSignature(t3);
        return e2 || (super.parsePropertyName(t3), t3.computed || "Identifier" !== t3.key.type || "get" !== t3.key.name && "set" !== t3.key.name || !this.tsTokenCanFollowModifier() || (t3.kind = t3.key.name, super.parsePropertyName(t3)), this.tsParsePropertyOrMethodSignature(t3, !!t3.readonly));
      }
      tsParseTypeLiteral() {
        const t3 = this.startNode();
        return t3.members = this.tsParseObjectTypeMembers(), this.finishNode(t3, "TSTypeLiteral");
      }
      tsParseObjectTypeMembers() {
        this.expect(5);
        const t3 = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
        return this.expect(8), t3;
      }
      tsIsStartOfMappedType() {
        return this.next(), this.eat(53) ? this.isContextual(122) : (this.isContextual(122) && this.next(), !!this.match(0) && (this.next(), !!this.tsIsIdentifier() && (this.next(), this.match(58))));
      }
      tsParseMappedTypeParameter() {
        const t3 = this.startNode();
        return t3.name = this.tsParseTypeParameterName(), t3.constraint = this.tsExpectThenParseType(58), this.finishNode(t3, "TSTypeParameter");
      }
      tsParseMappedType() {
        const t3 = this.startNode();
        return this.expect(5), this.match(53) ? (t3.readonly = this.state.value, this.next(), this.expectContextual(122)) : this.eatContextual(122) && (t3.readonly = true), this.expect(0), t3.typeParameter = this.tsParseMappedTypeParameter(), t3.nameType = this.eatContextual(93) ? this.tsParseType() : null, this.expect(3), this.match(53) ? (t3.optional = this.state.value, this.next(), this.expect(17)) : this.eat(17) && (t3.optional = true), t3.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(8), this.finishNode(t3, "TSMappedType");
      }
      tsParseTupleType() {
        const t3 = this.startNode();
        t3.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
        let e2 = false;
        return t3.elementTypes.forEach((t4) => {
          const { type: r2 } = t4;
          !e2 || "TSRestType" === r2 || "TSOptionalType" === r2 || "TSNamedTupleMember" === r2 && t4.optional || this.raise(ci.OptionalTypeBeforeRequired, { at: t4 }), e2 || (e2 = "TSNamedTupleMember" === r2 && t4.optional || "TSOptionalType" === r2);
        }), this.finishNode(t3, "TSTupleType");
      }
      tsParseTupleElementType() {
        const { startLoc: t3 } = this.state, e2 = this.eat(21);
        let r2, n2, i2, o2;
        const a2 = tokenIsKeywordOrIdentifier(this.state.type) ? this.lookaheadCharCode() : null;
        if (58 === a2)
          r2 = true, i2 = false, n2 = this.parseIdentifier(true), this.expect(14), o2 = this.tsParseType();
        else if (63 === a2) {
          i2 = true;
          const t4 = this.state.startLoc, e3 = this.state.value, a3 = this.tsParseNonArrayType();
          58 === this.lookaheadCharCode() ? (r2 = true, n2 = this.createIdentifier(this.startNodeAt(t4), e3), this.expect(17), this.expect(14), o2 = this.tsParseType()) : (r2 = false, o2 = a3, this.expect(17));
        } else
          o2 = this.tsParseType(), i2 = this.eat(17), r2 = this.eat(14);
        if (r2) {
          let t4;
          n2 ? (t4 = this.startNodeAtNode(n2), t4.optional = i2, t4.label = n2, t4.elementType = o2, this.eat(17) && (t4.optional = true, this.raise(ci.TupleOptionalAfterType, { at: this.state.lastTokStartLoc }))) : (t4 = this.startNodeAtNode(o2), t4.optional = i2, this.raise(ci.InvalidTupleMemberLabel, { at: o2 }), t4.label = o2, t4.elementType = this.tsParseType()), o2 = this.finishNode(t4, "TSNamedTupleMember");
        } else if (i2) {
          const t4 = this.startNodeAtNode(o2);
          t4.typeAnnotation = o2, o2 = this.finishNode(t4, "TSOptionalType");
        }
        if (e2) {
          const e3 = this.startNodeAt(t3);
          e3.typeAnnotation = o2, o2 = this.finishNode(e3, "TSRestType");
        }
        return o2;
      }
      tsParseParenthesizedType() {
        const t3 = this.startNode();
        return this.expect(10), t3.typeAnnotation = this.tsParseType(), this.expect(11), this.finishNode(t3, "TSParenthesizedType");
      }
      tsParseFunctionOrConstructorType(t3, e2) {
        const r2 = this.startNode();
        return "TSConstructorType" === t3 && (r2.abstract = !!e2, e2 && this.next(), this.next()), this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, r2)), this.finishNode(r2, t3);
      }
      tsParseLiteralTypeNode() {
        const t3 = this.startNode();
        switch (this.state.type) {
          case 134:
          case 135:
          case 133:
          case 85:
          case 86:
            t3.literal = super.parseExprAtom();
            break;
          default:
            this.unexpected();
        }
        return this.finishNode(t3, "TSLiteralType");
      }
      tsParseTemplateLiteralType() {
        const t3 = this.startNode();
        return t3.literal = super.parseTemplate(false), this.finishNode(t3, "TSLiteralType");
      }
      parseTemplateSubstitution() {
        return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
      }
      tsParseThisTypeOrThisTypePredicate() {
        const t3 = this.tsParseThisTypeNode();
        return this.isContextual(116) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(t3) : t3;
      }
      tsParseNonArrayType() {
        switch (this.state.type) {
          case 133:
          case 134:
          case 135:
          case 85:
          case 86:
            return this.tsParseLiteralTypeNode();
          case 53:
            if ("-" === this.state.value) {
              const t3 = this.startNode(), e2 = this.lookahead();
              return 134 !== e2.type && 135 !== e2.type && this.unexpected(), t3.literal = this.parseMaybeUnary(), this.finishNode(t3, "TSLiteralType");
            }
            break;
          case 78:
            return this.tsParseThisTypeOrThisTypePredicate();
          case 87:
            return this.tsParseTypeQuery();
          case 83:
            return this.tsParseImportType();
          case 5:
            return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
          case 0:
            return this.tsParseTupleType();
          case 10:
            return this.tsParseParenthesizedType();
          case 25:
          case 24:
            return this.tsParseTemplateLiteralType();
          default: {
            const { type: t3 } = this.state;
            if (tokenIsIdentifier(t3) || 88 === t3 || 84 === t3) {
              const e2 = 88 === t3 ? "TSVoidKeyword" : 84 === t3 ? "TSNullKeyword" : function(t4) {
                switch (t4) {
                  case "any":
                    return "TSAnyKeyword";
                  case "boolean":
                    return "TSBooleanKeyword";
                  case "bigint":
                    return "TSBigIntKeyword";
                  case "never":
                    return "TSNeverKeyword";
                  case "number":
                    return "TSNumberKeyword";
                  case "object":
                    return "TSObjectKeyword";
                  case "string":
                    return "TSStringKeyword";
                  case "symbol":
                    return "TSSymbolKeyword";
                  case "undefined":
                    return "TSUndefinedKeyword";
                  case "unknown":
                    return "TSUnknownKeyword";
                  default:
                    return;
                }
              }(this.state.value);
              if (void 0 !== e2 && 46 !== this.lookaheadCharCode()) {
                const t4 = this.startNode();
                return this.next(), this.finishNode(t4, e2);
              }
              return this.tsParseTypeReference();
            }
          }
        }
        this.unexpected();
      }
      tsParseArrayTypeOrHigher() {
        let t3 = this.tsParseNonArrayType();
        for (; !this.hasPrecedingLineBreak() && this.eat(0); )
          if (this.match(3)) {
            const e2 = this.startNodeAtNode(t3);
            e2.elementType = t3, this.expect(3), t3 = this.finishNode(e2, "TSArrayType");
          } else {
            const e2 = this.startNodeAtNode(t3);
            e2.objectType = t3, e2.indexType = this.tsParseType(), this.expect(3), t3 = this.finishNode(e2, "TSIndexedAccessType");
          }
        return t3;
      }
      tsParseTypeOperator() {
        const t3 = this.startNode(), e2 = this.state.value;
        return this.next(), t3.operator = e2, t3.typeAnnotation = this.tsParseTypeOperatorOrHigher(), "readonly" === e2 && this.tsCheckTypeAnnotationForReadOnly(t3), this.finishNode(t3, "TSTypeOperator");
      }
      tsCheckTypeAnnotationForReadOnly(t3) {
        switch (t3.typeAnnotation.type) {
          case "TSTupleType":
          case "TSArrayType":
            return;
          default:
            this.raise(ci.UnexpectedReadonly, { at: t3 });
        }
      }
      tsParseInferType() {
        const t3 = this.startNode();
        this.expectContextual(115);
        const e2 = this.startNode();
        return e2.name = this.tsParseTypeParameterName(), e2.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType()), t3.typeParameter = this.finishNode(e2, "TSTypeParameter"), this.finishNode(t3, "TSInferType");
      }
      tsParseConstraintForInferType() {
        if (this.eat(81)) {
          const t3 = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
          if (this.state.inDisallowConditionalTypesContext || !this.match(17))
            return t3;
        }
      }
      tsParseTypeOperatorOrHigher() {
        var t3;
        return (t3 = this.state.type) >= 121 && t3 <= 123 && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
      }
      tsParseUnionOrIntersectionType(t3, e2, r2) {
        const n2 = this.startNode(), i2 = this.eat(r2), o2 = [];
        do {
          o2.push(e2());
        } while (this.eat(r2));
        return 1 !== o2.length || i2 ? (n2.types = o2, this.finishNode(n2, t3)) : o2[0];
      }
      tsParseIntersectionTypeOrHigher() {
        return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
      }
      tsParseUnionTypeOrHigher() {
        return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
      }
      tsIsStartOfFunctionType() {
        return !!this.match(47) || this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
      }
      tsSkipParameterStart() {
        if (tokenIsIdentifier(this.state.type) || this.match(78))
          return this.next(), true;
        if (this.match(5)) {
          const { errors: t3 } = this.state, e2 = t3.length;
          try {
            return this.parseObjectLike(8, true), t3.length === e2;
          } catch (t4) {
            return false;
          }
        }
        if (this.match(0)) {
          this.next();
          const { errors: t3 } = this.state, e2 = t3.length;
          try {
            return super.parseBindingList(3, 93, 1), t3.length === e2;
          } catch (t4) {
            return false;
          }
        }
        return false;
      }
      tsIsUnambiguouslyStartOfFunctionType() {
        if (this.next(), this.match(11) || this.match(21))
          return true;
        if (this.tsSkipParameterStart()) {
          if (this.match(14) || this.match(12) || this.match(17) || this.match(29))
            return true;
          if (this.match(11) && (this.next(), this.match(19)))
            return true;
        }
        return false;
      }
      tsParseTypeOrTypePredicateAnnotation(t3) {
        return this.tsInType(() => {
          const e2 = this.startNode();
          this.expect(t3);
          const r2 = this.startNode(), n2 = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
          if (n2 && this.match(78)) {
            let t4 = this.tsParseThisTypeOrThisTypePredicate();
            return "TSThisType" === t4.type ? (r2.parameterName = t4, r2.asserts = true, r2.typeAnnotation = null, t4 = this.finishNode(r2, "TSTypePredicate")) : (this.resetStartLocationFromNode(t4, r2), t4.asserts = true), e2.typeAnnotation = t4, this.finishNode(e2, "TSTypeAnnotation");
          }
          const i2 = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
          if (!i2)
            return n2 ? (r2.parameterName = this.parseIdentifier(), r2.asserts = n2, r2.typeAnnotation = null, e2.typeAnnotation = this.finishNode(r2, "TSTypePredicate"), this.finishNode(e2, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(false, e2);
          const o2 = this.tsParseTypeAnnotation(false);
          return r2.parameterName = i2, r2.typeAnnotation = o2, r2.asserts = n2, e2.typeAnnotation = this.finishNode(r2, "TSTypePredicate"), this.finishNode(e2, "TSTypeAnnotation");
        });
      }
      tsTryParseTypeOrTypePredicateAnnotation() {
        if (this.match(14))
          return this.tsParseTypeOrTypePredicateAnnotation(14);
      }
      tsTryParseTypeAnnotation() {
        if (this.match(14))
          return this.tsParseTypeAnnotation();
      }
      tsTryParseType() {
        return this.tsEatThenParseType(14);
      }
      tsParseTypePredicatePrefix() {
        const t3 = this.parseIdentifier();
        if (this.isContextual(116) && !this.hasPrecedingLineBreak())
          return this.next(), t3;
      }
      tsParseTypePredicateAsserts() {
        if (109 !== this.state.type)
          return false;
        const t3 = this.state.containsEsc;
        return this.next(), !(!tokenIsIdentifier(this.state.type) && !this.match(78)) && (t3 && this.raise(xn.InvalidEscapedReservedWord, { at: this.state.lastTokStartLoc, reservedWord: "asserts" }), true);
      }
      tsParseTypeAnnotation(t3 = true, e2 = this.startNode()) {
        return this.tsInType(() => {
          t3 && this.expect(14), e2.typeAnnotation = this.tsParseType();
        }), this.finishNode(e2, "TSTypeAnnotation");
      }
      tsParseType() {
        assert$1(this.state.inType);
        const t3 = this.tsParseNonConditionalType();
        if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81))
          return t3;
        const e2 = this.startNodeAtNode(t3);
        return e2.checkType = t3, e2.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType()), this.expect(17), e2.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.expect(14), e2.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.finishNode(e2, "TSConditionalType");
      }
      isAbstractConstructorSignature() {
        return this.isContextual(124) && 77 === this.lookahead().type;
      }
      tsParseNonConditionalType() {
        return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(77) ? this.tsParseFunctionOrConstructorType("TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", true) : this.tsParseUnionTypeOrHigher();
      }
      tsParseTypeAssertion() {
        this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(ci.ReservedTypeAssertion, { at: this.state.startLoc });
        const t3 = this.startNode();
        return t3.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? this.tsParseTypeReference() : this.tsParseType())), this.expect(48), t3.expression = this.parseMaybeUnary(), this.finishNode(t3, "TSTypeAssertion");
      }
      tsParseHeritageClause(t3) {
        const e2 = this.state.startLoc, r2 = this.tsParseDelimitedList("HeritageClauseElement", () => {
          const t4 = this.startNode();
          return t4.expression = this.tsParseEntityName(), this.match(47) && (t4.typeParameters = this.tsParseTypeArguments()), this.finishNode(t4, "TSExpressionWithTypeArguments");
        });
        return r2.length || this.raise(ci.EmptyHeritageClauseType, { at: e2, token: t3 }), r2;
      }
      tsParseInterfaceDeclaration(t3, e2 = {}) {
        if (this.hasFollowingLineBreak())
          return null;
        this.expectContextual(129), e2.declare && (t3.declare = true), tokenIsIdentifier(this.state.type) ? (t3.id = this.parseIdentifier(), this.checkIdentifier(t3.id, 130)) : (t3.id = null, this.raise(ci.MissingInterfaceName, { at: this.state.startLoc })), t3.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers), this.eat(81) && (t3.extends = this.tsParseHeritageClause("extends"));
        const r2 = this.startNode();
        return r2.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), t3.body = this.finishNode(r2, "TSInterfaceBody"), this.finishNode(t3, "TSInterfaceDeclaration");
      }
      tsParseTypeAliasDeclaration(t3) {
        return t3.id = this.parseIdentifier(), this.checkIdentifier(t3.id, 2), t3.typeAnnotation = this.tsInType(() => {
          if (t3.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers), this.expect(29), this.isContextual(114) && 16 !== this.lookahead().type) {
            const t4 = this.startNode();
            return this.next(), this.finishNode(t4, "TSIntrinsicKeyword");
          }
          return this.tsParseType();
        }), this.semicolon(), this.finishNode(t3, "TSTypeAliasDeclaration");
      }
      tsInNoContext(t3) {
        const e2 = this.state.context;
        this.state.context = [e2[0]];
        try {
          return t3();
        } finally {
          this.state.context = e2;
        }
      }
      tsInType(t3) {
        const e2 = this.state.inType;
        this.state.inType = true;
        try {
          return t3();
        } finally {
          this.state.inType = e2;
        }
      }
      tsInDisallowConditionalTypesContext(t3) {
        const e2 = this.state.inDisallowConditionalTypesContext;
        this.state.inDisallowConditionalTypesContext = true;
        try {
          return t3();
        } finally {
          this.state.inDisallowConditionalTypesContext = e2;
        }
      }
      tsInAllowConditionalTypesContext(t3) {
        const e2 = this.state.inDisallowConditionalTypesContext;
        this.state.inDisallowConditionalTypesContext = false;
        try {
          return t3();
        } finally {
          this.state.inDisallowConditionalTypesContext = e2;
        }
      }
      tsEatThenParseType(t3) {
        if (this.match(t3))
          return this.tsNextThenParseType();
      }
      tsExpectThenParseType(t3) {
        return this.tsInType(() => (this.expect(t3), this.tsParseType()));
      }
      tsNextThenParseType() {
        return this.tsInType(() => (this.next(), this.tsParseType()));
      }
      tsParseEnumMember() {
        const t3 = this.startNode();
        return t3.id = this.match(133) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(true), this.eat(29) && (t3.initializer = super.parseMaybeAssignAllowIn()), this.finishNode(t3, "TSEnumMember");
      }
      tsParseEnumDeclaration(t3, e2 = {}) {
        return e2.const && (t3.const = true), e2.declare && (t3.declare = true), this.expectContextual(126), t3.id = this.parseIdentifier(), this.checkIdentifier(t3.id, t3.const ? 8971 : 8459), this.expect(5), t3.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(8), this.finishNode(t3, "TSEnumDeclaration");
      }
      tsParseModuleBlock() {
        const t3 = this.startNode();
        return this.scope.enter(0), this.expect(5), super.parseBlockOrModuleBlockBody(t3.body = [], void 0, true, 8), this.scope.exit(), this.finishNode(t3, "TSModuleBlock");
      }
      tsParseModuleOrNamespaceDeclaration(t3, e2 = false) {
        if (t3.id = this.parseIdentifier(), e2 || this.checkIdentifier(t3.id, 1024), this.eat(16)) {
          const e3 = this.startNode();
          this.tsParseModuleOrNamespaceDeclaration(e3, true), t3.body = e3;
        } else
          this.scope.enter(256), this.prodParam.enter(0), t3.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
        return this.finishNode(t3, "TSModuleDeclaration");
      }
      tsParseAmbientExternalModuleDeclaration(t3) {
        return this.isContextual(112) ? (t3.global = true, t3.id = this.parseIdentifier()) : this.match(133) ? t3.id = super.parseStringLiteral(this.state.value) : this.unexpected(), this.match(5) ? (this.scope.enter(256), this.prodParam.enter(0), t3.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(t3, "TSModuleDeclaration");
      }
      tsParseImportEqualsDeclaration(t3, e2, r2) {
        t3.isExport = r2 || false, t3.id = e2 || this.parseIdentifier(), this.checkIdentifier(t3.id, 4096), this.expect(29);
        const n2 = this.tsParseModuleReference();
        return "type" === t3.importKind && "TSExternalModuleReference" !== n2.type && this.raise(ci.ImportAliasHasImportType, { at: n2 }), t3.moduleReference = n2, this.semicolon(), this.finishNode(t3, "TSImportEqualsDeclaration");
      }
      tsIsExternalModuleReference() {
        return this.isContextual(119) && 40 === this.lookaheadCharCode();
      }
      tsParseModuleReference() {
        return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
      }
      tsParseExternalModuleReference() {
        const t3 = this.startNode();
        return this.expectContextual(119), this.expect(10), this.match(133) || this.unexpected(), t3.expression = super.parseExprAtom(), this.expect(11), this.sawUnambiguousESM = true, this.finishNode(t3, "TSExternalModuleReference");
      }
      tsLookAhead(t3) {
        const e2 = this.state.clone(), r2 = t3();
        return this.state = e2, r2;
      }
      tsTryParseAndCatch(t3) {
        const e2 = this.tryParse((e3) => t3() || e3());
        if (!e2.aborted && e2.node)
          return e2.error && (this.state = e2.failState), e2.node;
      }
      tsTryParse(t3) {
        const e2 = this.state.clone(), r2 = t3();
        if (void 0 !== r2 && false !== r2)
          return r2;
        this.state = e2;
      }
      tsTryParseDeclare(t3) {
        if (this.isLineTerminator())
          return;
        let e2, r2 = this.state.type;
        return this.isContextual(100) && (r2 = 74, e2 = "let"), this.tsInAmbientContext(() => {
          switch (r2) {
            case 68:
              return t3.declare = true, super.parseFunctionStatement(t3, false, false);
            case 80:
              return t3.declare = true, this.parseClass(t3, true, false);
            case 126:
              return this.tsParseEnumDeclaration(t3, { declare: true });
            case 112:
              return this.tsParseAmbientExternalModuleDeclaration(t3);
            case 75:
            case 74:
              return this.match(75) && this.isLookaheadContextual("enum") ? (this.expect(75), this.tsParseEnumDeclaration(t3, { const: true, declare: true })) : (t3.declare = true, this.parseVarStatement(t3, e2 || this.state.value, true));
            case 129: {
              const e3 = this.tsParseInterfaceDeclaration(t3, { declare: true });
              if (e3)
                return e3;
            }
            default:
              if (tokenIsIdentifier(r2))
                return this.tsParseDeclaration(t3, this.state.value, true, null);
          }
        });
      }
      tsTryParseExportDeclaration() {
        return this.tsParseDeclaration(this.startNode(), this.state.value, true, null);
      }
      tsParseExpressionStatement(t3, e2, r2) {
        switch (e2.name) {
          case "declare": {
            const e3 = this.tsTryParseDeclare(t3);
            return e3 && (e3.declare = true), e3;
          }
          case "global":
            if (this.match(5)) {
              this.scope.enter(256), this.prodParam.enter(0);
              const r3 = t3;
              return r3.global = true, r3.id = e2, r3.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(r3, "TSModuleDeclaration");
            }
            break;
          default:
            return this.tsParseDeclaration(t3, e2.name, false, r2);
        }
      }
      tsParseDeclaration(t3, e2, r2, n2) {
        switch (e2) {
          case "abstract":
            if (this.tsCheckLineTerminator(r2) && (this.match(80) || tokenIsIdentifier(this.state.type)))
              return this.tsParseAbstractDeclaration(t3, n2);
            break;
          case "module":
            if (this.tsCheckLineTerminator(r2)) {
              if (this.match(133))
                return this.tsParseAmbientExternalModuleDeclaration(t3);
              if (tokenIsIdentifier(this.state.type))
                return this.tsParseModuleOrNamespaceDeclaration(t3);
            }
            break;
          case "namespace":
            if (this.tsCheckLineTerminator(r2) && tokenIsIdentifier(this.state.type))
              return this.tsParseModuleOrNamespaceDeclaration(t3);
            break;
          case "type":
            if (this.tsCheckLineTerminator(r2) && tokenIsIdentifier(this.state.type))
              return this.tsParseTypeAliasDeclaration(t3);
        }
      }
      tsCheckLineTerminator(t3) {
        return t3 ? !this.hasFollowingLineBreak() && (this.next(), true) : !this.isLineTerminator();
      }
      tsTryParseGenericAsyncArrowFunction(t3) {
        if (!this.match(47))
          return;
        const e2 = this.state.maybeInArrowParameters;
        this.state.maybeInArrowParameters = true;
        const r2 = this.tsTryParseAndCatch(() => {
          const e3 = this.startNodeAt(t3);
          return e3.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier), super.parseFunctionParams(e3), e3.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(), this.expect(19), e3;
        });
        return this.state.maybeInArrowParameters = e2, r2 ? super.parseArrowExpression(r2, null, true) : void 0;
      }
      tsParseTypeArgumentsInExpression() {
        if (47 === this.reScan_lt())
          return this.tsParseTypeArguments();
      }
      tsParseTypeArguments() {
        const t3 = this.startNode();
        return t3.params = this.tsInType(() => this.tsInNoContext(() => (this.expect(47), this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this))))), 0 === t3.params.length ? this.raise(ci.EmptyTypeArguments, { at: t3 }) : this.state.inType || this.curContext() !== yn.brace || this.reScan_lt_gt(), this.expect(48), this.finishNode(t3, "TSTypeParameterInstantiation");
      }
      tsIsDeclarationStart() {
        return (t3 = this.state.type) >= 124 && t3 <= 130;
        var t3;
      }
      isExportDefaultSpecifier() {
        return !this.tsIsDeclarationStart() && super.isExportDefaultSpecifier();
      }
      parseAssignableListItem(t3, e2) {
        const r2 = this.state.startLoc, n2 = {};
        this.tsParseModifiers({ allowedModifiers: ["public", "private", "protected", "override", "readonly"] }, n2);
        const i2 = n2.accessibility, o2 = n2.override, a2 = n2.readonly;
        4 & t3 || !(i2 || a2 || o2) || this.raise(ci.UnexpectedParameterModifier, { at: r2 });
        const s2 = this.parseMaybeDefault();
        this.parseAssignableListItemTypes(s2, t3);
        const l2 = this.parseMaybeDefault(s2.loc.start, s2);
        if (i2 || a2 || o2) {
          const t4 = this.startNodeAt(r2);
          return e2.length && (t4.decorators = e2), i2 && (t4.accessibility = i2), a2 && (t4.readonly = a2), o2 && (t4.override = o2), "Identifier" !== l2.type && "AssignmentPattern" !== l2.type && this.raise(ci.UnsupportedParameterPropertyKind, { at: t4 }), t4.parameter = l2, this.finishNode(t4, "TSParameterProperty");
        }
        return e2.length && (s2.decorators = e2), l2;
      }
      isSimpleParameter(t3) {
        return "TSParameterProperty" === t3.type && super.isSimpleParameter(t3.parameter) || super.isSimpleParameter(t3);
      }
      tsDisallowOptionalPattern(t3) {
        for (const e2 of t3.params)
          "Identifier" !== e2.type && e2.optional && !this.state.isAmbientContext && this.raise(ci.PatternIsOptional, { at: e2 });
      }
      setArrowFunctionParameters(t3, e2, r2) {
        super.setArrowFunctionParameters(t3, e2, r2), this.tsDisallowOptionalPattern(t3);
      }
      parseFunctionBodyAndFinish(t3, e2, r2 = false) {
        this.match(14) && (t3.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
        const n2 = "FunctionDeclaration" === e2 ? "TSDeclareFunction" : "ClassMethod" === e2 || "ClassPrivateMethod" === e2 ? "TSDeclareMethod" : void 0;
        return n2 && !this.match(5) && this.isLineTerminator() ? this.finishNode(t3, n2) : "TSDeclareFunction" === n2 && this.state.isAmbientContext && (this.raise(ci.DeclareFunctionHasImplementation, { at: t3 }), t3.declare) ? super.parseFunctionBodyAndFinish(t3, n2, r2) : (this.tsDisallowOptionalPattern(t3), super.parseFunctionBodyAndFinish(t3, e2, r2));
      }
      registerFunctionStatementId(t3) {
        !t3.body && t3.id ? this.checkIdentifier(t3.id, 1024) : super.registerFunctionStatementId(t3);
      }
      tsCheckForInvalidTypeCasts(t3) {
        t3.forEach((t4) => {
          "TSTypeCastExpression" === (null == t4 ? void 0 : t4.type) && this.raise(ci.UnexpectedTypeAnnotation, { at: t4.typeAnnotation });
        });
      }
      toReferencedList(t3, e2) {
        return this.tsCheckForInvalidTypeCasts(t3), t3;
      }
      parseArrayLike(t3, e2, r2, n2) {
        const i2 = super.parseArrayLike(t3, e2, r2, n2);
        return "ArrayExpression" === i2.type && this.tsCheckForInvalidTypeCasts(i2.elements), i2;
      }
      parseSubscript(t3, e2, r2, n2) {
        if (!this.hasPrecedingLineBreak() && this.match(35)) {
          this.state.canStartJSXElement = false, this.next();
          const r3 = this.startNodeAt(e2);
          return r3.expression = t3, this.finishNode(r3, "TSNonNullExpression");
        }
        let i2 = false;
        if (this.match(18) && 60 === this.lookaheadCharCode()) {
          if (r2)
            return n2.stop = true, t3;
          n2.optionalChainMember = i2 = true, this.next();
        }
        if (this.match(47) || this.match(51)) {
          let o2;
          const a2 = this.tsTryParseAndCatch(() => {
            if (!r2 && this.atPossibleAsyncArrow(t3)) {
              const t4 = this.tsTryParseGenericAsyncArrowFunction(e2);
              if (t4)
                return t4;
            }
            const a3 = this.tsParseTypeArgumentsInExpression();
            if (!a3)
              return;
            if (i2 && !this.match(10))
              return void (o2 = this.state.curPosition());
            if (tokenIsTemplate(this.state.type)) {
              const r3 = super.parseTaggedTemplateExpression(t3, e2, n2);
              return r3.typeParameters = a3, r3;
            }
            if (!r2 && this.eat(10)) {
              const r3 = this.startNodeAt(e2);
              return r3.callee = t3, r3.arguments = this.parseCallExpressionArguments(11, false), this.tsCheckForInvalidTypeCasts(r3.arguments), r3.typeParameters = a3, n2.optionalChainMember && (r3.optional = i2), this.finishCallExpression(r3, n2.optionalChainMember);
            }
            const s2 = this.state.type;
            if (48 === s2 || 52 === s2 || 10 !== s2 && tokenCanStartExpression(s2) && !this.hasPrecedingLineBreak())
              return;
            const l2 = this.startNodeAt(e2);
            return l2.expression = t3, l2.typeParameters = a3, this.finishNode(l2, "TSInstantiationExpression");
          });
          if (o2 && this.unexpected(o2, 10), a2)
            return "TSInstantiationExpression" === a2.type && (this.match(16) || this.match(18) && 40 !== this.lookaheadCharCode()) && this.raise(ci.InvalidPropertyAccessAfterInstantiationExpression, { at: this.state.startLoc }), a2;
        }
        return super.parseSubscript(t3, e2, r2, n2);
      }
      parseNewCallee(t3) {
        var e2;
        super.parseNewCallee(t3);
        const { callee: r2 } = t3;
        "TSInstantiationExpression" !== r2.type || null != (e2 = r2.extra) && e2.parenthesized || (t3.typeParameters = r2.typeParameters, t3.callee = r2.expression);
      }
      parseExprOp(t3, e2, r2) {
        let n2;
        if (tokenOperatorPrecedence(58) > r2 && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (n2 = this.isContextual(120)))) {
          const i2 = this.startNodeAt(e2);
          return i2.expression = t3, i2.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? (n2 && this.raise(xn.UnexpectedKeyword, { at: this.state.startLoc, keyword: "const" }), this.tsParseTypeReference()) : this.tsParseType())), this.finishNode(i2, n2 ? "TSSatisfiesExpression" : "TSAsExpression"), this.reScan_lt_gt(), this.parseExprOp(i2, e2, r2);
        }
        return super.parseExprOp(t3, e2, r2);
      }
      checkReservedWord(t3, e2, r2, n2) {
        this.state.isAmbientContext || super.checkReservedWord(t3, e2, r2, n2);
      }
      checkImportReflection(t3) {
        super.checkImportReflection(t3), t3.module && "value" !== t3.importKind && this.raise(ci.ImportReflectionHasImportType, { at: t3.specifiers[0].loc.start });
      }
      checkDuplicateExports() {
      }
      isPotentialImportPhase(t3) {
        if (super.isPotentialImportPhase(t3))
          return true;
        if (this.isContextual(130)) {
          const e2 = this.lookaheadCharCode();
          return t3 ? 123 === e2 || 42 === e2 : 61 !== e2;
        }
        return !t3 && this.isContextual(87);
      }
      applyImportPhase(t3, e2, r2, n2) {
        super.applyImportPhase(t3, e2, r2, n2), e2 ? t3.exportKind = "type" === r2 ? "type" : "value" : t3.importKind = "type" === r2 || "typeof" === r2 ? r2 : "value";
      }
      parseImport(t3) {
        if (this.match(133))
          return t3.importKind = "value", super.parseImport(t3);
        let e2;
        if (tokenIsIdentifier(this.state.type) && 61 === this.lookaheadCharCode())
          return t3.importKind = "value", this.tsParseImportEqualsDeclaration(t3);
        if (this.isContextual(130)) {
          const r2 = this.parseMaybeImportPhase(t3, false);
          if (61 === this.lookaheadCharCode())
            return this.tsParseImportEqualsDeclaration(t3, r2);
          e2 = super.parseImportSpecifiersAndAfter(t3, r2);
        } else
          e2 = super.parseImport(t3);
        return "type" === e2.importKind && e2.specifiers.length > 1 && "ImportDefaultSpecifier" === e2.specifiers[0].type && this.raise(ci.TypeImportCannotSpecifyDefaultAndNamed, { at: e2 }), e2;
      }
      parseExport(t3, e2) {
        if (this.match(83)) {
          this.next();
          let e3 = null;
          return this.isContextual(130) && this.isPotentialImportPhase(false) ? e3 = this.parseMaybeImportPhase(t3, false) : t3.importKind = "value", this.tsParseImportEqualsDeclaration(t3, e3, true);
        }
        if (this.eat(29)) {
          const e3 = t3;
          return e3.expression = super.parseExpression(), this.semicolon(), this.sawUnambiguousESM = true, this.finishNode(e3, "TSExportAssignment");
        }
        if (this.eatContextual(93)) {
          const e3 = t3;
          return this.expectContextual(128), e3.id = this.parseIdentifier(), this.semicolon(), this.finishNode(e3, "TSNamespaceExportDeclaration");
        }
        return super.parseExport(t3, e2);
      }
      isAbstractClass() {
        return this.isContextual(124) && 80 === this.lookahead().type;
      }
      parseExportDefaultExpression() {
        if (this.isAbstractClass()) {
          const t3 = this.startNode();
          return this.next(), t3.abstract = true, this.parseClass(t3, true, true);
        }
        if (this.match(129)) {
          const t3 = this.tsParseInterfaceDeclaration(this.startNode());
          if (t3)
            return t3;
        }
        return super.parseExportDefaultExpression();
      }
      parseVarStatement(t3, e2, r2 = false) {
        const { isAmbientContext: n2 } = this.state, i2 = super.parseVarStatement(t3, e2, r2 || n2);
        if (!n2)
          return i2;
        for (const { id: t4, init: r3 } of i2.declarations)
          r3 && ("const" !== e2 || t4.typeAnnotation ? this.raise(ci.InitializerNotAllowedInAmbientContext, { at: r3 }) : isValidAmbientConstInitializer(r3, this.hasPlugin("estree")) || this.raise(ci.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, { at: r3 }));
        return i2;
      }
      parseStatementContent(t3, e2) {
        if (this.match(75) && this.isLookaheadContextual("enum")) {
          const t4 = this.startNode();
          return this.expect(75), this.tsParseEnumDeclaration(t4, { const: true });
        }
        if (this.isContextual(126))
          return this.tsParseEnumDeclaration(this.startNode());
        if (this.isContextual(129)) {
          const t4 = this.tsParseInterfaceDeclaration(this.startNode());
          if (t4)
            return t4;
        }
        return super.parseStatementContent(t3, e2);
      }
      parseAccessModifier() {
        return this.tsParseModifier(["public", "protected", "private"]);
      }
      tsHasSomeModifiers(t3, e2) {
        return e2.some((e3) => tsIsAccessModifier(e3) ? t3.accessibility === e3 : !!t3[e3]);
      }
      tsIsStartOfStaticBlocks() {
        return this.isContextual(106) && 123 === this.lookaheadCharCode();
      }
      parseClassMember(t3, e2, r2) {
        const n2 = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
        this.tsParseModifiers({ allowedModifiers: n2, disallowedModifiers: ["in", "out"], stopOnStartOfClassStaticBlock: true, errorTemplate: ci.InvalidModifierOnTypeParameterPositions }, e2);
        const callParseClassMemberWithIsStatic = () => {
          this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(e2, n2) && this.raise(ci.StaticBlockCannotHaveModifier, { at: this.state.curPosition() }), super.parseClassStaticBlock(t3, e2)) : this.parseClassMemberWithIsStatic(t3, e2, r2, !!e2.static);
        };
        e2.declare ? this.tsInAmbientContext(callParseClassMemberWithIsStatic) : callParseClassMemberWithIsStatic();
      }
      parseClassMemberWithIsStatic(t3, e2, r2, n2) {
        const i2 = this.tsTryParseIndexSignature(e2);
        if (i2)
          return t3.body.push(i2), e2.abstract && this.raise(ci.IndexSignatureHasAbstract, { at: e2 }), e2.accessibility && this.raise(ci.IndexSignatureHasAccessibility, { at: e2, modifier: e2.accessibility }), e2.declare && this.raise(ci.IndexSignatureHasDeclare, { at: e2 }), void (e2.override && this.raise(ci.IndexSignatureHasOverride, { at: e2 }));
        !this.state.inAbstractClass && e2.abstract && this.raise(ci.NonAbstractClassHasAbstractMethod, { at: e2 }), e2.override && (r2.hadSuperClass || this.raise(ci.OverrideNotInSubClass, { at: e2 })), super.parseClassMemberWithIsStatic(t3, e2, r2, n2);
      }
      parsePostMemberNameModifiers(t3) {
        this.eat(17) && (t3.optional = true), t3.readonly && this.match(10) && this.raise(ci.ClassMethodHasReadonly, { at: t3 }), t3.declare && this.match(10) && this.raise(ci.ClassMethodHasDeclare, { at: t3 });
      }
      parseExpressionStatement(t3, e2, r2) {
        return ("Identifier" === e2.type ? this.tsParseExpressionStatement(t3, e2, r2) : void 0) || super.parseExpressionStatement(t3, e2, r2);
      }
      shouldParseExportDeclaration() {
        return !!this.tsIsDeclarationStart() || super.shouldParseExportDeclaration();
      }
      parseConditional(t3, e2, r2) {
        if (!this.state.maybeInArrowParameters || !this.match(17))
          return super.parseConditional(t3, e2, r2);
        const n2 = this.tryParse(() => super.parseConditional(t3, e2));
        return n2.node ? (n2.error && (this.state = n2.failState), n2.node) : (n2.error && super.setOptionalParametersError(r2, n2.error), t3);
      }
      parseParenItem(t3, e2) {
        if (t3 = super.parseParenItem(t3, e2), this.eat(17) && (t3.optional = true, this.resetEndLocation(t3)), this.match(14)) {
          const r2 = this.startNodeAt(e2);
          return r2.expression = t3, r2.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(r2, "TSTypeCastExpression");
        }
        return t3;
      }
      parseExportDeclaration(t3) {
        if (!this.state.isAmbientContext && this.isContextual(125))
          return this.tsInAmbientContext(() => this.parseExportDeclaration(t3));
        const e2 = this.state.startLoc, r2 = this.eatContextual(125);
        if (r2 && (this.isContextual(125) || !this.shouldParseExportDeclaration()))
          throw this.raise(ci.ExpectedAmbientAfterExportDeclare, { at: this.state.startLoc });
        const n2 = tokenIsIdentifier(this.state.type) && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(t3);
        return n2 ? (("TSInterfaceDeclaration" === n2.type || "TSTypeAliasDeclaration" === n2.type || r2) && (t3.exportKind = "type"), r2 && (this.resetStartLocation(n2, e2), n2.declare = true), n2) : null;
      }
      parseClassId(t3, e2, r2, n2) {
        if ((!e2 || r2) && this.isContextual(113))
          return;
        super.parseClassId(t3, e2, r2, t3.declare ? 1024 : 8331);
        const i2 = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
        i2 && (t3.typeParameters = i2);
      }
      parseClassPropertyAnnotation(t3) {
        t3.optional || (this.eat(35) ? t3.definite = true : this.eat(17) && (t3.optional = true));
        const e2 = this.tsTryParseTypeAnnotation();
        e2 && (t3.typeAnnotation = e2);
      }
      parseClassProperty(t3) {
        if (this.parseClassPropertyAnnotation(t3), this.state.isAmbientContext && (!t3.readonly || t3.typeAnnotation) && this.match(29) && this.raise(ci.DeclareClassFieldHasInitializer, { at: this.state.startLoc }), t3.abstract && this.match(29)) {
          const { key: e2 } = t3;
          this.raise(ci.AbstractPropertyHasInitializer, { at: this.state.startLoc, propertyName: "Identifier" !== e2.type || t3.computed ? `[${this.input.slice(e2.start, e2.end)}]` : e2.name });
        }
        return super.parseClassProperty(t3);
      }
      parseClassPrivateProperty(t3) {
        return t3.abstract && this.raise(ci.PrivateElementHasAbstract, { at: t3 }), t3.accessibility && this.raise(ci.PrivateElementHasAccessibility, { at: t3, modifier: t3.accessibility }), this.parseClassPropertyAnnotation(t3), super.parseClassPrivateProperty(t3);
      }
      parseClassAccessorProperty(t3) {
        return this.parseClassPropertyAnnotation(t3), t3.optional && this.raise(ci.AccessorCannotBeOptional, { at: t3 }), super.parseClassAccessorProperty(t3);
      }
      pushClassMethod(t3, e2, r2, n2, i2, o2) {
        const a2 = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        a2 && i2 && this.raise(ci.ConstructorHasTypeParameters, { at: a2 });
        const { declare: s2 = false, kind: l2 } = e2;
        !s2 || "get" !== l2 && "set" !== l2 || this.raise(ci.DeclareAccessor, { at: e2, kind: l2 }), a2 && (e2.typeParameters = a2), super.pushClassMethod(t3, e2, r2, n2, i2, o2);
      }
      pushClassPrivateMethod(t3, e2, r2, n2) {
        const i2 = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        i2 && (e2.typeParameters = i2), super.pushClassPrivateMethod(t3, e2, r2, n2);
      }
      declareClassPrivateMethodInScope(t3, e2) {
        "TSDeclareMethod" !== t3.type && ("MethodDefinition" !== t3.type || t3.value.body) && super.declareClassPrivateMethodInScope(t3, e2);
      }
      parseClassSuper(t3) {
        super.parseClassSuper(t3), t3.superClass && (this.match(47) || this.match(51)) && (t3.superTypeParameters = this.tsParseTypeArgumentsInExpression()), this.eatContextual(113) && (t3.implements = this.tsParseHeritageClause("implements"));
      }
      parseObjPropValue(t3, e2, r2, n2, i2, o2, a2) {
        const s2 = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        return s2 && (t3.typeParameters = s2), super.parseObjPropValue(t3, e2, r2, n2, i2, o2, a2);
      }
      parseFunctionParams(t3, e2) {
        const r2 = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        r2 && (t3.typeParameters = r2), super.parseFunctionParams(t3, e2);
      }
      parseVarId(t3, e2) {
        super.parseVarId(t3, e2), "Identifier" === t3.id.type && !this.hasPrecedingLineBreak() && this.eat(35) && (t3.definite = true);
        const r2 = this.tsTryParseTypeAnnotation();
        r2 && (t3.id.typeAnnotation = r2, this.resetEndLocation(t3.id));
      }
      parseAsyncArrowFromCallExpression(t3, e2) {
        return this.match(14) && (t3.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(t3, e2);
      }
      parseMaybeAssign(t3, e2) {
        var r2, n2, i2, o2, a2;
        let s2, l2, p2, c2;
        if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
          if (s2 = this.state.clone(), l2 = this.tryParse(() => super.parseMaybeAssign(t3, e2), s2), !l2.error)
            return l2.node;
          const { context: r3 } = this.state, n3 = r3[r3.length - 1];
          n3 !== yn.j_oTag && n3 !== yn.j_expr || r3.pop();
        }
        if (!(null != (r2 = l2) && r2.error || this.match(47)))
          return super.parseMaybeAssign(t3, e2);
        s2 && s2 !== this.state || (s2 = this.state.clone());
        const d2 = this.tryParse((r3) => {
          var n3, i3;
          c2 = this.tsParseTypeParameters(this.tsParseConstModifier);
          const o3 = super.parseMaybeAssign(t3, e2);
          return ("ArrowFunctionExpression" !== o3.type || null != (n3 = o3.extra) && n3.parenthesized) && r3(), 0 !== (null == (i3 = c2) ? void 0 : i3.params.length) && this.resetStartLocationFromNode(o3, c2), o3.typeParameters = c2, o3;
        }, s2);
        if (!d2.error && !d2.aborted)
          return c2 && this.reportReservedArrowTypeParam(c2), d2.node;
        if (!l2 && (assert$1(!this.hasPlugin("jsx")), p2 = this.tryParse(() => super.parseMaybeAssign(t3, e2), s2), !p2.error))
          return p2.node;
        if (null != (n2 = l2) && n2.node)
          return this.state = l2.failState, l2.node;
        if (d2.node)
          return this.state = d2.failState, c2 && this.reportReservedArrowTypeParam(c2), d2.node;
        if (null != (i2 = p2) && i2.node)
          return this.state = p2.failState, p2.node;
        throw (null == (o2 = l2) ? void 0 : o2.error) || d2.error || (null == (a2 = p2) ? void 0 : a2.error);
      }
      reportReservedArrowTypeParam(t3) {
        var e2;
        1 !== t3.params.length || t3.params[0].constraint || null != (e2 = t3.extra) && e2.trailingComma || !this.getPluginOption("typescript", "disallowAmbiguousJSXLike") || this.raise(ci.ReservedArrowTypeParam, { at: t3 });
      }
      parseMaybeUnary(t3, e2) {
        return !this.hasPlugin("jsx") && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(t3, e2);
      }
      parseArrow(t3) {
        if (this.match(14)) {
          const e2 = this.tryParse((t4) => {
            const e3 = this.tsParseTypeOrTypePredicateAnnotation(14);
            return !this.canInsertSemicolon() && this.match(19) || t4(), e3;
          });
          if (e2.aborted)
            return;
          e2.thrown || (e2.error && (this.state = e2.failState), t3.returnType = e2.node);
        }
        return super.parseArrow(t3);
      }
      parseAssignableListItemTypes(t3, e2) {
        if (!(2 & e2))
          return t3;
        this.eat(17) && (t3.optional = true);
        const r2 = this.tsTryParseTypeAnnotation();
        return r2 && (t3.typeAnnotation = r2), this.resetEndLocation(t3), t3;
      }
      isAssignable(t3, e2) {
        switch (t3.type) {
          case "TSTypeCastExpression":
            return this.isAssignable(t3.expression, e2);
          case "TSParameterProperty":
            return true;
          default:
            return super.isAssignable(t3, e2);
        }
      }
      toAssignable(t3, e2 = false) {
        switch (t3.type) {
          case "ParenthesizedExpression":
            this.toAssignableParenthesizedExpression(t3, e2);
            break;
          case "TSAsExpression":
          case "TSSatisfiesExpression":
          case "TSNonNullExpression":
          case "TSTypeAssertion":
            e2 ? this.expressionScope.recordArrowParameterBindingError(ci.UnexpectedTypeCastInParameter, { at: t3 }) : this.raise(ci.UnexpectedTypeCastInParameter, { at: t3 }), this.toAssignable(t3.expression, e2);
            break;
          case "AssignmentExpression":
            e2 || "TSTypeCastExpression" !== t3.left.type || (t3.left = this.typeCastToParameter(t3.left));
          default:
            super.toAssignable(t3, e2);
        }
      }
      toAssignableParenthesizedExpression(t3, e2) {
        switch (t3.expression.type) {
          case "TSAsExpression":
          case "TSSatisfiesExpression":
          case "TSNonNullExpression":
          case "TSTypeAssertion":
          case "ParenthesizedExpression":
            this.toAssignable(t3.expression, e2);
            break;
          default:
            super.toAssignable(t3, e2);
        }
      }
      checkToRestConversion(t3, e2) {
        switch (t3.type) {
          case "TSAsExpression":
          case "TSSatisfiesExpression":
          case "TSTypeAssertion":
          case "TSNonNullExpression":
            this.checkToRestConversion(t3.expression, false);
            break;
          default:
            super.checkToRestConversion(t3, e2);
        }
      }
      isValidLVal(t3, e2, r2) {
        return n2 = { TSTypeCastExpression: true, TSParameterProperty: "parameter", TSNonNullExpression: "expression", TSAsExpression: (64 !== r2 || !e2) && ["expression", true], TSSatisfiesExpression: (64 !== r2 || !e2) && ["expression", true], TSTypeAssertion: (64 !== r2 || !e2) && ["expression", true] }, i2 = t3, Object.hasOwnProperty.call(n2, i2) && n2[i2] || super.isValidLVal(t3, e2, r2);
        var n2, i2;
      }
      parseBindingAtom() {
        return 78 === this.state.type ? this.parseIdentifier(true) : super.parseBindingAtom();
      }
      parseMaybeDecoratorArguments(t3) {
        if (this.match(47) || this.match(51)) {
          const e2 = this.tsParseTypeArgumentsInExpression();
          if (this.match(10)) {
            const r2 = super.parseMaybeDecoratorArguments(t3);
            return r2.typeParameters = e2, r2;
          }
          this.unexpected(null, 10);
        }
        return super.parseMaybeDecoratorArguments(t3);
      }
      checkCommaAfterRest(t3) {
        return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === t3 ? (this.next(), false) : super.checkCommaAfterRest(t3);
      }
      isClassMethod() {
        return this.match(47) || super.isClassMethod();
      }
      isClassProperty() {
        return this.match(35) || this.match(14) || super.isClassProperty();
      }
      parseMaybeDefault(t3, e2) {
        const r2 = super.parseMaybeDefault(t3, e2);
        return "AssignmentPattern" === r2.type && r2.typeAnnotation && r2.right.start < r2.typeAnnotation.start && this.raise(ci.TypeAnnotationAfterAssign, { at: r2.typeAnnotation }), r2;
      }
      getTokenFromCode(t3) {
        if (this.state.inType) {
          if (62 === t3)
            return void this.finishOp(48, 1);
          if (60 === t3)
            return void this.finishOp(47, 1);
        }
        super.getTokenFromCode(t3);
      }
      reScan_lt_gt() {
        const { type: t3 } = this.state;
        47 === t3 ? (this.state.pos -= 1, this.readToken_lt()) : 48 === t3 && (this.state.pos -= 1, this.readToken_gt());
      }
      reScan_lt() {
        const { type: t3 } = this.state;
        return 51 === t3 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : t3;
      }
      toAssignableList(t3, e2, r2) {
        for (let e3 = 0; e3 < t3.length; e3++) {
          const r3 = t3[e3];
          "TSTypeCastExpression" === (null == r3 ? void 0 : r3.type) && (t3[e3] = this.typeCastToParameter(r3));
        }
        super.toAssignableList(t3, e2, r2);
      }
      typeCastToParameter(t3) {
        return t3.expression.typeAnnotation = t3.typeAnnotation, this.resetEndLocation(t3.expression, t3.typeAnnotation.loc.end), t3.expression;
      }
      shouldParseArrow(t3) {
        return this.match(14) ? t3.every((t4) => this.isAssignable(t4, true)) : super.shouldParseArrow(t3);
      }
      shouldParseAsyncArrow() {
        return this.match(14) || super.shouldParseAsyncArrow();
      }
      canHaveLeadingDecorator() {
        return super.canHaveLeadingDecorator() || this.isAbstractClass();
      }
      jsxParseOpeningElementAfterName(t3) {
        if (this.match(47) || this.match(51)) {
          const e2 = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
          e2 && (t3.typeParameters = e2);
        }
        return super.jsxParseOpeningElementAfterName(t3);
      }
      getGetterSetterExpectedParamCount(t3) {
        const e2 = super.getGetterSetterExpectedParamCount(t3), r2 = this.getObjectOrClassMethodParams(t3)[0];
        return r2 && this.isThisParam(r2) ? e2 + 1 : e2;
      }
      parseCatchClauseParam() {
        const t3 = super.parseCatchClauseParam(), e2 = this.tsTryParseTypeAnnotation();
        return e2 && (t3.typeAnnotation = e2, this.resetEndLocation(t3)), t3;
      }
      tsInAmbientContext(t3) {
        const e2 = this.state.isAmbientContext;
        this.state.isAmbientContext = true;
        try {
          return t3();
        } finally {
          this.state.isAmbientContext = e2;
        }
      }
      parseClass(t3, e2, r2) {
        const n2 = this.state.inAbstractClass;
        this.state.inAbstractClass = !!t3.abstract;
        try {
          return super.parseClass(t3, e2, r2);
        } finally {
          this.state.inAbstractClass = n2;
        }
      }
      tsParseAbstractDeclaration(t3, e2) {
        if (this.match(80))
          return t3.abstract = true, this.maybeTakeDecorators(e2, this.parseClass(t3, true, false));
        if (this.isContextual(129)) {
          if (!this.hasFollowingLineBreak())
            return t3.abstract = true, this.raise(ci.NonClassMethodPropertyHasAbstractModifer, { at: t3 }), this.tsParseInterfaceDeclaration(t3);
        } else
          this.unexpected(null, 80);
      }
      parseMethod(t3, e2, r2, n2, i2, o2, a2) {
        const s2 = super.parseMethod(t3, e2, r2, n2, i2, o2, a2);
        if (s2.abstract) {
          if (this.hasPlugin("estree") ? !!s2.value.body : !!s2.body) {
            const { key: t4 } = s2;
            this.raise(ci.AbstractMethodHasImplementation, { at: s2, methodName: "Identifier" !== t4.type || s2.computed ? `[${this.input.slice(t4.start, t4.end)}]` : t4.name });
          }
        }
        return s2;
      }
      tsParseTypeParameterName() {
        return this.parseIdentifier().name;
      }
      shouldParseAsAmbientContext() {
        return !!this.getPluginOption("typescript", "dts");
      }
      parse() {
        return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = true), super.parse();
      }
      getExpression() {
        return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = true), super.getExpression();
      }
      parseExportSpecifier(t3, e2, r2, n2) {
        return !e2 && n2 ? (this.parseTypeOnlyImportExportSpecifier(t3, false, r2), this.finishNode(t3, "ExportSpecifier")) : (t3.exportKind = "value", super.parseExportSpecifier(t3, e2, r2, n2));
      }
      parseImportSpecifier(t3, e2, r2, n2, i2) {
        return !e2 && n2 ? (this.parseTypeOnlyImportExportSpecifier(t3, true, r2), this.finishNode(t3, "ImportSpecifier")) : (t3.importKind = "value", super.parseImportSpecifier(t3, e2, r2, n2, r2 ? 4098 : 4096));
      }
      parseTypeOnlyImportExportSpecifier(t3, e2, r2) {
        const n2 = e2 ? "imported" : "local", i2 = e2 ? "local" : "exported";
        let o2, a2 = t3[n2], s2 = false, l2 = true;
        const p2 = a2.loc.start;
        if (this.isContextual(93)) {
          const t4 = this.parseIdentifier();
          if (this.isContextual(93)) {
            const r3 = this.parseIdentifier();
            tokenIsKeywordOrIdentifier(this.state.type) ? (s2 = true, a2 = t4, o2 = e2 ? this.parseIdentifier() : this.parseModuleExportName(), l2 = false) : (o2 = r3, l2 = false);
          } else
            tokenIsKeywordOrIdentifier(this.state.type) ? (l2 = false, o2 = e2 ? this.parseIdentifier() : this.parseModuleExportName()) : (s2 = true, a2 = t4);
        } else
          tokenIsKeywordOrIdentifier(this.state.type) && (s2 = true, e2 ? (a2 = this.parseIdentifier(true), this.isContextual(93) || this.checkReservedWord(a2.name, a2.loc.start, true, true)) : a2 = this.parseModuleExportName());
        s2 && r2 && this.raise(e2 ? ci.TypeModifierIsUsedInTypeImports : ci.TypeModifierIsUsedInTypeExports, { at: p2 }), t3[n2] = a2, t3[i2] = o2;
        t3[e2 ? "importKind" : "exportKind"] = s2 ? "type" : "value", l2 && this.eatContextual(93) && (t3[i2] = e2 ? this.parseIdentifier() : this.parseModuleExportName()), t3[i2] || (t3[i2] = cloneIdentifier(t3[n2])), e2 && this.checkIdentifier(t3[i2], s2 ? 4098 : 4096);
      }
    }, v8intrinsic: (t2) => class extends t2 {
      parseV8Intrinsic() {
        if (this.match(54)) {
          const t3 = this.state.startLoc, e2 = this.startNode();
          if (this.next(), tokenIsIdentifier(this.state.type)) {
            const t4 = this.parseIdentifierName(), r2 = this.createIdentifier(e2, t4);
            if (r2.type = "V8IntrinsicIdentifier", this.match(10))
              return r2;
          }
          this.unexpected(t3);
        }
      }
      parseExprAtom(t3) {
        return this.parseV8Intrinsic() || super.parseExprAtom(t3);
      }
    }, placeholders: (t2) => class extends t2 {
      parsePlaceholder(t3) {
        if (this.match(144)) {
          const e2 = this.startNode();
          return this.next(), this.assertNoSpace(), e2.name = super.parseIdentifier(true), this.assertNoSpace(), this.expect(144), this.finishPlaceholder(e2, t3);
        }
      }
      finishPlaceholder(t3, e2) {
        const r2 = !(!t3.expectedNode || "Placeholder" !== t3.type);
        return t3.expectedNode = e2, r2 ? t3 : this.finishNode(t3, "Placeholder");
      }
      getTokenFromCode(t3) {
        37 === t3 && 37 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(144, 2) : super.getTokenFromCode(t3);
      }
      parseExprAtom(t3) {
        return this.parsePlaceholder("Expression") || super.parseExprAtom(t3);
      }
      parseIdentifier(t3) {
        return this.parsePlaceholder("Identifier") || super.parseIdentifier(t3);
      }
      checkReservedWord(t3, e2, r2, n2) {
        void 0 !== t3 && super.checkReservedWord(t3, e2, r2, n2);
      }
      parseBindingAtom() {
        return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
      }
      isValidLVal(t3, e2, r2) {
        return "Placeholder" === t3 || super.isValidLVal(t3, e2, r2);
      }
      toAssignable(t3, e2) {
        t3 && "Placeholder" === t3.type && "Expression" === t3.expectedNode ? t3.expectedNode = "Pattern" : super.toAssignable(t3, e2);
      }
      chStartsBindingIdentifier(t3, e2) {
        if (super.chStartsBindingIdentifier(t3, e2))
          return true;
        return 144 === this.lookahead().type;
      }
      verifyBreakContinue(t3, e2) {
        t3.label && "Placeholder" === t3.label.type || super.verifyBreakContinue(t3, e2);
      }
      parseExpressionStatement(t3, e2) {
        var r2;
        if ("Placeholder" !== e2.type || null != (r2 = e2.extra) && r2.parenthesized)
          return super.parseExpressionStatement(t3, e2);
        if (this.match(14)) {
          const r3 = t3;
          return r3.label = this.finishPlaceholder(e2, "Identifier"), this.next(), r3.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration(), this.finishNode(r3, "LabeledStatement");
        }
        return this.semicolon(), t3.name = e2.name, this.finishPlaceholder(t3, "Statement");
      }
      parseBlock(t3, e2, r2) {
        return this.parsePlaceholder("BlockStatement") || super.parseBlock(t3, e2, r2);
      }
      parseFunctionId(t3) {
        return this.parsePlaceholder("Identifier") || super.parseFunctionId(t3);
      }
      parseClass(t3, e2, r2) {
        const n2 = e2 ? "ClassDeclaration" : "ClassExpression";
        this.next();
        const i2 = this.state.strict, o2 = this.parsePlaceholder("Identifier");
        if (o2) {
          if (!(this.match(81) || this.match(144) || this.match(5))) {
            if (r2 || !e2)
              return t3.id = null, t3.body = this.finishPlaceholder(o2, "ClassBody"), this.finishNode(t3, n2);
            throw this.raise(di.ClassNameIsRequired, { at: this.state.startLoc });
          }
          t3.id = o2;
        } else
          this.parseClassId(t3, e2, r2);
        return super.parseClassSuper(t3), t3.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!t3.superClass, i2), this.finishNode(t3, n2);
      }
      parseExport(t3, e2) {
        const r2 = this.parsePlaceholder("Identifier");
        if (!r2)
          return super.parseExport(t3, e2);
        if (!this.isContextual(98) && !this.match(12))
          return t3.specifiers = [], t3.source = null, t3.declaration = this.finishPlaceholder(r2, "Declaration"), this.finishNode(t3, "ExportNamedDeclaration");
        this.expectPlugin("exportDefaultFrom");
        const n2 = this.startNode();
        return n2.exported = r2, t3.specifiers = [this.finishNode(n2, "ExportDefaultSpecifier")], super.parseExport(t3, e2);
      }
      isExportDefaultSpecifier() {
        if (this.match(65)) {
          const t3 = this.nextTokenStart();
          if (this.isUnparsedContextual(t3, "from") && this.input.startsWith(tokenLabelName(144), this.nextTokenStartSince(t3 + 4)))
            return true;
        }
        return super.isExportDefaultSpecifier();
      }
      maybeParseExportDefaultSpecifier(t3, e2) {
        var r2;
        return !(null == (r2 = t3.specifiers) || !r2.length) || super.maybeParseExportDefaultSpecifier(t3, e2);
      }
      checkExport(t3) {
        const { specifiers: e2 } = t3;
        null != e2 && e2.length && (t3.specifiers = e2.filter((t4) => "Placeholder" === t4.exported.type)), super.checkExport(t3), t3.specifiers = e2;
      }
      parseImport(t3) {
        const e2 = this.parsePlaceholder("Identifier");
        if (!e2)
          return super.parseImport(t3);
        if (t3.specifiers = [], !this.isContextual(98) && !this.match(12))
          return t3.source = this.finishPlaceholder(e2, "StringLiteral"), this.semicolon(), this.finishNode(t3, "ImportDeclaration");
        const r2 = this.startNodeAtNode(e2);
        if (r2.local = e2, t3.specifiers.push(this.finishNode(r2, "ImportDefaultSpecifier")), this.eat(12)) {
          this.maybeParseStarImportSpecifier(t3) || this.parseNamedImportSpecifiers(t3);
        }
        return this.expectContextual(98), t3.source = this.parseImportSource(), this.semicolon(), this.finishNode(t3, "ImportDeclaration");
      }
      parseImportSource() {
        return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
      }
      assertNoSpace() {
        this.state.start > this.state.lastTokEndLoc.index && this.raise(di.UnexpectedSpace, { at: this.state.lastTokEndLoc });
      }
    } }, gi = Object.keys(fi), xi = { sourceType: "script", sourceFilename: void 0, startColumn: 0, startLine: 1, allowAwaitOutsideFunction: false, allowReturnOutsideFunction: false, allowNewTargetOutsideFunction: false, allowImportExportEverywhere: false, allowSuperOutsideMethod: false, allowUndeclaredExports: false, plugins: [], strictMode: null, ranges: false, tokens: false, createImportExpressions: false, createParenthesizedExpressions: false, errorRecovery: false, attachComment: true, annexB: true };
    class ExpressionParser extends LValParser {
      checkProto(t2, e2, r2, n2) {
        if ("SpreadElement" === t2.type || this.isObjectMethod(t2) || t2.computed || t2.shorthand)
          return;
        const i2 = t2.key;
        if ("__proto__" === ("Identifier" === i2.type ? i2.name : i2.value)) {
          if (e2)
            return void this.raise(xn.RecordNoProto, { at: i2 });
          r2.used && (n2 ? null === n2.doubleProtoLoc && (n2.doubleProtoLoc = i2.loc.start) : this.raise(xn.DuplicateProto, { at: i2 })), r2.used = true;
        }
      }
      shouldExitDescending(t2, e2) {
        return "ArrowFunctionExpression" === t2.type && t2.start === e2;
      }
      getExpression() {
        this.enterInitialScopes(), this.nextToken();
        const t2 = this.parseExpression();
        return this.match(139) || this.unexpected(), this.finalizeRemainingComments(), t2.comments = this.state.comments, t2.errors = this.state.errors, this.options.tokens && (t2.tokens = this.tokens), t2;
      }
      parseExpression(t2, e2) {
        return t2 ? this.disallowInAnd(() => this.parseExpressionBase(e2)) : this.allowInAnd(() => this.parseExpressionBase(e2));
      }
      parseExpressionBase(t2) {
        const e2 = this.state.startLoc, r2 = this.parseMaybeAssign(t2);
        if (this.match(12)) {
          const n2 = this.startNodeAt(e2);
          for (n2.expressions = [r2]; this.eat(12); )
            n2.expressions.push(this.parseMaybeAssign(t2));
          return this.toReferencedList(n2.expressions), this.finishNode(n2, "SequenceExpression");
        }
        return r2;
      }
      parseMaybeAssignDisallowIn(t2, e2) {
        return this.disallowInAnd(() => this.parseMaybeAssign(t2, e2));
      }
      parseMaybeAssignAllowIn(t2, e2) {
        return this.allowInAnd(() => this.parseMaybeAssign(t2, e2));
      }
      setOptionalParametersError(t2, e2) {
        var r2;
        t2.optionalParametersLoc = null != (r2 = null == e2 ? void 0 : e2.loc) ? r2 : this.state.startLoc;
      }
      parseMaybeAssign(t2, e2) {
        const r2 = this.state.startLoc;
        if (this.isContextual(108) && this.prodParam.hasYield) {
          let t3 = this.parseYield();
          return e2 && (t3 = e2.call(this, t3, r2)), t3;
        }
        let n2;
        t2 ? n2 = false : (t2 = new ExpressionErrors(), n2 = true);
        const { type: i2 } = this.state;
        (10 === i2 || tokenIsIdentifier(i2)) && (this.state.potentialArrowAt = this.state.start);
        let o2 = this.parseMaybeConditional(t2);
        if (e2 && (o2 = e2.call(this, o2, r2)), (a2 = this.state.type) >= 29 && a2 <= 33) {
          const e3 = this.startNodeAt(r2), n3 = this.state.value;
          if (e3.operator = n3, this.match(29)) {
            this.toAssignable(o2, true), e3.left = o2;
            const n4 = r2.index;
            null != t2.doubleProtoLoc && t2.doubleProtoLoc.index >= n4 && (t2.doubleProtoLoc = null), null != t2.shorthandAssignLoc && t2.shorthandAssignLoc.index >= n4 && (t2.shorthandAssignLoc = null), null != t2.privateKeyLoc && t2.privateKeyLoc.index >= n4 && (this.checkDestructuringPrivate(t2), t2.privateKeyLoc = null);
          } else
            e3.left = o2;
          return this.next(), e3.right = this.parseMaybeAssign(), this.checkLVal(o2, { in: this.finishNode(e3, "AssignmentExpression") }), e3;
        }
        var a2;
        return n2 && this.checkExpressionErrors(t2, true), o2;
      }
      parseMaybeConditional(t2) {
        const e2 = this.state.startLoc, r2 = this.state.potentialArrowAt, n2 = this.parseExprOps(t2);
        return this.shouldExitDescending(n2, r2) ? n2 : this.parseConditional(n2, e2, t2);
      }
      parseConditional(t2, e2, r2) {
        if (this.eat(17)) {
          const r3 = this.startNodeAt(e2);
          return r3.test = t2, r3.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), r3.alternate = this.parseMaybeAssign(), this.finishNode(r3, "ConditionalExpression");
        }
        return t2;
      }
      parseMaybeUnaryOrPrivate(t2) {
        return this.match(138) ? this.parsePrivateName() : this.parseMaybeUnary(t2);
      }
      parseExprOps(t2) {
        const e2 = this.state.startLoc, r2 = this.state.potentialArrowAt, n2 = this.parseMaybeUnaryOrPrivate(t2);
        return this.shouldExitDescending(n2, r2) ? n2 : this.parseExprOp(n2, e2, -1);
      }
      parseExprOp(t2, e2, r2) {
        if (this.isPrivateName(t2)) {
          const e3 = this.getPrivateNameSV(t2);
          (r2 >= tokenOperatorPrecedence(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(xn.PrivateInExpectedIn, { at: t2, identifierName: e3 }), this.classScope.usePrivateName(e3, t2.loc.start);
        }
        const n2 = this.state.type;
        if ((i2 = n2) >= 39 && i2 <= 59 && (this.prodParam.hasIn || !this.match(58))) {
          let i3 = tokenOperatorPrecedence(n2);
          if (i3 > r2) {
            if (39 === n2) {
              if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody)
                return t2;
              this.checkPipelineAtInfixOperator(t2, e2);
            }
            const o2 = this.startNodeAt(e2);
            o2.left = t2, o2.operator = this.state.value;
            const a2 = 41 === n2 || 42 === n2, s2 = 40 === n2;
            if (s2 && (i3 = tokenOperatorPrecedence(42)), this.next(), 39 === n2 && this.hasPlugin(["pipelineOperator", { proposal: "minimal" }]) && 96 === this.state.type && this.prodParam.hasAwait)
              throw this.raise(xn.UnexpectedAwaitAfterPipelineBody, { at: this.state.startLoc });
            o2.right = this.parseExprOpRightExpr(n2, i3);
            const l2 = this.finishNode(o2, a2 || s2 ? "LogicalExpression" : "BinaryExpression"), p2 = this.state.type;
            if (s2 && (41 === p2 || 42 === p2) || a2 && 40 === p2)
              throw this.raise(xn.MixingCoalesceWithLogical, { at: this.state.startLoc });
            return this.parseExprOp(l2, e2, r2);
          }
        }
        var i2;
        return t2;
      }
      parseExprOpRightExpr(t2, e2) {
        const r2 = this.state.startLoc;
        if (39 === t2)
          switch (this.getPluginOption("pipelineOperator", "proposal")) {
            case "hack":
              return this.withTopicBindingContext(() => this.parseHackPipeBody());
            case "smart":
              return this.withTopicBindingContext(() => {
                if (this.prodParam.hasYield && this.isContextual(108))
                  throw this.raise(xn.PipeBodyIsTighter, { at: this.state.startLoc });
                return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(t2, e2), r2);
              });
            case "fsharp":
              return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(e2));
          }
        return this.parseExprOpBaseRightExpr(t2, e2);
      }
      parseExprOpBaseRightExpr(t2, e2) {
        const r2 = this.state.startLoc;
        return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), r2, 57 === t2 ? e2 - 1 : e2);
      }
      parseHackPipeBody() {
        var t2;
        const { startLoc: e2 } = this.state, r2 = this.parseMaybeAssign();
        return !mn.has(r2.type) || null != (t2 = r2.extra) && t2.parenthesized || this.raise(xn.PipeUnparenthesizedBody, { at: e2, type: r2.type }), this.topicReferenceWasUsedInCurrentContext() || this.raise(xn.PipeTopicUnused, { at: e2 }), r2;
      }
      checkExponentialAfterUnary(t2) {
        this.match(57) && this.raise(xn.UnexpectedTokenUnaryExponentiation, { at: t2.argument });
      }
      parseMaybeUnary(t2, e2) {
        const r2 = this.state.startLoc, n2 = this.isContextual(96);
        if (n2 && this.isAwaitAllowed()) {
          this.next();
          const t3 = this.parseAwait(r2);
          return e2 || this.checkExponentialAfterUnary(t3), t3;
        }
        const i2 = this.match(34), o2 = this.startNode();
        if (a2 = this.state.type, Rn[a2]) {
          o2.operator = this.state.value, o2.prefix = true, this.match(72) && this.expectPlugin("throwExpressions");
          const r3 = this.match(89);
          if (this.next(), o2.argument = this.parseMaybeUnary(null, true), this.checkExpressionErrors(t2, true), this.state.strict && r3) {
            const t3 = o2.argument;
            "Identifier" === t3.type ? this.raise(xn.StrictDelete, { at: o2 }) : this.hasPropertyAsPrivateName(t3) && this.raise(xn.DeletePrivateField, { at: o2 });
          }
          if (!i2)
            return e2 || this.checkExponentialAfterUnary(o2), this.finishNode(o2, "UnaryExpression");
        }
        var a2;
        const s2 = this.parseUpdate(o2, i2, t2);
        if (n2) {
          const { type: t3 } = this.state;
          if ((this.hasPlugin("v8intrinsic") ? tokenCanStartExpression(t3) : tokenCanStartExpression(t3) && !this.match(54)) && !this.isAmbiguousAwait())
            return this.raiseOverwrite(xn.AwaitNotInAsyncContext, { at: r2 }), this.parseAwait(r2);
        }
        return s2;
      }
      parseUpdate(t2, e2, r2) {
        if (e2) {
          const e3 = t2;
          return this.checkLVal(e3.argument, { in: this.finishNode(e3, "UpdateExpression") }), t2;
        }
        const n2 = this.state.startLoc;
        let i2 = this.parseExprSubscripts(r2);
        if (this.checkExpressionErrors(r2, false))
          return i2;
        for (; 34 === this.state.type && !this.canInsertSemicolon(); ) {
          const t3 = this.startNodeAt(n2);
          t3.operator = this.state.value, t3.prefix = false, t3.argument = i2, this.next(), this.checkLVal(i2, { in: i2 = this.finishNode(t3, "UpdateExpression") });
        }
        return i2;
      }
      parseExprSubscripts(t2) {
        const e2 = this.state.startLoc, r2 = this.state.potentialArrowAt, n2 = this.parseExprAtom(t2);
        return this.shouldExitDescending(n2, r2) ? n2 : this.parseSubscripts(n2, e2);
      }
      parseSubscripts(t2, e2, r2) {
        const n2 = { optionalChainMember: false, maybeAsyncArrow: this.atPossibleAsyncArrow(t2), stop: false };
        do {
          t2 = this.parseSubscript(t2, e2, r2, n2), n2.maybeAsyncArrow = false;
        } while (!n2.stop);
        return t2;
      }
      parseSubscript(t2, e2, r2, n2) {
        const { type: i2 } = this.state;
        if (!r2 && 15 === i2)
          return this.parseBind(t2, e2, r2, n2);
        if (tokenIsTemplate(i2))
          return this.parseTaggedTemplateExpression(t2, e2, n2);
        let o2 = false;
        if (18 === i2) {
          if (r2 && (this.raise(xn.OptionalChainingNoNew, { at: this.state.startLoc }), 40 === this.lookaheadCharCode()))
            return n2.stop = true, t2;
          n2.optionalChainMember = o2 = true, this.next();
        }
        if (!r2 && this.match(10))
          return this.parseCoverCallAndAsyncArrowHead(t2, e2, n2, o2);
        {
          const r3 = this.eat(0);
          return r3 || o2 || this.eat(16) ? this.parseMember(t2, e2, n2, r3, o2) : (n2.stop = true, t2);
        }
      }
      parseMember(t2, e2, r2, n2, i2) {
        const o2 = this.startNodeAt(e2);
        return o2.object = t2, o2.computed = n2, n2 ? (o2.property = this.parseExpression(), this.expect(3)) : this.match(138) ? ("Super" === t2.type && this.raise(xn.SuperPrivateField, { at: e2 }), this.classScope.usePrivateName(this.state.value, this.state.startLoc), o2.property = this.parsePrivateName()) : o2.property = this.parseIdentifier(true), r2.optionalChainMember ? (o2.optional = i2, this.finishNode(o2, "OptionalMemberExpression")) : this.finishNode(o2, "MemberExpression");
      }
      parseBind(t2, e2, r2, n2) {
        const i2 = this.startNodeAt(e2);
        return i2.object = t2, this.next(), i2.callee = this.parseNoCallExpr(), n2.stop = true, this.parseSubscripts(this.finishNode(i2, "BindExpression"), e2, r2);
      }
      parseCoverCallAndAsyncArrowHead(t2, e2, r2, n2) {
        const i2 = this.state.maybeInArrowParameters;
        let o2 = null;
        this.state.maybeInArrowParameters = true, this.next();
        const a2 = this.startNodeAt(e2);
        a2.callee = t2;
        const { maybeAsyncArrow: s2, optionalChainMember: l2 } = r2;
        s2 && (this.expressionScope.enter(new ArrowHeadParsingScope(2)), o2 = new ExpressionErrors()), l2 && (a2.optional = n2), a2.arguments = n2 ? this.parseCallExpressionArguments(11) : this.parseCallExpressionArguments(11, "Import" === t2.type, "Super" !== t2.type, a2, o2);
        let p2 = this.finishCallExpression(a2, l2);
        return s2 && this.shouldParseAsyncArrow() && !n2 ? (r2.stop = true, this.checkDestructuringPrivate(o2), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), p2 = this.parseAsyncArrowFromCallExpression(this.startNodeAt(e2), p2)) : (s2 && (this.checkExpressionErrors(o2, true), this.expressionScope.exit()), this.toReferencedArguments(p2)), this.state.maybeInArrowParameters = i2, p2;
      }
      toReferencedArguments(t2, e2) {
        this.toReferencedListDeep(t2.arguments, e2);
      }
      parseTaggedTemplateExpression(t2, e2, r2) {
        const n2 = this.startNodeAt(e2);
        return n2.tag = t2, n2.quasi = this.parseTemplate(true), r2.optionalChainMember && this.raise(xn.OptionalChainingNoTemplate, { at: e2 }), this.finishNode(n2, "TaggedTemplateExpression");
      }
      atPossibleAsyncArrow(t2) {
        return "Identifier" === t2.type && "async" === t2.name && this.state.lastTokEndLoc.index === t2.end && !this.canInsertSemicolon() && t2.end - t2.start == 5 && t2.start === this.state.potentialArrowAt;
      }
      expectImportAttributesPlugin() {
        this.hasPlugin("importAssertions") || this.expectPlugin("importAttributes");
      }
      finishCallExpression(t2, e2) {
        if ("Import" === t2.callee.type)
          if (2 === t2.arguments.length && (this.hasPlugin("moduleAttributes") || this.expectImportAttributesPlugin()), 0 === t2.arguments.length || t2.arguments.length > 2)
            this.raise(xn.ImportCallArity, { at: t2, maxArgumentCount: this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? 2 : 1 });
          else
            for (const e3 of t2.arguments)
              "SpreadElement" === e3.type && this.raise(xn.ImportCallSpreadArgument, { at: e3 });
        return this.finishNode(t2, e2 ? "OptionalCallExpression" : "CallExpression");
      }
      parseCallExpressionArguments(t2, e2, r2, n2, i2) {
        const o2 = [];
        let a2 = true;
        const s2 = this.state.inFSharpPipelineDirectBody;
        for (this.state.inFSharpPipelineDirectBody = false; !this.eat(t2); ) {
          if (a2)
            a2 = false;
          else if (this.expect(12), this.match(t2)) {
            !e2 || this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") || this.raise(xn.ImportCallArgumentTrailingComma, { at: this.state.lastTokStartLoc }), n2 && this.addTrailingCommaExtraToNode(n2), this.next();
            break;
          }
          o2.push(this.parseExprListItem(false, i2, r2));
        }
        return this.state.inFSharpPipelineDirectBody = s2, o2;
      }
      shouldParseAsyncArrow() {
        return this.match(19) && !this.canInsertSemicolon();
      }
      parseAsyncArrowFromCallExpression(t2, e2) {
        var r2;
        return this.resetPreviousNodeTrailingComments(e2), this.expect(19), this.parseArrowExpression(t2, e2.arguments, true, null == (r2 = e2.extra) ? void 0 : r2.trailingCommaLoc), e2.innerComments && setInnerComments(t2, e2.innerComments), e2.callee.trailingComments && setInnerComments(t2, e2.callee.trailingComments), t2;
      }
      parseNoCallExpr() {
        const t2 = this.state.startLoc;
        return this.parseSubscripts(this.parseExprAtom(), t2, true);
      }
      parseExprAtom(t2) {
        let e2, r2 = null;
        const { type: n2 } = this.state;
        switch (n2) {
          case 79:
            return this.parseSuper();
          case 83:
            return e2 = this.startNode(), this.next(), this.match(16) ? this.parseImportMetaProperty(e2) : this.match(10) ? this.options.createImportExpressions ? this.parseImportCall(e2) : this.finishNode(e2, "Import") : (this.raise(xn.UnsupportedImport, { at: this.state.lastTokStartLoc }), this.finishNode(e2, "Import"));
          case 78:
            return e2 = this.startNode(), this.next(), this.finishNode(e2, "ThisExpression");
          case 90:
            return this.parseDo(this.startNode(), false);
          case 56:
          case 31:
            return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
          case 134:
            return this.parseNumericLiteral(this.state.value);
          case 135:
            return this.parseBigIntLiteral(this.state.value);
          case 136:
            return this.parseDecimalLiteral(this.state.value);
          case 133:
            return this.parseStringLiteral(this.state.value);
          case 84:
            return this.parseNullLiteral();
          case 85:
            return this.parseBooleanLiteral(true);
          case 86:
            return this.parseBooleanLiteral(false);
          case 10: {
            const t3 = this.state.potentialArrowAt === this.state.start;
            return this.parseParenAndDistinguishExpression(t3);
          }
          case 2:
          case 1:
            return this.parseArrayLike(2 === this.state.type ? 4 : 3, false, true);
          case 0:
            return this.parseArrayLike(3, true, false, t2);
          case 6:
          case 7:
            return this.parseObjectLike(6 === this.state.type ? 9 : 8, false, true);
          case 5:
            return this.parseObjectLike(8, false, false, t2);
          case 68:
            return this.parseFunctionOrFunctionSent();
          case 26:
            r2 = this.parseDecorators();
          case 80:
            return this.parseClass(this.maybeTakeDecorators(r2, this.startNode()), false);
          case 77:
            return this.parseNewOrNewTarget();
          case 25:
          case 24:
            return this.parseTemplate(false);
          case 15: {
            e2 = this.startNode(), this.next(), e2.object = null;
            const t3 = e2.callee = this.parseNoCallExpr();
            if ("MemberExpression" === t3.type)
              return this.finishNode(e2, "BindExpression");
            throw this.raise(xn.UnsupportedBind, { at: t3 });
          }
          case 138:
            return this.raise(xn.PrivateInExpectedIn, { at: this.state.startLoc, identifierName: this.state.value }), this.parsePrivateName();
          case 33:
            return this.parseTopicReferenceThenEqualsSign(54, "%");
          case 32:
            return this.parseTopicReferenceThenEqualsSign(44, "^");
          case 37:
          case 38:
            return this.parseTopicReference("hack");
          case 44:
          case 54:
          case 27: {
            const t3 = this.getPluginOption("pipelineOperator", "proposal");
            if (t3)
              return this.parseTopicReference(t3);
            this.unexpected();
            break;
          }
          case 47: {
            const t3 = this.input.codePointAt(this.nextTokenStart());
            isIdentifierStart(t3) || 62 === t3 ? this.expectOnePlugin(["jsx", "flow", "typescript"]) : this.unexpected();
            break;
          }
          default:
            if (tokenIsIdentifier(n2)) {
              if (this.isContextual(127) && 123 === this.lookaheadInLineCharCode())
                return this.parseModuleExpression();
              const t3 = this.state.potentialArrowAt === this.state.start, e3 = this.state.containsEsc, r3 = this.parseIdentifier();
              if (!e3 && "async" === r3.name && !this.canInsertSemicolon()) {
                const { type: t4 } = this.state;
                if (68 === t4)
                  return this.resetPreviousNodeTrailingComments(r3), this.next(), this.parseAsyncFunctionExpression(this.startNodeAtNode(r3));
                if (tokenIsIdentifier(t4))
                  return 61 === this.lookaheadCharCode() ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(r3)) : r3;
                if (90 === t4)
                  return this.resetPreviousNodeTrailingComments(r3), this.parseDo(this.startNodeAtNode(r3), true);
              }
              return t3 && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(r3), [r3], false)) : r3;
            }
            this.unexpected();
        }
      }
      parseTopicReferenceThenEqualsSign(t2, e2) {
        const r2 = this.getPluginOption("pipelineOperator", "proposal");
        if (r2)
          return this.state.type = t2, this.state.value = e2, this.state.pos--, this.state.end--, this.state.endLoc = createPositionWithColumnOffset(this.state.endLoc, -1), this.parseTopicReference(r2);
        this.unexpected();
      }
      parseTopicReference(t2) {
        const e2 = this.startNode(), r2 = this.state.startLoc, n2 = this.state.type;
        return this.next(), this.finishTopicReference(e2, r2, t2, n2);
      }
      finishTopicReference(t2, e2, r2, n2) {
        if (this.testTopicReferenceConfiguration(r2, e2, n2)) {
          const n3 = "smart" === r2 ? "PipelinePrimaryTopicReference" : "TopicReference";
          return this.topicReferenceIsAllowedInCurrentContext() || this.raise("smart" === r2 ? xn.PrimaryTopicNotAllowed : xn.PipeTopicUnbound, { at: e2 }), this.registerTopicReference(), this.finishNode(t2, n3);
        }
        throw this.raise(xn.PipeTopicUnconfiguredToken, { at: e2, token: tokenLabelName(n2) });
      }
      testTopicReferenceConfiguration(t2, e2, r2) {
        switch (t2) {
          case "hack":
            return this.hasPlugin(["pipelineOperator", { topicToken: tokenLabelName(r2) }]);
          case "smart":
            return 27 === r2;
          default:
            throw this.raise(xn.PipeTopicRequiresHackPipes, { at: e2 });
        }
      }
      parseAsyncArrowUnaryFunction(t2) {
        this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));
        const e2 = [this.parseIdentifier()];
        return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(xn.LineTerminatorBeforeArrow, { at: this.state.curPosition() }), this.expect(19), this.parseArrowExpression(t2, e2, true);
      }
      parseDo(t2, e2) {
        this.expectPlugin("doExpressions"), e2 && this.expectPlugin("asyncDoExpressions"), t2.async = e2, this.next();
        const r2 = this.state.labels;
        return this.state.labels = [], e2 ? (this.prodParam.enter(2), t2.body = this.parseBlock(), this.prodParam.exit()) : t2.body = this.parseBlock(), this.state.labels = r2, this.finishNode(t2, "DoExpression");
      }
      parseSuper() {
        const t2 = this.startNode();
        return this.next(), !this.match(10) || this.scope.allowDirectSuper || this.options.allowSuperOutsideMethod ? this.scope.allowSuper || this.options.allowSuperOutsideMethod || this.raise(xn.UnexpectedSuper, { at: t2 }) : this.raise(xn.SuperNotAllowed, { at: t2 }), this.match(10) || this.match(0) || this.match(16) || this.raise(xn.UnsupportedSuper, { at: t2 }), this.finishNode(t2, "Super");
      }
      parsePrivateName() {
        const t2 = this.startNode(), e2 = this.startNodeAt(createPositionWithColumnOffset(this.state.startLoc, 1)), r2 = this.state.value;
        return this.next(), t2.id = this.createIdentifier(e2, r2), this.finishNode(t2, "PrivateName");
      }
      parseFunctionOrFunctionSent() {
        const t2 = this.startNode();
        if (this.next(), this.prodParam.hasYield && this.match(16)) {
          const e2 = this.createIdentifier(this.startNodeAtNode(t2), "function");
          return this.next(), this.match(103) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), this.parseMetaProperty(t2, e2, "sent");
        }
        return this.parseFunction(t2);
      }
      parseMetaProperty(t2, e2, r2) {
        t2.meta = e2;
        const n2 = this.state.containsEsc;
        return t2.property = this.parseIdentifier(true), (t2.property.name !== r2 || n2) && this.raise(xn.UnsupportedMetaProperty, { at: t2.property, target: e2.name, onlyValidPropertyName: r2 }), this.finishNode(t2, "MetaProperty");
      }
      parseImportMetaProperty(t2) {
        const e2 = this.createIdentifier(this.startNodeAtNode(t2), "import");
        if (this.next(), this.isContextual(101))
          this.inModule || this.raise(xn.ImportMetaOutsideModule, { at: e2 }), this.sawUnambiguousESM = true;
        else if (this.isContextual(105) || this.isContextual(97)) {
          const e3 = this.isContextual(105);
          if (e3 || this.unexpected(), this.expectPlugin(e3 ? "sourcePhaseImports" : "deferredImportEvaluation"), !this.options.createImportExpressions)
            throw this.raise(xn.DynamicImportPhaseRequiresImportExpressions, { at: this.state.startLoc, phase: this.state.value });
          return this.next(), t2.phase = e3 ? "source" : "defer", this.parseImportCall(t2);
        }
        return this.parseMetaProperty(t2, e2, "meta");
      }
      parseLiteralAtNode(t2, e2, r2) {
        return this.addExtra(r2, "rawValue", t2), this.addExtra(r2, "raw", this.input.slice(r2.start, this.state.end)), r2.value = t2, this.next(), this.finishNode(r2, e2);
      }
      parseLiteral(t2, e2) {
        const r2 = this.startNode();
        return this.parseLiteralAtNode(t2, e2, r2);
      }
      parseStringLiteral(t2) {
        return this.parseLiteral(t2, "StringLiteral");
      }
      parseNumericLiteral(t2) {
        return this.parseLiteral(t2, "NumericLiteral");
      }
      parseBigIntLiteral(t2) {
        return this.parseLiteral(t2, "BigIntLiteral");
      }
      parseDecimalLiteral(t2) {
        return this.parseLiteral(t2, "DecimalLiteral");
      }
      parseRegExpLiteral(t2) {
        const e2 = this.parseLiteral(t2.value, "RegExpLiteral");
        return e2.pattern = t2.pattern, e2.flags = t2.flags, e2;
      }
      parseBooleanLiteral(t2) {
        const e2 = this.startNode();
        return e2.value = t2, this.next(), this.finishNode(e2, "BooleanLiteral");
      }
      parseNullLiteral() {
        const t2 = this.startNode();
        return this.next(), this.finishNode(t2, "NullLiteral");
      }
      parseParenAndDistinguishExpression(t2) {
        const e2 = this.state.startLoc;
        let r2;
        this.next(), this.expressionScope.enter(new ArrowHeadParsingScope(1));
        const n2 = this.state.maybeInArrowParameters, i2 = this.state.inFSharpPipelineDirectBody;
        this.state.maybeInArrowParameters = true, this.state.inFSharpPipelineDirectBody = false;
        const o2 = this.state.startLoc, a2 = [], s2 = new ExpressionErrors();
        let l2, p2, c2 = true;
        for (; !this.match(11); ) {
          if (c2)
            c2 = false;
          else if (this.expect(12, null === s2.optionalParametersLoc ? null : s2.optionalParametersLoc), this.match(11)) {
            p2 = this.state.startLoc;
            break;
          }
          if (this.match(21)) {
            const t3 = this.state.startLoc;
            if (l2 = this.state.startLoc, a2.push(this.parseParenItem(this.parseRestBinding(), t3)), !this.checkCommaAfterRest(41))
              break;
          } else
            a2.push(this.parseMaybeAssignAllowIn(s2, this.parseParenItem));
        }
        const d2 = this.state.lastTokEndLoc;
        this.expect(11), this.state.maybeInArrowParameters = n2, this.state.inFSharpPipelineDirectBody = i2;
        let m2 = this.startNodeAt(e2);
        return t2 && this.shouldParseArrow(a2) && (m2 = this.parseArrow(m2)) ? (this.checkDestructuringPrivate(s2), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), this.parseArrowExpression(m2, a2, false), m2) : (this.expressionScope.exit(), a2.length || this.unexpected(this.state.lastTokStartLoc), p2 && this.unexpected(p2), l2 && this.unexpected(l2), this.checkExpressionErrors(s2, true), this.toReferencedListDeep(a2, true), a2.length > 1 ? (r2 = this.startNodeAt(o2), r2.expressions = a2, this.finishNode(r2, "SequenceExpression"), this.resetEndLocation(r2, d2)) : r2 = a2[0], this.wrapParenthesis(e2, r2));
      }
      wrapParenthesis(t2, e2) {
        if (!this.options.createParenthesizedExpressions)
          return this.addExtra(e2, "parenthesized", true), this.addExtra(e2, "parenStart", t2.index), this.takeSurroundingComments(e2, t2.index, this.state.lastTokEndLoc.index), e2;
        const r2 = this.startNodeAt(t2);
        return r2.expression = e2, this.finishNode(r2, "ParenthesizedExpression");
      }
      shouldParseArrow(t2) {
        return !this.canInsertSemicolon();
      }
      parseArrow(t2) {
        if (this.eat(19))
          return t2;
      }
      parseParenItem(t2, e2) {
        return t2;
      }
      parseNewOrNewTarget() {
        const t2 = this.startNode();
        if (this.next(), this.match(16)) {
          const e2 = this.createIdentifier(this.startNodeAtNode(t2), "new");
          this.next();
          const r2 = this.parseMetaProperty(t2, e2, "target");
          return this.scope.inNonArrowFunction || this.scope.inClass || this.options.allowNewTargetOutsideFunction || this.raise(xn.UnexpectedNewTarget, { at: r2 }), r2;
        }
        return this.parseNew(t2);
      }
      parseNew(t2) {
        if (this.parseNewCallee(t2), this.eat(10)) {
          const e2 = this.parseExprList(11);
          this.toReferencedList(e2), t2.arguments = e2;
        } else
          t2.arguments = [];
        return this.finishNode(t2, "NewExpression");
      }
      parseNewCallee(t2) {
        const e2 = this.match(83), r2 = this.parseNoCallExpr();
        t2.callee = r2, !e2 || "Import" !== r2.type && "ImportExpression" !== r2.type || this.raise(xn.ImportCallNotNewExpression, { at: r2 });
      }
      parseTemplateElement(t2) {
        const { start: e2, startLoc: r2, end: n2, value: i2 } = this.state, o2 = e2 + 1, a2 = this.startNodeAt(createPositionWithColumnOffset(r2, 1));
        null === i2 && (t2 || this.raise(xn.InvalidEscapeSequenceTemplate, { at: createPositionWithColumnOffset(this.state.firstInvalidTemplateEscapePos, 1) }));
        const s2 = this.match(24), l2 = s2 ? -1 : -2, p2 = n2 + l2;
        a2.value = { raw: this.input.slice(o2, p2).replace(/\r\n?/g, "\n"), cooked: null === i2 ? null : i2.slice(1, l2) }, a2.tail = s2, this.next();
        const c2 = this.finishNode(a2, "TemplateElement");
        return this.resetEndLocation(c2, createPositionWithColumnOffset(this.state.lastTokEndLoc, l2)), c2;
      }
      parseTemplate(t2) {
        const e2 = this.startNode();
        e2.expressions = [];
        let r2 = this.parseTemplateElement(t2);
        for (e2.quasis = [r2]; !r2.tail; )
          e2.expressions.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), e2.quasis.push(r2 = this.parseTemplateElement(t2));
        return this.finishNode(e2, "TemplateLiteral");
      }
      parseTemplateSubstitution() {
        return this.parseExpression();
      }
      parseObjectLike(t2, e2, r2, n2) {
        r2 && this.expectPlugin("recordAndTuple");
        const i2 = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = false;
        const o2 = /* @__PURE__ */ Object.create(null);
        let a2 = true;
        const s2 = this.startNode();
        for (s2.properties = [], this.next(); !this.match(t2); ) {
          if (a2)
            a2 = false;
          else if (this.expect(12), this.match(t2)) {
            this.addTrailingCommaExtraToNode(s2);
            break;
          }
          let i3;
          e2 ? i3 = this.parseBindingProperty() : (i3 = this.parsePropertyDefinition(n2), this.checkProto(i3, r2, o2, n2)), r2 && !this.isObjectProperty(i3) && "SpreadElement" !== i3.type && this.raise(xn.InvalidRecordProperty, { at: i3 }), i3.shorthand && this.addExtra(i3, "shorthand", true), s2.properties.push(i3);
        }
        this.next(), this.state.inFSharpPipelineDirectBody = i2;
        let l2 = "ObjectExpression";
        return e2 ? l2 = "ObjectPattern" : r2 && (l2 = "RecordExpression"), this.finishNode(s2, l2);
      }
      addTrailingCommaExtraToNode(t2) {
        this.addExtra(t2, "trailingComma", this.state.lastTokStart), this.addExtra(t2, "trailingCommaLoc", this.state.lastTokStartLoc, false);
      }
      maybeAsyncOrAccessorProp(t2) {
        return !t2.computed && "Identifier" === t2.key.type && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
      }
      parsePropertyDefinition(t2) {
        let e2 = [];
        if (this.match(26))
          for (this.hasPlugin("decorators") && this.raise(xn.UnsupportedPropertyDecorator, { at: this.state.startLoc }); this.match(26); )
            e2.push(this.parseDecorator());
        const r2 = this.startNode();
        let n2, i2 = false, o2 = false;
        if (this.match(21))
          return e2.length && this.unexpected(), this.parseSpread();
        e2.length && (r2.decorators = e2, e2 = []), r2.method = false, t2 && (n2 = this.state.startLoc);
        let a2 = this.eat(55);
        this.parsePropertyNamePrefixOperator(r2);
        const s2 = this.state.containsEsc, l2 = this.parsePropertyName(r2, t2);
        if (!a2 && !s2 && this.maybeAsyncOrAccessorProp(r2)) {
          const t3 = l2.name;
          "async" !== t3 || this.hasPrecedingLineBreak() || (i2 = true, this.resetPreviousNodeTrailingComments(l2), a2 = this.eat(55), this.parsePropertyName(r2)), "get" !== t3 && "set" !== t3 || (o2 = true, this.resetPreviousNodeTrailingComments(l2), r2.kind = t3, this.match(55) && (a2 = true, this.raise(xn.AccessorIsGenerator, { at: this.state.curPosition(), kind: t3 }), this.next()), this.parsePropertyName(r2));
        }
        return this.parseObjPropValue(r2, n2, a2, i2, false, o2, t2);
      }
      getGetterSetterExpectedParamCount(t2) {
        return "get" === t2.kind ? 0 : 1;
      }
      getObjectOrClassMethodParams(t2) {
        return t2.params;
      }
      checkGetterSetterParams(t2) {
        var e2;
        const r2 = this.getGetterSetterExpectedParamCount(t2), n2 = this.getObjectOrClassMethodParams(t2);
        n2.length !== r2 && this.raise("get" === t2.kind ? xn.BadGetterArity : xn.BadSetterArity, { at: t2 }), "set" === t2.kind && "RestElement" === (null == (e2 = n2[n2.length - 1]) ? void 0 : e2.type) && this.raise(xn.BadSetterRestParameter, { at: t2 });
      }
      parseObjectMethod(t2, e2, r2, n2, i2) {
        if (i2) {
          const r3 = this.parseMethod(t2, e2, false, false, false, "ObjectMethod");
          return this.checkGetterSetterParams(r3), r3;
        }
        if (r2 || e2 || this.match(10))
          return n2 && this.unexpected(), t2.kind = "method", t2.method = true, this.parseMethod(t2, e2, r2, false, false, "ObjectMethod");
      }
      parseObjectProperty(t2, e2, r2, n2) {
        if (t2.shorthand = false, this.eat(14))
          return t2.value = r2 ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(n2), this.finishNode(t2, "ObjectProperty");
        if (!t2.computed && "Identifier" === t2.key.type) {
          if (this.checkReservedWord(t2.key.name, t2.key.loc.start, true, false), r2)
            t2.value = this.parseMaybeDefault(e2, cloneIdentifier(t2.key));
          else if (this.match(29)) {
            const r3 = this.state.startLoc;
            null != n2 ? null === n2.shorthandAssignLoc && (n2.shorthandAssignLoc = r3) : this.raise(xn.InvalidCoverInitializedName, { at: r3 }), t2.value = this.parseMaybeDefault(e2, cloneIdentifier(t2.key));
          } else
            t2.value = cloneIdentifier(t2.key);
          return t2.shorthand = true, this.finishNode(t2, "ObjectProperty");
        }
      }
      parseObjPropValue(t2, e2, r2, n2, i2, o2, a2) {
        const s2 = this.parseObjectMethod(t2, r2, n2, i2, o2) || this.parseObjectProperty(t2, e2, i2, a2);
        return s2 || this.unexpected(), s2;
      }
      parsePropertyName(t2, e2) {
        if (this.eat(0))
          t2.computed = true, t2.key = this.parseMaybeAssignAllowIn(), this.expect(3);
        else {
          const { type: r2, value: n2 } = this.state;
          let i2;
          if (tokenIsKeywordOrIdentifier(r2))
            i2 = this.parseIdentifier(true);
          else
            switch (r2) {
              case 134:
                i2 = this.parseNumericLiteral(n2);
                break;
              case 133:
                i2 = this.parseStringLiteral(n2);
                break;
              case 135:
                i2 = this.parseBigIntLiteral(n2);
                break;
              case 136:
                i2 = this.parseDecimalLiteral(n2);
                break;
              case 138: {
                const t3 = this.state.startLoc;
                null != e2 ? null === e2.privateKeyLoc && (e2.privateKeyLoc = t3) : this.raise(xn.UnexpectedPrivateField, { at: t3 }), i2 = this.parsePrivateName();
                break;
              }
              default:
                this.unexpected();
            }
          t2.key = i2, 138 !== r2 && (t2.computed = false);
        }
        return t2.key;
      }
      initFunction(t2, e2) {
        t2.id = null, t2.generator = false, t2.async = e2;
      }
      parseMethod(t2, e2, r2, n2, i2, o2, a2 = false) {
        this.initFunction(t2, r2), t2.generator = e2, this.scope.enter(18 | (a2 ? 64 : 0) | (i2 ? 32 : 0)), this.prodParam.enter(functionFlags(r2, t2.generator)), this.parseFunctionParams(t2, n2);
        const s2 = this.parseFunctionBodyAndFinish(t2, o2, true);
        return this.prodParam.exit(), this.scope.exit(), s2;
      }
      parseArrayLike(t2, e2, r2, n2) {
        r2 && this.expectPlugin("recordAndTuple");
        const i2 = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = false;
        const o2 = this.startNode();
        return this.next(), o2.elements = this.parseExprList(t2, !r2, n2, o2), this.state.inFSharpPipelineDirectBody = i2, this.finishNode(o2, r2 ? "TupleExpression" : "ArrayExpression");
      }
      parseArrowExpression(t2, e2, r2, n2) {
        this.scope.enter(6);
        let i2 = functionFlags(r2, false);
        !this.match(5) && this.prodParam.hasIn && (i2 |= 8), this.prodParam.enter(i2), this.initFunction(t2, r2);
        const o2 = this.state.maybeInArrowParameters;
        return e2 && (this.state.maybeInArrowParameters = true, this.setArrowFunctionParameters(t2, e2, n2)), this.state.maybeInArrowParameters = false, this.parseFunctionBody(t2, true), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = o2, this.finishNode(t2, "ArrowFunctionExpression");
      }
      setArrowFunctionParameters(t2, e2, r2) {
        this.toAssignableList(e2, r2, false), t2.params = e2;
      }
      parseFunctionBodyAndFinish(t2, e2, r2 = false) {
        return this.parseFunctionBody(t2, false, r2), this.finishNode(t2, e2);
      }
      parseFunctionBody(t2, e2, r2 = false) {
        const n2 = e2 && !this.match(5);
        if (this.expressionScope.enter(newExpressionScope()), n2)
          t2.body = this.parseMaybeAssign(), this.checkParams(t2, false, e2, false);
        else {
          const n3 = this.state.strict, i2 = this.state.labels;
          this.state.labels = [], this.prodParam.enter(4 | this.prodParam.currentFlags()), t2.body = this.parseBlock(true, false, (i3) => {
            const o2 = !this.isSimpleParamList(t2.params);
            i3 && o2 && this.raise(xn.IllegalLanguageModeDirective, { at: "method" !== t2.kind && "constructor" !== t2.kind || !t2.key ? t2 : t2.key.loc.end });
            const a2 = !n3 && this.state.strict;
            this.checkParams(t2, !(this.state.strict || e2 || r2 || o2), e2, a2), this.state.strict && t2.id && this.checkIdentifier(t2.id, 65, a2);
          }), this.prodParam.exit(), this.state.labels = i2;
        }
        this.expressionScope.exit();
      }
      isSimpleParameter(t2) {
        return "Identifier" === t2.type;
      }
      isSimpleParamList(t2) {
        for (let e2 = 0, r2 = t2.length; e2 < r2; e2++)
          if (!this.isSimpleParameter(t2[e2]))
            return false;
        return true;
      }
      checkParams(t2, e2, r2, n2 = true) {
        const i2 = !e2 && /* @__PURE__ */ new Set(), o2 = { type: "FormalParameters" };
        for (const e3 of t2.params)
          this.checkLVal(e3, { in: o2, binding: 5, checkClashes: i2, strictModeChanged: n2 });
      }
      parseExprList(t2, e2, r2, n2) {
        const i2 = [];
        let o2 = true;
        for (; !this.eat(t2); ) {
          if (o2)
            o2 = false;
          else if (this.expect(12), this.match(t2)) {
            n2 && this.addTrailingCommaExtraToNode(n2), this.next();
            break;
          }
          i2.push(this.parseExprListItem(e2, r2));
        }
        return i2;
      }
      parseExprListItem(t2, e2, r2) {
        let n2;
        if (this.match(12))
          t2 || this.raise(xn.UnexpectedToken, { at: this.state.curPosition(), unexpected: "," }), n2 = null;
        else if (this.match(21)) {
          const t3 = this.state.startLoc;
          n2 = this.parseParenItem(this.parseSpread(e2), t3);
        } else if (this.match(17)) {
          this.expectPlugin("partialApplication"), r2 || this.raise(xn.UnexpectedArgumentPlaceholder, { at: this.state.startLoc });
          const t3 = this.startNode();
          this.next(), n2 = this.finishNode(t3, "ArgumentPlaceholder");
        } else
          n2 = this.parseMaybeAssignAllowIn(e2, this.parseParenItem);
        return n2;
      }
      parseIdentifier(t2) {
        const e2 = this.startNode(), r2 = this.parseIdentifierName(t2);
        return this.createIdentifier(e2, r2);
      }
      createIdentifier(t2, e2) {
        return t2.name = e2, t2.loc.identifierName = e2, this.finishNode(t2, "Identifier");
      }
      parseIdentifierName(t2) {
        let e2;
        const { startLoc: r2, type: n2 } = this.state;
        tokenIsKeywordOrIdentifier(n2) ? e2 = this.state.value : this.unexpected();
        const i2 = n2 <= 92;
        return t2 ? i2 && this.replaceToken(132) : this.checkReservedWord(e2, r2, i2, false), this.next(), e2;
      }
      checkReservedWord(t2, e2, r2, n2) {
        if (t2.length > 10)
          return;
        if (!function(t3) {
          return qn.has(t3);
        }(t2))
          return;
        if (r2 && function(t3) {
          return zn.has(t3);
        }(t2))
          return void this.raise(xn.UnexpectedKeyword, { at: e2, keyword: t2 });
        if ((this.state.strict ? n2 ? isStrictBindReservedWord : isStrictReservedWord : isReservedWord)(t2, this.inModule))
          this.raise(xn.UnexpectedReservedWord, { at: e2, reservedWord: t2 });
        else if ("yield" === t2) {
          if (this.prodParam.hasYield)
            return void this.raise(xn.YieldBindingIdentifier, { at: e2 });
        } else if ("await" === t2) {
          if (this.prodParam.hasAwait)
            return void this.raise(xn.AwaitBindingIdentifier, { at: e2 });
          if (this.scope.inStaticBlock)
            return void this.raise(xn.AwaitBindingIdentifierInStaticBlock, { at: e2 });
          this.expressionScope.recordAsyncArrowParametersError({ at: e2 });
        } else if ("arguments" === t2 && this.scope.inClassAndNotInNonArrowFunction)
          return void this.raise(xn.ArgumentsInClass, { at: e2 });
      }
      isAwaitAllowed() {
        return !!this.prodParam.hasAwait || !(!this.options.allowAwaitOutsideFunction || this.scope.inFunction);
      }
      parseAwait(t2) {
        const e2 = this.startNodeAt(t2);
        return this.expressionScope.recordParameterInitializerError(xn.AwaitExpressionFormalParameter, { at: e2 }), this.eat(55) && this.raise(xn.ObsoleteAwaitStar, { at: e2 }), this.scope.inFunction || this.options.allowAwaitOutsideFunction || (this.isAmbiguousAwait() ? this.ambiguousScriptDifferentAst = true : this.sawUnambiguousESM = true), this.state.soloAwait || (e2.argument = this.parseMaybeUnary(null, true)), this.finishNode(e2, "AwaitExpression");
      }
      isAmbiguousAwait() {
        if (this.hasPrecedingLineBreak())
          return true;
        const { type: t2 } = this.state;
        return 53 === t2 || 10 === t2 || 0 === t2 || tokenIsTemplate(t2) || 102 === t2 && !this.state.containsEsc || 137 === t2 || 56 === t2 || this.hasPlugin("v8intrinsic") && 54 === t2;
      }
      parseYield() {
        const t2 = this.startNode();
        this.expressionScope.recordParameterInitializerError(xn.YieldInParameter, { at: t2 }), this.next();
        let e2 = false, r2 = null;
        if (!this.hasPrecedingLineBreak())
          switch (e2 = this.eat(55), this.state.type) {
            case 13:
            case 139:
            case 8:
            case 11:
            case 3:
            case 9:
            case 14:
            case 12:
              if (!e2)
                break;
            default:
              r2 = this.parseMaybeAssign();
          }
        return t2.delegate = e2, t2.argument = r2, this.finishNode(t2, "YieldExpression");
      }
      parseImportCall(t2) {
        return this.next(), t2.source = this.parseMaybeAssignAllowIn(), (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) && (t2.options = null), this.eat(12) && (this.expectImportAttributesPlugin(), this.match(11) || (t2.options = this.parseMaybeAssignAllowIn(), this.eat(12))), this.expect(11), this.finishNode(t2, "ImportExpression");
      }
      checkPipelineAtInfixOperator(t2, e2) {
        this.hasPlugin(["pipelineOperator", { proposal: "smart" }]) && "SequenceExpression" === t2.type && this.raise(xn.PipelineHeadSequenceExpression, { at: e2 });
      }
      parseSmartPipelineBodyInStyle(t2, e2) {
        if (this.isSimpleReference(t2)) {
          const r2 = this.startNodeAt(e2);
          return r2.callee = t2, this.finishNode(r2, "PipelineBareFunction");
        }
        {
          const r2 = this.startNodeAt(e2);
          return this.checkSmartPipeTopicBodyEarlyErrors(e2), r2.expression = t2, this.finishNode(r2, "PipelineTopicExpression");
        }
      }
      isSimpleReference(t2) {
        switch (t2.type) {
          case "MemberExpression":
            return !t2.computed && this.isSimpleReference(t2.object);
          case "Identifier":
            return true;
          default:
            return false;
        }
      }
      checkSmartPipeTopicBodyEarlyErrors(t2) {
        if (this.match(19))
          throw this.raise(xn.PipelineBodyNoArrow, { at: this.state.startLoc });
        this.topicReferenceWasUsedInCurrentContext() || this.raise(xn.PipelineTopicUnused, { at: t2 });
      }
      withTopicBindingContext(t2) {
        const e2 = this.state.topicContext;
        this.state.topicContext = { maxNumOfResolvableTopics: 1, maxTopicIndex: null };
        try {
          return t2();
        } finally {
          this.state.topicContext = e2;
        }
      }
      withSmartMixTopicForbiddingContext(t2) {
        if (!this.hasPlugin(["pipelineOperator", { proposal: "smart" }]))
          return t2();
        {
          const e2 = this.state.topicContext;
          this.state.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null };
          try {
            return t2();
          } finally {
            this.state.topicContext = e2;
          }
        }
      }
      withSoloAwaitPermittingContext(t2) {
        const e2 = this.state.soloAwait;
        this.state.soloAwait = true;
        try {
          return t2();
        } finally {
          this.state.soloAwait = e2;
        }
      }
      allowInAnd(t2) {
        const e2 = this.prodParam.currentFlags();
        if (8 & ~e2) {
          this.prodParam.enter(8 | e2);
          try {
            return t2();
          } finally {
            this.prodParam.exit();
          }
        }
        return t2();
      }
      disallowInAnd(t2) {
        const e2 = this.prodParam.currentFlags();
        if (8 & e2) {
          this.prodParam.enter(-9 & e2);
          try {
            return t2();
          } finally {
            this.prodParam.exit();
          }
        }
        return t2();
      }
      registerTopicReference() {
        this.state.topicContext.maxTopicIndex = 0;
      }
      topicReferenceIsAllowedInCurrentContext() {
        return this.state.topicContext.maxNumOfResolvableTopics >= 1;
      }
      topicReferenceWasUsedInCurrentContext() {
        return null != this.state.topicContext.maxTopicIndex && this.state.topicContext.maxTopicIndex >= 0;
      }
      parseFSharpPipelineBody(t2) {
        const e2 = this.state.startLoc;
        this.state.potentialArrowAt = this.state.start;
        const r2 = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = true;
        const n2 = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), e2, t2);
        return this.state.inFSharpPipelineDirectBody = r2, n2;
      }
      parseModuleExpression() {
        this.expectPlugin("moduleBlocks");
        const t2 = this.startNode();
        this.next(), this.match(5) || this.unexpected(null, 5);
        const e2 = this.startNodeAt(this.state.endLoc);
        this.next();
        const r2 = this.initializeScopes(true);
        this.enterInitialScopes();
        try {
          t2.body = this.parseProgram(e2, 8, "module");
        } finally {
          r2();
        }
        return this.finishNode(t2, "ModuleExpression");
      }
      parsePropertyNamePrefixOperator(t2) {
      }
    }
    const vi = { kind: "loop" }, yi = { kind: "switch" }, bi = /[\uD800-\uDFFF]/u, wi = /in(?:stanceof)?/y;
    class StatementParser extends ExpressionParser {
      parseTopLevel(t2, e2) {
        return t2.program = this.parseProgram(e2), t2.comments = this.state.comments, this.options.tokens && (t2.tokens = function(t3, e3) {
          for (let r2 = 0; r2 < t3.length; r2++) {
            const n2 = t3[r2], { type: i2 } = n2;
            if ("number" == typeof i2) {
              if (138 === i2) {
                const { loc: e4, start: i3, value: o2, end: a2 } = n2, s2 = i3 + 1, l2 = createPositionWithColumnOffset(e4.start, 1);
                t3.splice(r2, 1, new Token({ type: getExportedToken(27), value: "#", start: i3, end: s2, startLoc: e4.start, endLoc: l2 }), new Token({ type: getExportedToken(132), value: o2, start: s2, end: a2, startLoc: l2, endLoc: e4.end })), r2++;
                continue;
              }
              if (tokenIsTemplate(i2)) {
                const { loc: o2, start: a2, value: s2, end: l2 } = n2, p2 = a2 + 1, c2 = createPositionWithColumnOffset(o2.start, 1);
                let d2, m2, u2, h2, g2;
                d2 = 96 === e3.charCodeAt(a2) ? new Token({ type: getExportedToken(22), value: "`", start: a2, end: p2, startLoc: o2.start, endLoc: c2 }) : new Token({ type: getExportedToken(8), value: "}", start: a2, end: p2, startLoc: o2.start, endLoc: c2 }), 24 === i2 ? (u2 = l2 - 1, h2 = createPositionWithColumnOffset(o2.end, -1), m2 = null === s2 ? null : s2.slice(1, -1), g2 = new Token({ type: getExportedToken(22), value: "`", start: u2, end: l2, startLoc: h2, endLoc: o2.end })) : (u2 = l2 - 2, h2 = createPositionWithColumnOffset(o2.end, -2), m2 = null === s2 ? null : s2.slice(1, -2), g2 = new Token({ type: getExportedToken(23), value: "${", start: u2, end: l2, startLoc: h2, endLoc: o2.end })), t3.splice(r2, 1, d2, new Token({ type: getExportedToken(20), value: m2, start: p2, end: u2, startLoc: c2, endLoc: h2 }), g2), r2 += 2;
                continue;
              }
              n2.type = getExportedToken(i2);
            }
          }
          return t3;
        }(this.tokens, this.input)), this.finishNode(t2, "File");
      }
      parseProgram(t2, e2 = 139, r2 = this.options.sourceType) {
        if (t2.sourceType = r2, t2.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(t2, true, true, e2), this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0)
          for (const [t3, e3] of Array.from(this.scope.undefinedExports))
            this.raise(xn.ModuleExportUndefined, { at: e3, localName: t3 });
        let n2;
        return n2 = 139 === e2 ? this.finishNode(t2, "Program") : this.finishNodeAt(t2, "Program", createPositionWithColumnOffset(this.state.startLoc, -1)), n2;
      }
      stmtToDirective(t2) {
        const e2 = t2;
        e2.type = "Directive", e2.value = e2.expression, delete e2.expression;
        const r2 = e2.value, n2 = r2.value, i2 = this.input.slice(r2.start, r2.end), o2 = r2.value = i2.slice(1, -1);
        return this.addExtra(r2, "raw", i2), this.addExtra(r2, "rawValue", o2), this.addExtra(r2, "expressionValue", n2), r2.type = "DirectiveLiteral", e2;
      }
      parseInterpreterDirective() {
        if (!this.match(28))
          return null;
        const t2 = this.startNode();
        return t2.value = this.state.value, this.next(), this.finishNode(t2, "InterpreterDirective");
      }
      isLet() {
        return !!this.isContextual(100) && this.hasFollowingBindingAtom();
      }
      chStartsBindingIdentifier(t2, e2) {
        if (isIdentifierStart(t2)) {
          if (wi.lastIndex = e2, wi.test(this.input)) {
            const t3 = this.codePointAtPos(wi.lastIndex);
            if (!isIdentifierChar(t3) && 92 !== t3)
              return false;
          }
          return true;
        }
        return 92 === t2;
      }
      chStartsBindingPattern(t2) {
        return 91 === t2 || 123 === t2;
      }
      hasFollowingBindingAtom() {
        const t2 = this.nextTokenStart(), e2 = this.codePointAtPos(t2);
        return this.chStartsBindingPattern(e2) || this.chStartsBindingIdentifier(e2, t2);
      }
      hasInLineFollowingBindingIdentifier() {
        const t2 = this.nextTokenInLineStart(), e2 = this.codePointAtPos(t2);
        return this.chStartsBindingIdentifier(e2, t2);
      }
      startsUsingForOf() {
        const { type: t2, containsEsc: e2 } = this.lookahead();
        return !(102 === t2 && !e2) && (tokenIsIdentifier(t2) && !this.hasFollowingLineBreak() ? (this.expectPlugin("explicitResourceManagement"), true) : void 0);
      }
      startsAwaitUsing() {
        let t2 = this.nextTokenInLineStart();
        if (this.isUnparsedContextual(t2, "using")) {
          t2 = this.nextTokenInLineStartSince(t2 + 5);
          const e2 = this.codePointAtPos(t2);
          if (this.chStartsBindingIdentifier(e2, t2))
            return this.expectPlugin("explicitResourceManagement"), true;
        }
        return false;
      }
      parseModuleItem() {
        return this.parseStatementLike(15);
      }
      parseStatementListItem() {
        return this.parseStatementLike(6 | (!this.options.annexB || this.state.strict ? 0 : 8));
      }
      parseStatementOrSloppyAnnexBFunctionDeclaration(t2 = false) {
        let e2 = 0;
        return this.options.annexB && !this.state.strict && (e2 |= 4, t2 && (e2 |= 8)), this.parseStatementLike(e2);
      }
      parseStatement() {
        return this.parseStatementLike(0);
      }
      parseStatementLike(t2) {
        let e2 = null;
        return this.match(26) && (e2 = this.parseDecorators(true)), this.parseStatementContent(t2, e2);
      }
      parseStatementContent(t2, e2) {
        const r2 = this.state.type, n2 = this.startNode(), i2 = !!(2 & t2), o2 = !!(4 & t2), a2 = 1 & t2;
        switch (r2) {
          case 60:
            return this.parseBreakContinueStatement(n2, true);
          case 63:
            return this.parseBreakContinueStatement(n2, false);
          case 64:
            return this.parseDebuggerStatement(n2);
          case 90:
            return this.parseDoWhileStatement(n2);
          case 91:
            return this.parseForStatement(n2);
          case 68:
            if (46 === this.lookaheadCharCode())
              break;
            return o2 || this.raise(this.state.strict ? xn.StrictFunction : this.options.annexB ? xn.SloppyFunctionAnnexB : xn.SloppyFunction, { at: this.state.startLoc }), this.parseFunctionStatement(n2, false, !i2 && o2);
          case 80:
            return i2 || this.unexpected(), this.parseClass(this.maybeTakeDecorators(e2, n2), true);
          case 69:
            return this.parseIfStatement(n2);
          case 70:
            return this.parseReturnStatement(n2);
          case 71:
            return this.parseSwitchStatement(n2);
          case 72:
            return this.parseThrowStatement(n2);
          case 73:
            return this.parseTryStatement(n2);
          case 96:
            if (!this.state.containsEsc && this.startsAwaitUsing())
              return this.isAwaitAllowed() ? i2 || this.raise(xn.UnexpectedLexicalDeclaration, { at: n2 }) : this.raise(xn.AwaitUsingNotInAsyncContext, { at: n2 }), this.next(), this.parseVarStatement(n2, "await using");
            break;
          case 107:
            if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifier())
              break;
            return this.expectPlugin("explicitResourceManagement"), !this.scope.inModule && this.scope.inTopLevel ? this.raise(xn.UnexpectedUsingDeclaration, { at: this.state.startLoc }) : i2 || this.raise(xn.UnexpectedLexicalDeclaration, { at: this.state.startLoc }), this.parseVarStatement(n2, "using");
          case 100: {
            if (this.state.containsEsc)
              break;
            const t3 = this.nextTokenStart(), e3 = this.codePointAtPos(t3);
            if (91 !== e3) {
              if (!i2 && this.hasFollowingLineBreak())
                break;
              if (!this.chStartsBindingIdentifier(e3, t3) && 123 !== e3)
                break;
            }
          }
          case 75:
            i2 || this.raise(xn.UnexpectedLexicalDeclaration, { at: this.state.startLoc });
          case 74: {
            const t3 = this.state.value;
            return this.parseVarStatement(n2, t3);
          }
          case 92:
            return this.parseWhileStatement(n2);
          case 76:
            return this.parseWithStatement(n2);
          case 5:
            return this.parseBlock();
          case 13:
            return this.parseEmptyStatement(n2);
          case 83: {
            const t3 = this.lookaheadCharCode();
            if (40 === t3 || 46 === t3)
              break;
          }
          case 82: {
            let t3;
            return this.options.allowImportExportEverywhere || a2 || this.raise(xn.UnexpectedImportExport, { at: this.state.startLoc }), this.next(), 83 === r2 ? (t3 = this.parseImport(n2), "ImportDeclaration" !== t3.type || t3.importKind && "value" !== t3.importKind || (this.sawUnambiguousESM = true)) : (t3 = this.parseExport(n2, e2), ("ExportNamedDeclaration" !== t3.type || t3.exportKind && "value" !== t3.exportKind) && ("ExportAllDeclaration" !== t3.type || t3.exportKind && "value" !== t3.exportKind) && "ExportDefaultDeclaration" !== t3.type || (this.sawUnambiguousESM = true)), this.assertModuleNodeAllowed(t3), t3;
          }
          default:
            if (this.isAsyncFunction())
              return i2 || this.raise(xn.AsyncFunctionInSingleStatementContext, { at: this.state.startLoc }), this.next(), this.parseFunctionStatement(n2, true, !i2 && o2);
        }
        const s2 = this.state.value, l2 = this.parseExpression();
        return tokenIsIdentifier(r2) && "Identifier" === l2.type && this.eat(14) ? this.parseLabeledStatement(n2, s2, l2, t2) : this.parseExpressionStatement(n2, l2, e2);
      }
      assertModuleNodeAllowed(t2) {
        this.options.allowImportExportEverywhere || this.inModule || this.raise(xn.ImportOutsideModule, { at: t2 });
      }
      decoratorsEnabledBeforeExport() {
        return !!this.hasPlugin("decorators-legacy") || this.hasPlugin("decorators") && false !== this.getPluginOption("decorators", "decoratorsBeforeExport");
      }
      maybeTakeDecorators(t2, e2, r2) {
        return t2 && (e2.decorators && e2.decorators.length > 0 ? ("boolean" != typeof this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(xn.DecoratorsBeforeAfterExport, { at: e2.decorators[0] }), e2.decorators.unshift(...t2)) : e2.decorators = t2, this.resetStartLocationFromNode(e2, t2[0]), r2 && this.resetStartLocationFromNode(r2, e2)), e2;
      }
      canHaveLeadingDecorator() {
        return this.match(80);
      }
      parseDecorators(t2) {
        const e2 = [];
        do {
          e2.push(this.parseDecorator());
        } while (this.match(26));
        if (this.match(82))
          t2 || this.unexpected(), this.decoratorsEnabledBeforeExport() || this.raise(xn.DecoratorExportClass, { at: this.state.startLoc });
        else if (!this.canHaveLeadingDecorator())
          throw this.raise(xn.UnexpectedLeadingDecorator, { at: this.state.startLoc });
        return e2;
      }
      parseDecorator() {
        this.expectOnePlugin(["decorators", "decorators-legacy"]);
        const t2 = this.startNode();
        if (this.next(), this.hasPlugin("decorators")) {
          const e2 = this.state.startLoc;
          let r2;
          if (this.match(10)) {
            const e3 = this.state.startLoc;
            this.next(), r2 = this.parseExpression(), this.expect(11), r2 = this.wrapParenthesis(e3, r2);
            const n2 = this.state.startLoc;
            t2.expression = this.parseMaybeDecoratorArguments(r2), false === this.getPluginOption("decorators", "allowCallParenthesized") && t2.expression !== r2 && this.raise(xn.DecoratorArgumentsOutsideParentheses, { at: n2 });
          } else {
            for (r2 = this.parseIdentifier(false); this.eat(16); ) {
              const t3 = this.startNodeAt(e2);
              t3.object = r2, this.match(138) ? (this.classScope.usePrivateName(this.state.value, this.state.startLoc), t3.property = this.parsePrivateName()) : t3.property = this.parseIdentifier(true), t3.computed = false, r2 = this.finishNode(t3, "MemberExpression");
            }
            t2.expression = this.parseMaybeDecoratorArguments(r2);
          }
        } else
          t2.expression = this.parseExprSubscripts();
        return this.finishNode(t2, "Decorator");
      }
      parseMaybeDecoratorArguments(t2) {
        if (this.eat(10)) {
          const e2 = this.startNodeAtNode(t2);
          return e2.callee = t2, e2.arguments = this.parseCallExpressionArguments(11, false), this.toReferencedList(e2.arguments), this.finishNode(e2, "CallExpression");
        }
        return t2;
      }
      parseBreakContinueStatement(t2, e2) {
        return this.next(), this.isLineTerminator() ? t2.label = null : (t2.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(t2, e2), this.finishNode(t2, e2 ? "BreakStatement" : "ContinueStatement");
      }
      verifyBreakContinue(t2, e2) {
        let r2;
        for (r2 = 0; r2 < this.state.labels.length; ++r2) {
          const n2 = this.state.labels[r2];
          if (null == t2.label || n2.name === t2.label.name) {
            if (null != n2.kind && (e2 || "loop" === n2.kind))
              break;
            if (t2.label && e2)
              break;
          }
        }
        if (r2 === this.state.labels.length) {
          const r3 = e2 ? "BreakStatement" : "ContinueStatement";
          this.raise(xn.IllegalBreakContinue, { at: t2, type: r3 });
        }
      }
      parseDebuggerStatement(t2) {
        return this.next(), this.semicolon(), this.finishNode(t2, "DebuggerStatement");
      }
      parseHeaderExpression() {
        this.expect(10);
        const t2 = this.parseExpression();
        return this.expect(11), t2;
      }
      parseDoWhileStatement(t2) {
        return this.next(), this.state.labels.push(vi), t2.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.expect(92), t2.test = this.parseHeaderExpression(), this.eat(13), this.finishNode(t2, "DoWhileStatement");
      }
      parseForStatement(t2) {
        this.next(), this.state.labels.push(vi);
        let e2 = null;
        if (this.isAwaitAllowed() && this.eatContextual(96) && (e2 = this.state.lastTokStartLoc), this.scope.enter(0), this.expect(10), this.match(13))
          return null !== e2 && this.unexpected(e2), this.parseFor(t2, null);
        const r2 = this.isContextual(100);
        {
          const n3 = this.isContextual(96) && this.startsAwaitUsing(), i3 = n3 || this.isContextual(107) && this.startsUsingForOf(), o3 = r2 && this.hasFollowingBindingAtom() || i3;
          if (this.match(74) || this.match(75) || o3) {
            const r3 = this.startNode();
            let o4;
            n3 ? (o4 = "await using", this.isAwaitAllowed() || this.raise(xn.AwaitUsingNotInAsyncContext, { at: this.state.startLoc }), this.next()) : o4 = this.state.value, this.next(), this.parseVar(r3, true, o4);
            const a3 = this.finishNode(r3, "VariableDeclaration"), s2 = this.match(58);
            return s2 && i3 && this.raise(xn.ForInUsing, { at: a3 }), (s2 || this.isContextual(102)) && 1 === a3.declarations.length ? this.parseForIn(t2, a3, e2) : (null !== e2 && this.unexpected(e2), this.parseFor(t2, a3));
          }
        }
        const n2 = this.isContextual(95), i2 = new ExpressionErrors(), o2 = this.parseExpression(true, i2), a2 = this.isContextual(102);
        if (a2 && (r2 && this.raise(xn.ForOfLet, { at: o2 }), null === e2 && n2 && "Identifier" === o2.type && this.raise(xn.ForOfAsync, { at: o2 })), a2 || this.match(58)) {
          this.checkDestructuringPrivate(i2), this.toAssignable(o2, true);
          const r3 = a2 ? "ForOfStatement" : "ForInStatement";
          return this.checkLVal(o2, { in: { type: r3 } }), this.parseForIn(t2, o2, e2);
        }
        return this.checkExpressionErrors(i2, true), null !== e2 && this.unexpected(e2), this.parseFor(t2, o2);
      }
      parseFunctionStatement(t2, e2, r2) {
        return this.next(), this.parseFunction(t2, 1 | (r2 ? 2 : 0) | (e2 ? 8 : 0));
      }
      parseIfStatement(t2) {
        return this.next(), t2.test = this.parseHeaderExpression(), t2.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration(), t2.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null, this.finishNode(t2, "IfStatement");
      }
      parseReturnStatement(t2) {
        return this.prodParam.hasReturn || this.options.allowReturnOutsideFunction || this.raise(xn.IllegalReturn, { at: this.state.startLoc }), this.next(), this.isLineTerminator() ? t2.argument = null : (t2.argument = this.parseExpression(), this.semicolon()), this.finishNode(t2, "ReturnStatement");
      }
      parseSwitchStatement(t2) {
        this.next(), t2.discriminant = this.parseHeaderExpression();
        const e2 = t2.cases = [];
        let r2;
        this.expect(5), this.state.labels.push(yi), this.scope.enter(0);
        for (let t3; !this.match(8); )
          if (this.match(61) || this.match(65)) {
            const n2 = this.match(61);
            r2 && this.finishNode(r2, "SwitchCase"), e2.push(r2 = this.startNode()), r2.consequent = [], this.next(), n2 ? r2.test = this.parseExpression() : (t3 && this.raise(xn.MultipleDefaultsInSwitch, { at: this.state.lastTokStartLoc }), t3 = true, r2.test = null), this.expect(14);
          } else
            r2 ? r2.consequent.push(this.parseStatementListItem()) : this.unexpected();
        return this.scope.exit(), r2 && this.finishNode(r2, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(t2, "SwitchStatement");
      }
      parseThrowStatement(t2) {
        return this.next(), this.hasPrecedingLineBreak() && this.raise(xn.NewlineAfterThrow, { at: this.state.lastTokEndLoc }), t2.argument = this.parseExpression(), this.semicolon(), this.finishNode(t2, "ThrowStatement");
      }
      parseCatchClauseParam() {
        const t2 = this.parseBindingAtom();
        return this.scope.enter(this.options.annexB && "Identifier" === t2.type ? 8 : 0), this.checkLVal(t2, { in: { type: "CatchClause" }, binding: 9 }), t2;
      }
      parseTryStatement(t2) {
        if (this.next(), t2.block = this.parseBlock(), t2.handler = null, this.match(62)) {
          const e2 = this.startNode();
          this.next(), this.match(10) ? (this.expect(10), e2.param = this.parseCatchClauseParam(), this.expect(11)) : (e2.param = null, this.scope.enter(0)), e2.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false)), this.scope.exit(), t2.handler = this.finishNode(e2, "CatchClause");
        }
        return t2.finalizer = this.eat(67) ? this.parseBlock() : null, t2.handler || t2.finalizer || this.raise(xn.NoCatchOrFinally, { at: t2 }), this.finishNode(t2, "TryStatement");
      }
      parseVarStatement(t2, e2, r2 = false) {
        return this.next(), this.parseVar(t2, false, e2, r2), this.semicolon(), this.finishNode(t2, "VariableDeclaration");
      }
      parseWhileStatement(t2) {
        return this.next(), t2.test = this.parseHeaderExpression(), this.state.labels.push(vi), t2.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.finishNode(t2, "WhileStatement");
      }
      parseWithStatement(t2) {
        return this.state.strict && this.raise(xn.StrictWith, { at: this.state.startLoc }), this.next(), t2.object = this.parseHeaderExpression(), t2.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.finishNode(t2, "WithStatement");
      }
      parseEmptyStatement(t2) {
        return this.next(), this.finishNode(t2, "EmptyStatement");
      }
      parseLabeledStatement(t2, e2, r2, n2) {
        for (const t3 of this.state.labels)
          t3.name === e2 && this.raise(xn.LabelRedeclaration, { at: r2, labelName: e2 });
        const i2 = (o2 = this.state.type) >= 90 && o2 <= 92 ? "loop" : this.match(71) ? "switch" : null;
        var o2;
        for (let e3 = this.state.labels.length - 1; e3 >= 0; e3--) {
          const r3 = this.state.labels[e3];
          if (r3.statementStart !== t2.start)
            break;
          r3.statementStart = this.state.start, r3.kind = i2;
        }
        return this.state.labels.push({ name: e2, kind: i2, statementStart: this.state.start }), t2.body = 8 & n2 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(true) : this.parseStatement(), this.state.labels.pop(), t2.label = r2, this.finishNode(t2, "LabeledStatement");
      }
      parseExpressionStatement(t2, e2, r2) {
        return t2.expression = e2, this.semicolon(), this.finishNode(t2, "ExpressionStatement");
      }
      parseBlock(t2 = false, e2 = true, r2) {
        const n2 = this.startNode();
        return t2 && this.state.strictErrors.clear(), this.expect(5), e2 && this.scope.enter(0), this.parseBlockBody(n2, t2, false, 8, r2), e2 && this.scope.exit(), this.finishNode(n2, "BlockStatement");
      }
      isValidDirective(t2) {
        return "ExpressionStatement" === t2.type && "StringLiteral" === t2.expression.type && !t2.expression.extra.parenthesized;
      }
      parseBlockBody(t2, e2, r2, n2, i2) {
        const o2 = t2.body = [], a2 = t2.directives = [];
        this.parseBlockOrModuleBlockBody(o2, e2 ? a2 : void 0, r2, n2, i2);
      }
      parseBlockOrModuleBlockBody(t2, e2, r2, n2, i2) {
        const o2 = this.state.strict;
        let a2 = false, s2 = false;
        for (; !this.match(n2); ) {
          const n3 = r2 ? this.parseModuleItem() : this.parseStatementListItem();
          if (e2 && !s2) {
            if (this.isValidDirective(n3)) {
              const t3 = this.stmtToDirective(n3);
              e2.push(t3), a2 || "use strict" !== t3.value.value || (a2 = true, this.setStrict(true));
              continue;
            }
            s2 = true, this.state.strictErrors.clear();
          }
          t2.push(n3);
        }
        null == i2 || i2.call(this, a2), o2 || this.setStrict(false), this.next();
      }
      parseFor(t2, e2) {
        return t2.init = e2, this.semicolon(false), t2.test = this.match(13) ? null : this.parseExpression(), this.semicolon(false), t2.update = this.match(11) ? null : this.parseExpression(), this.expect(11), t2.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(t2, "ForStatement");
      }
      parseForIn(t2, e2, r2) {
        const n2 = this.match(58);
        return this.next(), n2 ? null !== r2 && this.unexpected(r2) : t2.await = null !== r2, "VariableDeclaration" !== e2.type || null == e2.declarations[0].init || n2 && this.options.annexB && !this.state.strict && "var" === e2.kind && "Identifier" === e2.declarations[0].id.type || this.raise(xn.ForInOfLoopInitializer, { at: e2, type: n2 ? "ForInStatement" : "ForOfStatement" }), "AssignmentPattern" === e2.type && this.raise(xn.InvalidLhs, { at: e2, ancestor: { type: "ForStatement" } }), t2.left = e2, t2.right = n2 ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(11), t2.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(t2, n2 ? "ForInStatement" : "ForOfStatement");
      }
      parseVar(t2, e2, r2, n2 = false) {
        const i2 = t2.declarations = [];
        for (t2.kind = r2; ; ) {
          const t3 = this.startNode();
          if (this.parseVarId(t3, r2), t3.init = this.eat(29) ? e2 ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : null, null !== t3.init || n2 || ("Identifier" === t3.id.type || e2 && (this.match(58) || this.isContextual(102)) ? "const" !== r2 || this.match(58) || this.isContextual(102) || this.raise(xn.DeclarationMissingInitializer, { at: this.state.lastTokEndLoc, kind: "const" }) : this.raise(xn.DeclarationMissingInitializer, { at: this.state.lastTokEndLoc, kind: "destructuring" })), i2.push(this.finishNode(t3, "VariableDeclarator")), !this.eat(12))
            break;
        }
        return t2;
      }
      parseVarId(t2, e2) {
        const r2 = this.parseBindingAtom();
        this.checkLVal(r2, { in: { type: "VariableDeclarator" }, binding: "var" === e2 ? 5 : 8201 }), t2.id = r2;
      }
      parseAsyncFunctionExpression(t2) {
        return this.parseFunction(t2, 8);
      }
      parseFunction(t2, e2 = 0) {
        const r2 = 2 & e2, n2 = !!(1 & e2), i2 = n2 && !(4 & e2), o2 = !!(8 & e2);
        this.initFunction(t2, o2), this.match(55) && (r2 && this.raise(xn.GeneratorInSingleStatementContext, { at: this.state.startLoc }), this.next(), t2.generator = true), n2 && (t2.id = this.parseFunctionId(i2));
        const a2 = this.state.maybeInArrowParameters;
        return this.state.maybeInArrowParameters = false, this.scope.enter(2), this.prodParam.enter(functionFlags(o2, t2.generator)), n2 || (t2.id = this.parseFunctionId()), this.parseFunctionParams(t2, false), this.withSmartMixTopicForbiddingContext(() => {
          this.parseFunctionBodyAndFinish(t2, n2 ? "FunctionDeclaration" : "FunctionExpression");
        }), this.prodParam.exit(), this.scope.exit(), n2 && !r2 && this.registerFunctionStatementId(t2), this.state.maybeInArrowParameters = a2, t2;
      }
      parseFunctionId(t2) {
        return t2 || tokenIsIdentifier(this.state.type) ? this.parseIdentifier() : null;
      }
      parseFunctionParams(t2, e2) {
        this.expect(10), this.expressionScope.enter(new ExpressionScope(3)), t2.params = this.parseBindingList(11, 41, 2 | (e2 ? 4 : 0)), this.expressionScope.exit();
      }
      registerFunctionStatementId(t2) {
        t2.id && this.scope.declareName(t2.id.name, !this.options.annexB || this.state.strict || t2.generator || t2.async ? this.scope.treatFunctionsAsVar ? 5 : 8201 : 17, t2.id.loc.start);
      }
      parseClass(t2, e2, r2) {
        this.next();
        const n2 = this.state.strict;
        return this.state.strict = true, this.parseClassId(t2, e2, r2), this.parseClassSuper(t2), t2.body = this.parseClassBody(!!t2.superClass, n2), this.finishNode(t2, e2 ? "ClassDeclaration" : "ClassExpression");
      }
      isClassProperty() {
        return this.match(29) || this.match(13) || this.match(8);
      }
      isClassMethod() {
        return this.match(10);
      }
      isNonstaticConstructor(t2) {
        return !(t2.computed || t2.static || "constructor" !== t2.key.name && "constructor" !== t2.key.value);
      }
      parseClassBody(t2, e2) {
        this.classScope.enter();
        const r2 = { hadConstructor: false, hadSuperClass: t2 };
        let n2 = [];
        const i2 = this.startNode();
        if (i2.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext(() => {
          for (; !this.match(8); ) {
            if (this.eat(13)) {
              if (n2.length > 0)
                throw this.raise(xn.DecoratorSemicolon, { at: this.state.lastTokEndLoc });
              continue;
            }
            if (this.match(26)) {
              n2.push(this.parseDecorator());
              continue;
            }
            const t3 = this.startNode();
            n2.length && (t3.decorators = n2, this.resetStartLocationFromNode(t3, n2[0]), n2 = []), this.parseClassMember(i2, t3, r2), "constructor" === t3.kind && t3.decorators && t3.decorators.length > 0 && this.raise(xn.DecoratorConstructor, { at: t3 });
          }
        }), this.state.strict = e2, this.next(), n2.length)
          throw this.raise(xn.TrailingDecorator, { at: this.state.startLoc });
        return this.classScope.exit(), this.finishNode(i2, "ClassBody");
      }
      parseClassMemberFromModifier(t2, e2) {
        const r2 = this.parseIdentifier(true);
        if (this.isClassMethod()) {
          const n2 = e2;
          return n2.kind = "method", n2.computed = false, n2.key = r2, n2.static = false, this.pushClassMethod(t2, n2, false, false, false, false), true;
        }
        if (this.isClassProperty()) {
          const n2 = e2;
          return n2.computed = false, n2.key = r2, n2.static = false, t2.body.push(this.parseClassProperty(n2)), true;
        }
        return this.resetPreviousNodeTrailingComments(r2), false;
      }
      parseClassMember(t2, e2, r2) {
        const n2 = this.isContextual(106);
        if (n2) {
          if (this.parseClassMemberFromModifier(t2, e2))
            return;
          if (this.eat(5))
            return void this.parseClassStaticBlock(t2, e2);
        }
        this.parseClassMemberWithIsStatic(t2, e2, r2, n2);
      }
      parseClassMemberWithIsStatic(t2, e2, r2, n2) {
        const i2 = e2, o2 = e2, a2 = e2, s2 = e2, l2 = e2, p2 = i2, c2 = i2;
        if (e2.static = n2, this.parsePropertyNamePrefixOperator(e2), this.eat(55)) {
          p2.kind = "method";
          const e3 = this.match(138);
          return this.parseClassElementName(p2), e3 ? void this.pushClassPrivateMethod(t2, o2, true, false) : (this.isNonstaticConstructor(i2) && this.raise(xn.ConstructorIsGenerator, { at: i2.key }), void this.pushClassMethod(t2, i2, true, false, false, false));
        }
        const d2 = tokenIsIdentifier(this.state.type) && !this.state.containsEsc, m2 = this.match(138), u2 = this.parseClassElementName(e2), h2 = this.state.startLoc;
        if (this.parsePostMemberNameModifiers(c2), this.isClassMethod()) {
          if (p2.kind = "method", m2)
            return void this.pushClassPrivateMethod(t2, o2, false, false);
          const n3 = this.isNonstaticConstructor(i2);
          let a3 = false;
          n3 && (i2.kind = "constructor", r2.hadConstructor && !this.hasPlugin("typescript") && this.raise(xn.DuplicateConstructor, { at: u2 }), n3 && this.hasPlugin("typescript") && e2.override && this.raise(xn.OverrideOnConstructor, { at: u2 }), r2.hadConstructor = true, a3 = r2.hadSuperClass), this.pushClassMethod(t2, i2, false, false, n3, a3);
        } else if (this.isClassProperty())
          m2 ? this.pushClassPrivateProperty(t2, s2) : this.pushClassProperty(t2, a2);
        else if (d2 && "async" === u2.name && !this.isLineTerminator()) {
          this.resetPreviousNodeTrailingComments(u2);
          const e3 = this.eat(55);
          c2.optional && this.unexpected(h2), p2.kind = "method";
          const r3 = this.match(138);
          this.parseClassElementName(p2), this.parsePostMemberNameModifiers(c2), r3 ? this.pushClassPrivateMethod(t2, o2, e3, true) : (this.isNonstaticConstructor(i2) && this.raise(xn.ConstructorIsAsync, { at: i2.key }), this.pushClassMethod(t2, i2, e3, true, false, false));
        } else if (!d2 || "get" !== u2.name && "set" !== u2.name || this.match(55) && this.isLineTerminator())
          if (d2 && "accessor" === u2.name && !this.isLineTerminator()) {
            this.expectPlugin("decoratorAutoAccessors"), this.resetPreviousNodeTrailingComments(u2);
            const e3 = this.match(138);
            this.parseClassElementName(a2), this.pushClassAccessorProperty(t2, l2, e3);
          } else
            this.isLineTerminator() ? m2 ? this.pushClassPrivateProperty(t2, s2) : this.pushClassProperty(t2, a2) : this.unexpected();
        else {
          this.resetPreviousNodeTrailingComments(u2), p2.kind = u2.name;
          const e3 = this.match(138);
          this.parseClassElementName(i2), e3 ? this.pushClassPrivateMethod(t2, o2, false, false) : (this.isNonstaticConstructor(i2) && this.raise(xn.ConstructorIsAccessor, { at: i2.key }), this.pushClassMethod(t2, i2, false, false, false, false)), this.checkGetterSetterParams(i2);
        }
      }
      parseClassElementName(t2) {
        const { type: e2, value: r2 } = this.state;
        if (132 !== e2 && 133 !== e2 || !t2.static || "prototype" !== r2 || this.raise(xn.StaticPrototype, { at: this.state.startLoc }), 138 === e2) {
          "constructor" === r2 && this.raise(xn.ConstructorClassPrivateField, { at: this.state.startLoc });
          const e3 = this.parsePrivateName();
          return t2.key = e3, e3;
        }
        return this.parsePropertyName(t2);
      }
      parseClassStaticBlock(t2, e2) {
        var r2;
        this.scope.enter(208);
        const n2 = this.state.labels;
        this.state.labels = [], this.prodParam.enter(0);
        const i2 = e2.body = [];
        this.parseBlockOrModuleBlockBody(i2, void 0, false, 8), this.prodParam.exit(), this.scope.exit(), this.state.labels = n2, t2.body.push(this.finishNode(e2, "StaticBlock")), null != (r2 = e2.decorators) && r2.length && this.raise(xn.DecoratorStaticBlock, { at: e2 });
      }
      pushClassProperty(t2, e2) {
        e2.computed || "constructor" !== e2.key.name && "constructor" !== e2.key.value || this.raise(xn.ConstructorClassField, { at: e2.key }), t2.body.push(this.parseClassProperty(e2));
      }
      pushClassPrivateProperty(t2, e2) {
        const r2 = this.parseClassPrivateProperty(e2);
        t2.body.push(r2), this.classScope.declarePrivateName(this.getPrivateNameSV(r2.key), 0, r2.key.loc.start);
      }
      pushClassAccessorProperty(t2, e2, r2) {
        if (!r2 && !e2.computed) {
          const t3 = e2.key;
          "constructor" !== t3.name && "constructor" !== t3.value || this.raise(xn.ConstructorClassField, { at: t3 });
        }
        const n2 = this.parseClassAccessorProperty(e2);
        t2.body.push(n2), r2 && this.classScope.declarePrivateName(this.getPrivateNameSV(n2.key), 0, n2.key.loc.start);
      }
      pushClassMethod(t2, e2, r2, n2, i2, o2) {
        t2.body.push(this.parseMethod(e2, r2, n2, i2, o2, "ClassMethod", true));
      }
      pushClassPrivateMethod(t2, e2, r2, n2) {
        const i2 = this.parseMethod(e2, r2, n2, false, false, "ClassPrivateMethod", true);
        t2.body.push(i2);
        const o2 = "get" === i2.kind ? i2.static ? 6 : 2 : "set" === i2.kind ? i2.static ? 5 : 1 : 0;
        this.declareClassPrivateMethodInScope(i2, o2);
      }
      declareClassPrivateMethodInScope(t2, e2) {
        this.classScope.declarePrivateName(this.getPrivateNameSV(t2.key), e2, t2.key.loc.start);
      }
      parsePostMemberNameModifiers(t2) {
      }
      parseClassPrivateProperty(t2) {
        return this.parseInitializer(t2), this.semicolon(), this.finishNode(t2, "ClassPrivateProperty");
      }
      parseClassProperty(t2) {
        return this.parseInitializer(t2), this.semicolon(), this.finishNode(t2, "ClassProperty");
      }
      parseClassAccessorProperty(t2) {
        return this.parseInitializer(t2), this.semicolon(), this.finishNode(t2, "ClassAccessorProperty");
      }
      parseInitializer(t2) {
        this.scope.enter(80), this.expressionScope.enter(newExpressionScope()), this.prodParam.enter(0), t2.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
      }
      parseClassId(t2, e2, r2, n2 = 8331) {
        if (tokenIsIdentifier(this.state.type))
          t2.id = this.parseIdentifier(), e2 && this.declareNameFromIdentifier(t2.id, n2);
        else {
          if (!r2 && e2)
            throw this.raise(xn.MissingClassName, { at: this.state.startLoc });
          t2.id = null;
        }
      }
      parseClassSuper(t2) {
        t2.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
      }
      parseExport(t2, e2) {
        const r2 = this.parseMaybeImportPhase(t2, true), n2 = this.maybeParseExportDefaultSpecifier(t2, r2), i2 = !n2 || this.eat(12), o2 = i2 && this.eatExportStar(t2), a2 = o2 && this.maybeParseExportNamespaceSpecifier(t2), s2 = i2 && (!a2 || this.eat(12)), l2 = n2 || o2;
        if (o2 && !a2) {
          if (n2 && this.unexpected(), e2)
            throw this.raise(xn.UnsupportedDecoratorExport, { at: t2 });
          return this.parseExportFrom(t2, true), this.finishNode(t2, "ExportAllDeclaration");
        }
        const p2 = this.maybeParseExportNamedSpecifiers(t2);
        let c2;
        if (n2 && i2 && !o2 && !p2 && this.unexpected(null, 5), a2 && s2 && this.unexpected(null, 98), l2 || p2) {
          if (c2 = false, e2)
            throw this.raise(xn.UnsupportedDecoratorExport, { at: t2 });
          this.parseExportFrom(t2, l2);
        } else
          c2 = this.maybeParseExportDeclaration(t2);
        if (l2 || p2 || c2) {
          var d2;
          const r3 = t2;
          if (this.checkExport(r3, true, false, !!r3.source), "ClassDeclaration" === (null == (d2 = r3.declaration) ? void 0 : d2.type))
            this.maybeTakeDecorators(e2, r3.declaration, r3);
          else if (e2)
            throw this.raise(xn.UnsupportedDecoratorExport, { at: t2 });
          return this.finishNode(r3, "ExportNamedDeclaration");
        }
        if (this.eat(65)) {
          const r3 = t2, n3 = this.parseExportDefaultExpression();
          if (r3.declaration = n3, "ClassDeclaration" === n3.type)
            this.maybeTakeDecorators(e2, n3, r3);
          else if (e2)
            throw this.raise(xn.UnsupportedDecoratorExport, { at: t2 });
          return this.checkExport(r3, true, true), this.finishNode(r3, "ExportDefaultDeclaration");
        }
        this.unexpected(null, 5);
      }
      eatExportStar(t2) {
        return this.eat(55);
      }
      maybeParseExportDefaultSpecifier(t2, e2) {
        if (e2 || this.isExportDefaultSpecifier()) {
          this.expectPlugin("exportDefaultFrom", null == e2 ? void 0 : e2.loc.start);
          const r2 = e2 || this.parseIdentifier(true), n2 = this.startNodeAtNode(r2);
          return n2.exported = r2, t2.specifiers = [this.finishNode(n2, "ExportDefaultSpecifier")], true;
        }
        return false;
      }
      maybeParseExportNamespaceSpecifier(t2) {
        if (this.isContextual(93)) {
          t2.specifiers || (t2.specifiers = []);
          const e2 = this.startNodeAt(this.state.lastTokStartLoc);
          return this.next(), e2.exported = this.parseModuleExportName(), t2.specifiers.push(this.finishNode(e2, "ExportNamespaceSpecifier")), true;
        }
        return false;
      }
      maybeParseExportNamedSpecifiers(t2) {
        if (this.match(5)) {
          t2.specifiers || (t2.specifiers = []);
          const e2 = "type" === t2.exportKind;
          return t2.specifiers.push(...this.parseExportSpecifiers(e2)), t2.source = null, t2.declaration = null, this.hasPlugin("importAssertions") && (t2.assertions = []), true;
        }
        return false;
      }
      maybeParseExportDeclaration(t2) {
        return !!this.shouldParseExportDeclaration() && (t2.specifiers = [], t2.source = null, this.hasPlugin("importAssertions") && (t2.assertions = []), t2.declaration = this.parseExportDeclaration(t2), true);
      }
      isAsyncFunction() {
        if (!this.isContextual(95))
          return false;
        const t2 = this.nextTokenInLineStart();
        return this.isUnparsedContextual(t2, "function");
      }
      parseExportDefaultExpression() {
        const t2 = this.startNode();
        if (this.match(68))
          return this.next(), this.parseFunction(t2, 5);
        if (this.isAsyncFunction())
          return this.next(), this.next(), this.parseFunction(t2, 13);
        if (this.match(80))
          return this.parseClass(t2, true, true);
        if (this.match(26))
          return this.hasPlugin("decorators") && true === this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(xn.DecoratorBeforeExport, { at: this.state.startLoc }), this.parseClass(this.maybeTakeDecorators(this.parseDecorators(false), this.startNode()), true, true);
        if (this.match(75) || this.match(74) || this.isLet())
          throw this.raise(xn.UnsupportedDefaultExport, { at: this.state.startLoc });
        const e2 = this.parseMaybeAssignAllowIn();
        return this.semicolon(), e2;
      }
      parseExportDeclaration(t2) {
        if (this.match(80)) {
          return this.parseClass(this.startNode(), true, false);
        }
        return this.parseStatementListItem();
      }
      isExportDefaultSpecifier() {
        const { type: t2 } = this.state;
        if (tokenIsIdentifier(t2)) {
          if (95 === t2 && !this.state.containsEsc || 100 === t2)
            return false;
          if ((130 === t2 || 129 === t2) && !this.state.containsEsc) {
            const { type: t3 } = this.lookahead();
            if (tokenIsIdentifier(t3) && 98 !== t3 || 5 === t3)
              return this.expectOnePlugin(["flow", "typescript"]), false;
          }
        } else if (!this.match(65))
          return false;
        const e2 = this.nextTokenStart(), r2 = this.isUnparsedContextual(e2, "from");
        if (44 === this.input.charCodeAt(e2) || tokenIsIdentifier(this.state.type) && r2)
          return true;
        if (this.match(65) && r2) {
          const t3 = this.input.charCodeAt(this.nextTokenStartSince(e2 + 4));
          return 34 === t3 || 39 === t3;
        }
        return false;
      }
      parseExportFrom(t2, e2) {
        this.eatContextual(98) ? (t2.source = this.parseImportSource(), this.checkExport(t2), this.maybeParseImportAttributes(t2), this.checkJSONModuleImport(t2)) : e2 && this.unexpected(), this.semicolon();
      }
      shouldParseExportDeclaration() {
        const { type: t2 } = this.state;
        return 26 === t2 && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators")) ? (true === this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(xn.DecoratorBeforeExport, { at: this.state.startLoc }), true) : 74 === t2 || 75 === t2 || 68 === t2 || 80 === t2 || this.isLet() || this.isAsyncFunction();
      }
      checkExport(t2, e2, r2, n2) {
        var i2;
        if (e2) {
          if (r2) {
            if (this.checkDuplicateExports(t2, "default"), this.hasPlugin("exportDefaultFrom")) {
              var o2;
              const e3 = t2.declaration;
              "Identifier" !== e3.type || "from" !== e3.name || e3.end - e3.start != 4 || null != (o2 = e3.extra) && o2.parenthesized || this.raise(xn.ExportDefaultFromAsIdentifier, { at: e3 });
            }
          } else if (null != (i2 = t2.specifiers) && i2.length)
            for (const e3 of t2.specifiers) {
              const { exported: t3 } = e3, r3 = "Identifier" === t3.type ? t3.name : t3.value;
              if (this.checkDuplicateExports(e3, r3), !n2 && e3.local) {
                const { local: t4 } = e3;
                "Identifier" !== t4.type ? this.raise(xn.ExportBindingIsString, { at: e3, localName: t4.value, exportName: r3 }) : (this.checkReservedWord(t4.name, t4.loc.start, true, false), this.scope.checkLocalExport(t4));
              }
            }
          else if (t2.declaration) {
            if ("FunctionDeclaration" === t2.declaration.type || "ClassDeclaration" === t2.declaration.type) {
              const e3 = t2.declaration.id;
              if (!e3)
                throw new Error("Assertion failure");
              this.checkDuplicateExports(t2, e3.name);
            } else if ("VariableDeclaration" === t2.declaration.type)
              for (const e3 of t2.declaration.declarations)
                this.checkDeclaration(e3.id);
          }
        }
      }
      checkDeclaration(t2) {
        if ("Identifier" === t2.type)
          this.checkDuplicateExports(t2, t2.name);
        else if ("ObjectPattern" === t2.type)
          for (const e2 of t2.properties)
            this.checkDeclaration(e2);
        else if ("ArrayPattern" === t2.type)
          for (const e2 of t2.elements)
            e2 && this.checkDeclaration(e2);
        else
          "ObjectProperty" === t2.type ? this.checkDeclaration(t2.value) : "RestElement" === t2.type ? this.checkDeclaration(t2.argument) : "AssignmentPattern" === t2.type && this.checkDeclaration(t2.left);
      }
      checkDuplicateExports(t2, e2) {
        this.exportedIdentifiers.has(e2) && ("default" === e2 ? this.raise(xn.DuplicateDefaultExport, { at: t2 }) : this.raise(xn.DuplicateExport, { at: t2, exportName: e2 })), this.exportedIdentifiers.add(e2);
      }
      parseExportSpecifiers(t2) {
        const e2 = [];
        let r2 = true;
        for (this.expect(5); !this.eat(8); ) {
          if (r2)
            r2 = false;
          else if (this.expect(12), this.eat(8))
            break;
          const n2 = this.isContextual(130), i2 = this.match(133), o2 = this.startNode();
          o2.local = this.parseModuleExportName(), e2.push(this.parseExportSpecifier(o2, i2, t2, n2));
        }
        return e2;
      }
      parseExportSpecifier(t2, e2, r2, n2) {
        return this.eatContextual(93) ? t2.exported = this.parseModuleExportName() : e2 ? t2.exported = cloneStringLiteral(t2.local) : t2.exported || (t2.exported = cloneIdentifier(t2.local)), this.finishNode(t2, "ExportSpecifier");
      }
      parseModuleExportName() {
        if (this.match(133)) {
          const t2 = this.parseStringLiteral(this.state.value), e2 = t2.value.match(bi);
          return e2 && this.raise(xn.ModuleExportNameHasLoneSurrogate, { at: t2, surrogateCharCode: e2[0].charCodeAt(0) }), t2;
        }
        return this.parseIdentifier(true);
      }
      isJSONModuleImport(t2) {
        return null != t2.assertions && t2.assertions.some(({ key: t3, value: e2 }) => "json" === e2.value && ("Identifier" === t3.type ? "type" === t3.name : "type" === t3.value));
      }
      checkImportReflection(t2) {
        const { specifiers: e2 } = t2, r2 = 1 === e2.length ? e2[0].type : null;
        if ("source" === t2.phase)
          "ImportDefaultSpecifier" !== r2 && this.raise(xn.SourcePhaseImportRequiresDefault, { at: e2[0].loc.start });
        else if ("defer" === t2.phase)
          "ImportNamespaceSpecifier" !== r2 && this.raise(xn.DeferImportRequiresNamespace, { at: e2[0].loc.start });
        else if (t2.module) {
          var n2;
          "ImportDefaultSpecifier" !== r2 && this.raise(xn.ImportReflectionNotBinding, { at: e2[0].loc.start }), (null == (n2 = t2.assertions) ? void 0 : n2.length) > 0 && this.raise(xn.ImportReflectionHasAssertion, { at: t2.specifiers[0].loc.start });
        }
      }
      checkJSONModuleImport(t2) {
        if (this.isJSONModuleImport(t2) && "ExportAllDeclaration" !== t2.type) {
          const { specifiers: e2 } = t2;
          if (null != e2) {
            const t3 = e2.find((t4) => {
              let e3;
              if ("ExportSpecifier" === t4.type ? e3 = t4.local : "ImportSpecifier" === t4.type && (e3 = t4.imported), void 0 !== e3)
                return "Identifier" === e3.type ? "default" !== e3.name : "default" !== e3.value;
            });
            void 0 !== t3 && this.raise(xn.ImportJSONBindingNotDefault, { at: t3.loc.start });
          }
        }
      }
      isPotentialImportPhase(t2) {
        return !t2 && (this.isContextual(105) || this.isContextual(97) || this.isContextual(127));
      }
      applyImportPhase(t2, e2, r2, n2) {
        e2 || ("module" === r2 ? (this.expectPlugin("importReflection", n2), t2.module = true) : this.hasPlugin("importReflection") && (t2.module = false), "source" === r2 ? (this.expectPlugin("sourcePhaseImports", n2), t2.phase = "source") : "defer" === r2 ? (this.expectPlugin("deferredImportEvaluation", n2), t2.phase = "defer") : this.hasPlugin("sourcePhaseImports") && (t2.phase = null));
      }
      parseMaybeImportPhase(t2, e2) {
        if (!this.isPotentialImportPhase(e2))
          return this.applyImportPhase(t2, e2, null), null;
        const r2 = this.parseIdentifier(true), { type: n2 } = this.state;
        return (tokenIsKeywordOrIdentifier(n2) ? 98 !== n2 || 102 === this.lookaheadCharCode() : 12 !== n2) ? (this.resetPreviousIdentifierLeadingComments(r2), this.applyImportPhase(t2, e2, r2.name, r2.loc.start), null) : (this.applyImportPhase(t2, e2, null), r2);
      }
      isPrecedingIdImportPhase(t2) {
        const { type: e2 } = this.state;
        return tokenIsIdentifier(e2) ? 98 !== e2 || 102 === this.lookaheadCharCode() : 12 !== e2;
      }
      parseImport(t2) {
        return this.match(133) ? this.parseImportSourceAndAttributes(t2) : this.parseImportSpecifiersAndAfter(t2, this.parseMaybeImportPhase(t2, false));
      }
      parseImportSpecifiersAndAfter(t2, e2) {
        t2.specifiers = [];
        const r2 = !this.maybeParseDefaultImportSpecifier(t2, e2) || this.eat(12), n2 = r2 && this.maybeParseStarImportSpecifier(t2);
        return r2 && !n2 && this.parseNamedImportSpecifiers(t2), this.expectContextual(98), this.parseImportSourceAndAttributes(t2);
      }
      parseImportSourceAndAttributes(t2) {
        return null != t2.specifiers || (t2.specifiers = []), t2.source = this.parseImportSource(), this.maybeParseImportAttributes(t2), this.checkImportReflection(t2), this.checkJSONModuleImport(t2), this.semicolon(), this.finishNode(t2, "ImportDeclaration");
      }
      parseImportSource() {
        return this.match(133) || this.unexpected(), this.parseExprAtom();
      }
      parseImportSpecifierLocal(t2, e2, r2) {
        e2.local = this.parseIdentifier(), t2.specifiers.push(this.finishImportSpecifier(e2, r2));
      }
      finishImportSpecifier(t2, e2, r2 = 8201) {
        return this.checkLVal(t2.local, { in: { type: e2 }, binding: r2 }), this.finishNode(t2, e2);
      }
      parseImportAttributes() {
        this.expect(5);
        const t2 = [], e2 = /* @__PURE__ */ new Set();
        do {
          if (this.match(8))
            break;
          const r2 = this.startNode(), n2 = this.state.value;
          if (e2.has(n2) && this.raise(xn.ModuleAttributesWithDuplicateKeys, { at: this.state.startLoc, key: n2 }), e2.add(n2), this.match(133) ? r2.key = this.parseStringLiteral(n2) : r2.key = this.parseIdentifier(true), this.expect(14), !this.match(133))
            throw this.raise(xn.ModuleAttributeInvalidValue, { at: this.state.startLoc });
          r2.value = this.parseStringLiteral(this.state.value), t2.push(this.finishNode(r2, "ImportAttribute"));
        } while (this.eat(12));
        return this.expect(8), t2;
      }
      parseModuleAttributes() {
        const t2 = [], e2 = /* @__PURE__ */ new Set();
        do {
          const r2 = this.startNode();
          if (r2.key = this.parseIdentifier(true), "type" !== r2.key.name && this.raise(xn.ModuleAttributeDifferentFromType, { at: r2.key }), e2.has(r2.key.name) && this.raise(xn.ModuleAttributesWithDuplicateKeys, { at: r2.key, key: r2.key.name }), e2.add(r2.key.name), this.expect(14), !this.match(133))
            throw this.raise(xn.ModuleAttributeInvalidValue, { at: this.state.startLoc });
          r2.value = this.parseStringLiteral(this.state.value), t2.push(this.finishNode(r2, "ImportAttribute"));
        } while (this.eat(12));
        return t2;
      }
      maybeParseImportAttributes(t2) {
        let e2, r2 = false;
        if (this.match(76)) {
          if (this.hasPrecedingLineBreak() && 40 === this.lookaheadCharCode())
            return;
          this.next(), this.hasPlugin("moduleAttributes") ? e2 = this.parseModuleAttributes() : (this.expectImportAttributesPlugin(), e2 = this.parseImportAttributes()), r2 = true;
        } else if (this.isContextual(94) && !this.hasPrecedingLineBreak())
          this.hasPlugin("importAttributes") ? (true !== this.getPluginOption("importAttributes", "deprecatedAssertSyntax") && this.raise(xn.ImportAttributesUseAssert, { at: this.state.startLoc }), this.addExtra(t2, "deprecatedAssertSyntax", true)) : this.expectOnePlugin(["importAttributes", "importAssertions"]), this.next(), e2 = this.parseImportAttributes();
        else if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions"))
          e2 = [];
        else {
          if (!this.hasPlugin("moduleAttributes"))
            return;
          e2 = [];
        }
        !r2 && this.hasPlugin("importAssertions") ? t2.assertions = e2 : t2.attributes = e2;
      }
      maybeParseDefaultImportSpecifier(t2, e2) {
        if (e2) {
          const r2 = this.startNodeAtNode(e2);
          return r2.local = e2, t2.specifiers.push(this.finishImportSpecifier(r2, "ImportDefaultSpecifier")), true;
        }
        return !!tokenIsKeywordOrIdentifier(this.state.type) && (this.parseImportSpecifierLocal(t2, this.startNode(), "ImportDefaultSpecifier"), true);
      }
      maybeParseStarImportSpecifier(t2) {
        if (this.match(55)) {
          const e2 = this.startNode();
          return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(t2, e2, "ImportNamespaceSpecifier"), true;
        }
        return false;
      }
      parseNamedImportSpecifiers(t2) {
        let e2 = true;
        for (this.expect(5); !this.eat(8); ) {
          if (e2)
            e2 = false;
          else {
            if (this.eat(14))
              throw this.raise(xn.DestructureNamedImport, { at: this.state.startLoc });
            if (this.expect(12), this.eat(8))
              break;
          }
          const r2 = this.startNode(), n2 = this.match(133), i2 = this.isContextual(130);
          r2.imported = this.parseModuleExportName();
          const o2 = this.parseImportSpecifier(r2, n2, "type" === t2.importKind || "typeof" === t2.importKind, i2, void 0);
          t2.specifiers.push(o2);
        }
      }
      parseImportSpecifier(t2, e2, r2, n2, i2) {
        if (this.eatContextual(93))
          t2.local = this.parseIdentifier();
        else {
          const { imported: r3 } = t2;
          if (e2)
            throw this.raise(xn.ImportBindingIsString, { at: t2, importName: r3.value });
          this.checkReservedWord(r3.name, t2.loc.start, true, true), t2.local || (t2.local = cloneIdentifier(r3));
        }
        return this.finishImportSpecifier(t2, "ImportSpecifier", i2);
      }
      isThisParam(t2) {
        return "Identifier" === t2.type && "this" === t2.name;
      }
    }
    class Parser extends StatementParser {
      constructor(t2, e2) {
        super(t2 = function(t3) {
          if (null == t3)
            return Object.assign({}, xi);
          if (null != t3.annexB && false !== t3.annexB)
            throw new Error("The `annexB` option can only be set to `false`.");
          const e3 = {};
          for (const n2 of Object.keys(xi)) {
            var r2;
            e3[n2] = null != (r2 = t3[n2]) ? r2 : xi[n2];
          }
          return e3;
        }(t2), e2), this.options = t2, this.initializeScopes(), this.plugins = function(t3) {
          const e3 = /* @__PURE__ */ new Map();
          for (const r2 of t3) {
            const [t4, n2] = Array.isArray(r2) ? r2 : [r2, {}];
            e3.has(t4) || e3.set(t4, n2 || {});
          }
          return e3;
        }(this.options.plugins), this.filename = t2.sourceFilename;
      }
      getScopeHandler() {
        return ScopeHandler;
      }
      parse() {
        this.enterInitialScopes();
        const t2 = this.startNode(), e2 = this.startNode();
        return this.nextToken(), t2.errors = null, this.parseTopLevel(t2, e2), t2.errors = this.state.errors, t2;
      }
    }
    const ki = function(t2) {
      const e2 = {};
      for (const r2 of Object.keys(t2))
        e2[r2] = getExportedToken(t2[r2]);
      return e2;
    }(On);
    function getParser(t2, e2) {
      let r2 = Parser;
      return null != t2 && t2.plugins && (!function(t3) {
        if (hasPlugin(t3, "decorators")) {
          if (hasPlugin(t3, "decorators-legacy"))
            throw new Error("Cannot use the decorators and decorators-legacy plugin together");
          const e3 = getPluginOption(t3, "decorators", "decoratorsBeforeExport");
          if (null != e3 && "boolean" != typeof e3)
            throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
          const r3 = getPluginOption(t3, "decorators", "allowCallParenthesized");
          if (null != r3 && "boolean" != typeof r3)
            throw new Error("'allowCallParenthesized' must be a boolean.");
        }
        if (hasPlugin(t3, "flow") && hasPlugin(t3, "typescript"))
          throw new Error("Cannot combine flow and typescript plugins.");
        if (hasPlugin(t3, "placeholders") && hasPlugin(t3, "v8intrinsic"))
          throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
        if (hasPlugin(t3, "pipelineOperator")) {
          const e3 = getPluginOption(t3, "pipelineOperator", "proposal");
          if (!mi.includes(e3)) {
            const t4 = mi.map((t5) => `"${t5}"`).join(", ");
            throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${t4}.`);
          }
          const r3 = hasPlugin(t3, ["recordAndTuple", { syntaxType: "hash" }]);
          if ("hack" === e3) {
            if (hasPlugin(t3, "placeholders"))
              throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
            if (hasPlugin(t3, "v8intrinsic"))
              throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
            const e4 = getPluginOption(t3, "pipelineOperator", "topicToken");
            if (!ui.includes(e4)) {
              const t4 = ui.map((t5) => `"${t5}"`).join(", ");
              throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${t4}.`);
            }
            if ("#" === e4 && r3)
              throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
          } else if ("smart" === e3 && r3)
            throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
        }
        if (hasPlugin(t3, "moduleAttributes")) {
          if (hasPlugin(t3, "importAssertions") || hasPlugin(t3, "importAttributes"))
            throw new Error("Cannot combine importAssertions, importAttributes and moduleAttributes plugins.");
          if ("may-2020" !== getPluginOption(t3, "moduleAttributes", "version"))
            throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
        }
        if (hasPlugin(t3, "importAssertions") && hasPlugin(t3, "importAttributes"))
          throw new Error("Cannot combine importAssertions and importAttributes plugins.");
        if (hasPlugin(t3, "recordAndTuple") && null != getPluginOption(t3, "recordAndTuple", "syntaxType") && !hi.includes(getPluginOption(t3, "recordAndTuple", "syntaxType")))
          throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + hi.map((t4) => `'${t4}'`).join(", "));
        if (hasPlugin(t3, "asyncDoExpressions") && !hasPlugin(t3, "doExpressions")) {
          const t4 = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
          throw t4.missingPlugins = "doExpressions", t4;
        }
        if (hasPlugin(t3, "optionalChainingAssign") && "2023-07" !== getPluginOption(t3, "optionalChainingAssign", "version"))
          throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is '2023-07'.");
      }(t2.plugins), r2 = function(t3) {
        const e3 = gi.filter((e4) => hasPlugin(t3, e4)), r3 = e3.join("/");
        let n2 = Si[r3];
        if (!n2) {
          n2 = Parser;
          for (const t4 of e3)
            n2 = fi[t4](n2);
          Si[r3] = n2;
        }
        return n2;
      }(t2.plugins)), new r2(t2, e2);
    }
    const Si = {};
    sn.parse = function(t2, e2) {
      var r2;
      if ("unambiguous" !== (null == (r2 = e2) ? void 0 : r2.sourceType))
        return getParser(e2, t2).parse();
      e2 = Object.assign({}, e2);
      try {
        e2.sourceType = "module";
        const r3 = getParser(e2, t2), n2 = r3.parse();
        if (r3.sawUnambiguousESM)
          return n2;
        if (r3.ambiguousScriptDifferentAst)
          try {
            return e2.sourceType = "script", getParser(e2, t2).parse();
          } catch (t3) {
          }
        else
          n2.program.sourceType = "script";
        return n2;
      } catch (r3) {
        try {
          return e2.sourceType = "script", getParser(e2, t2).parse();
        } catch (t3) {
        }
        throw r3;
      }
    }, sn.parseExpression = function(t2, e2) {
      const r2 = getParser(e2, t2);
      return r2.options.strictMode && (r2.state.strict = true), r2.getExpression();
    }, sn.tokTypes = ki;
    var Ci = {}, Ei = {}, _i = {}, Pi = {}, Ti = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
    Pi.encode = function(t2) {
      if (0 <= t2 && t2 < Ti.length)
        return Ti[t2];
      throw new TypeError("Must be between 0 and 63: " + t2);
    }, Pi.decode = function(t2) {
      return 65 <= t2 && t2 <= 90 ? t2 - 65 : 97 <= t2 && t2 <= 122 ? t2 - 97 + 26 : 48 <= t2 && t2 <= 57 ? t2 - 48 + 52 : 43 == t2 ? 62 : 47 == t2 ? 63 : -1;
    };
    var Ai = Pi;
    _i.encode = function(t2) {
      var e2, r2 = "", n2 = function(t3) {
        return t3 < 0 ? 1 + (-t3 << 1) : 0 + (t3 << 1);
      }(t2);
      do {
        e2 = 31 & n2, (n2 >>>= 5) > 0 && (e2 |= 32), r2 += Ai.encode(e2);
      } while (n2 > 0);
      return r2;
    }, _i.decode = function(t2, e2, r2) {
      var n2, i2, o2, a2, s2 = t2.length, l2 = 0, p2 = 0;
      do {
        if (e2 >= s2)
          throw new Error("Expected more digits in base 64 VLQ value.");
        if (-1 === (i2 = Ai.decode(t2.charCodeAt(e2++))))
          throw new Error("Invalid base64 digit: " + t2.charAt(e2 - 1));
        n2 = !!(32 & i2), l2 += (i2 &= 31) << p2, p2 += 5;
      } while (n2);
      r2.value = (a2 = (o2 = l2) >> 1, 1 == (1 & o2) ? -a2 : a2), r2.rest = e2;
    };
    var Ii = {};
    !function(t2) {
      t2.getArg = function(t3, e3, r3) {
        if (e3 in t3)
          return t3[e3];
        if (3 === arguments.length)
          return r3;
        throw new Error('"' + e3 + '" is a required argument.');
      };
      var e2 = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/, r2 = /^data:.+\,.+$/;
      function urlParse(t3) {
        var r3 = t3.match(e2);
        return r3 ? { scheme: r3[1], auth: r3[2], host: r3[3], port: r3[4], path: r3[5] } : null;
      }
      function urlGenerate(t3) {
        var e3 = "";
        return t3.scheme && (e3 += t3.scheme + ":"), e3 += "//", t3.auth && (e3 += t3.auth + "@"), t3.host && (e3 += t3.host), t3.port && (e3 += ":" + t3.port), t3.path && (e3 += t3.path), e3;
      }
      t2.urlParse = urlParse, t2.urlGenerate = urlGenerate;
      var n2, i2, o2 = (n2 = function(e3) {
        var r3 = e3, n3 = urlParse(e3);
        if (n3) {
          if (!n3.path)
            return e3;
          r3 = n3.path;
        }
        for (var i3 = t2.isAbsolute(r3), o3 = [], a3 = 0, s2 = 0; ; ) {
          if (a3 = s2, -1 === (s2 = r3.indexOf("/", a3))) {
            o3.push(r3.slice(a3));
            break;
          }
          for (o3.push(r3.slice(a3, s2)); s2 < r3.length && "/" === r3[s2]; )
            s2++;
        }
        var l2, p2 = 0;
        for (s2 = o3.length - 1; s2 >= 0; s2--)
          "." === (l2 = o3[s2]) ? o3.splice(s2, 1) : ".." === l2 ? p2++ : p2 > 0 && ("" === l2 ? (o3.splice(s2 + 1, p2), p2 = 0) : (o3.splice(s2, 2), p2--));
        return "" === (r3 = o3.join("/")) && (r3 = i3 ? "/" : "."), n3 ? (n3.path = r3, urlGenerate(n3)) : r3;
      }, i2 = [], function(t3) {
        for (var e3 = 0; e3 < i2.length; e3++)
          if (i2[e3].input === t3) {
            var r3 = i2[0];
            return i2[0] = i2[e3], i2[e3] = r3, i2[0].result;
          }
        var o3 = n2(t3);
        return i2.unshift({ input: t3, result: o3 }), i2.length > 32 && i2.pop(), o3;
      });
      function join(t3, e3) {
        "" === t3 && (t3 = "."), "" === e3 && (e3 = ".");
        var n3 = urlParse(e3), i3 = urlParse(t3);
        if (i3 && (t3 = i3.path || "/"), n3 && !n3.scheme)
          return i3 && (n3.scheme = i3.scheme), urlGenerate(n3);
        if (n3 || e3.match(r2))
          return e3;
        if (i3 && !i3.host && !i3.path)
          return i3.host = e3, urlGenerate(i3);
        var a3 = "/" === e3.charAt(0) ? e3 : o2(t3.replace(/\/+$/, "") + "/" + e3);
        return i3 ? (i3.path = a3, urlGenerate(i3)) : a3;
      }
      t2.normalize = o2, t2.join = join, t2.isAbsolute = function(t3) {
        return "/" === t3.charAt(0) || e2.test(t3);
      }, t2.relative = function(t3, e3) {
        "" === t3 && (t3 = "."), t3 = t3.replace(/\/$/, "");
        for (var r3 = 0; 0 !== e3.indexOf(t3 + "/"); ) {
          var n3 = t3.lastIndexOf("/");
          if (n3 < 0)
            return e3;
          if ((t3 = t3.slice(0, n3)).match(/^([^\/]+:\/)?\/*$/))
            return e3;
          ++r3;
        }
        return Array(r3 + 1).join("../") + e3.substr(t3.length + 1);
      };
      var a2 = !("__proto__" in /* @__PURE__ */ Object.create(null));
      function identity(t3) {
        return t3;
      }
      function isProtoString(t3) {
        if (!t3)
          return false;
        var e3 = t3.length;
        if (e3 < 9)
          return false;
        if (95 !== t3.charCodeAt(e3 - 1) || 95 !== t3.charCodeAt(e3 - 2) || 111 !== t3.charCodeAt(e3 - 3) || 116 !== t3.charCodeAt(e3 - 4) || 111 !== t3.charCodeAt(e3 - 5) || 114 !== t3.charCodeAt(e3 - 6) || 112 !== t3.charCodeAt(e3 - 7) || 95 !== t3.charCodeAt(e3 - 8) || 95 !== t3.charCodeAt(e3 - 9))
          return false;
        for (var r3 = e3 - 10; r3 >= 0; r3--)
          if (36 !== t3.charCodeAt(r3))
            return false;
        return true;
      }
      function strcmp(t3, e3) {
        return t3 === e3 ? 0 : null === t3 ? 1 : null === e3 ? -1 : t3 > e3 ? 1 : -1;
      }
      t2.toSetString = a2 ? identity : function(t3) {
        return isProtoString(t3) ? "$" + t3 : t3;
      }, t2.fromSetString = a2 ? identity : function(t3) {
        return isProtoString(t3) ? t3.slice(1) : t3;
      }, t2.compareByOriginalPositions = function(t3, e3, r3) {
        var n3 = strcmp(t3.source, e3.source);
        return 0 !== n3 || 0 !== (n3 = t3.originalLine - e3.originalLine) || 0 !== (n3 = t3.originalColumn - e3.originalColumn) || r3 || 0 !== (n3 = t3.generatedColumn - e3.generatedColumn) || 0 !== (n3 = t3.generatedLine - e3.generatedLine) ? n3 : strcmp(t3.name, e3.name);
      }, t2.compareByOriginalPositionsNoSource = function(t3, e3, r3) {
        var n3;
        return 0 !== (n3 = t3.originalLine - e3.originalLine) || 0 !== (n3 = t3.originalColumn - e3.originalColumn) || r3 || 0 !== (n3 = t3.generatedColumn - e3.generatedColumn) || 0 !== (n3 = t3.generatedLine - e3.generatedLine) ? n3 : strcmp(t3.name, e3.name);
      }, t2.compareByGeneratedPositionsDeflated = function(t3, e3, r3) {
        var n3 = t3.generatedLine - e3.generatedLine;
        return 0 !== n3 || 0 !== (n3 = t3.generatedColumn - e3.generatedColumn) || r3 || 0 !== (n3 = strcmp(t3.source, e3.source)) || 0 !== (n3 = t3.originalLine - e3.originalLine) || 0 !== (n3 = t3.originalColumn - e3.originalColumn) ? n3 : strcmp(t3.name, e3.name);
      }, t2.compareByGeneratedPositionsDeflatedNoLine = function(t3, e3, r3) {
        var n3 = t3.generatedColumn - e3.generatedColumn;
        return 0 !== n3 || r3 || 0 !== (n3 = strcmp(t3.source, e3.source)) || 0 !== (n3 = t3.originalLine - e3.originalLine) || 0 !== (n3 = t3.originalColumn - e3.originalColumn) ? n3 : strcmp(t3.name, e3.name);
      }, t2.compareByGeneratedPositionsInflated = function(t3, e3) {
        var r3 = t3.generatedLine - e3.generatedLine;
        return 0 !== r3 || 0 !== (r3 = t3.generatedColumn - e3.generatedColumn) || 0 !== (r3 = strcmp(t3.source, e3.source)) || 0 !== (r3 = t3.originalLine - e3.originalLine) || 0 !== (r3 = t3.originalColumn - e3.originalColumn) ? r3 : strcmp(t3.name, e3.name);
      }, t2.parseSourceMapInput = function(t3) {
        return JSON.parse(t3.replace(/^\)]}'[^\n]*\n/, ""));
      }, t2.computeSourceURL = function(t3, e3, r3) {
        if (e3 = e3 || "", t3 && ("/" !== t3[t3.length - 1] && "/" !== e3[0] && (t3 += "/"), e3 = t3 + e3), r3) {
          var n3 = urlParse(r3);
          if (!n3)
            throw new Error("sourceMapURL could not be parsed");
          if (n3.path) {
            var i3 = n3.path.lastIndexOf("/");
            i3 >= 0 && (n3.path = n3.path.substring(0, i3 + 1));
          }
          e3 = join(urlGenerate(n3), e3);
        }
        return o2(e3);
      };
    }(Ii);
    var Ni = {}, Ri = Ii, Oi = Object.prototype.hasOwnProperty, Li = "undefined" != typeof Map;
    function ArraySet$2() {
      this._array = [], this._set = Li ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
    }
    ArraySet$2.fromArray = function(t2, e2) {
      for (var r2 = new ArraySet$2(), n2 = 0, i2 = t2.length; n2 < i2; n2++)
        r2.add(t2[n2], e2);
      return r2;
    }, ArraySet$2.prototype.size = function() {
      return Li ? this._set.size : Object.getOwnPropertyNames(this._set).length;
    }, ArraySet$2.prototype.add = function(t2, e2) {
      var r2 = Li ? t2 : Ri.toSetString(t2), n2 = Li ? this.has(t2) : Oi.call(this._set, r2), i2 = this._array.length;
      n2 && !e2 || this._array.push(t2), n2 || (Li ? this._set.set(t2, i2) : this._set[r2] = i2);
    }, ArraySet$2.prototype.has = function(t2) {
      if (Li)
        return this._set.has(t2);
      var e2 = Ri.toSetString(t2);
      return Oi.call(this._set, e2);
    }, ArraySet$2.prototype.indexOf = function(t2) {
      if (Li) {
        var e2 = this._set.get(t2);
        if (e2 >= 0)
          return e2;
      } else {
        var r2 = Ri.toSetString(t2);
        if (Oi.call(this._set, r2))
          return this._set[r2];
      }
      throw new Error('"' + t2 + '" is not in the set.');
    }, ArraySet$2.prototype.at = function(t2) {
      if (t2 >= 0 && t2 < this._array.length)
        return this._array[t2];
      throw new Error("No element indexed by " + t2);
    }, ArraySet$2.prototype.toArray = function() {
      return this._array.slice();
    }, Ni.ArraySet = ArraySet$2;
    var Mi = {}, Bi = Ii;
    function MappingList$1() {
      this._array = [], this._sorted = true, this._last = { generatedLine: -1, generatedColumn: 0 };
    }
    MappingList$1.prototype.unsortedForEach = function(t2, e2) {
      this._array.forEach(t2, e2);
    }, MappingList$1.prototype.add = function(t2) {
      var e2, r2, n2, i2, o2, a2;
      e2 = this._last, r2 = t2, n2 = e2.generatedLine, i2 = r2.generatedLine, o2 = e2.generatedColumn, a2 = r2.generatedColumn, i2 > n2 || i2 == n2 && a2 >= o2 || Bi.compareByGeneratedPositionsInflated(e2, r2) <= 0 ? (this._last = t2, this._array.push(t2)) : (this._sorted = false, this._array.push(t2));
    }, MappingList$1.prototype.toArray = function() {
      return this._sorted || (this._array.sort(Bi.compareByGeneratedPositionsInflated), this._sorted = true), this._array;
    }, Mi.MappingList = MappingList$1;
    var Di = _i, ji = Ii, Fi = Ni.ArraySet, $i = Mi.MappingList;
    function SourceMapGenerator$1(t2) {
      t2 || (t2 = {}), this._file = ji.getArg(t2, "file", null), this._sourceRoot = ji.getArg(t2, "sourceRoot", null), this._skipValidation = ji.getArg(t2, "skipValidation", false), this._sources = new Fi(), this._names = new Fi(), this._mappings = new $i(), this._sourcesContents = null;
    }
    SourceMapGenerator$1.prototype._version = 3, SourceMapGenerator$1.fromSourceMap = function(t2) {
      var e2 = t2.sourceRoot, r2 = new SourceMapGenerator$1({ file: t2.file, sourceRoot: e2 });
      return t2.eachMapping(function(t3) {
        var n2 = { generated: { line: t3.generatedLine, column: t3.generatedColumn } };
        null != t3.source && (n2.source = t3.source, null != e2 && (n2.source = ji.relative(e2, n2.source)), n2.original = { line: t3.originalLine, column: t3.originalColumn }, null != t3.name && (n2.name = t3.name)), r2.addMapping(n2);
      }), t2.sources.forEach(function(n2) {
        var i2 = n2;
        null !== e2 && (i2 = ji.relative(e2, n2)), r2._sources.has(i2) || r2._sources.add(i2);
        var o2 = t2.sourceContentFor(n2);
        null != o2 && r2.setSourceContent(n2, o2);
      }), r2;
    }, SourceMapGenerator$1.prototype.addMapping = function(t2) {
      var e2 = ji.getArg(t2, "generated"), r2 = ji.getArg(t2, "original", null), n2 = ji.getArg(t2, "source", null), i2 = ji.getArg(t2, "name", null);
      this._skipValidation || this._validateMapping(e2, r2, n2, i2), null != n2 && (n2 = String(n2), this._sources.has(n2) || this._sources.add(n2)), null != i2 && (i2 = String(i2), this._names.has(i2) || this._names.add(i2)), this._mappings.add({ generatedLine: e2.line, generatedColumn: e2.column, originalLine: null != r2 && r2.line, originalColumn: null != r2 && r2.column, source: n2, name: i2 });
    }, SourceMapGenerator$1.prototype.setSourceContent = function(t2, e2) {
      var r2 = t2;
      null != this._sourceRoot && (r2 = ji.relative(this._sourceRoot, r2)), null != e2 ? (this._sourcesContents || (this._sourcesContents = /* @__PURE__ */ Object.create(null)), this._sourcesContents[ji.toSetString(r2)] = e2) : this._sourcesContents && (delete this._sourcesContents[ji.toSetString(r2)], 0 === Object.keys(this._sourcesContents).length && (this._sourcesContents = null));
    }, SourceMapGenerator$1.prototype.applySourceMap = function(t2, e2, r2) {
      var n2 = e2;
      if (null == e2) {
        if (null == t2.file)
          throw new Error(`SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`);
        n2 = t2.file;
      }
      var i2 = this._sourceRoot;
      null != i2 && (n2 = ji.relative(i2, n2));
      var o2 = new Fi(), a2 = new Fi();
      this._mappings.unsortedForEach(function(e3) {
        if (e3.source === n2 && null != e3.originalLine) {
          var s2 = t2.originalPositionFor({ line: e3.originalLine, column: e3.originalColumn });
          null != s2.source && (e3.source = s2.source, null != r2 && (e3.source = ji.join(r2, e3.source)), null != i2 && (e3.source = ji.relative(i2, e3.source)), e3.originalLine = s2.line, e3.originalColumn = s2.column, null != s2.name && (e3.name = s2.name));
        }
        var l2 = e3.source;
        null == l2 || o2.has(l2) || o2.add(l2);
        var p2 = e3.name;
        null == p2 || a2.has(p2) || a2.add(p2);
      }, this), this._sources = o2, this._names = a2, t2.sources.forEach(function(e3) {
        var n3 = t2.sourceContentFor(e3);
        null != n3 && (null != r2 && (e3 = ji.join(r2, e3)), null != i2 && (e3 = ji.relative(i2, e3)), this.setSourceContent(e3, n3));
      }, this);
    }, SourceMapGenerator$1.prototype._validateMapping = function(t2, e2, r2, n2) {
      if (e2 && "number" != typeof e2.line && "number" != typeof e2.column)
        throw new Error("original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.");
      if ((!(t2 && "line" in t2 && "column" in t2 && t2.line > 0 && t2.column >= 0) || e2 || r2 || n2) && !(t2 && "line" in t2 && "column" in t2 && e2 && "line" in e2 && "column" in e2 && t2.line > 0 && t2.column >= 0 && e2.line > 0 && e2.column >= 0 && r2))
        throw new Error("Invalid mapping: " + JSON.stringify({ generated: t2, source: r2, original: e2, name: n2 }));
    }, SourceMapGenerator$1.prototype._serializeMappings = function() {
      for (var t2, e2, r2, n2, i2 = 0, o2 = 1, a2 = 0, s2 = 0, l2 = 0, p2 = 0, c2 = "", d2 = this._mappings.toArray(), m2 = 0, u2 = d2.length; m2 < u2; m2++) {
        if (t2 = "", (e2 = d2[m2]).generatedLine !== o2)
          for (i2 = 0; e2.generatedLine !== o2; )
            t2 += ";", o2++;
        else if (m2 > 0) {
          if (!ji.compareByGeneratedPositionsInflated(e2, d2[m2 - 1]))
            continue;
          t2 += ",";
        }
        t2 += Di.encode(e2.generatedColumn - i2), i2 = e2.generatedColumn, null != e2.source && (n2 = this._sources.indexOf(e2.source), t2 += Di.encode(n2 - p2), p2 = n2, t2 += Di.encode(e2.originalLine - 1 - s2), s2 = e2.originalLine - 1, t2 += Di.encode(e2.originalColumn - a2), a2 = e2.originalColumn, null != e2.name && (r2 = this._names.indexOf(e2.name), t2 += Di.encode(r2 - l2), l2 = r2)), c2 += t2;
      }
      return c2;
    }, SourceMapGenerator$1.prototype._generateSourcesContent = function(t2, e2) {
      return t2.map(function(t3) {
        if (!this._sourcesContents)
          return null;
        null != e2 && (t3 = ji.relative(e2, t3));
        var r2 = ji.toSetString(t3);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents, r2) ? this._sourcesContents[r2] : null;
      }, this);
    }, SourceMapGenerator$1.prototype.toJSON = function() {
      var t2 = { version: this._version, sources: this._sources.toArray(), names: this._names.toArray(), mappings: this._serializeMappings() };
      return null != this._file && (t2.file = this._file), null != this._sourceRoot && (t2.sourceRoot = this._sourceRoot), this._sourcesContents && (t2.sourcesContent = this._generateSourcesContent(t2.sources, t2.sourceRoot)), t2;
    }, SourceMapGenerator$1.prototype.toString = function() {
      return JSON.stringify(this.toJSON());
    }, Ei.SourceMapGenerator = SourceMapGenerator$1;
    var Vi = {}, zi = {};
    !function(t2) {
      function recursiveSearch(e2, r2, n2, i2, o2, a2) {
        var s2 = Math.floor((r2 - e2) / 2) + e2, l2 = o2(n2, i2[s2], true);
        return 0 === l2 ? s2 : l2 > 0 ? r2 - s2 > 1 ? recursiveSearch(s2, r2, n2, i2, o2, a2) : a2 == t2.LEAST_UPPER_BOUND ? r2 < i2.length ? r2 : -1 : s2 : s2 - e2 > 1 ? recursiveSearch(e2, s2, n2, i2, o2, a2) : a2 == t2.LEAST_UPPER_BOUND ? s2 : e2 < 0 ? -1 : e2;
      }
      t2.GREATEST_LOWER_BOUND = 1, t2.LEAST_UPPER_BOUND = 2, t2.search = function(e2, r2, n2, i2) {
        if (0 === r2.length)
          return -1;
        var o2 = recursiveSearch(-1, r2.length, e2, r2, n2, i2 || t2.GREATEST_LOWER_BOUND);
        if (o2 < 0)
          return -1;
        for (; o2 - 1 >= 0 && 0 === n2(r2[o2], r2[o2 - 1], true); )
          --o2;
        return o2;
      };
    }(zi);
    var Ui = {};
    function SortTemplate(t2) {
      function swap2(t3, e2, r2) {
        var n2 = t3[e2];
        t3[e2] = t3[r2], t3[r2] = n2;
      }
      return function doQuickSort(t3, e2, r2, n2) {
        if (r2 < n2) {
          var i2 = r2 - 1;
          swap2(t3, (l2 = r2, p2 = n2, Math.round(l2 + Math.random() * (p2 - l2))), n2);
          for (var o2 = t3[n2], a2 = r2; a2 < n2; a2++)
            e2(t3[a2], o2, false) <= 0 && swap2(t3, i2 += 1, a2);
          swap2(t3, i2 + 1, a2);
          var s2 = i2 + 1;
          doQuickSort(t3, e2, r2, s2 - 1), doQuickSort(t3, e2, s2 + 1, n2);
        }
        var l2, p2;
      };
    }
    let Hi = /* @__PURE__ */ new WeakMap();
    Ui.quickSort = function(t2, e2, r2 = 0) {
      let n2 = Hi.get(e2);
      void 0 === n2 && (n2 = function(t3) {
        let e3 = SortTemplate.toString();
        return new Function(`return ${e3}`)()(t3);
      }(e2), Hi.set(e2, n2)), n2(t2, e2, r2, t2.length - 1);
    };
    var qi = Ii, Wi = zi, Ki = Ni.ArraySet, Gi = _i, Ji = Ui.quickSort;
    function SourceMapConsumer(t2, e2) {
      var r2 = t2;
      return "string" == typeof t2 && (r2 = qi.parseSourceMapInput(t2)), null != r2.sections ? new IndexedSourceMapConsumer(r2, e2) : new BasicSourceMapConsumer(r2, e2);
    }
    function BasicSourceMapConsumer(t2, e2) {
      var r2 = t2;
      "string" == typeof t2 && (r2 = qi.parseSourceMapInput(t2));
      var n2 = qi.getArg(r2, "version"), i2 = qi.getArg(r2, "sources"), o2 = qi.getArg(r2, "names", []), a2 = qi.getArg(r2, "sourceRoot", null), s2 = qi.getArg(r2, "sourcesContent", null), l2 = qi.getArg(r2, "mappings"), p2 = qi.getArg(r2, "file", null);
      if (n2 != this._version)
        throw new Error("Unsupported version: " + n2);
      a2 && (a2 = qi.normalize(a2)), i2 = i2.map(String).map(qi.normalize).map(function(t3) {
        return a2 && qi.isAbsolute(a2) && qi.isAbsolute(t3) ? qi.relative(a2, t3) : t3;
      }), this._names = Ki.fromArray(o2.map(String), true), this._sources = Ki.fromArray(i2, true), this._absoluteSources = this._sources.toArray().map(function(t3) {
        return qi.computeSourceURL(a2, t3, e2);
      }), this.sourceRoot = a2, this.sourcesContent = s2, this._mappings = l2, this._sourceMapURL = e2, this.file = p2;
    }
    function Mapping() {
      this.generatedLine = 0, this.generatedColumn = 0, this.source = null, this.originalLine = null, this.originalColumn = null, this.name = null;
    }
    SourceMapConsumer.fromSourceMap = function(t2, e2) {
      return BasicSourceMapConsumer.fromSourceMap(t2, e2);
    }, SourceMapConsumer.prototype._version = 3, SourceMapConsumer.prototype.__generatedMappings = null, Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", { configurable: true, enumerable: true, get: function() {
      return this.__generatedMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__generatedMappings;
    } }), SourceMapConsumer.prototype.__originalMappings = null, Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", { configurable: true, enumerable: true, get: function() {
      return this.__originalMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__originalMappings;
    } }), SourceMapConsumer.prototype._charIsMappingSeparator = function(t2, e2) {
      var r2 = t2.charAt(e2);
      return ";" === r2 || "," === r2;
    }, SourceMapConsumer.prototype._parseMappings = function(t2, e2) {
      throw new Error("Subclasses must implement _parseMappings");
    }, SourceMapConsumer.GENERATED_ORDER = 1, SourceMapConsumer.ORIGINAL_ORDER = 2, SourceMapConsumer.GREATEST_LOWER_BOUND = 1, SourceMapConsumer.LEAST_UPPER_BOUND = 2, SourceMapConsumer.prototype.eachMapping = function(t2, e2, r2) {
      var n2, i2 = e2 || null;
      switch (r2 || SourceMapConsumer.GENERATED_ORDER) {
        case SourceMapConsumer.GENERATED_ORDER:
          n2 = this._generatedMappings;
          break;
        case SourceMapConsumer.ORIGINAL_ORDER:
          n2 = this._originalMappings;
          break;
        default:
          throw new Error("Unknown order of iteration.");
      }
      for (var o2 = this.sourceRoot, a2 = t2.bind(i2), s2 = this._names, l2 = this._sources, p2 = this._sourceMapURL, c2 = 0, d2 = n2.length; c2 < d2; c2++) {
        var m2 = n2[c2], u2 = null === m2.source ? null : l2.at(m2.source);
        a2({ source: u2 = qi.computeSourceURL(o2, u2, p2), generatedLine: m2.generatedLine, generatedColumn: m2.generatedColumn, originalLine: m2.originalLine, originalColumn: m2.originalColumn, name: null === m2.name ? null : s2.at(m2.name) });
      }
    }, SourceMapConsumer.prototype.allGeneratedPositionsFor = function(t2) {
      var e2 = qi.getArg(t2, "line"), r2 = { source: qi.getArg(t2, "source"), originalLine: e2, originalColumn: qi.getArg(t2, "column", 0) };
      if (r2.source = this._findSourceIndex(r2.source), r2.source < 0)
        return [];
      var n2 = [], i2 = this._findMapping(r2, this._originalMappings, "originalLine", "originalColumn", qi.compareByOriginalPositions, Wi.LEAST_UPPER_BOUND);
      if (i2 >= 0) {
        var o2 = this._originalMappings[i2];
        if (void 0 === t2.column)
          for (var a2 = o2.originalLine; o2 && o2.originalLine === a2; )
            n2.push({ line: qi.getArg(o2, "generatedLine", null), column: qi.getArg(o2, "generatedColumn", null), lastColumn: qi.getArg(o2, "lastGeneratedColumn", null) }), o2 = this._originalMappings[++i2];
        else
          for (var s2 = o2.originalColumn; o2 && o2.originalLine === e2 && o2.originalColumn == s2; )
            n2.push({ line: qi.getArg(o2, "generatedLine", null), column: qi.getArg(o2, "generatedColumn", null), lastColumn: qi.getArg(o2, "lastGeneratedColumn", null) }), o2 = this._originalMappings[++i2];
      }
      return n2;
    }, Vi.SourceMapConsumer = SourceMapConsumer, BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype), BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer, BasicSourceMapConsumer.prototype._findSourceIndex = function(t2) {
      var e2, r2 = t2;
      if (null != this.sourceRoot && (r2 = qi.relative(this.sourceRoot, r2)), this._sources.has(r2))
        return this._sources.indexOf(r2);
      for (e2 = 0; e2 < this._absoluteSources.length; ++e2)
        if (this._absoluteSources[e2] == t2)
          return e2;
      return -1;
    }, BasicSourceMapConsumer.fromSourceMap = function(t2, e2) {
      var r2 = Object.create(BasicSourceMapConsumer.prototype), n2 = r2._names = Ki.fromArray(t2._names.toArray(), true), i2 = r2._sources = Ki.fromArray(t2._sources.toArray(), true);
      r2.sourceRoot = t2._sourceRoot, r2.sourcesContent = t2._generateSourcesContent(r2._sources.toArray(), r2.sourceRoot), r2.file = t2._file, r2._sourceMapURL = e2, r2._absoluteSources = r2._sources.toArray().map(function(t3) {
        return qi.computeSourceURL(r2.sourceRoot, t3, e2);
      });
      for (var o2 = t2._mappings.toArray().slice(), a2 = r2.__generatedMappings = [], s2 = r2.__originalMappings = [], l2 = 0, p2 = o2.length; l2 < p2; l2++) {
        var c2 = o2[l2], d2 = new Mapping();
        d2.generatedLine = c2.generatedLine, d2.generatedColumn = c2.generatedColumn, c2.source && (d2.source = i2.indexOf(c2.source), d2.originalLine = c2.originalLine, d2.originalColumn = c2.originalColumn, c2.name && (d2.name = n2.indexOf(c2.name)), s2.push(d2)), a2.push(d2);
      }
      return Ji(r2.__originalMappings, qi.compareByOriginalPositions), r2;
    }, BasicSourceMapConsumer.prototype._version = 3, Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", { get: function() {
      return this._absoluteSources.slice();
    } });
    const Yi = qi.compareByGeneratedPositionsDeflatedNoLine;
    function sortGenerated(t2, e2) {
      let r2 = t2.length, n2 = t2.length - e2;
      if (!(n2 <= 1))
        if (2 == n2) {
          let r3 = t2[e2], n3 = t2[e2 + 1];
          Yi(r3, n3) > 0 && (t2[e2] = n3, t2[e2 + 1] = r3);
        } else if (n2 < 20)
          for (let n3 = e2; n3 < r2; n3++)
            for (let r3 = n3; r3 > e2; r3--) {
              let e3 = t2[r3 - 1], n4 = t2[r3];
              if (Yi(e3, n4) <= 0)
                break;
              t2[r3 - 1] = n4, t2[r3] = e3;
            }
        else
          Ji(t2, Yi, e2);
    }
    function IndexedSourceMapConsumer(t2, e2) {
      var r2 = t2;
      "string" == typeof t2 && (r2 = qi.parseSourceMapInput(t2));
      var n2 = qi.getArg(r2, "version"), i2 = qi.getArg(r2, "sections");
      if (n2 != this._version)
        throw new Error("Unsupported version: " + n2);
      this._sources = new Ki(), this._names = new Ki();
      var o2 = { line: -1, column: 0 };
      this._sections = i2.map(function(t3) {
        if (t3.url)
          throw new Error("Support for url field in sections not implemented.");
        var r3 = qi.getArg(t3, "offset"), n3 = qi.getArg(r3, "line"), i3 = qi.getArg(r3, "column");
        if (n3 < o2.line || n3 === o2.line && i3 < o2.column)
          throw new Error("Section offsets must be ordered and non-overlapping.");
        return o2 = r3, { generatedOffset: { generatedLine: n3 + 1, generatedColumn: i3 + 1 }, consumer: new SourceMapConsumer(qi.getArg(t3, "map"), e2) };
      });
    }
    BasicSourceMapConsumer.prototype._parseMappings = function(t2, e2) {
      var r2, n2, i2, o2, a2 = 1, s2 = 0, l2 = 0, p2 = 0, c2 = 0, d2 = 0, m2 = t2.length, u2 = 0, h2 = {}, g2 = [], x2 = [];
      let v2 = 0;
      for (; u2 < m2; )
        if (";" === t2.charAt(u2))
          a2++, u2++, s2 = 0, sortGenerated(x2, v2), v2 = x2.length;
        else if ("," === t2.charAt(u2))
          u2++;
        else {
          for ((r2 = new Mapping()).generatedLine = a2, i2 = u2; i2 < m2 && !this._charIsMappingSeparator(t2, i2); i2++)
            ;
          for (t2.slice(u2, i2), n2 = []; u2 < i2; )
            Gi.decode(t2, u2, h2), o2 = h2.value, u2 = h2.rest, n2.push(o2);
          if (2 === n2.length)
            throw new Error("Found a source, but no line and column");
          if (3 === n2.length)
            throw new Error("Found a source and line, but no column");
          if (r2.generatedColumn = s2 + n2[0], s2 = r2.generatedColumn, n2.length > 1 && (r2.source = c2 + n2[1], c2 += n2[1], r2.originalLine = l2 + n2[2], l2 = r2.originalLine, r2.originalLine += 1, r2.originalColumn = p2 + n2[3], p2 = r2.originalColumn, n2.length > 4 && (r2.name = d2 + n2[4], d2 += n2[4])), x2.push(r2), "number" == typeof r2.originalLine) {
            let t3 = r2.source;
            for (; g2.length <= t3; )
              g2.push(null);
            null === g2[t3] && (g2[t3] = []), g2[t3].push(r2);
          }
        }
      sortGenerated(x2, v2), this.__generatedMappings = x2;
      for (var y2 = 0; y2 < g2.length; y2++)
        null != g2[y2] && Ji(g2[y2], qi.compareByOriginalPositionsNoSource);
      this.__originalMappings = [].concat(...g2);
    }, BasicSourceMapConsumer.prototype._findMapping = function(t2, e2, r2, n2, i2, o2) {
      if (t2[r2] <= 0)
        throw new TypeError("Line must be greater than or equal to 1, got " + t2[r2]);
      if (t2[n2] < 0)
        throw new TypeError("Column must be greater than or equal to 0, got " + t2[n2]);
      return Wi.search(t2, e2, i2, o2);
    }, BasicSourceMapConsumer.prototype.computeColumnSpans = function() {
      for (var t2 = 0; t2 < this._generatedMappings.length; ++t2) {
        var e2 = this._generatedMappings[t2];
        if (t2 + 1 < this._generatedMappings.length) {
          var r2 = this._generatedMappings[t2 + 1];
          if (e2.generatedLine === r2.generatedLine) {
            e2.lastGeneratedColumn = r2.generatedColumn - 1;
            continue;
          }
        }
        e2.lastGeneratedColumn = 1 / 0;
      }
    }, BasicSourceMapConsumer.prototype.originalPositionFor = function(t2) {
      var e2 = { generatedLine: qi.getArg(t2, "line"), generatedColumn: qi.getArg(t2, "column") }, r2 = this._findMapping(e2, this._generatedMappings, "generatedLine", "generatedColumn", qi.compareByGeneratedPositionsDeflated, qi.getArg(t2, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND));
      if (r2 >= 0) {
        var n2 = this._generatedMappings[r2];
        if (n2.generatedLine === e2.generatedLine) {
          var i2 = qi.getArg(n2, "source", null);
          null !== i2 && (i2 = this._sources.at(i2), i2 = qi.computeSourceURL(this.sourceRoot, i2, this._sourceMapURL));
          var o2 = qi.getArg(n2, "name", null);
          return null !== o2 && (o2 = this._names.at(o2)), { source: i2, line: qi.getArg(n2, "originalLine", null), column: qi.getArg(n2, "originalColumn", null), name: o2 };
        }
      }
      return { source: null, line: null, column: null, name: null };
    }, BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function() {
      return !!this.sourcesContent && (this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(t2) {
        return null == t2;
      }));
    }, BasicSourceMapConsumer.prototype.sourceContentFor = function(t2, e2) {
      if (!this.sourcesContent)
        return null;
      var r2 = this._findSourceIndex(t2);
      if (r2 >= 0)
        return this.sourcesContent[r2];
      var n2, i2 = t2;
      if (null != this.sourceRoot && (i2 = qi.relative(this.sourceRoot, i2)), null != this.sourceRoot && (n2 = qi.urlParse(this.sourceRoot))) {
        var o2 = i2.replace(/^file:\/\//, "");
        if ("file" == n2.scheme && this._sources.has(o2))
          return this.sourcesContent[this._sources.indexOf(o2)];
        if ((!n2.path || "/" == n2.path) && this._sources.has("/" + i2))
          return this.sourcesContent[this._sources.indexOf("/" + i2)];
      }
      if (e2)
        return null;
      throw new Error('"' + i2 + '" is not in the SourceMap.');
    }, BasicSourceMapConsumer.prototype.generatedPositionFor = function(t2) {
      var e2 = qi.getArg(t2, "source");
      if ((e2 = this._findSourceIndex(e2)) < 0)
        return { line: null, column: null, lastColumn: null };
      var r2 = { source: e2, originalLine: qi.getArg(t2, "line"), originalColumn: qi.getArg(t2, "column") }, n2 = this._findMapping(r2, this._originalMappings, "originalLine", "originalColumn", qi.compareByOriginalPositions, qi.getArg(t2, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND));
      if (n2 >= 0) {
        var i2 = this._originalMappings[n2];
        if (i2.source === r2.source)
          return { line: qi.getArg(i2, "generatedLine", null), column: qi.getArg(i2, "generatedColumn", null), lastColumn: qi.getArg(i2, "lastGeneratedColumn", null) };
      }
      return { line: null, column: null, lastColumn: null };
    }, Vi.BasicSourceMapConsumer = BasicSourceMapConsumer, IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype), IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer, IndexedSourceMapConsumer.prototype._version = 3, Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", { get: function() {
      for (var t2 = [], e2 = 0; e2 < this._sections.length; e2++)
        for (var r2 = 0; r2 < this._sections[e2].consumer.sources.length; r2++)
          t2.push(this._sections[e2].consumer.sources[r2]);
      return t2;
    } }), IndexedSourceMapConsumer.prototype.originalPositionFor = function(t2) {
      var e2 = { generatedLine: qi.getArg(t2, "line"), generatedColumn: qi.getArg(t2, "column") }, r2 = Wi.search(e2, this._sections, function(t3, e3) {
        var r3 = t3.generatedLine - e3.generatedOffset.generatedLine;
        return r3 || t3.generatedColumn - e3.generatedOffset.generatedColumn;
      }), n2 = this._sections[r2];
      return n2 ? n2.consumer.originalPositionFor({ line: e2.generatedLine - (n2.generatedOffset.generatedLine - 1), column: e2.generatedColumn - (n2.generatedOffset.generatedLine === e2.generatedLine ? n2.generatedOffset.generatedColumn - 1 : 0), bias: t2.bias }) : { source: null, line: null, column: null, name: null };
    }, IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function() {
      return this._sections.every(function(t2) {
        return t2.consumer.hasContentsOfAllSources();
      });
    }, IndexedSourceMapConsumer.prototype.sourceContentFor = function(t2, e2) {
      for (var r2 = 0; r2 < this._sections.length; r2++) {
        var n2 = this._sections[r2].consumer.sourceContentFor(t2, true);
        if (n2)
          return n2;
      }
      if (e2)
        return null;
      throw new Error('"' + t2 + '" is not in the SourceMap.');
    }, IndexedSourceMapConsumer.prototype.generatedPositionFor = function(t2) {
      for (var e2 = 0; e2 < this._sections.length; e2++) {
        var r2 = this._sections[e2];
        if (-1 !== r2.consumer._findSourceIndex(qi.getArg(t2, "source"))) {
          var n2 = r2.consumer.generatedPositionFor(t2);
          if (n2)
            return { line: n2.line + (r2.generatedOffset.generatedLine - 1), column: n2.column + (r2.generatedOffset.generatedLine === n2.line ? r2.generatedOffset.generatedColumn - 1 : 0) };
        }
      }
      return { line: null, column: null };
    }, IndexedSourceMapConsumer.prototype._parseMappings = function(t2, e2) {
      this.__generatedMappings = [], this.__originalMappings = [];
      for (var r2 = 0; r2 < this._sections.length; r2++)
        for (var n2 = this._sections[r2], i2 = n2.consumer._generatedMappings, o2 = 0; o2 < i2.length; o2++) {
          var a2 = i2[o2], s2 = n2.consumer._sources.at(a2.source);
          s2 = qi.computeSourceURL(n2.consumer.sourceRoot, s2, this._sourceMapURL), this._sources.add(s2), s2 = this._sources.indexOf(s2);
          var l2 = null;
          a2.name && (l2 = n2.consumer._names.at(a2.name), this._names.add(l2), l2 = this._names.indexOf(l2));
          var p2 = { source: s2, generatedLine: a2.generatedLine + (n2.generatedOffset.generatedLine - 1), generatedColumn: a2.generatedColumn + (n2.generatedOffset.generatedLine === a2.generatedLine ? n2.generatedOffset.generatedColumn - 1 : 0), originalLine: a2.originalLine, originalColumn: a2.originalColumn, name: l2 };
          this.__generatedMappings.push(p2), "number" == typeof p2.originalLine && this.__originalMappings.push(p2);
        }
      Ji(this.__generatedMappings, qi.compareByGeneratedPositionsDeflated), Ji(this.__originalMappings, qi.compareByOriginalPositions);
    }, Vi.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
    var Xi = {}, Qi = Ei.SourceMapGenerator, Zi = Ii, to = /(\r?\n)/, eo = "$$$isSourceNode$$$";
    function SourceNode(t2, e2, r2, n2, i2) {
      this.children = [], this.sourceContents = {}, this.line = null == t2 ? null : t2, this.column = null == e2 ? null : e2, this.source = null == r2 ? null : r2, this.name = null == i2 ? null : i2, this[eo] = true, null != n2 && this.add(n2);
    }
    SourceNode.fromStringWithSourceMap = function(t2, e2, r2) {
      var n2 = new SourceNode(), i2 = t2.split(to), o2 = 0, shiftNextLine = function() {
        return getNextLine() + (getNextLine() || "");
        function getNextLine() {
          return o2 < i2.length ? i2[o2++] : void 0;
        }
      }, a2 = 1, s2 = 0, l2 = null;
      return e2.eachMapping(function(t3) {
        if (null !== l2) {
          if (!(a2 < t3.generatedLine)) {
            var e3 = (r3 = i2[o2] || "").substr(0, t3.generatedColumn - s2);
            return i2[o2] = r3.substr(t3.generatedColumn - s2), s2 = t3.generatedColumn, addMappingWithCode(l2, e3), void (l2 = t3);
          }
          addMappingWithCode(l2, shiftNextLine()), a2++, s2 = 0;
        }
        for (; a2 < t3.generatedLine; )
          n2.add(shiftNextLine()), a2++;
        if (s2 < t3.generatedColumn) {
          var r3 = i2[o2] || "";
          n2.add(r3.substr(0, t3.generatedColumn)), i2[o2] = r3.substr(t3.generatedColumn), s2 = t3.generatedColumn;
        }
        l2 = t3;
      }, this), o2 < i2.length && (l2 && addMappingWithCode(l2, shiftNextLine()), n2.add(i2.splice(o2).join(""))), e2.sources.forEach(function(t3) {
        var i3 = e2.sourceContentFor(t3);
        null != i3 && (null != r2 && (t3 = Zi.join(r2, t3)), n2.setSourceContent(t3, i3));
      }), n2;
      function addMappingWithCode(t3, e3) {
        if (null === t3 || void 0 === t3.source)
          n2.add(e3);
        else {
          var i3 = r2 ? Zi.join(r2, t3.source) : t3.source;
          n2.add(new SourceNode(t3.originalLine, t3.originalColumn, i3, e3, t3.name));
        }
      }
    }, SourceNode.prototype.add = function(t2) {
      if (Array.isArray(t2))
        t2.forEach(function(t3) {
          this.add(t3);
        }, this);
      else {
        if (!t2[eo] && "string" != typeof t2)
          throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + t2);
        t2 && this.children.push(t2);
      }
      return this;
    }, SourceNode.prototype.prepend = function(t2) {
      if (Array.isArray(t2))
        for (var e2 = t2.length - 1; e2 >= 0; e2--)
          this.prepend(t2[e2]);
      else {
        if (!t2[eo] && "string" != typeof t2)
          throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + t2);
        this.children.unshift(t2);
      }
      return this;
    }, SourceNode.prototype.walk = function(t2) {
      for (var e2, r2 = 0, n2 = this.children.length; r2 < n2; r2++)
        (e2 = this.children[r2])[eo] ? e2.walk(t2) : "" !== e2 && t2(e2, { source: this.source, line: this.line, column: this.column, name: this.name });
    }, SourceNode.prototype.join = function(t2) {
      var e2, r2, n2 = this.children.length;
      if (n2 > 0) {
        for (e2 = [], r2 = 0; r2 < n2 - 1; r2++)
          e2.push(this.children[r2]), e2.push(t2);
        e2.push(this.children[r2]), this.children = e2;
      }
      return this;
    }, SourceNode.prototype.replaceRight = function(t2, e2) {
      var r2 = this.children[this.children.length - 1];
      return r2[eo] ? r2.replaceRight(t2, e2) : "string" == typeof r2 ? this.children[this.children.length - 1] = r2.replace(t2, e2) : this.children.push("".replace(t2, e2)), this;
    }, SourceNode.prototype.setSourceContent = function(t2, e2) {
      this.sourceContents[Zi.toSetString(t2)] = e2;
    }, SourceNode.prototype.walkSourceContents = function(t2) {
      for (var e2 = 0, r2 = this.children.length; e2 < r2; e2++)
        this.children[e2][eo] && this.children[e2].walkSourceContents(t2);
      var n2 = Object.keys(this.sourceContents);
      for (e2 = 0, r2 = n2.length; e2 < r2; e2++)
        t2(Zi.fromSetString(n2[e2]), this.sourceContents[n2[e2]]);
    }, SourceNode.prototype.toString = function() {
      var t2 = "";
      return this.walk(function(e2) {
        t2 += e2;
      }), t2;
    }, SourceNode.prototype.toStringWithSourceMap = function(t2) {
      var e2 = { code: "", line: 1, column: 0 }, r2 = new Qi(t2), n2 = false, i2 = null, o2 = null, a2 = null, s2 = null;
      return this.walk(function(t3, l2) {
        e2.code += t3, null !== l2.source && null !== l2.line && null !== l2.column ? (i2 === l2.source && o2 === l2.line && a2 === l2.column && s2 === l2.name || r2.addMapping({ source: l2.source, original: { line: l2.line, column: l2.column }, generated: { line: e2.line, column: e2.column }, name: l2.name }), i2 = l2.source, o2 = l2.line, a2 = l2.column, s2 = l2.name, n2 = true) : n2 && (r2.addMapping({ generated: { line: e2.line, column: e2.column } }), i2 = null, n2 = false);
        for (var p2 = 0, c2 = t3.length; p2 < c2; p2++)
          10 === t3.charCodeAt(p2) ? (e2.line++, e2.column = 0, p2 + 1 === c2 ? (i2 = null, n2 = false) : n2 && r2.addMapping({ source: l2.source, original: { line: l2.line, column: l2.column }, generated: { line: e2.line, column: e2.column }, name: l2.name })) : e2.column++;
      }), this.walkSourceContents(function(t3, e3) {
        r2.setSourceContent(t3, e3);
      }), { code: e2.code, map: r2 };
    }, Xi.SourceNode = SourceNode, Ci.SourceMapGenerator = Ei.SourceMapGenerator, Ci.SourceMapConsumer = Vi.SourceMapConsumer, Ci.SourceNode = Xi.SourceNode;
    var ro = { exports: {} };
    (function(t2) {
      class WalkerBase {
        constructor() {
          this.should_skip = false, this.should_remove = false, this.replacement = null, this.context = { skip: () => this.should_skip = true, remove: () => this.should_remove = true, replace: (t3) => this.replacement = t3 };
        }
        replace(t3, e2, r2, n2) {
          t3 && (null !== r2 ? t3[e2][r2] = n2 : t3[e2] = n2);
        }
        remove(t3, e2, r2) {
          t3 && (null !== r2 ? t3[e2].splice(r2, 1) : delete t3[e2]);
        }
      }
      class SyncWalker extends WalkerBase {
        constructor(t3, e2) {
          super(), this.enter = t3, this.leave = e2;
        }
        visit(t3, e2, r2, n2) {
          if (t3) {
            if (this.enter) {
              const i2 = this.should_skip, o2 = this.should_remove, a2 = this.replacement;
              this.should_skip = false, this.should_remove = false, this.replacement = null, this.enter.call(this.context, t3, e2, r2, n2), this.replacement && (t3 = this.replacement, this.replace(e2, r2, n2, t3)), this.should_remove && this.remove(e2, r2, n2);
              const s2 = this.should_skip, l2 = this.should_remove;
              if (this.should_skip = i2, this.should_remove = o2, this.replacement = a2, s2)
                return t3;
              if (l2)
                return null;
            }
            for (const e3 in t3) {
              const r3 = t3[e3];
              if ("object" == typeof r3)
                if (Array.isArray(r3))
                  for (let n3 = 0; n3 < r3.length; n3 += 1)
                    null !== r3[n3] && "string" == typeof r3[n3].type && (this.visit(r3[n3], t3, e3, n3) || n3--);
                else
                  null !== r3 && "string" == typeof r3.type && this.visit(r3, t3, e3, null);
            }
            if (this.leave) {
              const i2 = this.replacement, o2 = this.should_remove;
              this.replacement = null, this.should_remove = false, this.leave.call(this.context, t3, e2, r2, n2), this.replacement && (t3 = this.replacement, this.replace(e2, r2, n2, t3)), this.should_remove && this.remove(e2, r2, n2);
              const a2 = this.should_remove;
              if (this.replacement = i2, this.should_remove = o2, a2)
                return null;
            }
          }
          return t3;
        }
      }
      class AsyncWalker extends WalkerBase {
        constructor(t3, e2) {
          super(), this.enter = t3, this.leave = e2;
        }
        async visit(t3, e2, r2, n2) {
          if (t3) {
            if (this.enter) {
              const i2 = this.should_skip, o2 = this.should_remove, a2 = this.replacement;
              this.should_skip = false, this.should_remove = false, this.replacement = null, await this.enter.call(this.context, t3, e2, r2, n2), this.replacement && (t3 = this.replacement, this.replace(e2, r2, n2, t3)), this.should_remove && this.remove(e2, r2, n2);
              const s2 = this.should_skip, l2 = this.should_remove;
              if (this.should_skip = i2, this.should_remove = o2, this.replacement = a2, s2)
                return t3;
              if (l2)
                return null;
            }
            for (const e3 in t3) {
              const r3 = t3[e3];
              if ("object" == typeof r3)
                if (Array.isArray(r3))
                  for (let n3 = 0; n3 < r3.length; n3 += 1)
                    null !== r3[n3] && "string" == typeof r3[n3].type && (await this.visit(r3[n3], t3, e3, n3) || n3--);
                else
                  null !== r3 && "string" == typeof r3.type && await this.visit(r3, t3, e3, null);
            }
            if (this.leave) {
              const i2 = this.replacement, o2 = this.should_remove;
              this.replacement = null, this.should_remove = false, await this.leave.call(this.context, t3, e2, r2, n2), this.replacement && (t3 = this.replacement, this.replace(e2, r2, n2, t3)), this.should_remove && this.remove(e2, r2, n2);
              const a2 = this.should_remove;
              if (this.replacement = i2, this.should_remove = o2, a2)
                return null;
            }
          }
          return t3;
        }
      }
      function walk2(t3, { enter: e2, leave: r2 }) {
        return new SyncWalker(e2, r2).visit(t3, null);
      }
      async function asyncWalk(t3, { enter: e2, leave: r2 }) {
        const n2 = new AsyncWalker(e2, r2);
        return await n2.visit(t3, null);
      }
      t2.asyncWalk = asyncWalk, t2.walk = walk2, Object.defineProperty(t2, "__esModule", { value: true });
    })(ro.exports);
    var no = ro.exports;
    Object.defineProperty(an, "__esModule", { value: true });
    var io = gr, oo = sn, ao = Ci, so = no;
    function defaultOnError(t2) {
      throw t2;
    }
    function defaultOnWarn(t2) {
    }
    function createCompilerError(t2, e2, r2, n2) {
      const i2 = (r2 || lo)[t2] + (n2 || ""), o2 = new SyntaxError(String(i2));
      return o2.code = t2, o2.loc = e2, o2;
    }
    const lo = { 0: "Illegal comment.", 1: "CDATA section is allowed only in XML context.", 2: "Duplicate attribute.", 3: "End tag cannot have attributes.", 4: "Illegal '/' in tags.", 5: "Unexpected EOF in tag.", 6: "Unexpected EOF in CDATA section.", 7: "Unexpected EOF in comment.", 8: "Unexpected EOF in script.", 9: "Unexpected EOF in tag.", 10: "Incorrectly closed comment.", 11: "Incorrectly opened comment.", 12: "Illegal tag name. Use '&lt;' to print '<'.", 13: "Attribute value was expected.", 14: "End tag name was expected.", 15: "Whitespace was expected.", 16: "Unexpected '<!--' in comment.", 17: `Attribute name cannot contain U+0022 ("), U+0027 ('), and U+003C (<).`, 18: "Unquoted attribute value cannot contain U+0022 (\"), U+0027 ('), U+003C (<), U+003D (=), and U+0060 (`).", 19: "Attribute name cannot start with '='.", 21: "'<?' is allowed only in XML context.", 20: "Unexpected null character.", 22: "Illegal '/' in tags.", 23: "Invalid end tag.", 24: "Element is missing end tag.", 25: "Interpolation end sign was not found.", 27: "End bracket for dynamic directive argument was not found. Note that dynamic directive argument cannot contain spaces.", 26: "Legal directive name was expected.", 28: "v-if/v-else-if is missing expression.", 29: "v-if/else branches must use unique keys.", 30: "v-else/v-else-if has no adjacent v-if or v-else-if.", 31: "v-for is missing expression.", 32: "v-for has invalid expression.", 33: "<template v-for> key should be placed on the <template> tag.", 34: "v-bind is missing expression.", 35: "v-on is missing expression.", 36: "Unexpected custom directive on <slot> outlet.", 37: "Mixed v-slot usage on both the component and nested <template>. When there are multiple named slots, all slots should use <template> syntax to avoid scope ambiguity.", 38: "Duplicate slot names found. ", 39: "Extraneous children found when component already has explicitly named default slot. These children will be ignored.", 40: "v-slot can only be used on components or <template> tags.", 41: "v-model is missing expression.", 42: "v-model value must be a valid JavaScript member expression.", 43: "v-model cannot be used on v-for or v-slot scope variables because they are not writable.", 44: "v-model cannot be used on a prop, because local prop bindings are not writable.\nUse a v-bind binding combined with a v-on listener that emits update:x event instead.", 45: "Error parsing JavaScript expression: ", 46: "<KeepAlive> expects exactly one child component.", 47: '"prefixIdentifiers" option is not supported in this build of compiler.', 48: "ES module mode is not supported in this build of compiler.", 49: '"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.', 50: '"scopeId" option is only supported in module mode.', 51: "@vnode-* hooks in templates are deprecated. Use the vue: prefix instead. For example, @vnode-mounted should be changed to @vue:mounted. @vnode-* hooks support will be removed in 3.4.", 52: 'v-is="component-name" has been deprecated. Use is="vue:component-name" instead. v-is support will be removed in 3.4.', 53: "" }, po = Symbol(""), co = Symbol(""), mo = Symbol(""), uo = Symbol(""), ho = Symbol(""), fo = Symbol(""), xo = Symbol(""), vo = Symbol(""), yo = Symbol(""), bo = Symbol(""), wo = Symbol(""), ko = Symbol(""), So = Symbol(""), Co = Symbol(""), Eo = Symbol(""), _o = Symbol(""), Po = Symbol(""), To = Symbol(""), Ao = Symbol(""), Io = Symbol(""), No = Symbol(""), Ro = Symbol(""), Oo = Symbol(""), Lo = Symbol(""), Mo = Symbol(""), Bo = Symbol(""), Do = Symbol(""), jo = Symbol(""), Fo = Symbol(""), $o = Symbol(""), Vo = Symbol(""), zo = Symbol(""), Uo = Symbol(""), Ho = Symbol(""), qo = Symbol(""), Wo = Symbol(""), Ko = Symbol(""), Go = Symbol(""), Jo = Symbol(""), Yo = { [po]: "Fragment", [co]: "Teleport", [mo]: "Suspense", [uo]: "KeepAlive", [ho]: "BaseTransition", [fo]: "openBlock", [xo]: "createBlock", [vo]: "createElementBlock", [yo]: "createVNode", [bo]: "createElementVNode", [wo]: "createCommentVNode", [ko]: "createTextVNode", [So]: "createStaticVNode", [Co]: "resolveComponent", [Eo]: "resolveDynamicComponent", [_o]: "resolveDirective", [Po]: "resolveFilter", [To]: "withDirectives", [Ao]: "renderList", [Io]: "renderSlot", [No]: "createSlots", [Ro]: "toDisplayString", [Oo]: "mergeProps", [Lo]: "normalizeClass", [Mo]: "normalizeStyle", [Bo]: "normalizeProps", [Do]: "guardReactiveProps", [jo]: "toHandlers", [Fo]: "camelize", [$o]: "capitalize", [Vo]: "toHandlerKey", [zo]: "setBlockTracking", [Uo]: "pushScopeId", [Ho]: "popScopeId", [qo]: "withCtx", [Wo]: "unref", [Ko]: "isRef", [Go]: "withMemo", [Jo]: "isMemoSame" };
    const Xo = { source: "", start: { line: 1, column: 1, offset: 0 }, end: { line: 1, column: 1, offset: 0 } };
    function createRoot(t2, e2 = Xo) {
      return { type: 0, children: t2, helpers: /* @__PURE__ */ new Set(), components: [], directives: [], hoists: [], imports: [], cached: 0, temps: 0, codegenNode: void 0, loc: e2 };
    }
    function createVNodeCall(t2, e2, r2, n2, i2, o2, a2, s2 = false, l2 = false, p2 = false, c2 = Xo) {
      return t2 && (s2 ? (t2.helper(fo), t2.helper(getVNodeBlockHelper(t2.inSSR, p2))) : t2.helper(getVNodeHelper(t2.inSSR, p2)), a2 && t2.helper(To)), { type: 13, tag: e2, props: r2, children: n2, patchFlag: i2, dynamicProps: o2, directives: a2, isBlock: s2, disableTracking: l2, isComponent: p2, loc: c2 };
    }
    function createArrayExpression(t2, e2 = Xo) {
      return { type: 17, loc: e2, elements: t2 };
    }
    function createObjectExpression(t2, e2 = Xo) {
      return { type: 15, loc: e2, properties: t2 };
    }
    function createObjectProperty(t2, e2) {
      return { type: 16, loc: Xo, key: io.isString(t2) ? createSimpleExpression(t2, true) : t2, value: e2 };
    }
    function createSimpleExpression(t2, e2 = false, r2 = Xo, n2 = 0) {
      return { type: 4, loc: r2, content: t2, isStatic: e2, constType: e2 ? 3 : n2 };
    }
    function createCompoundExpression(t2, e2 = Xo) {
      return { type: 8, loc: e2, children: t2 };
    }
    function createCallExpression(t2, e2 = [], r2 = Xo) {
      return { type: 14, loc: r2, callee: t2, arguments: e2 };
    }
    function createFunctionExpression(t2, e2 = void 0, r2 = false, n2 = false, i2 = Xo) {
      return { type: 18, params: t2, returns: e2, newline: r2, isSlot: n2, loc: i2 };
    }
    function createConditionalExpression(t2, e2, r2, n2 = true) {
      return { type: 19, test: t2, consequent: e2, alternate: r2, newline: n2, loc: Xo };
    }
    function createCacheExpression(t2, e2, r2 = false) {
      return { type: 20, index: t2, value: e2, isVNode: r2, loc: Xo };
    }
    function createBlockStatement(t2) {
      return { type: 21, body: t2, loc: Xo };
    }
    function getVNodeHelper(t2, e2) {
      return t2 || e2 ? yo : bo;
    }
    function getVNodeBlockHelper(t2, e2) {
      return t2 || e2 ? xo : vo;
    }
    function convertToBlock(t2, { helper: e2, removeHelper: r2, inSSR: n2 }) {
      t2.isBlock || (t2.isBlock = true, r2(getVNodeHelper(n2, t2.isComponent)), e2(fo), e2(getVNodeBlockHelper(n2, t2.isComponent)));
    }
    const isStaticExp = (t2) => 4 === t2.type && t2.isStatic, isBuiltInType = (t2, e2) => t2 === e2 || t2 === io.hyphenate(e2);
    function isCoreComponent(t2) {
      return isBuiltInType(t2, "Teleport") ? co : isBuiltInType(t2, "Suspense") ? mo : isBuiltInType(t2, "KeepAlive") ? uo : isBuiltInType(t2, "BaseTransition") ? ho : void 0;
    }
    const Qo = /^\d|[^\$\w]/, isSimpleIdentifier = (t2) => !Qo.test(t2), Zo = /[A-Za-z_$\xA0-\uFFFF]/, ta = /[\.\?\w$\xA0-\uFFFF]/, ea = /\s+[.[]\s*|\s*[.[]\s+/g, isMemberExpressionNode = (t2, e2) => {
      try {
        let r2 = oo.parseExpression(t2, { plugins: e2.expressionPlugins });
        return "TSAsExpression" !== r2.type && "TSTypeAssertion" !== r2.type || (r2 = r2.expression), "MemberExpression" === r2.type || "OptionalMemberExpression" === r2.type || "Identifier" === r2.type;
      } catch (t3) {
        return false;
      }
    }, ra = isMemberExpressionNode;
    function getInnerRange(t2, e2, r2) {
      const n2 = { source: t2.source.slice(e2, e2 + r2), start: advancePositionWithClone(t2.start, t2.source, e2), end: t2.end };
      return null != r2 && (n2.end = advancePositionWithClone(t2.start, t2.source, e2 + r2)), n2;
    }
    function advancePositionWithClone(t2, e2, r2 = e2.length) {
      return advancePositionWithMutation(io.extend({}, t2), e2, r2);
    }
    function advancePositionWithMutation(t2, e2, r2 = e2.length) {
      let n2 = 0, i2 = -1;
      for (let t3 = 0; t3 < r2; t3++)
        10 === e2.charCodeAt(t3) && (n2++, i2 = t3);
      return t2.offset += r2, t2.line += n2, t2.column = -1 === i2 ? t2.column + r2 : r2 - i2, t2;
    }
    function findDir(t2, e2, r2 = false) {
      for (let n2 = 0; n2 < t2.props.length; n2++) {
        const i2 = t2.props[n2];
        if (7 === i2.type && (r2 || i2.exp) && (io.isString(e2) ? i2.name === e2 : e2.test(i2.name)))
          return i2;
      }
    }
    function findProp(t2, e2, r2 = false, n2 = false) {
      for (let i2 = 0; i2 < t2.props.length; i2++) {
        const o2 = t2.props[i2];
        if (6 === o2.type) {
          if (r2)
            continue;
          if (o2.name === e2 && (o2.value || n2))
            return o2;
        } else if ("bind" === o2.name && (o2.exp || n2) && isStaticArgOf(o2.arg, e2))
          return o2;
      }
    }
    function isStaticArgOf(t2, e2) {
      return !(!t2 || !isStaticExp(t2) || t2.content !== e2);
    }
    function isText$1(t2) {
      return 5 === t2.type || 2 === t2.type;
    }
    function isVSlot(t2) {
      return 7 === t2.type && "slot" === t2.name;
    }
    function isTemplateNode(t2) {
      return 1 === t2.type && 3 === t2.tagType;
    }
    function isSlotOutlet(t2) {
      return 1 === t2.type && 2 === t2.tagType;
    }
    const na = /* @__PURE__ */ new Set([Bo, Do]);
    function getUnnormalizedProps(t2, e2 = []) {
      if (t2 && !io.isString(t2) && 14 === t2.type) {
        const r2 = t2.callee;
        if (!io.isString(r2) && na.has(r2))
          return getUnnormalizedProps(t2.arguments[0], e2.concat(t2));
      }
      return [t2, e2];
    }
    function injectProp(t2, e2, r2) {
      let n2, i2, o2 = 13 === t2.type ? t2.props : t2.arguments[2], a2 = [];
      if (o2 && !io.isString(o2) && 14 === o2.type) {
        const t3 = getUnnormalizedProps(o2);
        o2 = t3[0], a2 = t3[1], i2 = a2[a2.length - 1];
      }
      if (null == o2 || io.isString(o2))
        n2 = createObjectExpression([e2]);
      else if (14 === o2.type) {
        const t3 = o2.arguments[0];
        io.isString(t3) || 15 !== t3.type ? o2.callee === jo ? n2 = createCallExpression(r2.helper(Oo), [createObjectExpression([e2]), o2]) : o2.arguments.unshift(createObjectExpression([e2])) : hasProp(e2, t3) || t3.properties.unshift(e2), !n2 && (n2 = o2);
      } else
        15 === o2.type ? (hasProp(e2, o2) || o2.properties.unshift(e2), n2 = o2) : (n2 = createCallExpression(r2.helper(Oo), [createObjectExpression([e2]), o2]), i2 && i2.callee === Do && (i2 = a2[a2.length - 2]));
      13 === t2.type ? i2 ? i2.arguments[0] = n2 : t2.props = n2 : i2 ? i2.arguments[0] = n2 : t2.arguments[2] = n2;
    }
    function hasProp(t2, e2) {
      let r2 = false;
      if (4 === t2.key.type) {
        const n2 = t2.key.content;
        r2 = e2.properties.some((t3) => 4 === t3.key.type && t3.key.content === n2);
      }
      return r2;
    }
    function toValidAssetId(t2, e2) {
      return `_${e2}_${t2.replace(/[^\w]/g, (e3, r2) => "-" === e3 ? "_" : t2.charCodeAt(r2).toString())}`;
    }
    function hasScopeRef(t2, e2) {
      if (!t2 || 0 === Object.keys(e2).length)
        return false;
      switch (t2.type) {
        case 1:
          for (let r2 = 0; r2 < t2.props.length; r2++) {
            const n2 = t2.props[r2];
            if (7 === n2.type && (hasScopeRef(n2.arg, e2) || hasScopeRef(n2.exp, e2)))
              return true;
          }
          return t2.children.some((t3) => hasScopeRef(t3, e2));
        case 11:
          return !!hasScopeRef(t2.source, e2) || t2.children.some((t3) => hasScopeRef(t3, e2));
        case 9:
          return t2.branches.some((t3) => hasScopeRef(t3, e2));
        case 10:
          return !!hasScopeRef(t2.condition, e2) || t2.children.some((t3) => hasScopeRef(t3, e2));
        case 4:
          return !t2.isStatic && isSimpleIdentifier(t2.content) && !!e2[t2.content];
        case 8:
          return t2.children.some((t3) => io.isObject(t3) && hasScopeRef(t3, e2));
        case 5:
        case 12:
          return hasScopeRef(t2.content, e2);
        default:
          return false;
      }
    }
    function getMemoedVNodeCall(t2) {
      return 14 === t2.type && t2.callee === Go ? t2.arguments[1].returns : t2;
    }
    const ia = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/, oa = { COMPILER_IS_ON_ELEMENT: { message: 'Platform-native elements with "is" prop will no longer be treated as components in Vue 3 unless the "is" value is explicitly prefixed with "vue:".', link: "https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html" }, COMPILER_V_BIND_SYNC: { message: (t2) => `.sync modifier for v-bind has been removed. Use v-model with argument instead. \`v-bind:${t2}.sync\` should be changed to \`v-model:${t2}\`.`, link: "https://v3-migration.vuejs.org/breaking-changes/v-model.html" }, COMPILER_V_BIND_PROP: { message: ".prop modifier for v-bind has been removed and no longer necessary. Vue 3 will automatically set a binding as DOM property when appropriate." }, COMPILER_V_BIND_OBJECT_ORDER: { message: 'v-bind="obj" usage is now order sensitive and behaves like JavaScript object spread: it will now overwrite an existing non-mergeable attribute that appears before v-bind in the case of conflict. To retain 2.x behavior, move v-bind to make it the first attribute. You can also suppress this warning if the usage is intended.', link: "https://v3-migration.vuejs.org/breaking-changes/v-bind.html" }, COMPILER_V_ON_NATIVE: { message: ".native modifier for v-on has been removed as is no longer necessary.", link: "https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html" }, COMPILER_V_IF_V_FOR_PRECEDENCE: { message: "v-if / v-for precedence when used on the same element has changed in Vue 3: v-if now takes higher precedence and will no longer have access to v-for scope variables. It is best to avoid the ambiguity with <template> tags or use a computed property that filters v-for data source.", link: "https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html" }, COMPILER_NATIVE_TEMPLATE: { message: "<template> with no special directives will render as a native template element instead of its inner content in Vue 3." }, COMPILER_INLINE_TEMPLATE: { message: '"inline-template" has been removed in Vue 3.', link: "https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html" }, COMPILER_FILTER: { message: 'filters have been removed in Vue 3. The "|" symbol will be treated as native JavaScript bitwise OR operator. Use method calls or computed properties instead.', link: "https://v3-migration.vuejs.org/breaking-changes/filters.html" } };
    function getCompatValue(t2, e2) {
      const r2 = e2.options ? e2.options.compatConfig : e2.compatConfig, n2 = r2 && r2[t2];
      return "MODE" === t2 ? n2 || 3 : n2;
    }
    function isCompatEnabled(t2, e2) {
      const r2 = getCompatValue("MODE", e2), n2 = getCompatValue(t2, e2);
      return 3 === r2 ? true === n2 : false !== n2;
    }
    function checkCompatEnabled(t2, e2, r2, ...n2) {
      return isCompatEnabled(t2, e2);
    }
    const aa = /&(gt|lt|amp|apos|quot);/g, sa = { gt: ">", lt: "<", amp: "&", apos: "'", quot: '"' }, la = { delimiters: ["{{", "}}"], getNamespace: () => 0, getTextMode: () => 0, isVoidTag: io.NO, isPreTag: io.NO, isCustomElement: io.NO, decodeEntities: (t2) => t2.replace(aa, (t3, e2) => sa[e2]), onError: defaultOnError, onWarn: defaultOnWarn, comments: false };
    function baseParse(t2, e2 = {}) {
      const r2 = function(t3, e3) {
        const r3 = io.extend({}, la);
        let n3;
        for (n3 in e3)
          r3[n3] = void 0 === e3[n3] ? la[n3] : e3[n3];
        return { options: r3, column: 1, line: 1, offset: 0, originalSource: t3, source: t3, inPre: false, inVPre: false, onWarn: r3.onWarn };
      }(t2, e2), n2 = getCursor(r2);
      return createRoot(parseChildren(r2, 0, []), getSelection(r2, n2));
    }
    function parseChildren(t2, e2, r2) {
      const n2 = last(r2), i2 = n2 ? n2.ns : 0, o2 = [];
      for (; !isEnd(t2, e2, r2); ) {
        const a3 = t2.source;
        let s2;
        if (0 === e2 || 1 === e2) {
          if (!t2.inVPre && startsWith(a3, t2.options.delimiters[0]))
            s2 = parseInterpolation(t2, e2);
          else if (0 === e2 && "<" === a3[0])
            if (1 === a3.length)
              emitError(t2, 5, 1);
            else if ("!" === a3[1])
              startsWith(a3, "<!--") ? s2 = parseComment(t2) : startsWith(a3, "<!DOCTYPE") ? s2 = parseBogusComment(t2) : startsWith(a3, "<![CDATA[") ? 0 !== i2 ? s2 = parseCDATA(t2, r2) : (emitError(t2, 1), s2 = parseBogusComment(t2)) : (emitError(t2, 11), s2 = parseBogusComment(t2));
            else if ("/" === a3[1])
              if (2 === a3.length)
                emitError(t2, 5, 2);
              else {
                if (">" === a3[2]) {
                  emitError(t2, 14, 2), advanceBy(t2, 3);
                  continue;
                }
                if (/[a-z]/i.test(a3[2])) {
                  emitError(t2, 23), parseTag(t2, 1, n2);
                  continue;
                }
                emitError(t2, 12, 2), s2 = parseBogusComment(t2);
              }
            else
              /[a-z]/i.test(a3[1]) ? (s2 = parseElement(t2, r2), isCompatEnabled("COMPILER_NATIVE_TEMPLATE", t2) && s2 && "template" === s2.tag && !s2.props.some((t3) => 7 === t3.type && pa(t3.name)) && (s2 = s2.children)) : "?" === a3[1] ? (emitError(t2, 21, 1), s2 = parseBogusComment(t2)) : emitError(t2, 12, 1);
        }
        if (s2 || (s2 = parseText(t2, e2)), io.isArray(s2))
          for (let t3 = 0; t3 < s2.length; t3++)
            pushNode(o2, s2[t3]);
        else
          pushNode(o2, s2);
      }
      let a2 = false;
      if (2 !== e2 && 1 !== e2) {
        const e3 = "preserve" !== t2.options.whitespace;
        for (let r3 = 0; r3 < o2.length; r3++) {
          const n3 = o2[r3];
          if (2 === n3.type)
            if (t2.inPre)
              n3.content = n3.content.replace(/\r\n/g, "\n");
            else if (/[^\t\r\n\f ]/.test(n3.content))
              e3 && (n3.content = n3.content.replace(/[\t\r\n\f ]+/g, " "));
            else {
              const t3 = o2[r3 - 1], i3 = o2[r3 + 1];
              !t3 || !i3 || e3 && (3 === t3.type && 3 === i3.type || 3 === t3.type && 1 === i3.type || 1 === t3.type && 3 === i3.type || 1 === t3.type && 1 === i3.type && /[\r\n]/.test(n3.content)) ? (a2 = true, o2[r3] = null) : n3.content = " ";
            }
          else
            3 !== n3.type || t2.options.comments || (a2 = true, o2[r3] = null);
        }
        if (t2.inPre && n2 && t2.options.isPreTag(n2.tag)) {
          const t3 = o2[0];
          t3 && 2 === t3.type && (t3.content = t3.content.replace(/^\r?\n/, ""));
        }
      }
      return a2 ? o2.filter(Boolean) : o2;
    }
    function pushNode(t2, e2) {
      if (2 === e2.type) {
        const r2 = last(t2);
        if (r2 && 2 === r2.type && r2.loc.end.offset === e2.loc.start.offset)
          return r2.content += e2.content, r2.loc.end = e2.loc.end, void (r2.loc.source += e2.loc.source);
      }
      t2.push(e2);
    }
    function parseCDATA(t2, e2) {
      advanceBy(t2, 9);
      const r2 = parseChildren(t2, 3, e2);
      return 0 === t2.source.length ? emitError(t2, 6) : advanceBy(t2, 3), r2;
    }
    function parseComment(t2) {
      const e2 = getCursor(t2);
      let r2;
      const n2 = /--(\!)?>/.exec(t2.source);
      if (n2) {
        n2.index <= 3 && emitError(t2, 0), n2[1] && emitError(t2, 10), r2 = t2.source.slice(4, n2.index);
        const e3 = t2.source.slice(0, n2.index);
        let i2 = 1, o2 = 0;
        for (; -1 !== (o2 = e3.indexOf("<!--", i2)); )
          advanceBy(t2, o2 - i2 + 1), o2 + 4 < e3.length && emitError(t2, 16), i2 = o2 + 1;
        advanceBy(t2, n2.index + n2[0].length - i2 + 1);
      } else
        r2 = t2.source.slice(4), advanceBy(t2, t2.source.length), emitError(t2, 7);
      return { type: 3, content: r2, loc: getSelection(t2, e2) };
    }
    function parseBogusComment(t2) {
      const e2 = getCursor(t2), r2 = "?" === t2.source[1] ? 1 : 2;
      let n2;
      const i2 = t2.source.indexOf(">");
      return -1 === i2 ? (n2 = t2.source.slice(r2), advanceBy(t2, t2.source.length)) : (n2 = t2.source.slice(r2, i2), advanceBy(t2, i2 + 1)), { type: 3, content: n2, loc: getSelection(t2, e2) };
    }
    function parseElement(t2, e2) {
      const r2 = t2.inPre, n2 = t2.inVPre, i2 = last(e2), o2 = parseTag(t2, 0, i2), a2 = t2.inPre && !r2, s2 = t2.inVPre && !n2;
      if (o2.isSelfClosing || t2.options.isVoidTag(o2.tag))
        return a2 && (t2.inPre = false), s2 && (t2.inVPre = false), o2;
      e2.push(o2);
      const l2 = t2.options.getTextMode(o2, i2), p2 = parseChildren(t2, l2, e2);
      e2.pop();
      {
        const e3 = o2.props.find((t3) => 6 === t3.type && "inline-template" === t3.name);
        if (e3 && checkCompatEnabled("COMPILER_INLINE_TEMPLATE", t2, e3.loc)) {
          const r3 = getSelection(t2, o2.loc.end);
          e3.value = { type: 2, content: r3.source, loc: r3 };
        }
      }
      if (o2.children = p2, startsWithEndTagOpen(t2.source, o2.tag))
        parseTag(t2, 1, i2);
      else if (emitError(t2, 24, 0, o2.loc.start), 0 === t2.source.length && "script" === o2.tag.toLowerCase()) {
        const e3 = p2[0];
        e3 && startsWith(e3.loc.source, "<!--") && emitError(t2, 8);
      }
      return o2.loc = getSelection(t2, o2.loc.start), a2 && (t2.inPre = false), s2 && (t2.inVPre = false), o2;
    }
    const pa = io.makeMap("if,else,else-if,for,slot");
    function parseTag(t2, e2, r2) {
      const n2 = getCursor(t2), i2 = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(t2.source), o2 = i2[1], a2 = t2.options.getNamespace(o2, r2);
      advanceBy(t2, i2[0].length), advanceSpaces(t2);
      const s2 = getCursor(t2), l2 = t2.source;
      t2.options.isPreTag(o2) && (t2.inPre = true);
      let p2 = parseAttributes(t2, e2);
      0 === e2 && !t2.inVPre && p2.some((t3) => 7 === t3.type && "pre" === t3.name) && (t2.inVPre = true, io.extend(t2, s2), t2.source = l2, p2 = parseAttributes(t2, e2).filter((t3) => "v-pre" !== t3.name));
      let c2 = false;
      if (0 === t2.source.length ? emitError(t2, 9) : (c2 = startsWith(t2.source, "/>"), 1 === e2 && c2 && emitError(t2, 4), advanceBy(t2, c2 ? 2 : 1)), 1 === e2)
        return;
      let d2 = 0;
      return t2.inVPre || ("slot" === o2 ? d2 = 2 : "template" === o2 ? p2.some((t3) => 7 === t3.type && pa(t3.name)) && (d2 = 3) : function(t3, e3, r3) {
        const n3 = r3.options;
        if (n3.isCustomElement(t3))
          return false;
        if ("component" === t3 || /^[A-Z]/.test(t3) || isCoreComponent(t3) || n3.isBuiltInComponent && n3.isBuiltInComponent(t3) || n3.isNativeTag && !n3.isNativeTag(t3))
          return true;
        for (let t4 = 0; t4 < e3.length; t4++) {
          const n4 = e3[t4];
          if (6 === n4.type) {
            if ("is" === n4.name && n4.value) {
              if (n4.value.content.startsWith("vue:"))
                return true;
              if (checkCompatEnabled("COMPILER_IS_ON_ELEMENT", r3, n4.loc))
                return true;
            }
          } else {
            if ("is" === n4.name)
              return true;
            if ("bind" === n4.name && isStaticArgOf(n4.arg, "is") && checkCompatEnabled("COMPILER_IS_ON_ELEMENT", r3, n4.loc))
              return true;
          }
        }
      }(o2, p2, t2) && (d2 = 1)), { type: 1, ns: a2, tag: o2, tagType: d2, props: p2, isSelfClosing: c2, children: [], loc: getSelection(t2, n2), codegenNode: void 0 };
    }
    function parseAttributes(t2, e2) {
      const r2 = [], n2 = /* @__PURE__ */ new Set();
      for (; t2.source.length > 0 && !startsWith(t2.source, ">") && !startsWith(t2.source, "/>"); ) {
        if (startsWith(t2.source, "/")) {
          emitError(t2, 22), advanceBy(t2, 1), advanceSpaces(t2);
          continue;
        }
        1 === e2 && emitError(t2, 3);
        const i2 = parseAttribute(t2, n2);
        6 === i2.type && i2.value && "class" === i2.name && (i2.value.content = i2.value.content.replace(/\s+/g, " ").trim()), 0 === e2 && r2.push(i2), /^[^\t\r\n\f />]/.test(t2.source) && emitError(t2, 15), advanceSpaces(t2);
      }
      return r2;
    }
    function parseAttribute(t2, e2) {
      var r2;
      const n2 = getCursor(t2), i2 = /^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(t2.source)[0];
      e2.has(i2) && emitError(t2, 2), e2.add(i2), "=" === i2[0] && emitError(t2, 19);
      {
        const e3 = /["'<]/g;
        let r3;
        for (; r3 = e3.exec(i2); )
          emitError(t2, 17, r3.index);
      }
      let o2;
      advanceBy(t2, i2.length), /^[\t\r\n\f ]*=/.test(t2.source) && (advanceSpaces(t2), advanceBy(t2, 1), advanceSpaces(t2), o2 = function(t3) {
        const e3 = getCursor(t3);
        let r3;
        const n3 = t3.source[0], i3 = '"' === n3 || "'" === n3;
        if (i3) {
          advanceBy(t3, 1);
          const e4 = t3.source.indexOf(n3);
          -1 === e4 ? r3 = parseTextData(t3, t3.source.length, 4) : (r3 = parseTextData(t3, e4, 4), advanceBy(t3, 1));
        } else {
          const e4 = /^[^\t\r\n\f >]+/.exec(t3.source);
          if (!e4)
            return;
          const n4 = /["'<=`]/g;
          let i4;
          for (; i4 = n4.exec(e4[0]); )
            emitError(t3, 18, i4.index);
          r3 = parseTextData(t3, e4[0].length, 4);
        }
        return { content: r3, isQuoted: i3, loc: getSelection(t3, e3) };
      }(t2), o2 || emitError(t2, 13));
      const a2 = getSelection(t2, n2);
      if (!t2.inVPre && /^(v-[A-Za-z0-9-]|:|\.|@|#)/.test(i2)) {
        const e3 = /(?:^v-([a-z0-9-]+))?(?:(?::|^\.|^@|^#)(\[[^\]]+\]|[^\.]+))?(.+)?$/i.exec(i2);
        let s2, l2 = startsWith(i2, "."), p2 = e3[1] || (l2 || startsWith(i2, ":") ? "bind" : startsWith(i2, "@") ? "on" : "slot");
        if (e3[2]) {
          const o3 = "slot" === p2, a3 = i2.lastIndexOf(e3[2], i2.length - ((null == (r2 = e3[3]) ? void 0 : r2.length) || 0)), l3 = getSelection(t2, getNewPosition(t2, n2, a3), getNewPosition(t2, n2, a3 + e3[2].length + (o3 && e3[3] || "").length));
          let c3 = e3[2], d2 = true;
          c3.startsWith("[") ? (d2 = false, c3.endsWith("]") ? c3 = c3.slice(1, c3.length - 1) : (emitError(t2, 27), c3 = c3.slice(1))) : o3 && (c3 += e3[3] || ""), s2 = { type: 4, content: c3, isStatic: d2, constType: d2 ? 3 : 0, loc: l3 };
        }
        if (o2 && o2.isQuoted) {
          const t3 = o2.loc;
          t3.start.offset++, t3.start.column++, t3.end = advancePositionWithClone(t3.start, o2.content), t3.source = t3.source.slice(1, -1);
        }
        const c2 = e3[3] ? e3[3].slice(1).split(".") : [];
        return l2 && c2.push("prop"), "bind" === p2 && s2 && c2.includes("sync") && checkCompatEnabled("COMPILER_V_BIND_SYNC", t2, 0, s2.loc.source) && (p2 = "model", c2.splice(c2.indexOf("sync"), 1)), { type: 7, name: p2, exp: o2 && { type: 4, content: o2.content, isStatic: false, constType: 0, loc: o2.loc }, arg: s2, modifiers: c2, loc: a2 };
      }
      return !t2.inVPre && startsWith(i2, "v-") && emitError(t2, 26), { type: 6, name: i2, value: o2 && { type: 2, content: o2.content, loc: o2.loc }, loc: a2 };
    }
    function parseInterpolation(t2, e2) {
      const [r2, n2] = t2.options.delimiters, i2 = t2.source.indexOf(n2, r2.length);
      if (-1 === i2)
        return void emitError(t2, 25);
      const o2 = getCursor(t2);
      advanceBy(t2, r2.length);
      const a2 = getCursor(t2), s2 = getCursor(t2), l2 = i2 - r2.length, p2 = t2.source.slice(0, l2), c2 = parseTextData(t2, l2, e2), d2 = c2.trim(), m2 = c2.indexOf(d2);
      m2 > 0 && advancePositionWithMutation(a2, p2, m2);
      return advancePositionWithMutation(s2, p2, l2 - (c2.length - d2.length - m2)), advanceBy(t2, n2.length), { type: 5, content: { type: 4, isStatic: false, constType: 0, content: d2, loc: getSelection(t2, a2, s2) }, loc: getSelection(t2, o2) };
    }
    function parseText(t2, e2) {
      const r2 = 3 === e2 ? ["]]>"] : ["<", t2.options.delimiters[0]];
      let n2 = t2.source.length;
      for (let e3 = 0; e3 < r2.length; e3++) {
        const i3 = t2.source.indexOf(r2[e3], 1);
        -1 !== i3 && n2 > i3 && (n2 = i3);
      }
      const i2 = getCursor(t2);
      return { type: 2, content: parseTextData(t2, n2, e2), loc: getSelection(t2, i2) };
    }
    function parseTextData(t2, e2, r2) {
      const n2 = t2.source.slice(0, e2);
      return advanceBy(t2, e2), 2 !== r2 && 3 !== r2 && n2.includes("&") ? t2.options.decodeEntities(n2, 4 === r2) : n2;
    }
    function getCursor(t2) {
      const { column: e2, line: r2, offset: n2 } = t2;
      return { column: e2, line: r2, offset: n2 };
    }
    function getSelection(t2, e2, r2) {
      return { start: e2, end: r2 = r2 || getCursor(t2), source: t2.originalSource.slice(e2.offset, r2.offset) };
    }
    function last(t2) {
      return t2[t2.length - 1];
    }
    function startsWith(t2, e2) {
      return t2.startsWith(e2);
    }
    function advanceBy(t2, e2) {
      const { source: r2 } = t2;
      advancePositionWithMutation(t2, r2, e2), t2.source = r2.slice(e2);
    }
    function advanceSpaces(t2) {
      const e2 = /^[\t\r\n\f ]+/.exec(t2.source);
      e2 && advanceBy(t2, e2[0].length);
    }
    function getNewPosition(t2, e2, r2) {
      return advancePositionWithClone(e2, t2.originalSource.slice(e2.offset, r2), r2);
    }
    function emitError(t2, e2, r2, n2 = getCursor(t2)) {
      r2 && (n2.offset += r2, n2.column += r2), t2.options.onError(createCompilerError(e2, { start: n2, end: n2, source: "" }));
    }
    function isEnd(t2, e2, r2) {
      const n2 = t2.source;
      switch (e2) {
        case 0:
          if (startsWith(n2, "</")) {
            for (let t3 = r2.length - 1; t3 >= 0; --t3)
              if (startsWithEndTagOpen(n2, r2[t3].tag))
                return true;
          }
          break;
        case 1:
        case 2: {
          const t3 = last(r2);
          if (t3 && startsWithEndTagOpen(n2, t3.tag))
            return true;
          break;
        }
        case 3:
          if (startsWith(n2, "]]>"))
            return true;
      }
      return !n2;
    }
    function startsWithEndTagOpen(t2, e2) {
      return startsWith(t2, "</") && t2.slice(2, 2 + e2.length).toLowerCase() === e2.toLowerCase() && /[\t\r\n\f />]/.test(t2[2 + e2.length] || ">");
    }
    function hoistStatic(t2, e2) {
      walk(t2, e2, isSingleElementRoot(t2, t2.children[0]));
    }
    function isSingleElementRoot(t2, e2) {
      const { children: r2 } = t2;
      return 1 === r2.length && 1 === e2.type && !isSlotOutlet(e2);
    }
    function walk(t2, e2, r2 = false) {
      const { children: n2 } = t2, i2 = n2.length;
      let o2 = 0;
      for (let t3 = 0; t3 < n2.length; t3++) {
        const i3 = n2[t3];
        if (1 === i3.type && 0 === i3.tagType) {
          const t4 = r2 ? 0 : getConstantType(i3, e2);
          if (t4 > 0) {
            if (t4 >= 2) {
              i3.codegenNode.patchFlag = "-1", i3.codegenNode = e2.hoist(i3.codegenNode), o2++;
              continue;
            }
          } else {
            const t5 = i3.codegenNode;
            if (13 === t5.type) {
              const r3 = getPatchFlag(t5);
              if ((!r3 || 512 === r3 || 1 === r3) && getGeneratedPropsConstantType(i3, e2) >= 2) {
                const r4 = getNodeProps(i3);
                r4 && (t5.props = e2.hoist(r4));
              }
              t5.dynamicProps && (t5.dynamicProps = e2.hoist(t5.dynamicProps));
            }
          }
        }
        if (1 === i3.type) {
          const t4 = 1 === i3.tagType;
          t4 && e2.scopes.vSlot++, walk(i3, e2), t4 && e2.scopes.vSlot--;
        } else if (11 === i3.type)
          walk(i3, e2, 1 === i3.children.length);
        else if (9 === i3.type)
          for (let t4 = 0; t4 < i3.branches.length; t4++)
            walk(i3.branches[t4], e2, 1 === i3.branches[t4].children.length);
      }
      if (o2 && e2.transformHoist && e2.transformHoist(n2, e2, t2), o2 && o2 === i2 && 1 === t2.type && 0 === t2.tagType && t2.codegenNode && 13 === t2.codegenNode.type && io.isArray(t2.codegenNode.children)) {
        const r3 = e2.hoist(createArrayExpression(t2.codegenNode.children));
        e2.hmr && (r3.content = `[...${r3.content}]`), t2.codegenNode.children = r3;
      }
    }
    function getConstantType(t2, e2) {
      const { constantCache: r2 } = e2;
      switch (t2.type) {
        case 1:
          if (0 !== t2.tagType)
            return 0;
          const n2 = r2.get(t2);
          if (void 0 !== n2)
            return n2;
          const i2 = t2.codegenNode;
          if (13 !== i2.type)
            return 0;
          if (i2.isBlock && "svg" !== t2.tag && "foreignObject" !== t2.tag)
            return 0;
          if (getPatchFlag(i2))
            return r2.set(t2, 0), 0;
          {
            let n3 = 3;
            const o3 = getGeneratedPropsConstantType(t2, e2);
            if (0 === o3)
              return r2.set(t2, 0), 0;
            o3 < n3 && (n3 = o3);
            for (let i3 = 0; i3 < t2.children.length; i3++) {
              const o4 = getConstantType(t2.children[i3], e2);
              if (0 === o4)
                return r2.set(t2, 0), 0;
              o4 < n3 && (n3 = o4);
            }
            if (n3 > 1)
              for (let i3 = 0; i3 < t2.props.length; i3++) {
                const o4 = t2.props[i3];
                if (7 === o4.type && "bind" === o4.name && o4.exp) {
                  const i4 = getConstantType(o4.exp, e2);
                  if (0 === i4)
                    return r2.set(t2, 0), 0;
                  i4 < n3 && (n3 = i4);
                }
              }
            if (i2.isBlock) {
              for (let e3 = 0; e3 < t2.props.length; e3++) {
                if (7 === t2.props[e3].type)
                  return r2.set(t2, 0), 0;
              }
              e2.removeHelper(fo), e2.removeHelper(getVNodeBlockHelper(e2.inSSR, i2.isComponent)), i2.isBlock = false, e2.helper(getVNodeHelper(e2.inSSR, i2.isComponent));
            }
            return r2.set(t2, n3), n3;
          }
        case 2:
        case 3:
          return 3;
        case 9:
        case 11:
        case 10:
        default:
          return 0;
        case 5:
        case 12:
          return getConstantType(t2.content, e2);
        case 4:
          return t2.constType;
        case 8:
          let o2 = 3;
          for (let r3 = 0; r3 < t2.children.length; r3++) {
            const n3 = t2.children[r3];
            if (io.isString(n3) || io.isSymbol(n3))
              continue;
            const i3 = getConstantType(n3, e2);
            if (0 === i3)
              return 0;
            i3 < o2 && (o2 = i3);
          }
          return o2;
      }
    }
    const ca = /* @__PURE__ */ new Set([Lo, Mo, Bo, Do]);
    function getConstantTypeOfHelperCall(t2, e2) {
      if (14 === t2.type && !io.isString(t2.callee) && ca.has(t2.callee)) {
        const r2 = t2.arguments[0];
        if (4 === r2.type)
          return getConstantType(r2, e2);
        if (14 === r2.type)
          return getConstantTypeOfHelperCall(r2, e2);
      }
      return 0;
    }
    function getGeneratedPropsConstantType(t2, e2) {
      let r2 = 3;
      const n2 = getNodeProps(t2);
      if (n2 && 15 === n2.type) {
        const { properties: t3 } = n2;
        for (let n3 = 0; n3 < t3.length; n3++) {
          const { key: i2, value: o2 } = t3[n3], a2 = getConstantType(i2, e2);
          if (0 === a2)
            return a2;
          let s2;
          if (a2 < r2 && (r2 = a2), s2 = 4 === o2.type ? getConstantType(o2, e2) : 14 === o2.type ? getConstantTypeOfHelperCall(o2, e2) : 0, 0 === s2)
            return s2;
          s2 < r2 && (r2 = s2);
        }
      }
      return r2;
    }
    function getNodeProps(t2) {
      const e2 = t2.codegenNode;
      if (13 === e2.type)
        return e2.props;
    }
    function getPatchFlag(t2) {
      const e2 = t2.patchFlag;
      return e2 ? parseInt(e2, 10) : void 0;
    }
    function createTransformContext(t2, { filename: e2 = "", prefixIdentifiers: r2 = false, hoistStatic: n2 = false, hmr: i2 = false, cacheHandlers: o2 = false, nodeTransforms: a2 = [], directiveTransforms: s2 = {}, transformHoist: l2 = null, isBuiltInComponent: p2 = io.NOOP, isCustomElement: c2 = io.NOOP, expressionPlugins: d2 = [], scopeId: m2 = null, slotted: u2 = true, ssr: h2 = false, inSSR: g2 = false, ssrCssVars: x2 = "", bindingMetadata: v2 = io.EMPTY_OBJ, inline: y2 = false, isTS: b2 = false, onError: w2 = defaultOnError, onWarn: k2 = defaultOnWarn, compatConfig: S2 }) {
      const C2 = e2.replace(/\?.*$/, "").match(/([^/\\]+)\.\w+$/), _2 = { selfName: C2 && io.capitalize(io.camelize(C2[1])), prefixIdentifiers: r2, hoistStatic: n2, hmr: i2, cacheHandlers: o2, nodeTransforms: a2, directiveTransforms: s2, transformHoist: l2, isBuiltInComponent: p2, isCustomElement: c2, expressionPlugins: d2, scopeId: m2, slotted: u2, ssr: h2, inSSR: g2, ssrCssVars: x2, bindingMetadata: v2, inline: y2, isTS: b2, onError: w2, onWarn: k2, compatConfig: S2, root: t2, helpers: /* @__PURE__ */ new Map(), components: /* @__PURE__ */ new Set(), directives: /* @__PURE__ */ new Set(), hoists: [], imports: [], constantCache: /* @__PURE__ */ new WeakMap(), temps: 0, cached: 0, identifiers: /* @__PURE__ */ Object.create(null), scopes: { vFor: 0, vSlot: 0, vPre: 0, vOnce: 0 }, parent: null, currentNode: t2, childIndex: 0, inVOnce: false, helper(t3) {
        const e3 = _2.helpers.get(t3) || 0;
        return _2.helpers.set(t3, e3 + 1), t3;
      }, removeHelper(t3) {
        const e3 = _2.helpers.get(t3);
        if (e3) {
          const r3 = e3 - 1;
          r3 ? _2.helpers.set(t3, r3) : _2.helpers.delete(t3);
        }
      }, helperString: (t3) => `_${Yo[_2.helper(t3)]}`, replaceNode(t3) {
        _2.parent.children[_2.childIndex] = _2.currentNode = t3;
      }, removeNode(t3) {
        const e3 = _2.parent.children, r3 = t3 ? e3.indexOf(t3) : _2.currentNode ? _2.childIndex : -1;
        t3 && t3 !== _2.currentNode ? _2.childIndex > r3 && (_2.childIndex--, _2.onNodeRemoved()) : (_2.currentNode = null, _2.onNodeRemoved()), _2.parent.children.splice(r3, 1);
      }, onNodeRemoved: () => {
      }, addIdentifiers(t3) {
        io.isString(t3) ? addId(t3) : t3.identifiers ? t3.identifiers.forEach(addId) : 4 === t3.type && addId(t3.content);
      }, removeIdentifiers(t3) {
        io.isString(t3) ? removeId(t3) : t3.identifiers ? t3.identifiers.forEach(removeId) : 4 === t3.type && removeId(t3.content);
      }, hoist(t3) {
        io.isString(t3) && (t3 = createSimpleExpression(t3)), _2.hoists.push(t3);
        const e3 = createSimpleExpression(`_hoisted_${_2.hoists.length}`, false, t3.loc, 2);
        return e3.hoisted = t3, e3;
      }, cache: (t3, e3 = false) => createCacheExpression(_2.cached++, t3, e3) };
      function addId(t3) {
        const { identifiers: e3 } = _2;
        void 0 === e3[t3] && (e3[t3] = 0), e3[t3]++;
      }
      function removeId(t3) {
        _2.identifiers[t3]--;
      }
      return _2.filters = /* @__PURE__ */ new Set(), _2;
    }
    function transform$2(t2, e2) {
      const r2 = createTransformContext(t2, e2);
      traverseNode(t2, r2), e2.hoistStatic && hoistStatic(t2, r2), e2.ssr || function(t3, e3) {
        const { helper: r3 } = e3, { children: n2 } = t3;
        if (1 === n2.length) {
          const r4 = n2[0];
          if (isSingleElementRoot(t3, r4) && r4.codegenNode) {
            const n3 = r4.codegenNode;
            13 === n3.type && convertToBlock(n3, e3), t3.codegenNode = n3;
          } else
            t3.codegenNode = r4;
        } else if (n2.length > 1) {
          let n3 = 64;
          io.PatchFlagNames[64], t3.codegenNode = createVNodeCall(e3, r3(po), void 0, t3.children, n3 + "", void 0, void 0, true, void 0, false);
        }
      }(t2, r2), t2.helpers = /* @__PURE__ */ new Set([...r2.helpers.keys()]), t2.components = [...r2.components], t2.directives = [...r2.directives], t2.imports = r2.imports, t2.hoists = r2.hoists, t2.temps = r2.temps, t2.cached = r2.cached, t2.filters = [...r2.filters];
    }
    function traverseNode(t2, e2) {
      e2.currentNode = t2;
      const { nodeTransforms: r2 } = e2, n2 = [];
      for (let i3 = 0; i3 < r2.length; i3++) {
        const o2 = r2[i3](t2, e2);
        if (o2 && (io.isArray(o2) ? n2.push(...o2) : n2.push(o2)), !e2.currentNode)
          return;
        t2 = e2.currentNode;
      }
      switch (t2.type) {
        case 3:
          e2.ssr || e2.helper(wo);
          break;
        case 5:
          e2.ssr || e2.helper(Ro);
          break;
        case 9:
          for (let r3 = 0; r3 < t2.branches.length; r3++)
            traverseNode(t2.branches[r3], e2);
          break;
        case 10:
        case 11:
        case 1:
        case 0:
          !function(t3, e3) {
            let r3 = 0;
            const nodeRemoved = () => {
              r3--;
            };
            for (; r3 < t3.children.length; r3++) {
              const n3 = t3.children[r3];
              io.isString(n3) || (e3.parent = t3, e3.childIndex = r3, e3.onNodeRemoved = nodeRemoved, traverseNode(n3, e3));
            }
          }(t2, e2);
      }
      e2.currentNode = t2;
      let i2 = n2.length;
      for (; i2--; )
        n2[i2]();
    }
    function createStructuralDirectiveTransform(t2, e2) {
      const r2 = io.isString(t2) ? (e3) => e3 === t2 : (e3) => t2.test(e3);
      return (t3, n2) => {
        if (1 === t3.type) {
          const { props: i2 } = t3;
          if (3 === t3.tagType && i2.some(isVSlot))
            return;
          const o2 = [];
          for (let a2 = 0; a2 < i2.length; a2++) {
            const s2 = i2[a2];
            if (7 === s2.type && r2(s2.name)) {
              i2.splice(a2, 1), a2--;
              const r3 = e2(t3, s2, n2);
              r3 && o2.push(r3);
            }
          }
          return o2;
        }
      };
    }
    const da = "/*#__PURE__*/", aliasHelper = (t2) => `${Yo[t2]}: _${Yo[t2]}`;
    function createCodegenContext(t2, { mode: e2 = "function", prefixIdentifiers: r2 = "module" === e2, sourceMap: n2 = false, filename: i2 = "template.vue.html", scopeId: o2 = null, optimizeImports: a2 = false, runtimeGlobalName: s2 = "Vue", runtimeModuleName: l2 = "vue", ssrRuntimeModuleName: p2 = "vue/server-renderer", ssr: c2 = false, isTS: d2 = false, inSSR: m2 = false }) {
      const u2 = { mode: e2, prefixIdentifiers: r2, sourceMap: n2, filename: i2, scopeId: o2, optimizeImports: a2, runtimeGlobalName: s2, runtimeModuleName: l2, ssrRuntimeModuleName: p2, ssr: c2, isTS: d2, inSSR: m2, source: t2.loc.source, code: "", column: 1, line: 1, offset: 0, indentLevel: 0, pure: false, map: void 0, helper: (t3) => `_${Yo[t3]}`, push(t3, e3) {
        if (u2.code += t3, u2.map) {
          if (e3) {
            let t4;
            if (4 === e3.type && !e3.isStatic) {
              const r3 = e3.content.replace(/^_ctx\./, "");
              r3 !== e3.content && isSimpleIdentifier(r3) && (t4 = r3);
            }
            addMapping(e3.loc.start, t4);
          }
          advancePositionWithMutation(u2, t3), e3 && e3.loc !== Xo && addMapping(e3.loc.end);
        }
      }, indent() {
        newline(++u2.indentLevel);
      }, deindent(t3 = false) {
        t3 ? --u2.indentLevel : newline(--u2.indentLevel);
      }, newline() {
        newline(u2.indentLevel);
      } };
      function newline(t3) {
        u2.push("\n" + "  ".repeat(t3));
      }
      function addMapping(t3, e3) {
        u2.map.addMapping({ name: e3, source: u2.filename, original: { line: t3.line, column: t3.column - 1 }, generated: { line: u2.line, column: u2.column - 1 } });
      }
      return n2 && (u2.map = new ao.SourceMapGenerator(), u2.map.setSourceContent(i2, u2.source)), u2;
    }
    function generate(t2, e2 = {}) {
      const r2 = createCodegenContext(t2, e2);
      e2.onContextCreated && e2.onContextCreated(r2);
      const { mode: n2, push: i2, prefixIdentifiers: o2, indent: a2, deindent: s2, newline: l2, scopeId: p2, ssr: c2 } = r2, d2 = Array.from(t2.helpers), m2 = d2.length > 0, u2 = !o2 && "module" !== n2, h2 = null != p2 && "module" === n2, g2 = !!e2.inline, x2 = g2 ? createCodegenContext(t2, e2) : r2;
      "module" === n2 ? function(t3, e3, r3, n3) {
        const { push: i3, newline: o3, optimizeImports: a3, runtimeModuleName: s3, ssrRuntimeModuleName: l3 } = e3;
        r3 && t3.hoists.length && (t3.helpers.add(Uo), t3.helpers.add(Ho));
        if (t3.helpers.size) {
          const e4 = Array.from(t3.helpers);
          a3 ? (i3(`import { ${e4.map((t4) => Yo[t4]).join(", ")} } from ${JSON.stringify(s3)}
`), i3(`
// Binding optimization for webpack code-split
const ${e4.map((t4) => `_${Yo[t4]} = ${Yo[t4]}`).join(", ")}
`)) : i3(`import { ${e4.map((t4) => `${Yo[t4]} as _${Yo[t4]}`).join(", ")} } from ${JSON.stringify(s3)}
`);
        }
        t3.ssrHelpers && t3.ssrHelpers.length && i3(`import { ${t3.ssrHelpers.map((t4) => `${Yo[t4]} as _${Yo[t4]}`).join(", ")} } from "${l3}"
`);
        t3.imports.length && (!function(t4, e4) {
          if (!t4.length)
            return;
          t4.forEach((t5) => {
            e4.push("import "), genNode(t5.exp, e4), e4.push(` from '${t5.path}'`), e4.newline();
          });
        }(t3.imports, e3), o3());
        genHoists(t3.hoists, e3), o3(), n3 || i3("export ");
      }(t2, x2, h2, g2) : function(t3, e3) {
        const { ssr: r3, prefixIdentifiers: n3, push: i3, newline: o3, runtimeModuleName: a3, runtimeGlobalName: s3, ssrRuntimeModuleName: l3 } = e3, p3 = r3 ? `require(${JSON.stringify(a3)})` : s3, c3 = Array.from(t3.helpers);
        if (c3.length > 0) {
          if (n3)
            i3(`const { ${c3.map(aliasHelper).join(", ")} } = ${p3}
`);
          else if (i3(`const _Vue = ${p3}
`), t3.hoists.length) {
            i3(`const { ${[yo, bo, wo, ko, So].filter((t4) => c3.includes(t4)).map(aliasHelper).join(", ")} } = _Vue
`);
          }
        }
        t3.ssrHelpers && t3.ssrHelpers.length && i3(`const { ${t3.ssrHelpers.map(aliasHelper).join(", ")} } = require("${l3}")
`);
        genHoists(t3.hoists, e3), o3(), i3("return ");
      }(t2, x2);
      const v2 = c2 ? "ssrRender" : "render", y2 = c2 ? ["_ctx", "_push", "_parent", "_attrs"] : ["_ctx", "_cache"];
      e2.bindingMetadata && !e2.inline && y2.push("$props", "$setup", "$data", "$options");
      const b2 = e2.isTS ? y2.map((t3) => `${t3}: any`).join(",") : y2.join(", ");
      if (i2(g2 ? `(${b2}) => {` : `function ${v2}(${b2}) {`), a2(), u2 && (i2("with (_ctx) {"), a2(), m2 && (i2(`const { ${d2.map(aliasHelper).join(", ")} } = _Vue`), i2("\n"), l2())), t2.components.length && (genAssets(t2.components, "component", r2), (t2.directives.length || t2.temps > 0) && l2()), t2.directives.length && (genAssets(t2.directives, "directive", r2), t2.temps > 0 && l2()), t2.filters && t2.filters.length && (l2(), genAssets(t2.filters, "filter", r2), l2()), t2.temps > 0) {
        i2("let ");
        for (let e3 = 0; e3 < t2.temps; e3++)
          i2(`${e3 > 0 ? ", " : ""}_temp${e3}`);
      }
      return (t2.components.length || t2.directives.length || t2.temps) && (i2("\n"), l2()), c2 || i2("return "), t2.codegenNode ? genNode(t2.codegenNode, r2) : i2("null"), u2 && (s2(), i2("}")), s2(), i2("}"), { ast: t2, code: r2.code, preamble: g2 ? x2.code : "", map: r2.map ? r2.map.toJSON() : void 0 };
    }
    function genAssets(t2, e2, { helper: r2, push: n2, newline: i2, isTS: o2 }) {
      const a2 = r2("filter" === e2 ? Po : "component" === e2 ? Co : _o);
      for (let r3 = 0; r3 < t2.length; r3++) {
        let s2 = t2[r3];
        const l2 = s2.endsWith("__self");
        l2 && (s2 = s2.slice(0, -6)), n2(`const ${toValidAssetId(s2, e2)} = ${a2}(${JSON.stringify(s2)}${l2 ? ", true" : ""})${o2 ? "!" : ""}`), r3 < t2.length - 1 && i2();
      }
    }
    function genHoists(t2, e2) {
      if (!t2.length)
        return;
      e2.pure = true;
      const { push: r2, newline: n2, helper: i2, scopeId: o2, mode: a2 } = e2, s2 = null != o2 && "function" !== a2;
      n2(), s2 && (r2(`const _withScopeId = n => (${i2(Uo)}("${o2}"),n=n(),${i2(Ho)}(),n)`), n2());
      for (let i3 = 0; i3 < t2.length; i3++) {
        const o3 = t2[i3];
        if (o3) {
          const t3 = s2 && 13 === o3.type;
          r2(`const _hoisted_${i3 + 1} = ${t3 ? `${da} _withScopeId(() => ` : ""}`), genNode(o3, e2), t3 && r2(")"), n2();
        }
      }
      e2.pure = false;
    }
    function genNodeListAsArray(t2, e2) {
      const r2 = t2.length > 3 || t2.some((t3) => io.isArray(t3) || !function(t4) {
        return io.isString(t4) || 4 === t4.type || 2 === t4.type || 5 === t4.type || 8 === t4.type;
      }(t3));
      e2.push("["), r2 && e2.indent(), genNodeList(t2, e2, r2), r2 && e2.deindent(), e2.push("]");
    }
    function genNodeList(t2, e2, r2 = false, n2 = true) {
      const { push: i2, newline: o2 } = e2;
      for (let a2 = 0; a2 < t2.length; a2++) {
        const s2 = t2[a2];
        io.isString(s2) ? i2(s2) : io.isArray(s2) ? genNodeListAsArray(s2, e2) : genNode(s2, e2), a2 < t2.length - 1 && (r2 ? (n2 && i2(","), o2()) : n2 && i2(", "));
      }
    }
    function genNode(t2, e2) {
      if (io.isString(t2))
        e2.push(t2);
      else if (io.isSymbol(t2))
        e2.push(e2.helper(t2));
      else
        switch (t2.type) {
          case 1:
          case 9:
          case 11:
          case 12:
            genNode(t2.codegenNode, e2);
            break;
          case 2:
            !function(t3, e3) {
              e3.push(JSON.stringify(t3.content), t3);
            }(t2, e2);
            break;
          case 4:
            genExpression(t2, e2);
            break;
          case 5:
            !function(t3, e3) {
              const { push: r2, helper: n2, pure: i2 } = e3;
              i2 && r2(da);
              r2(`${n2(Ro)}(`), genNode(t3.content, e3), r2(")");
            }(t2, e2);
            break;
          case 8:
            genCompoundExpression(t2, e2);
            break;
          case 3:
            !function(t3, e3) {
              const { push: r2, helper: n2, pure: i2 } = e3;
              i2 && r2(da);
              r2(`${n2(wo)}(${JSON.stringify(t3.content)})`, t3);
            }(t2, e2);
            break;
          case 13:
            !function(t3, e3) {
              const { push: r2, helper: n2, pure: i2 } = e3, { tag: o2, props: a2, children: s2, patchFlag: l2, dynamicProps: p2, directives: c2, isBlock: d2, disableTracking: m2, isComponent: u2 } = t3;
              c2 && r2(n2(To) + "(");
              d2 && r2(`(${n2(fo)}(${m2 ? "true" : ""}), `);
              i2 && r2(da);
              const h2 = d2 ? getVNodeBlockHelper(e3.inSSR, u2) : getVNodeHelper(e3.inSSR, u2);
              r2(n2(h2) + "(", t3), genNodeList(function(t4) {
                let e4 = t4.length;
                for (; e4-- && null == t4[e4]; )
                  ;
                return t4.slice(0, e4 + 1).map((t5) => t5 || "null");
              }([o2, a2, s2, l2, p2]), e3), r2(")"), d2 && r2(")");
              c2 && (r2(", "), genNode(c2, e3), r2(")"));
            }(t2, e2);
            break;
          case 14:
            !function(t3, e3) {
              const { push: r2, helper: n2, pure: i2 } = e3, o2 = io.isString(t3.callee) ? t3.callee : n2(t3.callee);
              i2 && r2(da);
              r2(o2 + "(", t3), genNodeList(t3.arguments, e3), r2(")");
            }(t2, e2);
            break;
          case 15:
            !function(t3, e3) {
              const { push: r2, indent: n2, deindent: i2, newline: o2 } = e3, { properties: a2 } = t3;
              if (!a2.length)
                return void r2("{}", t3);
              const s2 = a2.length > 1 || a2.some((t4) => 4 !== t4.value.type);
              r2(s2 ? "{" : "{ "), s2 && n2();
              for (let t4 = 0; t4 < a2.length; t4++) {
                const { key: n3, value: i3 } = a2[t4];
                genExpressionAsPropertyKey(n3, e3), r2(": "), genNode(i3, e3), t4 < a2.length - 1 && (r2(","), o2());
              }
              s2 && i2(), r2(s2 ? "}" : " }");
            }(t2, e2);
            break;
          case 17:
            !function(t3, e3) {
              genNodeListAsArray(t3.elements, e3);
            }(t2, e2);
            break;
          case 18:
            !function(t3, e3) {
              const { push: r2, indent: n2, deindent: i2 } = e3, { params: o2, returns: a2, body: s2, newline: l2, isSlot: p2 } = t3;
              p2 && r2(`_${Yo[qo]}(`);
              r2("(", t3), io.isArray(o2) ? genNodeList(o2, e3) : o2 && genNode(o2, e3);
              r2(") => "), (l2 || s2) && (r2("{"), n2());
              a2 ? (l2 && r2("return "), io.isArray(a2) ? genNodeListAsArray(a2, e3) : genNode(a2, e3)) : s2 && genNode(s2, e3);
              (l2 || s2) && (i2(), r2("}"));
              p2 && (t3.isNonScopedSlot && r2(", undefined, true"), r2(")"));
            }(t2, e2);
            break;
          case 19:
            !function(t3, e3) {
              const { test: r2, consequent: n2, alternate: i2, newline: o2 } = t3, { push: a2, indent: s2, deindent: l2, newline: p2 } = e3;
              if (4 === r2.type) {
                const t4 = !isSimpleIdentifier(r2.content);
                t4 && a2("("), genExpression(r2, e3), t4 && a2(")");
              } else
                a2("("), genNode(r2, e3), a2(")");
              o2 && s2(), e3.indentLevel++, o2 || a2(" "), a2("? "), genNode(n2, e3), e3.indentLevel--, o2 && p2(), o2 || a2(" "), a2(": ");
              const c2 = 19 === i2.type;
              c2 || e3.indentLevel++;
              genNode(i2, e3), c2 || e3.indentLevel--;
              o2 && l2(true);
            }(t2, e2);
            break;
          case 20:
            !function(t3, e3) {
              const { push: r2, helper: n2, indent: i2, deindent: o2, newline: a2 } = e3;
              r2(`_cache[${t3.index}] || (`), t3.isVNode && (i2(), r2(`${n2(zo)}(-1),`), a2());
              r2(`_cache[${t3.index}] = `), genNode(t3.value, e3), t3.isVNode && (r2(","), a2(), r2(`${n2(zo)}(1),`), a2(), r2(`_cache[${t3.index}]`), o2());
              r2(")");
            }(t2, e2);
            break;
          case 21:
            genNodeList(t2.body, e2, true, false);
            break;
          case 22:
            !function(t3, e3) {
              const { push: r2, indent: n2, deindent: i2 } = e3;
              r2("`");
              const o2 = t3.elements.length, a2 = o2 > 3;
              for (let s2 = 0; s2 < o2; s2++) {
                const o3 = t3.elements[s2];
                io.isString(o3) ? r2(o3.replace(/(`|\$|\\)/g, "\\$1")) : (r2("${"), a2 && n2(), genNode(o3, e3), a2 && i2(), r2("}"));
              }
              r2("`");
            }(t2, e2);
            break;
          case 23:
            genIfStatement(t2, e2);
            break;
          case 24:
            !function(t3, e3) {
              genNode(t3.left, e3), e3.push(" = "), genNode(t3.right, e3);
            }(t2, e2);
            break;
          case 25:
            !function(t3, e3) {
              e3.push("("), genNodeList(t3.expressions, e3), e3.push(")");
            }(t2, e2);
            break;
          case 26:
            !function({ returns: t3 }, e3) {
              e3.push("return "), io.isArray(t3) ? genNodeListAsArray(t3, e3) : genNode(t3, e3);
            }(t2, e2);
        }
    }
    function genExpression(t2, e2) {
      const { content: r2, isStatic: n2 } = t2;
      e2.push(n2 ? JSON.stringify(r2) : r2, t2);
    }
    function genCompoundExpression(t2, e2) {
      for (let r2 = 0; r2 < t2.children.length; r2++) {
        const n2 = t2.children[r2];
        io.isString(n2) ? e2.push(n2) : genNode(n2, e2);
      }
    }
    function genExpressionAsPropertyKey(t2, e2) {
      const { push: r2 } = e2;
      if (8 === t2.type)
        r2("["), genCompoundExpression(t2, e2), r2("]");
      else if (t2.isStatic) {
        r2(isSimpleIdentifier(t2.content) ? t2.content : JSON.stringify(t2.content), t2);
      } else
        r2(`[${t2.content}]`, t2);
    }
    function genIfStatement(t2, e2) {
      const { push: r2, indent: n2, deindent: i2 } = e2, { test: o2, consequent: a2, alternate: s2 } = t2;
      r2("if ("), genNode(o2, e2), r2(") {"), n2(), genNode(a2, e2), i2(), r2("}"), s2 && (r2(" else "), 23 === s2.type ? genIfStatement(s2, e2) : (r2("{"), n2(), genNode(s2, e2), i2(), r2("}")));
    }
    function walkIdentifiers(t2, e2, r2 = false, n2 = [], i2 = /* @__PURE__ */ Object.create(null)) {
      const o2 = "Program" === t2.type && "ExpressionStatement" === t2.body[0].type && t2.body[0].expression;
      so.walk(t2, { enter(t3, o3) {
        if (o3 && n2.push(o3), o3 && o3.type.startsWith("TS") && !ma.includes(o3.type))
          return this.skip();
        if ("Identifier" === t3.type) {
          const a2 = !!i2[t3.name], s2 = isReferencedIdentifier(t3, o3, n2);
          (r2 || s2 && !a2) && e2(t3, o3, n2, s2, a2);
        } else
          "ObjectProperty" === t3.type && "ObjectPattern" === o3.type ? t3.inPattern = true : isFunctionType(t3) ? walkFunctionParams(t3, (e3) => markScopeIdentifier(t3, e3, i2)) : "BlockStatement" === t3.type && walkBlockDeclarations(t3, (e3) => markScopeIdentifier(t3, e3, i2));
      }, leave(t3, e3) {
        if (e3 && n2.pop(), t3 !== o2 && t3.scopeIds)
          for (const e4 of t3.scopeIds)
            i2[e4]--, 0 === i2[e4] && delete i2[e4];
      } });
    }
    function isReferencedIdentifier(t2, e2, r2) {
      if (!e2)
        return true;
      if ("arguments" === t2.name)
        return false;
      if (function(t3, e3, r3) {
        switch (e3.type) {
          case "MemberExpression":
          case "OptionalMemberExpression":
            return e3.property === t3 ? !!e3.computed : e3.object === t3;
          case "JSXMemberExpression":
            return e3.object === t3;
          case "VariableDeclarator":
            return e3.init === t3;
          case "ArrowFunctionExpression":
            return e3.body === t3;
          case "PrivateName":
          case "LabeledStatement":
          case "CatchClause":
          case "RestElement":
          case "BreakStatement":
          case "ContinueStatement":
          case "FunctionDeclaration":
          case "FunctionExpression":
          case "ExportNamespaceSpecifier":
          case "ExportDefaultSpecifier":
          case "ImportDefaultSpecifier":
          case "ImportNamespaceSpecifier":
          case "ImportSpecifier":
          case "ImportAttribute":
          case "JSXAttribute":
          case "ObjectPattern":
          case "ArrayPattern":
          case "MetaProperty":
            return false;
          case "ClassMethod":
          case "ClassPrivateMethod":
          case "ObjectMethod":
            return e3.key === t3 && !!e3.computed;
          case "ObjectProperty":
            return e3.key === t3 ? !!e3.computed : !r3 || "ObjectPattern" !== r3.type;
          case "ClassProperty":
          case "TSPropertySignature":
            return e3.key !== t3 || !!e3.computed;
          case "ClassPrivateProperty":
          case "ObjectTypeProperty":
            return e3.key !== t3;
          case "ClassDeclaration":
          case "ClassExpression":
            return e3.superClass === t3;
          case "AssignmentExpression":
          case "AssignmentPattern":
            return e3.right === t3;
          case "ExportSpecifier":
            return !(null == r3 ? void 0 : r3.source) && e3.local === t3;
          case "TSEnumMember":
            return e3.id !== t3;
        }
        return true;
      }(t2, e2))
        return true;
      switch (e2.type) {
        case "AssignmentExpression":
        case "AssignmentPattern":
          return true;
        case "ObjectPattern":
        case "ArrayPattern":
          return isInDestructureAssignment(e2, r2);
      }
      return false;
    }
    function isInDestructureAssignment(t2, e2) {
      if (t2 && ("ObjectProperty" === t2.type || "ArrayPattern" === t2.type)) {
        let t3 = e2.length;
        for (; t3--; ) {
          const r2 = e2[t3];
          if ("AssignmentExpression" === r2.type)
            return true;
          if ("ObjectProperty" !== r2.type && !r2.type.endsWith("Pattern"))
            break;
        }
      }
      return false;
    }
    function walkFunctionParams(t2, e2) {
      for (const r2 of t2.params)
        for (const t3 of extractIdentifiers(r2))
          e2(t3);
    }
    function walkBlockDeclarations(t2, e2) {
      for (const r2 of t2.body)
        if ("VariableDeclaration" === r2.type) {
          if (r2.declare)
            continue;
          for (const t3 of r2.declarations)
            for (const r3 of extractIdentifiers(t3.id))
              e2(r3);
        } else if ("FunctionDeclaration" === r2.type || "ClassDeclaration" === r2.type) {
          if (r2.declare || !r2.id)
            continue;
          e2(r2.id);
        } else if ("ForOfStatement" === r2.type || "ForInStatement" === r2.type || "ForStatement" === r2.type) {
          const t3 = "ForStatement" === r2.type ? r2.init : r2.left;
          if (t3 && "VariableDeclaration" === t3.type)
            for (const r3 of t3.declarations)
              for (const t4 of extractIdentifiers(r3.id))
                e2(t4);
        }
    }
    function extractIdentifiers(t2, e2 = []) {
      switch (t2.type) {
        case "Identifier":
          e2.push(t2);
          break;
        case "MemberExpression":
          let r2 = t2;
          for (; "MemberExpression" === r2.type; )
            r2 = r2.object;
          e2.push(r2);
          break;
        case "ObjectPattern":
          for (const r3 of t2.properties)
            "RestElement" === r3.type ? extractIdentifiers(r3.argument, e2) : extractIdentifiers(r3.value, e2);
          break;
        case "ArrayPattern":
          t2.elements.forEach((t3) => {
            t3 && extractIdentifiers(t3, e2);
          });
          break;
        case "RestElement":
          extractIdentifiers(t2.argument, e2);
          break;
        case "AssignmentPattern":
          extractIdentifiers(t2.left, e2);
      }
      return e2;
    }
    function markScopeIdentifier(t2, e2, r2) {
      const { name: n2 } = e2;
      t2.scopeIds && t2.scopeIds.has(n2) || (n2 in r2 ? r2[n2]++ : r2[n2] = 1, (t2.scopeIds || (t2.scopeIds = /* @__PURE__ */ new Set())).add(n2));
    }
    const isFunctionType = (t2) => /Function(?:Expression|Declaration)$|Method$/.test(t2.type), isStaticProperty = (t2) => t2 && ("ObjectProperty" === t2.type || "ObjectMethod" === t2.type) && !t2.computed, isStaticPropertyKey = (t2, e2) => isStaticProperty(e2) && e2.key === t2;
    const ma = ["TSAsExpression", "TSTypeAssertion", "TSNonNullExpression", "TSInstantiationExpression", "TSSatisfiesExpression"], ua = io.makeMap("true,false,null,this"), ha = /\w\s*\(|\.[^\d]/, transformExpression = (t2, e2) => {
      if (5 === t2.type)
        t2.content = processExpression(t2.content, e2);
      else if (1 === t2.type)
        for (let r2 = 0; r2 < t2.props.length; r2++) {
          const n2 = t2.props[r2];
          if (7 === n2.type && "for" !== n2.name) {
            const t3 = n2.exp, r3 = n2.arg;
            !t3 || 4 !== t3.type || "on" === n2.name && r3 || (n2.exp = processExpression(t3, e2, "slot" === n2.name)), r3 && 4 === r3.type && !r3.isStatic && (n2.arg = processExpression(r3, e2));
          }
        }
    };
    function processExpression(t2, e2, r2 = false, n2 = false, i2 = Object.create(e2.identifiers)) {
      if (!e2.prefixIdentifiers || !t2.content.trim())
        return t2;
      const { inline: o2, bindingMetadata: a2 } = e2, rewriteIdentifier = (t3, r3, n3) => {
        const l3 = io.hasOwn(a2, t3) && a2[t3];
        if (o2) {
          const o3 = r3 && "AssignmentExpression" === r3.type && r3.left === n3, p3 = r3 && "UpdateExpression" === r3.type && r3.argument === n3, c3 = r3 && isInDestructureAssignment(r3, m2);
          if (isConst(l3) || "setup-reactive-const" === l3 || i2[t3])
            return t3;
          if ("setup-ref" === l3)
            return `${t3}.value`;
          if ("setup-maybe-ref" === l3)
            return o3 || p3 || c3 ? `${t3}.value` : `${e2.helperString(Wo)}(${t3})`;
          if ("setup-let" === l3) {
            if (o3) {
              const { right: n4, operator: i3 } = r3, o4 = stringifyExpression(processExpression(createSimpleExpression(s2.slice(n4.start - 1, n4.end - 1), false), e2, false, false, u2));
              return `${e2.helperString(Ko)}(${t3})${e2.isTS ? " //@ts-ignore\n" : ""} ? ${t3}.value ${i3} ${o4} : ${t3}`;
            }
            if (p3) {
              n3.start = r3.start, n3.end = r3.end;
              const { prefix: i3, operator: o4 } = r3, a3 = i3 ? o4 : "", s3 = i3 ? "" : o4;
              return `${e2.helperString(Ko)}(${t3})${e2.isTS ? " //@ts-ignore\n" : ""} ? ${a3}${t3}.value${s3} : ${a3}${t3}${s3}`;
            }
            return c3 ? t3 : `${e2.helperString(Wo)}(${t3})`;
          }
          if ("props" === l3)
            return io.genPropsAccessExp(t3);
          if ("props-aliased" === l3)
            return io.genPropsAccessExp(a2.__propsAliases[t3]);
        } else {
          if (l3 && l3.startsWith("setup") || "literal-const" === l3)
            return `$setup.${t3}`;
          if ("props-aliased" === l3)
            return `$props['${a2.__propsAliases[t3]}']`;
          if (l3)
            return `$${l3}.${t3}`;
        }
        return `_ctx.${t3}`;
      }, s2 = t2.content, l2 = ha.test(s2);
      if (isSimpleIdentifier(s2)) {
        const n3 = e2.identifiers[s2], i3 = io.isGloballyAllowed(s2), o3 = ua(s2);
        return r2 || n3 || o3 || i3 && !a2[s2] ? n3 || (t2.constType = o3 ? 3 : 2) : (isConst(a2[s2]) && (t2.constType = 1), t2.content = rewriteIdentifier(s2)), t2;
      }
      let p2;
      const c2 = n2 ? ` ${s2} ` : `(${s2})${r2 ? "=>{}" : ""}`;
      try {
        p2 = oo.parse(c2, { plugins: e2.expressionPlugins }).program;
      } catch (r3) {
        return e2.onError(createCompilerError(45, t2.loc, void 0, r3.message)), t2;
      }
      const d2 = [], m2 = [], u2 = Object.create(e2.identifiers);
      walkIdentifiers(p2, (t3, e3, r3, n3, i3) => {
        if (isStaticPropertyKey(t3, e3))
          return;
        if (t3.name.startsWith("_filter_"))
          return;
        const o3 = n3 && function(t4) {
          if (io.isGloballyAllowed(t4.name))
            return false;
          if ("require" === t4.name)
            return false;
          return true;
        }(t3);
        o3 && !i3 ? (isStaticProperty(e3) && e3.shorthand && (t3.prefix = `${t3.name}: `), t3.name = rewriteIdentifier(t3.name, e3, t3), d2.push(t3)) : (o3 && i3 || l2 || (t3.isConstant = true), d2.push(t3));
      }, true, m2, u2);
      const h2 = [];
      let g2;
      return d2.sort((t3, e3) => t3.start - e3.start), d2.forEach((e3, r3) => {
        const n3 = e3.start - 1, i3 = e3.end - 1, o3 = d2[r3 - 1], a3 = s2.slice(o3 ? o3.end - 1 : 0, n3);
        (a3.length || e3.prefix) && h2.push(a3 + (e3.prefix || ""));
        const l3 = s2.slice(n3, i3);
        h2.push(createSimpleExpression(e3.name, false, { source: l3, start: advancePositionWithClone(t2.loc.start, l3, n3), end: advancePositionWithClone(t2.loc.start, l3, i3) }, e3.isConstant ? 3 : 0)), r3 === d2.length - 1 && i3 < s2.length && h2.push(s2.slice(i3));
      }), h2.length ? g2 = createCompoundExpression(h2, t2.loc) : (g2 = t2, g2.constType = l2 ? 0 : 3), g2.identifiers = Object.keys(u2), g2;
    }
    function stringifyExpression(t2) {
      return io.isString(t2) ? t2 : 4 === t2.type ? t2.content : t2.children.map(stringifyExpression).join("");
    }
    function isConst(t2) {
      return "setup-const" === t2 || "literal-const" === t2;
    }
    const fa = createStructuralDirectiveTransform(/^(if|else|else-if)$/, (t2, e2, r2) => processIf(t2, e2, r2, (t3, e3, n2) => {
      const i2 = r2.parent.children;
      let o2 = i2.indexOf(t3), a2 = 0;
      for (; o2-- >= 0; ) {
        const t4 = i2[o2];
        t4 && 9 === t4.type && (a2 += t4.branches.length);
      }
      return () => {
        if (n2)
          t3.codegenNode = createCodegenNodeForBranch(e3, a2, r2);
        else {
          const n3 = function(t4) {
            for (; ; )
              if (19 === t4.type) {
                if (19 !== t4.alternate.type)
                  return t4;
                t4 = t4.alternate;
              } else
                20 === t4.type && (t4 = t4.value);
          }(t3.codegenNode);
          n3.alternate = createCodegenNodeForBranch(e3, a2 + t3.branches.length - 1, r2);
        }
      };
    }));
    function processIf(t2, e2, r2, n2) {
      if (!("else" === e2.name || e2.exp && e2.exp.content.trim())) {
        const n3 = e2.exp ? e2.exp.loc : t2.loc;
        r2.onError(createCompilerError(28, e2.loc)), e2.exp = createSimpleExpression("true", false, n3);
      }
      if (r2.prefixIdentifiers && e2.exp && (e2.exp = processExpression(e2.exp, r2)), "if" === e2.name) {
        const i2 = createIfBranch(t2, e2), o2 = { type: 9, loc: t2.loc, branches: [i2] };
        if (r2.replaceNode(o2), n2)
          return n2(o2, i2, true);
      } else {
        const i2 = r2.parent.children;
        let o2 = i2.indexOf(t2);
        for (; o2-- >= -1; ) {
          const a2 = i2[o2];
          if (a2 && 3 === a2.type)
            r2.removeNode(a2);
          else {
            if (!a2 || 2 !== a2.type || a2.content.trim().length) {
              if (a2 && 9 === a2.type) {
                "else-if" === e2.name && void 0 === a2.branches[a2.branches.length - 1].condition && r2.onError(createCompilerError(30, t2.loc)), r2.removeNode();
                const i3 = createIfBranch(t2, e2);
                {
                  const t3 = i3.userKey;
                  t3 && a2.branches.forEach(({ userKey: e3 }) => {
                    isSameKey(e3, t3) && r2.onError(createCompilerError(29, i3.userKey.loc));
                  });
                }
                a2.branches.push(i3);
                const o3 = n2 && n2(a2, i3, false);
                traverseNode(i3, r2), o3 && o3(), r2.currentNode = null;
              } else
                r2.onError(createCompilerError(30, t2.loc));
              break;
            }
            r2.removeNode(a2);
          }
        }
      }
    }
    function createIfBranch(t2, e2) {
      const r2 = 3 === t2.tagType;
      return { type: 10, loc: t2.loc, condition: "else" === e2.name ? void 0 : e2.exp, children: r2 && !findDir(t2, "for") ? t2.children : [t2], userKey: findProp(t2, "key"), isTemplateIf: r2 };
    }
    function createCodegenNodeForBranch(t2, e2, r2) {
      return t2.condition ? createConditionalExpression(t2.condition, createChildrenCodegenNode(t2, e2, r2), createCallExpression(r2.helper(wo), ['""', "true"])) : createChildrenCodegenNode(t2, e2, r2);
    }
    function createChildrenCodegenNode(t2, e2, r2) {
      const { helper: n2 } = r2, i2 = createObjectProperty("key", createSimpleExpression(`${e2}`, false, Xo, 2)), { children: o2 } = t2, a2 = o2[0];
      if (1 !== o2.length || 1 !== a2.type) {
        if (1 === o2.length && 11 === a2.type) {
          const t3 = a2.codegenNode;
          return injectProp(t3, i2, r2), t3;
        }
        {
          let e3 = 64;
          return io.PatchFlagNames[64], createVNodeCall(r2, n2(po), createObjectExpression([i2]), o2, e3 + "", void 0, void 0, true, false, false, t2.loc);
        }
      }
      {
        const t3 = a2.codegenNode, e3 = getMemoedVNodeCall(t3);
        return 13 === e3.type && convertToBlock(e3, r2), injectProp(e3, i2, r2), t3;
      }
    }
    function isSameKey(t2, e2) {
      if (!t2 || t2.type !== e2.type)
        return false;
      if (6 === t2.type) {
        if (t2.value.content !== e2.value.content)
          return false;
      } else {
        const r2 = t2.exp, n2 = e2.exp;
        if (r2.type !== n2.type)
          return false;
        if (4 !== r2.type || r2.isStatic !== n2.isStatic || r2.content !== n2.content)
          return false;
      }
      return true;
    }
    const ga = createStructuralDirectiveTransform("for", (t2, e2, r2) => {
      const { helper: n2, removeHelper: i2 } = r2;
      return processFor(t2, e2, r2, (e3) => {
        const o2 = createCallExpression(n2(Ao), [e3.source]), a2 = isTemplateNode(t2), s2 = findDir(t2, "memo"), l2 = findProp(t2, "key"), p2 = l2 && (6 === l2.type ? createSimpleExpression(l2.value.content, true) : l2.exp), c2 = l2 ? createObjectProperty("key", p2) : null;
        a2 && (s2 && (s2.exp = processExpression(s2.exp, r2)), c2 && 6 !== l2.type && (c2.value = processExpression(c2.value, r2)));
        const d2 = 4 === e3.source.type && e3.source.constType > 0, m2 = d2 ? 64 : l2 ? 128 : 256;
        return e3.codegenNode = createVNodeCall(r2, n2(po), void 0, o2, m2 + "", void 0, void 0, true, !d2, false, t2.loc), () => {
          let l3;
          const { children: m3 } = e3;
          a2 && t2.children.some((t3) => {
            if (1 === t3.type) {
              const e4 = findProp(t3, "key");
              if (e4)
                return r2.onError(createCompilerError(33, e4.loc)), true;
            }
          });
          const u2 = 1 !== m3.length || 1 !== m3[0].type, h2 = isSlotOutlet(t2) ? t2 : a2 && 1 === t2.children.length && isSlotOutlet(t2.children[0]) ? t2.children[0] : null;
          if (h2 ? (l3 = h2.codegenNode, a2 && c2 && injectProp(l3, c2, r2)) : u2 ? l3 = createVNodeCall(r2, n2(po), c2 ? createObjectExpression([c2]) : void 0, t2.children, "64", void 0, void 0, true, void 0, false) : (l3 = m3[0].codegenNode, a2 && c2 && injectProp(l3, c2, r2), l3.isBlock !== !d2 && (l3.isBlock ? (i2(fo), i2(getVNodeBlockHelper(r2.inSSR, l3.isComponent))) : i2(getVNodeHelper(r2.inSSR, l3.isComponent))), l3.isBlock = !d2, l3.isBlock ? (n2(fo), n2(getVNodeBlockHelper(r2.inSSR, l3.isComponent))) : n2(getVNodeHelper(r2.inSSR, l3.isComponent))), s2) {
            const t3 = createFunctionExpression(createForLoopParams(e3.parseResult, [createSimpleExpression("_cached")]));
            t3.body = createBlockStatement([createCompoundExpression(["const _memo = (", s2.exp, ")"]), createCompoundExpression(["if (_cached", ...p2 ? [" && _cached.key === ", p2] : [], ` && ${r2.helperString(Jo)}(_cached, _memo)) return _cached`]), createCompoundExpression(["const _item = ", l3]), createSimpleExpression("_item.memo = _memo"), createSimpleExpression("return _item")]), o2.arguments.push(t3, createSimpleExpression("_cache"), createSimpleExpression(String(r2.cached++)));
          } else
            o2.arguments.push(createFunctionExpression(createForLoopParams(e3.parseResult), l3, true));
        };
      });
    });
    function processFor(t2, e2, r2, n2) {
      if (!e2.exp)
        return void r2.onError(createCompilerError(31, e2.loc));
      const i2 = parseForExpression(e2.exp, r2);
      if (!i2)
        return void r2.onError(createCompilerError(32, e2.loc));
      const { addIdentifiers: o2, removeIdentifiers: a2, scopes: s2 } = r2, { source: l2, value: p2, key: c2, index: d2 } = i2, m2 = { type: 11, loc: e2.loc, source: l2, valueAlias: p2, keyAlias: c2, objectIndexAlias: d2, parseResult: i2, children: isTemplateNode(t2) ? t2.children : [t2] };
      r2.replaceNode(m2), s2.vFor++, r2.prefixIdentifiers && (p2 && o2(p2), c2 && o2(c2), d2 && o2(d2));
      const u2 = n2 && n2(m2);
      return () => {
        s2.vFor--, r2.prefixIdentifiers && (p2 && a2(p2), c2 && a2(c2), d2 && a2(d2)), u2 && u2();
      };
    }
    const xa = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/, va = /^\(|\)$/g;
    function parseForExpression(t2, e2) {
      const r2 = t2.loc, n2 = t2.content, i2 = n2.match(ia);
      if (!i2)
        return;
      const [, o2, a2] = i2, s2 = { source: createAliasExpression(r2, a2.trim(), n2.indexOf(a2, o2.length)), value: void 0, key: void 0, index: void 0 };
      e2.prefixIdentifiers && (s2.source = processExpression(s2.source, e2));
      let l2 = o2.trim().replace(va, "").trim();
      const p2 = o2.indexOf(l2), c2 = l2.match(xa);
      if (c2) {
        l2 = l2.replace(xa, "").trim();
        const t3 = c2[1].trim();
        let i3;
        if (t3 && (i3 = n2.indexOf(t3, p2 + l2.length), s2.key = createAliasExpression(r2, t3, i3), e2.prefixIdentifiers && (s2.key = processExpression(s2.key, e2, true))), c2[2]) {
          const o3 = c2[2].trim();
          o3 && (s2.index = createAliasExpression(r2, o3, n2.indexOf(o3, s2.key ? i3 + t3.length : p2 + l2.length)), e2.prefixIdentifiers && (s2.index = processExpression(s2.index, e2, true)));
        }
      }
      return l2 && (s2.value = createAliasExpression(r2, l2, p2), e2.prefixIdentifiers && (s2.value = processExpression(s2.value, e2, true))), s2;
    }
    function createAliasExpression(t2, e2, r2) {
      return createSimpleExpression(e2, false, getInnerRange(t2, r2, e2.length));
    }
    function createForLoopParams({ value: t2, key: e2, index: r2 }, n2 = []) {
      return function(t3) {
        let e3 = t3.length;
        for (; e3-- && !t3[e3]; )
          ;
        return t3.slice(0, e3 + 1).map((t4, e4) => t4 || createSimpleExpression("_".repeat(e4 + 1), false));
      }([t2, e2, r2, ...n2]);
    }
    const ya = createSimpleExpression("undefined", false), trackSlotScopes = (t2, e2) => {
      if (1 === t2.type && (1 === t2.tagType || 3 === t2.tagType)) {
        const r2 = findDir(t2, "slot");
        if (r2) {
          const t3 = r2.exp;
          return e2.prefixIdentifiers && t3 && e2.addIdentifiers(t3), e2.scopes.vSlot++, () => {
            e2.prefixIdentifiers && t3 && e2.removeIdentifiers(t3), e2.scopes.vSlot--;
          };
        }
      }
    }, trackVForSlotScopes = (t2, e2) => {
      let r2;
      if (isTemplateNode(t2) && t2.props.some(isVSlot) && (r2 = findDir(t2, "for"))) {
        const t3 = r2.parseResult = parseForExpression(r2.exp, e2);
        if (t3) {
          const { value: r3, key: n2, index: i2 } = t3, { addIdentifiers: o2, removeIdentifiers: a2 } = e2;
          return r3 && o2(r3), n2 && o2(n2), i2 && o2(i2), () => {
            r3 && a2(r3), n2 && a2(n2), i2 && a2(i2);
          };
        }
      }
    }, buildClientSlotFn = (t2, e2, r2, n2) => createFunctionExpression(t2, r2, false, true, r2.length ? r2[0].loc : n2);
    function buildSlots(t2, e2, r2 = buildClientSlotFn) {
      e2.helper(qo);
      const { children: n2, loc: i2 } = t2, o2 = [], a2 = [];
      let s2 = e2.scopes.vSlot > 0 || e2.scopes.vFor > 0;
      !e2.ssr && e2.prefixIdentifiers && (s2 = hasScopeRef(t2, e2.identifiers));
      const l2 = findDir(t2, "slot", true);
      if (l2) {
        const { arg: t3, exp: e3 } = l2;
        t3 && !isStaticExp(t3) && (s2 = true), o2.push(createObjectProperty(t3 || createSimpleExpression("default", true), r2(e3, void 0, n2, i2)));
      }
      let p2 = false, c2 = false;
      const d2 = [], m2 = /* @__PURE__ */ new Set();
      let u2 = 0;
      for (let t3 = 0; t3 < n2.length; t3++) {
        const i3 = n2[t3];
        let h3;
        if (!isTemplateNode(i3) || !(h3 = findDir(i3, "slot", true))) {
          3 !== i3.type && d2.push(i3);
          continue;
        }
        if (l2) {
          e2.onError(createCompilerError(37, h3.loc));
          break;
        }
        p2 = true;
        const { children: g3, loc: x2 } = i3, { arg: v2 = createSimpleExpression("default", true), exp: y2, loc: b2 } = h3;
        let w2;
        isStaticExp(v2) ? w2 = v2 ? v2.content : "default" : s2 = true;
        const k2 = findDir(i3, "for"), S2 = r2(y2, null == k2 ? void 0 : k2.exp, g3, x2);
        let C2, _2;
        if (C2 = findDir(i3, "if"))
          s2 = true, a2.push(createConditionalExpression(C2.exp, buildDynamicSlot(v2, S2, u2++), ya));
        else if (_2 = findDir(i3, /^else(-if)?$/, true)) {
          let r3, i4 = t3;
          for (; i4-- && (r3 = n2[i4], 3 === r3.type); )
            ;
          if (r3 && isTemplateNode(r3) && findDir(r3, "if")) {
            n2.splice(t3, 1), t3--;
            let e3 = a2[a2.length - 1];
            for (; 19 === e3.alternate.type; )
              e3 = e3.alternate;
            e3.alternate = _2.exp ? createConditionalExpression(_2.exp, buildDynamicSlot(v2, S2, u2++), ya) : buildDynamicSlot(v2, S2, u2++);
          } else
            e2.onError(createCompilerError(30, _2.loc));
        } else if (k2) {
          s2 = true;
          const t4 = k2.parseResult || parseForExpression(k2.exp, e2);
          t4 ? a2.push(createCallExpression(e2.helper(Ao), [t4.source, createFunctionExpression(createForLoopParams(t4), buildDynamicSlot(v2, S2), true)])) : e2.onError(createCompilerError(32, k2.loc));
        } else {
          if (w2) {
            if (m2.has(w2)) {
              e2.onError(createCompilerError(38, b2));
              continue;
            }
            m2.add(w2), "default" === w2 && (c2 = true);
          }
          o2.push(createObjectProperty(v2, S2));
        }
      }
      if (!l2) {
        const buildDefaultSlotProperty = (t3, n3) => {
          const o3 = r2(t3, void 0, n3, i2);
          return e2.compatConfig && (o3.isNonScopedSlot = true), createObjectProperty("default", o3);
        };
        p2 ? d2.length && d2.some((t3) => isNonWhitespaceContent(t3)) && (c2 ? e2.onError(createCompilerError(39, d2[0].loc)) : o2.push(buildDefaultSlotProperty(void 0, d2))) : o2.push(buildDefaultSlotProperty(void 0, n2));
      }
      const h2 = s2 ? 2 : hasForwardedSlots(t2.children) ? 3 : 1;
      let g2 = createObjectExpression(o2.concat(createObjectProperty("_", createSimpleExpression(h2 + "", false))), i2);
      return a2.length && (g2 = createCallExpression(e2.helper(No), [g2, createArrayExpression(a2)])), { slots: g2, hasDynamicSlots: s2 };
    }
    function buildDynamicSlot(t2, e2, r2) {
      const n2 = [createObjectProperty("name", t2), createObjectProperty("fn", e2)];
      return null != r2 && n2.push(createObjectProperty("key", createSimpleExpression(String(r2), true))), createObjectExpression(n2);
    }
    function hasForwardedSlots(t2) {
      for (let e2 = 0; e2 < t2.length; e2++) {
        const r2 = t2[e2];
        switch (r2.type) {
          case 1:
            if (2 === r2.tagType || hasForwardedSlots(r2.children))
              return true;
            break;
          case 9:
            if (hasForwardedSlots(r2.branches))
              return true;
            break;
          case 10:
          case 11:
            if (hasForwardedSlots(r2.children))
              return true;
        }
      }
      return false;
    }
    function isNonWhitespaceContent(t2) {
      return 2 !== t2.type && 12 !== t2.type || (2 === t2.type ? !!t2.content.trim() : isNonWhitespaceContent(t2.content));
    }
    const ba = /* @__PURE__ */ new WeakMap(), transformElement = (t2, e2) => function() {
      if (1 !== (t2 = e2.currentNode).type || 0 !== t2.tagType && 1 !== t2.tagType)
        return;
      const { tag: r2, props: n2 } = t2, i2 = 1 === t2.tagType;
      let o2 = i2 ? resolveComponentType(t2, e2) : `"${r2}"`;
      const a2 = io.isObject(o2) && o2.callee === Eo;
      let s2, l2, p2, c2, d2, m2, u2 = 0, h2 = a2 || o2 === co || o2 === mo || !i2 && ("svg" === r2 || "foreignObject" === r2);
      if (n2.length > 0) {
        const r3 = buildProps(t2, e2, void 0, i2, a2);
        s2 = r3.props, u2 = r3.patchFlag, d2 = r3.dynamicPropNames;
        const n3 = r3.directives;
        m2 = n3 && n3.length ? createArrayExpression(n3.map((t3) => buildDirectiveArgs(t3, e2))) : void 0, r3.shouldUseBlock && (h2 = true);
      }
      if (t2.children.length > 0) {
        o2 === uo && (h2 = true, u2 |= 1024);
        if (i2 && o2 !== co && o2 !== uo) {
          const { slots: r3, hasDynamicSlots: n3 } = buildSlots(t2, e2);
          l2 = r3, n3 && (u2 |= 1024);
        } else if (1 === t2.children.length && o2 !== co) {
          const r3 = t2.children[0], n3 = r3.type, i3 = 5 === n3 || 8 === n3;
          i3 && 0 === getConstantType(r3, e2) && (u2 |= 1), l2 = i3 || 2 === n3 ? r3 : t2.children;
        } else
          l2 = t2.children;
      }
      0 !== u2 && (p2 = String(u2), d2 && d2.length && (c2 = function(t3) {
        let e3 = "[";
        for (let r3 = 0, n3 = t3.length; r3 < n3; r3++)
          e3 += JSON.stringify(t3[r3]), r3 < n3 - 1 && (e3 += ", ");
        return e3 + "]";
      }(d2))), t2.codegenNode = createVNodeCall(e2, o2, s2, l2, p2, c2, m2, !!h2, false, i2, t2.loc);
    };
    function resolveComponentType(t2, e2, r2 = false) {
      let { tag: n2 } = t2;
      const i2 = isComponentTag(n2), o2 = findProp(t2, "is");
      if (o2)
        if (i2 || isCompatEnabled("COMPILER_IS_ON_ELEMENT", e2)) {
          const t3 = 6 === o2.type ? o2.value && createSimpleExpression(o2.value.content, true) : o2.exp;
          if (t3)
            return createCallExpression(e2.helper(Eo), [t3]);
        } else
          6 === o2.type && o2.value.content.startsWith("vue:") && (n2 = o2.value.content.slice(4));
      const a2 = !i2 && findDir(t2, "is");
      if (a2 && a2.exp)
        return createCallExpression(e2.helper(Eo), [a2.exp]);
      const s2 = isCoreComponent(n2) || e2.isBuiltInComponent(n2);
      if (s2)
        return r2 || e2.helper(s2), s2;
      {
        const t3 = resolveSetupReference(n2, e2);
        if (t3)
          return t3;
        const r3 = n2.indexOf(".");
        if (r3 > 0) {
          const t4 = resolveSetupReference(n2.slice(0, r3), e2);
          if (t4)
            return t4 + n2.slice(r3);
        }
      }
      return e2.selfName && io.capitalize(io.camelize(n2)) === e2.selfName ? (e2.helper(Co), e2.components.add(n2 + "__self"), toValidAssetId(n2, "component")) : (e2.helper(Co), e2.components.add(n2), toValidAssetId(n2, "component"));
    }
    function resolveSetupReference(t2, e2) {
      const r2 = e2.bindingMetadata;
      if (!r2 || false === r2.__isScriptSetup)
        return;
      const n2 = io.camelize(t2), i2 = io.capitalize(n2), checkType = (e3) => r2[t2] === e3 ? t2 : r2[n2] === e3 ? n2 : r2[i2] === e3 ? i2 : void 0, o2 = checkType("setup-const") || checkType("setup-reactive-const") || checkType("literal-const");
      if (o2)
        return e2.inline ? o2 : `$setup[${JSON.stringify(o2)}]`;
      const a2 = checkType("setup-let") || checkType("setup-ref") || checkType("setup-maybe-ref");
      if (a2)
        return e2.inline ? `${e2.helperString(Wo)}(${a2})` : `$setup[${JSON.stringify(a2)}]`;
      const s2 = checkType("props");
      return s2 ? `${e2.helperString(Wo)}(${e2.inline ? "__props" : "$props"}[${JSON.stringify(s2)}])` : void 0;
    }
    function buildProps(t2, e2, r2 = t2.props, n2, i2, o2 = false) {
      const { tag: a2, loc: s2, children: l2 } = t2;
      let p2 = [];
      const c2 = [], d2 = [], m2 = l2.length > 0;
      let u2 = false, h2 = 0, g2 = false, x2 = false, v2 = false, y2 = false, b2 = false, w2 = false;
      const k2 = [], pushMergeArg = (t3) => {
        p2.length && (c2.push(createObjectExpression(dedupeProperties(p2), s2)), p2 = []), t3 && c2.push(t3);
      }, analyzePatchFlag = ({ key: t3, value: r3 }) => {
        if (isStaticExp(t3)) {
          const o3 = t3.content, a3 = io.isOn(o3);
          if (!a3 || n2 && !i2 || "onclick" === o3.toLowerCase() || "onUpdate:modelValue" === o3 || io.isReservedProp(o3) || (y2 = true), a3 && io.isReservedProp(o3) && (w2 = true), a3 && 14 === r3.type && (r3 = r3.arguments[0]), 20 === r3.type || (4 === r3.type || 8 === r3.type) && getConstantType(r3, e2) > 0)
            return;
          "ref" === o3 ? g2 = true : "class" === o3 ? x2 = true : "style" === o3 ? v2 = true : "key" === o3 || k2.includes(o3) || k2.push(o3), !n2 || "class" !== o3 && "style" !== o3 || k2.includes(o3) || k2.push(o3);
        } else
          b2 = true;
      };
      for (let i3 = 0; i3 < r2.length; i3++) {
        const l3 = r2[i3];
        if (6 === l3.type) {
          const { loc: t3, name: r3, value: n3 } = l3;
          let i4 = true;
          if ("ref" === r3 && (g2 = true, e2.scopes.vFor > 0 && p2.push(createObjectProperty(createSimpleExpression("ref_for", true), createSimpleExpression("true"))), n3 && e2.inline)) {
            const t4 = e2.bindingMetadata[n3.content];
            "setup-let" !== t4 && "setup-ref" !== t4 && "setup-maybe-ref" !== t4 || (i4 = false, p2.push(createObjectProperty(createSimpleExpression("ref_key", true), createSimpleExpression(n3.content, true, n3.loc))));
          }
          if ("is" === r3 && (isComponentTag(a2) || n3 && n3.content.startsWith("vue:") || isCompatEnabled("COMPILER_IS_ON_ELEMENT", e2)))
            continue;
          p2.push(createObjectProperty(createSimpleExpression(r3, true, getInnerRange(t3, 0, r3.length)), createSimpleExpression(n3 ? n3.content : "", i4, n3 ? n3.loc : t3)));
        } else {
          const { name: r3, arg: i4, exp: g3, loc: x3, modifiers: v3 } = l3, y3 = "bind" === r3, w3 = "on" === r3;
          if ("slot" === r3) {
            n2 || e2.onError(createCompilerError(40, x3));
            continue;
          }
          if ("once" === r3 || "memo" === r3)
            continue;
          if ("is" === r3 || y3 && isStaticArgOf(i4, "is") && (isComponentTag(a2) || isCompatEnabled("COMPILER_IS_ON_ELEMENT", e2)))
            continue;
          if (w3 && o2)
            continue;
          if ((y3 && isStaticArgOf(i4, "key") || w3 && m2 && isStaticArgOf(i4, "vue:before-update")) && (u2 = true), y3 && isStaticArgOf(i4, "ref") && e2.scopes.vFor > 0 && p2.push(createObjectProperty(createSimpleExpression("ref_for", true), createSimpleExpression("true"))), !i4 && (y3 || w3)) {
            if (b2 = true, g3)
              if (y3) {
                if (pushMergeArg(), isCompatEnabled("COMPILER_V_BIND_OBJECT_ORDER", e2)) {
                  c2.unshift(g3);
                  continue;
                }
                c2.push(g3);
              } else
                pushMergeArg({ type: 14, loc: x3, callee: e2.helper(jo), arguments: n2 ? [g3] : [g3, "true"] });
            else
              e2.onError(createCompilerError(y3 ? 34 : 35, x3));
            continue;
          }
          y3 && v3.includes("prop") && (h2 |= 32);
          const k3 = e2.directiveTransforms[r3];
          if (k3) {
            const { props: r4, needRuntime: n3 } = k3(l3, t2, e2);
            !o2 && r4.forEach(analyzePatchFlag), w3 && i4 && !isStaticExp(i4) ? pushMergeArg(createObjectExpression(r4, s2)) : p2.push(...r4), n3 && (d2.push(l3), io.isSymbol(n3) && ba.set(l3, n3));
          } else
            io.isBuiltInDirective(r3) || (d2.push(l3), m2 && (u2 = true));
        }
      }
      let S2;
      if (c2.length ? (pushMergeArg(), S2 = c2.length > 1 ? createCallExpression(e2.helper(Oo), c2, s2) : c2[0]) : p2.length && (S2 = createObjectExpression(dedupeProperties(p2), s2)), b2 ? h2 |= 16 : (x2 && !n2 && (h2 |= 2), v2 && !n2 && (h2 |= 4), k2.length && (h2 |= 8), y2 && (h2 |= 32)), u2 || 0 !== h2 && 32 !== h2 || !(g2 || w2 || d2.length > 0) || (h2 |= 512), !e2.inSSR && S2)
        switch (S2.type) {
          case 15:
            let t3 = -1, r3 = -1, n3 = false;
            for (let e3 = 0; e3 < S2.properties.length; e3++) {
              const i4 = S2.properties[e3].key;
              isStaticExp(i4) ? "class" === i4.content ? t3 = e3 : "style" === i4.content && (r3 = e3) : i4.isHandlerKey || (n3 = true);
            }
            const i3 = S2.properties[t3], o3 = S2.properties[r3];
            n3 ? S2 = createCallExpression(e2.helper(Bo), [S2]) : (i3 && !isStaticExp(i3.value) && (i3.value = createCallExpression(e2.helper(Lo), [i3.value])), o3 && (v2 || 4 === o3.value.type && "[" === o3.value.content.trim()[0] || 17 === o3.value.type) && (o3.value = createCallExpression(e2.helper(Mo), [o3.value])));
            break;
          case 14:
            break;
          default:
            S2 = createCallExpression(e2.helper(Bo), [createCallExpression(e2.helper(Do), [S2])]);
        }
      return { props: S2, directives: d2, patchFlag: h2, dynamicPropNames: k2, shouldUseBlock: u2 };
    }
    function dedupeProperties(t2) {
      const e2 = /* @__PURE__ */ new Map(), r2 = [];
      for (let n2 = 0; n2 < t2.length; n2++) {
        const i2 = t2[n2];
        if (8 === i2.key.type || !i2.key.isStatic) {
          r2.push(i2);
          continue;
        }
        const o2 = i2.key.content, a2 = e2.get(o2);
        a2 ? ("style" === o2 || "class" === o2 || io.isOn(o2)) && mergeAsArray(a2, i2) : (e2.set(o2, i2), r2.push(i2));
      }
      return r2;
    }
    function mergeAsArray(t2, e2) {
      17 === t2.value.type ? t2.value.elements.push(e2.value) : t2.value = createArrayExpression([t2.value, e2.value], t2.loc);
    }
    function buildDirectiveArgs(t2, e2) {
      const r2 = [], n2 = ba.get(t2);
      if (n2)
        r2.push(e2.helperString(n2));
      else {
        const n3 = resolveSetupReference("v-" + t2.name, e2);
        n3 ? r2.push(n3) : (e2.helper(_o), e2.directives.add(t2.name), r2.push(toValidAssetId(t2.name, "directive")));
      }
      const { loc: i2 } = t2;
      if (t2.exp && r2.push(t2.exp), t2.arg && (t2.exp || r2.push("void 0"), r2.push(t2.arg)), Object.keys(t2.modifiers).length) {
        t2.arg || (t2.exp || r2.push("void 0"), r2.push("void 0"));
        const e3 = createSimpleExpression("true", false, i2);
        r2.push(createObjectExpression(t2.modifiers.map((t3) => createObjectProperty(t3, e3)), i2));
      }
      return createArrayExpression(r2, t2.loc);
    }
    function isComponentTag(t2) {
      return "component" === t2 || "Component" === t2;
    }
    const transformSlotOutlet = (t2, e2) => {
      if (isSlotOutlet(t2)) {
        const { children: r2, loc: n2 } = t2, { slotName: i2, slotProps: o2 } = processSlotOutlet(t2, e2), a2 = [e2.prefixIdentifiers ? "_ctx.$slots" : "$slots", i2, "{}", "undefined", "true"];
        let s2 = 2;
        o2 && (a2[2] = o2, s2 = 3), r2.length && (a2[3] = createFunctionExpression([], r2, false, false, n2), s2 = 4), e2.scopeId && !e2.slotted && (s2 = 5), a2.splice(s2), t2.codegenNode = createCallExpression(e2.helper(Io), a2, n2);
      }
    };
    function processSlotOutlet(t2, e2) {
      let r2, n2 = '"default"';
      const i2 = [];
      for (let e3 = 0; e3 < t2.props.length; e3++) {
        const r3 = t2.props[e3];
        6 === r3.type ? r3.value && ("name" === r3.name ? n2 = JSON.stringify(r3.value.content) : (r3.name = io.camelize(r3.name), i2.push(r3))) : "bind" === r3.name && isStaticArgOf(r3.arg, "name") ? r3.exp && (n2 = r3.exp) : ("bind" === r3.name && r3.arg && isStaticExp(r3.arg) && (r3.arg.content = io.camelize(r3.arg.content)), i2.push(r3));
      }
      if (i2.length > 0) {
        const { props: n3, directives: o2 } = buildProps(t2, e2, i2, false, false);
        r2 = n3, o2.length && e2.onError(createCompilerError(36, o2[0].loc));
      }
      return { slotName: n2, slotProps: r2 };
    }
    const wa = /^\s*([\w$_]+|(async\s*)?\([^)]*?\))\s*(:[^=]+)?=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/, transformOn = (t2, e2, r2, n2) => {
      const { loc: i2, modifiers: o2, arg: a2 } = t2;
      let s2;
      if (t2.exp || o2.length || r2.onError(createCompilerError(35, i2)), 4 === a2.type)
        if (a2.isStatic) {
          let t3 = a2.content;
          t3.startsWith("vue:") && (t3 = `vnode-${t3.slice(4)}`);
          s2 = createSimpleExpression(0 !== e2.tagType || t3.startsWith("vnode") || !/[A-Z]/.test(t3) ? io.toHandlerKey(io.camelize(t3)) : `on:${t3}`, true, a2.loc);
        } else
          s2 = createCompoundExpression([`${r2.helperString(Vo)}(`, a2, ")"]);
      else
        s2 = a2, s2.children.unshift(`${r2.helperString(Vo)}(`), s2.children.push(")");
      let l2 = t2.exp;
      l2 && !l2.content.trim() && (l2 = void 0);
      let p2 = r2.cacheHandlers && !l2 && !r2.inVOnce;
      if (l2) {
        const n3 = ra(l2.content, r2), i3 = !(n3 || wa.test(l2.content)), o3 = l2.content.includes(";");
        r2.prefixIdentifiers && (i3 && r2.addIdentifiers("$event"), l2 = t2.exp = processExpression(l2, r2, false, o3), i3 && r2.removeIdentifiers("$event"), p2 = r2.cacheHandlers && !r2.inVOnce && !(4 === l2.type && l2.constType > 0) && !(n3 && 1 === e2.tagType) && !hasScopeRef(l2, r2.identifiers), p2 && n3 && (4 === l2.type ? l2.content = `${l2.content} && ${l2.content}(...args)` : l2.children = [...l2.children, " && ", ...l2.children, "(...args)"])), (i3 || p2 && n3) && (l2 = createCompoundExpression([`${i3 ? r2.isTS ? "($event: any)" : "$event" : (r2.isTS ? "\n//@ts-ignore\n" : "") + "(...args)"} => ${o3 ? "{" : "("}`, l2, o3 ? "}" : ")"]));
      }
      let c2 = { props: [createObjectProperty(s2, l2 || createSimpleExpression("() => {}", false, i2))] };
      return n2 && (c2 = n2(c2)), p2 && (c2.props[0].value = r2.cache(c2.props[0].value)), c2.props.forEach((t3) => t3.key.isHandlerKey = true), c2;
    }, transformBind = (t2, e2, r2) => {
      const { exp: n2, modifiers: i2, loc: o2 } = t2, a2 = t2.arg;
      return 4 !== a2.type ? (a2.children.unshift("("), a2.children.push(') || ""')) : a2.isStatic || (a2.content = `${a2.content} || ""`), i2.includes("camel") && (4 === a2.type ? a2.isStatic ? a2.content = io.camelize(a2.content) : a2.content = `${r2.helperString(Fo)}(${a2.content})` : (a2.children.unshift(`${r2.helperString(Fo)}(`), a2.children.push(")"))), r2.inSSR || (i2.includes("prop") && injectPrefix(a2, "."), i2.includes("attr") && injectPrefix(a2, "^")), !n2 || 4 === n2.type && !n2.content.trim() ? (r2.onError(createCompilerError(34, o2)), { props: [createObjectProperty(a2, createSimpleExpression("", true, o2))] }) : { props: [createObjectProperty(a2, n2)] };
    }, injectPrefix = (t2, e2) => {
      4 === t2.type ? t2.isStatic ? t2.content = e2 + t2.content : t2.content = `\`${e2}\${${t2.content}}\`` : (t2.children.unshift(`'${e2}' + (`), t2.children.push(")"));
    }, transformText = (t2, e2) => {
      if (0 === t2.type || 1 === t2.type || 11 === t2.type || 10 === t2.type)
        return () => {
          const r2 = t2.children;
          let n2, i2 = false;
          for (let t3 = 0; t3 < r2.length; t3++) {
            const e3 = r2[t3];
            if (isText$1(e3)) {
              i2 = true;
              for (let i3 = t3 + 1; i3 < r2.length; i3++) {
                const o2 = r2[i3];
                if (!isText$1(o2)) {
                  n2 = void 0;
                  break;
                }
                n2 || (n2 = r2[t3] = createCompoundExpression([e3], e3.loc)), n2.children.push(" + ", o2), r2.splice(i3, 1), i3--;
              }
            }
          }
          if (i2 && (1 !== r2.length || 0 !== t2.type && (1 !== t2.type || 0 !== t2.tagType || t2.props.find((t3) => 7 === t3.type && !e2.directiveTransforms[t3.name]) || "template" === t2.tag)))
            for (let t3 = 0; t3 < r2.length; t3++) {
              const n3 = r2[t3];
              if (isText$1(n3) || 8 === n3.type) {
                const i3 = [];
                2 === n3.type && " " === n3.content || i3.push(n3), e2.ssr || 0 !== getConstantType(n3, e2) || i3.push("1"), r2[t3] = { type: 12, content: n3, loc: n3.loc, codegenNode: createCallExpression(e2.helper(ko), i3) };
              }
            }
        };
    }, ka = /* @__PURE__ */ new WeakSet(), transformOnce = (t2, e2) => {
      if (1 === t2.type && findDir(t2, "once", true)) {
        if (ka.has(t2) || e2.inVOnce || e2.inSSR)
          return;
        return ka.add(t2), e2.inVOnce = true, e2.helper(zo), () => {
          e2.inVOnce = false;
          const t3 = e2.currentNode;
          t3.codegenNode && (t3.codegenNode = e2.cache(t3.codegenNode, true));
        };
      }
    }, transformModel = (t2, e2, r2) => {
      const { exp: n2, arg: i2 } = t2;
      if (!n2)
        return r2.onError(createCompilerError(41, t2.loc)), createTransformProps();
      const o2 = n2.loc.source, a2 = 4 === n2.type ? n2.content : o2, s2 = r2.bindingMetadata[o2];
      if ("props" === s2 || "props-aliased" === s2)
        return r2.onError(createCompilerError(44, n2.loc)), createTransformProps();
      const l2 = r2.inline && ("setup-let" === s2 || "setup-ref" === s2 || "setup-maybe-ref" === s2);
      if (!a2.trim() || !ra(a2, r2) && !l2)
        return r2.onError(createCompilerError(42, n2.loc)), createTransformProps();
      if (r2.prefixIdentifiers && isSimpleIdentifier(a2) && r2.identifiers[a2])
        return r2.onError(createCompilerError(43, n2.loc)), createTransformProps();
      const p2 = i2 || createSimpleExpression("modelValue", true), c2 = i2 ? isStaticExp(i2) ? `onUpdate:${io.camelize(i2.content)}` : createCompoundExpression(['"onUpdate:" + ', i2]) : "onUpdate:modelValue";
      let d2;
      const m2 = r2.isTS ? "($event: any)" : "$event";
      if (l2)
        if ("setup-ref" === s2)
          d2 = createCompoundExpression([`${m2} => ((`, createSimpleExpression(o2, false, n2.loc), ").value = $event)"]);
        else {
          const t3 = "setup-let" === s2 ? `${o2} = $event` : "null";
          d2 = createCompoundExpression([`${m2} => (${r2.helperString(Ko)}(${o2}) ? (`, createSimpleExpression(o2, false, n2.loc), `).value = $event : ${t3})`]);
        }
      else
        d2 = createCompoundExpression([`${m2} => ((`, n2, ") = $event)"]);
      const u2 = [createObjectProperty(p2, t2.exp), createObjectProperty(c2, d2)];
      if (r2.prefixIdentifiers && !r2.inVOnce && r2.cacheHandlers && !hasScopeRef(n2, r2.identifiers) && (u2[1].value = r2.cache(u2[1].value)), t2.modifiers.length && 1 === e2.tagType) {
        const e3 = t2.modifiers.map((t3) => (isSimpleIdentifier(t3) ? t3 : JSON.stringify(t3)) + ": true").join(", "), r3 = i2 ? isStaticExp(i2) ? `${i2.content}Modifiers` : createCompoundExpression([i2, ' + "Modifiers"']) : "modelModifiers";
        u2.push(createObjectProperty(r3, createSimpleExpression(`{ ${e3} }`, false, t2.loc, 2)));
      }
      return createTransformProps(u2);
    };
    function createTransformProps(t2 = []) {
      return { props: t2 };
    }
    const Sa = /[\w).+\-_$\]]/, transformFilter = (t2, e2) => {
      isCompatEnabled("COMPILER_FILTER", e2) && (5 === t2.type && rewriteFilter(t2.content, e2), 1 === t2.type && t2.props.forEach((t3) => {
        7 === t3.type && "for" !== t3.name && t3.exp && rewriteFilter(t3.exp, e2);
      }));
    };
    function rewriteFilter(t2, e2) {
      if (4 === t2.type)
        parseFilter(t2, e2);
      else
        for (let r2 = 0; r2 < t2.children.length; r2++) {
          const n2 = t2.children[r2];
          "object" == typeof n2 && (4 === n2.type ? parseFilter(n2, e2) : 8 === n2.type ? rewriteFilter(t2, e2) : 5 === n2.type && rewriteFilter(n2.content, e2));
        }
    }
    function parseFilter(t2, e2) {
      const r2 = t2.content;
      let n2, i2, o2, a2, s2 = false, l2 = false, p2 = false, c2 = false, d2 = 0, m2 = 0, u2 = 0, h2 = 0, g2 = [];
      for (o2 = 0; o2 < r2.length; o2++)
        if (i2 = n2, n2 = r2.charCodeAt(o2), s2)
          39 === n2 && 92 !== i2 && (s2 = false);
        else if (l2)
          34 === n2 && 92 !== i2 && (l2 = false);
        else if (p2)
          96 === n2 && 92 !== i2 && (p2 = false);
        else if (c2)
          47 === n2 && 92 !== i2 && (c2 = false);
        else if (124 !== n2 || 124 === r2.charCodeAt(o2 + 1) || 124 === r2.charCodeAt(o2 - 1) || d2 || m2 || u2) {
          switch (n2) {
            case 34:
              l2 = true;
              break;
            case 39:
              s2 = true;
              break;
            case 96:
              p2 = true;
              break;
            case 40:
              u2++;
              break;
            case 41:
              u2--;
              break;
            case 91:
              m2++;
              break;
            case 93:
              m2--;
              break;
            case 123:
              d2++;
              break;
            case 125:
              d2--;
          }
          if (47 === n2) {
            let t3, e3 = o2 - 1;
            for (; e3 >= 0 && (t3 = r2.charAt(e3), " " === t3); e3--)
              ;
            t3 && Sa.test(t3) || (c2 = true);
          }
        } else
          void 0 === a2 ? (h2 = o2 + 1, a2 = r2.slice(0, o2).trim()) : pushFilter();
      function pushFilter() {
        g2.push(r2.slice(h2, o2).trim()), h2 = o2 + 1;
      }
      if (void 0 === a2 ? a2 = r2.slice(0, o2).trim() : 0 !== h2 && pushFilter(), g2.length) {
        for (o2 = 0; o2 < g2.length; o2++)
          a2 = wrapFilter(a2, g2[o2], e2);
        t2.content = a2;
      }
    }
    function wrapFilter(t2, e2, r2) {
      r2.helper(Po);
      const n2 = e2.indexOf("(");
      if (n2 < 0)
        return r2.filters.add(e2), `${toValidAssetId(e2, "filter")}(${t2})`;
      {
        const i2 = e2.slice(0, n2), o2 = e2.slice(n2 + 1);
        return r2.filters.add(i2), `${toValidAssetId(i2, "filter")}(${t2}${")" !== o2 ? "," + o2 : o2}`;
      }
    }
    const Ca = /* @__PURE__ */ new WeakSet(), transformMemo = (t2, e2) => {
      if (1 === t2.type) {
        const r2 = findDir(t2, "memo");
        if (!r2 || Ca.has(t2))
          return;
        return Ca.add(t2), () => {
          const n2 = t2.codegenNode || e2.currentNode.codegenNode;
          n2 && 13 === n2.type && (1 !== t2.tagType && convertToBlock(n2, e2), t2.codegenNode = createCallExpression(e2.helper(Go), [r2.exp, createFunctionExpression(void 0, n2), "_cache", String(e2.cached++)]));
        };
      }
    };
    function getBaseTransformPreset(t2) {
      return [[transformOnce, fa, transformMemo, ga, transformFilter, ...t2 ? [trackVForSlotScopes, transformExpression] : [], transformSlotOutlet, transformElement, trackSlotScopes, transformText], { on: transformOn, bind: transformBind, model: transformModel }];
    }
    an.generateCodeFrame = io.generateCodeFrame, an.BASE_TRANSITION = ho, an.CAMELIZE = Fo, an.CAPITALIZE = $o, an.CREATE_BLOCK = xo, an.CREATE_COMMENT = wo, an.CREATE_ELEMENT_BLOCK = vo, an.CREATE_ELEMENT_VNODE = bo, an.CREATE_SLOTS = No, an.CREATE_STATIC = So, an.CREATE_TEXT = ko, an.CREATE_VNODE = yo, an.FRAGMENT = po, an.GUARD_REACTIVE_PROPS = Do, an.IS_MEMO_SAME = Jo, an.IS_REF = Ko, an.KEEP_ALIVE = uo, an.MERGE_PROPS = Oo, an.NORMALIZE_CLASS = Lo, an.NORMALIZE_PROPS = Bo, an.NORMALIZE_STYLE = Mo, an.OPEN_BLOCK = fo, an.POP_SCOPE_ID = Ho, an.PUSH_SCOPE_ID = Uo, an.RENDER_LIST = Ao, an.RENDER_SLOT = Io, an.RESOLVE_COMPONENT = Co, an.RESOLVE_DIRECTIVE = _o, an.RESOLVE_DYNAMIC_COMPONENT = Eo, an.RESOLVE_FILTER = Po, an.SET_BLOCK_TRACKING = zo, an.SUSPENSE = mo, an.TELEPORT = co, an.TO_DISPLAY_STRING = Ro, an.TO_HANDLERS = jo, an.TO_HANDLER_KEY = Vo, an.TS_NODE_TYPES = ma, an.UNREF = Wo, an.WITH_CTX = qo, an.WITH_DIRECTIVES = To, an.WITH_MEMO = Go, an.advancePositionWithClone = advancePositionWithClone, an.advancePositionWithMutation = advancePositionWithMutation, an.assert = function(t2, e2) {
      if (!t2)
        throw new Error(e2 || "unexpected compiler condition");
    }, an.baseCompile = function(t2, e2 = {}) {
      const r2 = e2.onError || defaultOnError, n2 = "module" === e2.mode, i2 = true === e2.prefixIdentifiers || n2;
      !i2 && e2.cacheHandlers && r2(createCompilerError(49)), e2.scopeId && !n2 && r2(createCompilerError(50));
      const o2 = io.isString(t2) ? baseParse(t2, e2) : t2, [a2, s2] = getBaseTransformPreset(i2);
      if (e2.isTS) {
        const { expressionPlugins: t3 } = e2;
        t3 && t3.includes("typescript") || (e2.expressionPlugins = [...t3 || [], "typescript"]);
      }
      return transform$2(o2, io.extend({}, e2, { prefixIdentifiers: i2, nodeTransforms: [...a2, ...e2.nodeTransforms || []], directiveTransforms: io.extend({}, s2, e2.directiveTransforms || {}) })), generate(o2, io.extend({}, e2, { prefixIdentifiers: i2 }));
    }, an.baseParse = baseParse, an.buildDirectiveArgs = buildDirectiveArgs, an.buildProps = buildProps, an.buildSlots = buildSlots, an.checkCompatEnabled = checkCompatEnabled, an.convertToBlock = convertToBlock, an.createArrayExpression = createArrayExpression, an.createAssignmentExpression = function(t2, e2) {
      return { type: 24, left: t2, right: e2, loc: Xo };
    }, an.createBlockStatement = createBlockStatement, an.createCacheExpression = createCacheExpression, an.createCallExpression = createCallExpression, an.createCompilerError = createCompilerError, an.createCompoundExpression = createCompoundExpression, an.createConditionalExpression = createConditionalExpression, an.createForLoopParams = createForLoopParams, an.createFunctionExpression = createFunctionExpression, an.createIfStatement = function(t2, e2, r2) {
      return { type: 23, test: t2, consequent: e2, alternate: r2, loc: Xo };
    }, an.createInterpolation = function(t2, e2) {
      return { type: 5, loc: e2, content: io.isString(t2) ? createSimpleExpression(t2, false, e2) : t2 };
    }, an.createObjectExpression = createObjectExpression, an.createObjectProperty = createObjectProperty, an.createReturnStatement = function(t2) {
      return { type: 26, returns: t2, loc: Xo };
    }, an.createRoot = createRoot, an.createSequenceExpression = function(t2) {
      return { type: 25, expressions: t2, loc: Xo };
    }, an.createSimpleExpression = createSimpleExpression, an.createStructuralDirectiveTransform = createStructuralDirectiveTransform, an.createTemplateLiteral = function(t2) {
      return { type: 22, elements: t2, loc: Xo };
    }, an.createTransformContext = createTransformContext, an.createVNodeCall = createVNodeCall, an.extractIdentifiers = extractIdentifiers, an.findDir = findDir, an.findProp = findProp, an.forAliasRE = ia, an.generate = generate, an.getBaseTransformPreset = getBaseTransformPreset, an.getConstantType = getConstantType, an.getInnerRange = getInnerRange, an.getMemoedVNodeCall = getMemoedVNodeCall, an.getVNodeBlockHelper = getVNodeBlockHelper, an.getVNodeHelper = getVNodeHelper, an.hasDynamicKeyVBind = function(t2) {
      return t2.props.some((t3) => !(7 !== t3.type || "bind" !== t3.name || t3.arg && 4 === t3.arg.type && t3.arg.isStatic));
    }, an.hasScopeRef = hasScopeRef, an.helperNameMap = Yo, an.injectProp = injectProp, an.isBuiltInType = isBuiltInType, an.isCoreComponent = isCoreComponent, an.isFunctionType = isFunctionType, an.isInDestructureAssignment = isInDestructureAssignment, an.isMemberExpression = ra, an.isMemberExpressionBrowser = (t2) => {
      t2 = t2.trim().replace(ea, (t3) => t3.trim());
      let e2 = 0, r2 = [], n2 = 0, i2 = 0, o2 = null;
      for (let a2 = 0; a2 < t2.length; a2++) {
        const s2 = t2.charAt(a2);
        switch (e2) {
          case 0:
            if ("[" === s2)
              r2.push(e2), e2 = 1, n2++;
            else if ("(" === s2)
              r2.push(e2), e2 = 2, i2++;
            else if (!(0 === a2 ? Zo : ta).test(s2))
              return false;
            break;
          case 1:
            "'" === s2 || '"' === s2 || "`" === s2 ? (r2.push(e2), e2 = 3, o2 = s2) : "[" === s2 ? n2++ : "]" === s2 && (--n2 || (e2 = r2.pop()));
            break;
          case 2:
            if ("'" === s2 || '"' === s2 || "`" === s2)
              r2.push(e2), e2 = 3, o2 = s2;
            else if ("(" === s2)
              i2++;
            else if (")" === s2) {
              if (a2 === t2.length - 1)
                return false;
              --i2 || (e2 = r2.pop());
            }
            break;
          case 3:
            s2 === o2 && (e2 = r2.pop(), o2 = null);
        }
      }
      return !n2 && !i2;
    }, an.isMemberExpressionNode = isMemberExpressionNode, an.isReferencedIdentifier = isReferencedIdentifier, an.isSimpleIdentifier = isSimpleIdentifier, an.isSlotOutlet = isSlotOutlet, an.isStaticArgOf = isStaticArgOf, an.isStaticExp = isStaticExp, an.isStaticProperty = isStaticProperty, an.isStaticPropertyKey = isStaticPropertyKey, an.isTemplateNode = isTemplateNode, an.isText = isText$1, an.isVSlot = isVSlot, an.locStub = Xo, an.noopDirectiveTransform = () => ({ props: [] }), an.processExpression = processExpression, an.processFor = processFor, an.processIf = processIf, an.processSlotOutlet = processSlotOutlet, an.registerRuntimeHelpers = function(t2) {
      Object.getOwnPropertySymbols(t2).forEach((e2) => {
        Yo[e2] = t2[e2];
      });
    }, an.resolveComponentType = resolveComponentType, an.stringifyExpression = stringifyExpression, an.toValidAssetId = toValidAssetId, an.trackSlotScopes = trackSlotScopes, an.trackVForSlotScopes = trackVForSlotScopes, an.transform = transform$2, an.transformBind = transformBind, an.transformElement = transformElement, an.transformExpression = transformExpression, an.transformModel = transformModel, an.transformOn = transformOn, an.traverseNode = traverseNode, an.walkBlockDeclarations = walkBlockDeclarations, an.walkFunctionParams = walkFunctionParams, an.walkIdentifiers = walkIdentifiers, an.warnDeprecation = function(t2, e2, r2, ...n2) {
      if ("suppress-warning" === getCompatValue(t2, e2))
        return;
      const { message: i2, link: o2 } = oa[t2], a2 = `(deprecation ${t2}) ${"function" == typeof i2 ? i2(...n2) : i2}${o2 ? `
  Details: ${o2}` : ""}`, s2 = new SyntaxError(a2);
      s2.code = t2, r2 && (s2.loc = r2), e2.onWarn(s2);
    }, on.exports = an;
    var Ea = on.exports;
    !function(t2) {
      Object.defineProperty(t2, "__esModule", { value: true });
      var e2 = Ea, r2 = gr;
      const n2 = Symbol(""), i2 = Symbol(""), o2 = Symbol(""), a2 = Symbol(""), s2 = Symbol(""), l2 = Symbol(""), p2 = Symbol(""), c2 = Symbol(""), d2 = Symbol(""), m2 = Symbol("");
      e2.registerRuntimeHelpers({ [n2]: "vModelRadio", [i2]: "vModelCheckbox", [o2]: "vModelText", [a2]: "vModelSelect", [s2]: "vModelDynamic", [l2]: "withModifiers", [p2]: "withKeys", [c2]: "vShow", [d2]: "Transition", [m2]: "TransitionGroup" });
      var u2 = { GT: ">", gt: ">", LT: "<", lt: "<", "ac;": "\u223E", "af;": "\u2061", AMP: "&", amp: "&", "ap;": "\u2248", "DD;": "\u2145", "dd;": "\u2146", deg: "\xB0", "ee;": "\u2147", "eg;": "\u2A9A", "el;": "\u2A99", ETH: "\xD0", eth: "\xF0", "gE;": "\u2267", "ge;": "\u2265", "Gg;": "\u22D9", "gg;": "\u226B", "gl;": "\u2277", "GT;": ">", "Gt;": "\u226B", "gt;": ">", "ic;": "\u2063", "ii;": "\u2148", "Im;": "\u2111", "in;": "\u2208", "it;": "\u2062", "lE;": "\u2266", "le;": "\u2264", "lg;": "\u2276", "Ll;": "\u22D8", "ll;": "\u226A", "LT;": "<", "Lt;": "\u226A", "lt;": "<", "mp;": "\u2213", "Mu;": "\u039C", "mu;": "\u03BC", "ne;": "\u2260", "ni;": "\u220B", not: "\xAC", "Nu;": "\u039D", "nu;": "\u03BD", "Or;": "\u2A54", "or;": "\u2228", "oS;": "\u24C8", "Pi;": "\u03A0", "pi;": "\u03C0", "pm;": "\xB1", "Pr;": "\u2ABB", "pr;": "\u227A", "Re;": "\u211C", REG: "\xAE", reg: "\xAE", "rx;": "\u211E", "Sc;": "\u2ABC", "sc;": "\u227B", shy: "\xAD", uml: "\xA8", "wp;": "\u2118", "wr;": "\u2240", "Xi;": "\u039E", "xi;": "\u03BE", yen: "\xA5", "acd;": "\u223F", "acE;": "\u223E\u0333", "Acy;": "\u0410", "acy;": "\u0430", "Afr;": "\u{1D504}", "afr;": "\u{1D51E}", "AMP;": "&", "amp;": "&", "And;": "\u2A53", "and;": "\u2227", "ang;": "\u2220", "apE;": "\u2A70", "ape;": "\u224A", "ast;": "*", Auml: "\xC4", auml: "\xE4", "Bcy;": "\u0411", "bcy;": "\u0431", "Bfr;": "\u{1D505}", "bfr;": "\u{1D51F}", "bne;": "=\u20E5", "bot;": "\u22A5", "Cap;": "\u22D2", "cap;": "\u2229", cent: "\xA2", "Cfr;": "\u212D", "cfr;": "\u{1D520}", "Chi;": "\u03A7", "chi;": "\u03C7", "cir;": "\u25CB", COPY: "\xA9", copy: "\xA9", "Cup;": "\u22D3", "cup;": "\u222A", "Dcy;": "\u0414", "dcy;": "\u0434", "deg;": "\xB0", "Del;": "\u2207", "Dfr;": "\u{1D507}", "dfr;": "\u{1D521}", "die;": "\xA8", "div;": "\xF7", "Dot;": "\xA8", "dot;": "\u02D9", "Ecy;": "\u042D", "ecy;": "\u044D", "Efr;": "\u{1D508}", "efr;": "\u{1D522}", "egs;": "\u2A96", "ell;": "\u2113", "els;": "\u2A95", "ENG;": "\u014A", "eng;": "\u014B", "Eta;": "\u0397", "eta;": "\u03B7", "ETH;": "\xD0", "eth;": "\xF0", Euml: "\xCB", euml: "\xEB", "Fcy;": "\u0424", "fcy;": "\u0444", "Ffr;": "\u{1D509}", "ffr;": "\u{1D523}", "gap;": "\u2A86", "Gcy;": "\u0413", "gcy;": "\u0433", "gEl;": "\u2A8C", "gel;": "\u22DB", "geq;": "\u2265", "ges;": "\u2A7E", "Gfr;": "\u{1D50A}", "gfr;": "\u{1D524}", "ggg;": "\u22D9", "gla;": "\u2AA5", "glE;": "\u2A92", "glj;": "\u2AA4", "gnE;": "\u2269", "gne;": "\u2A88", "Hat;": "^", "Hfr;": "\u210C", "hfr;": "\u{1D525}", "Icy;": "\u0418", "icy;": "\u0438", "iff;": "\u21D4", "Ifr;": "\u2111", "ifr;": "\u{1D526}", "Int;": "\u222C", "int;": "\u222B", Iuml: "\xCF", iuml: "\xEF", "Jcy;": "\u0419", "jcy;": "\u0439", "Jfr;": "\u{1D50D}", "jfr;": "\u{1D527}", "Kcy;": "\u041A", "kcy;": "\u043A", "Kfr;": "\u{1D50E}", "kfr;": "\u{1D528}", "lap;": "\u2A85", "lat;": "\u2AAB", "Lcy;": "\u041B", "lcy;": "\u043B", "lEg;": "\u2A8B", "leg;": "\u22DA", "leq;": "\u2264", "les;": "\u2A7D", "Lfr;": "\u{1D50F}", "lfr;": "\u{1D529}", "lgE;": "\u2A91", "lnE;": "\u2268", "lne;": "\u2A87", "loz;": "\u25CA", "lrm;": "\u200E", "Lsh;": "\u21B0", "lsh;": "\u21B0", macr: "\xAF", "Map;": "\u2905", "map;": "\u21A6", "Mcy;": "\u041C", "mcy;": "\u043C", "Mfr;": "\u{1D510}", "mfr;": "\u{1D52A}", "mho;": "\u2127", "mid;": "\u2223", "nap;": "\u2249", nbsp: "\xA0", "Ncy;": "\u041D", "ncy;": "\u043D", "Nfr;": "\u{1D511}", "nfr;": "\u{1D52B}", "ngE;": "\u2267\u0338", "nge;": "\u2271", "nGg;": "\u22D9\u0338", "nGt;": "\u226B\u20D2", "ngt;": "\u226F", "nis;": "\u22FC", "niv;": "\u220B", "nlE;": "\u2266\u0338", "nle;": "\u2270", "nLl;": "\u22D8\u0338", "nLt;": "\u226A\u20D2", "nlt;": "\u226E", "Not;": "\u2AEC", "not;": "\xAC", "npr;": "\u2280", "nsc;": "\u2281", "num;": "#", "Ocy;": "\u041E", "ocy;": "\u043E", "Ofr;": "\u{1D512}", "ofr;": "\u{1D52C}", "ogt;": "\u29C1", "ohm;": "\u03A9", "olt;": "\u29C0", "ord;": "\u2A5D", ordf: "\xAA", ordm: "\xBA", "orv;": "\u2A5B", Ouml: "\xD6", ouml: "\xF6", "par;": "\u2225", para: "\xB6", "Pcy;": "\u041F", "pcy;": "\u043F", "Pfr;": "\u{1D513}", "pfr;": "\u{1D52D}", "Phi;": "\u03A6", "phi;": "\u03C6", "piv;": "\u03D6", "prE;": "\u2AB3", "pre;": "\u2AAF", "Psi;": "\u03A8", "psi;": "\u03C8", "Qfr;": "\u{1D514}", "qfr;": "\u{1D52E}", QUOT: '"', quot: '"', "Rcy;": "\u0420", "rcy;": "\u0440", "REG;": "\xAE", "reg;": "\xAE", "Rfr;": "\u211C", "rfr;": "\u{1D52F}", "Rho;": "\u03A1", "rho;": "\u03C1", "rlm;": "\u200F", "Rsh;": "\u21B1", "rsh;": "\u21B1", "scE;": "\u2AB4", "sce;": "\u2AB0", "Scy;": "\u0421", "scy;": "\u0441", sect: "\xA7", "Sfr;": "\u{1D516}", "sfr;": "\u{1D530}", "shy;": "\xAD", "sim;": "\u223C", "smt;": "\u2AAA", "sol;": "/", "squ;": "\u25A1", "Sub;": "\u22D0", "sub;": "\u2282", "Sum;": "\u2211", "sum;": "\u2211", "Sup;": "\u22D1", "sup;": "\u2283", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", "Tab;": "	", "Tau;": "\u03A4", "tau;": "\u03C4", "Tcy;": "\u0422", "tcy;": "\u0442", "Tfr;": "\u{1D517}", "tfr;": "\u{1D531}", "top;": "\u22A4", "Ucy;": "\u0423", "ucy;": "\u0443", "Ufr;": "\u{1D518}", "ufr;": "\u{1D532}", "uml;": "\xA8", Uuml: "\xDC", uuml: "\xFC", "Vcy;": "\u0412", "vcy;": "\u0432", "Vee;": "\u22C1", "vee;": "\u2228", "Vfr;": "\u{1D519}", "vfr;": "\u{1D533}", "Wfr;": "\u{1D51A}", "wfr;": "\u{1D534}", "Xfr;": "\u{1D51B}", "xfr;": "\u{1D535}", "Ycy;": "\u042B", "ycy;": "\u044B", "yen;": "\xA5", "Yfr;": "\u{1D51C}", "yfr;": "\u{1D536}", yuml: "\xFF", "Zcy;": "\u0417", "zcy;": "\u0437", "Zfr;": "\u2128", "zfr;": "\u{1D537}", "zwj;": "\u200D", Acirc: "\xC2", acirc: "\xE2", acute: "\xB4", AElig: "\xC6", aelig: "\xE6", "andd;": "\u2A5C", "andv;": "\u2A5A", "ange;": "\u29A4", "Aopf;": "\u{1D538}", "aopf;": "\u{1D552}", "apid;": "\u224B", "apos;": "'", Aring: "\xC5", aring: "\xE5", "Ascr;": "\u{1D49C}", "ascr;": "\u{1D4B6}", "Auml;": "\xC4", "auml;": "\xE4", "Barv;": "\u2AE7", "bbrk;": "\u23B5", "Beta;": "\u0392", "beta;": "\u03B2", "beth;": "\u2136", "bNot;": "\u2AED", "bnot;": "\u2310", "Bopf;": "\u{1D539}", "bopf;": "\u{1D553}", "boxH;": "\u2550", "boxh;": "\u2500", "boxV;": "\u2551", "boxv;": "\u2502", "Bscr;": "\u212C", "bscr;": "\u{1D4B7}", "bsim;": "\u223D", "bsol;": "\\", "bull;": "\u2022", "bump;": "\u224E", "caps;": "\u2229\uFE00", "Cdot;": "\u010A", "cdot;": "\u010B", cedil: "\xB8", "cent;": "\xA2", "CHcy;": "\u0427", "chcy;": "\u0447", "circ;": "\u02C6", "cirE;": "\u29C3", "cire;": "\u2257", "comp;": "\u2201", "cong;": "\u2245", "Copf;": "\u2102", "copf;": "\u{1D554}", "COPY;": "\xA9", "copy;": "\xA9", "Cscr;": "\u{1D49E}", "cscr;": "\u{1D4B8}", "csub;": "\u2ACF", "csup;": "\u2AD0", "cups;": "\u222A\uFE00", "Darr;": "\u21A1", "dArr;": "\u21D3", "darr;": "\u2193", "dash;": "\u2010", "dHar;": "\u2965", "diam;": "\u22C4", "DJcy;": "\u0402", "djcy;": "\u0452", "Dopf;": "\u{1D53B}", "dopf;": "\u{1D555}", "Dscr;": "\u{1D49F}", "dscr;": "\u{1D4B9}", "DScy;": "\u0405", "dscy;": "\u0455", "dsol;": "\u29F6", "dtri;": "\u25BF", "DZcy;": "\u040F", "dzcy;": "\u045F", "ecir;": "\u2256", Ecirc: "\xCA", ecirc: "\xEA", "Edot;": "\u0116", "eDot;": "\u2251", "edot;": "\u0117", "emsp;": "\u2003", "ensp;": "\u2002", "Eopf;": "\u{1D53C}", "eopf;": "\u{1D556}", "epar;": "\u22D5", "epsi;": "\u03B5", "Escr;": "\u2130", "escr;": "\u212F", "Esim;": "\u2A73", "esim;": "\u2242", "Euml;": "\xCB", "euml;": "\xEB", "euro;": "\u20AC", "excl;": "!", "flat;": "\u266D", "fnof;": "\u0192", "Fopf;": "\u{1D53D}", "fopf;": "\u{1D557}", "fork;": "\u22D4", "Fscr;": "\u2131", "fscr;": "\u{1D4BB}", "Gdot;": "\u0120", "gdot;": "\u0121", "geqq;": "\u2267", "gesl;": "\u22DB\uFE00", "GJcy;": "\u0403", "gjcy;": "\u0453", "gnap;": "\u2A8A", "gneq;": "\u2A88", "Gopf;": "\u{1D53E}", "gopf;": "\u{1D558}", "Gscr;": "\u{1D4A2}", "gscr;": "\u210A", "gsim;": "\u2273", "gtcc;": "\u2AA7", "gvnE;": "\u2269\uFE00", "half;": "\xBD", "hArr;": "\u21D4", "harr;": "\u2194", "hbar;": "\u210F", "Hopf;": "\u210D", "hopf;": "\u{1D559}", "Hscr;": "\u210B", "hscr;": "\u{1D4BD}", Icirc: "\xCE", icirc: "\xEE", "Idot;": "\u0130", "IEcy;": "\u0415", "iecy;": "\u0435", iexcl: "\xA1", "imof;": "\u22B7", "IOcy;": "\u0401", "iocy;": "\u0451", "Iopf;": "\u{1D540}", "iopf;": "\u{1D55A}", "Iota;": "\u0399", "iota;": "\u03B9", "Iscr;": "\u2110", "iscr;": "\u{1D4BE}", "isin;": "\u2208", "Iuml;": "\xCF", "iuml;": "\xEF", "Jopf;": "\u{1D541}", "jopf;": "\u{1D55B}", "Jscr;": "\u{1D4A5}", "jscr;": "\u{1D4BF}", "KHcy;": "\u0425", "khcy;": "\u0445", "KJcy;": "\u040C", "kjcy;": "\u045C", "Kopf;": "\u{1D542}", "kopf;": "\u{1D55C}", "Kscr;": "\u{1D4A6}", "kscr;": "\u{1D4C0}", "Lang;": "\u27EA", "lang;": "\u27E8", laquo: "\xAB", "Larr;": "\u219E", "lArr;": "\u21D0", "larr;": "\u2190", "late;": "\u2AAD", "lcub;": "{", "ldca;": "\u2936", "ldsh;": "\u21B2", "leqq;": "\u2266", "lesg;": "\u22DA\uFE00", "lHar;": "\u2962", "LJcy;": "\u0409", "ljcy;": "\u0459", "lnap;": "\u2A89", "lneq;": "\u2A87", "Lopf;": "\u{1D543}", "lopf;": "\u{1D55D}", "lozf;": "\u29EB", "lpar;": "(", "Lscr;": "\u2112", "lscr;": "\u{1D4C1}", "lsim;": "\u2272", "lsqb;": "[", "ltcc;": "\u2AA6", "ltri;": "\u25C3", "lvnE;": "\u2268\uFE00", "macr;": "\xAF", "male;": "\u2642", "malt;": "\u2720", micro: "\xB5", "mlcp;": "\u2ADB", "mldr;": "\u2026", "Mopf;": "\u{1D544}", "mopf;": "\u{1D55E}", "Mscr;": "\u2133", "mscr;": "\u{1D4C2}", "nang;": "\u2220\u20D2", "napE;": "\u2A70\u0338", "nbsp;": "\xA0", "ncap;": "\u2A43", "ncup;": "\u2A42", "ngeq;": "\u2271", "nges;": "\u2A7E\u0338", "ngtr;": "\u226F", "nGtv;": "\u226B\u0338", "nisd;": "\u22FA", "NJcy;": "\u040A", "njcy;": "\u045A", "nldr;": "\u2025", "nleq;": "\u2270", "nles;": "\u2A7D\u0338", "nLtv;": "\u226A\u0338", "nmid;": "\u2224", "Nopf;": "\u2115", "nopf;": "\u{1D55F}", "npar;": "\u2226", "npre;": "\u2AAF\u0338", "nsce;": "\u2AB0\u0338", "Nscr;": "\u{1D4A9}", "nscr;": "\u{1D4C3}", "nsim;": "\u2241", "nsub;": "\u2284", "nsup;": "\u2285", "ntgl;": "\u2279", "ntlg;": "\u2278", "nvap;": "\u224D\u20D2", "nvge;": "\u2265\u20D2", "nvgt;": ">\u20D2", "nvle;": "\u2264\u20D2", "nvlt;": "<\u20D2", "oast;": "\u229B", "ocir;": "\u229A", Ocirc: "\xD4", ocirc: "\xF4", "odiv;": "\u2A38", "odot;": "\u2299", "ogon;": "\u02DB", "oint;": "\u222E", "omid;": "\u29B6", "Oopf;": "\u{1D546}", "oopf;": "\u{1D560}", "opar;": "\u29B7", "ordf;": "\xAA", "ordm;": "\xBA", "oror;": "\u2A56", "Oscr;": "\u{1D4AA}", "oscr;": "\u2134", "osol;": "\u2298", "Ouml;": "\xD6", "ouml;": "\xF6", "para;": "\xB6", "part;": "\u2202", "perp;": "\u22A5", "phiv;": "\u03D5", "plus;": "+", "Popf;": "\u2119", "popf;": "\u{1D561}", pound: "\xA3", "prap;": "\u2AB7", "prec;": "\u227A", "prnE;": "\u2AB5", "prod;": "\u220F", "prop;": "\u221D", "Pscr;": "\u{1D4AB}", "pscr;": "\u{1D4C5}", "qint;": "\u2A0C", "Qopf;": "\u211A", "qopf;": "\u{1D562}", "Qscr;": "\u{1D4AC}", "qscr;": "\u{1D4C6}", "QUOT;": '"', "quot;": '"', "race;": "\u223D\u0331", "Rang;": "\u27EB", "rang;": "\u27E9", raquo: "\xBB", "Rarr;": "\u21A0", "rArr;": "\u21D2", "rarr;": "\u2192", "rcub;": "}", "rdca;": "\u2937", "rdsh;": "\u21B3", "real;": "\u211C", "rect;": "\u25AD", "rHar;": "\u2964", "rhov;": "\u03F1", "ring;": "\u02DA", "Ropf;": "\u211D", "ropf;": "\u{1D563}", "rpar;": ")", "Rscr;": "\u211B", "rscr;": "\u{1D4C7}", "rsqb;": "]", "rtri;": "\u25B9", "scap;": "\u2AB8", "scnE;": "\u2AB6", "sdot;": "\u22C5", "sect;": "\xA7", "semi;": ";", "sext;": "\u2736", "SHcy;": "\u0428", "shcy;": "\u0448", "sime;": "\u2243", "simg;": "\u2A9E", "siml;": "\u2A9D", "smid;": "\u2223", "smte;": "\u2AAC", "solb;": "\u29C4", "Sopf;": "\u{1D54A}", "sopf;": "\u{1D564}", "spar;": "\u2225", "Sqrt;": "\u221A", "squf;": "\u25AA", "Sscr;": "\u{1D4AE}", "sscr;": "\u{1D4C8}", "Star;": "\u22C6", "star;": "\u2606", "subE;": "\u2AC5", "sube;": "\u2286", "succ;": "\u227B", "sung;": "\u266A", "sup1;": "\xB9", "sup2;": "\xB2", "sup3;": "\xB3", "supE;": "\u2AC6", "supe;": "\u2287", szlig: "\xDF", "tbrk;": "\u23B4", "tdot;": "\u20DB", THORN: "\xDE", thorn: "\xFE", times: "\xD7", "tint;": "\u222D", "toea;": "\u2928", "Topf;": "\u{1D54B}", "topf;": "\u{1D565}", "tosa;": "\u2929", "trie;": "\u225C", "Tscr;": "\u{1D4AF}", "tscr;": "\u{1D4C9}", "TScy;": "\u0426", "tscy;": "\u0446", "Uarr;": "\u219F", "uArr;": "\u21D1", "uarr;": "\u2191", Ucirc: "\xDB", ucirc: "\xFB", "uHar;": "\u2963", "Uopf;": "\u{1D54C}", "uopf;": "\u{1D566}", "Upsi;": "\u03D2", "upsi;": "\u03C5", "Uscr;": "\u{1D4B0}", "uscr;": "\u{1D4CA}", "utri;": "\u25B5", "Uuml;": "\xDC", "uuml;": "\xFC", "vArr;": "\u21D5", "varr;": "\u2195", "Vbar;": "\u2AEB", "vBar;": "\u2AE8", "Vert;": "\u2016", "vert;": "|", "Vopf;": "\u{1D54D}", "vopf;": "\u{1D567}", "Vscr;": "\u{1D4B1}", "vscr;": "\u{1D4CB}", "Wopf;": "\u{1D54E}", "wopf;": "\u{1D568}", "Wscr;": "\u{1D4B2}", "wscr;": "\u{1D4CC}", "xcap;": "\u22C2", "xcup;": "\u22C3", "xmap;": "\u27FC", "xnis;": "\u22FB", "Xopf;": "\u{1D54F}", "xopf;": "\u{1D569}", "Xscr;": "\u{1D4B3}", "xscr;": "\u{1D4CD}", "xvee;": "\u22C1", "YAcy;": "\u042F", "yacy;": "\u044F", "YIcy;": "\u0407", "yicy;": "\u0457", "Yopf;": "\u{1D550}", "yopf;": "\u{1D56A}", "Yscr;": "\u{1D4B4}", "yscr;": "\u{1D4CE}", "YUcy;": "\u042E", "yucy;": "\u044E", "Yuml;": "\u0178", "yuml;": "\xFF", "Zdot;": "\u017B", "zdot;": "\u017C", "Zeta;": "\u0396", "zeta;": "\u03B6", "ZHcy;": "\u0416", "zhcy;": "\u0436", "Zopf;": "\u2124", "zopf;": "\u{1D56B}", "Zscr;": "\u{1D4B5}", "zscr;": "\u{1D4CF}", "zwnj;": "\u200C", Aacute: "\xC1", aacute: "\xE1", "Acirc;": "\xC2", "acirc;": "\xE2", "acute;": "\xB4", "AElig;": "\xC6", "aelig;": "\xE6", Agrave: "\xC0", agrave: "\xE0", "aleph;": "\u2135", "Alpha;": "\u0391", "alpha;": "\u03B1", "Amacr;": "\u0100", "amacr;": "\u0101", "amalg;": "\u2A3F", "angle;": "\u2220", "angrt;": "\u221F", "angst;": "\xC5", "Aogon;": "\u0104", "aogon;": "\u0105", "Aring;": "\xC5", "aring;": "\xE5", "asymp;": "\u2248", Atilde: "\xC3", atilde: "\xE3", "awint;": "\u2A11", "bcong;": "\u224C", "bdquo;": "\u201E", "bepsi;": "\u03F6", "blank;": "\u2423", "blk12;": "\u2592", "blk14;": "\u2591", "blk34;": "\u2593", "block;": "\u2588", "boxDL;": "\u2557", "boxDl;": "\u2556", "boxdL;": "\u2555", "boxdl;": "\u2510", "boxDR;": "\u2554", "boxDr;": "\u2553", "boxdR;": "\u2552", "boxdr;": "\u250C", "boxHD;": "\u2566", "boxHd;": "\u2564", "boxhD;": "\u2565", "boxhd;": "\u252C", "boxHU;": "\u2569", "boxHu;": "\u2567", "boxhU;": "\u2568", "boxhu;": "\u2534", "boxUL;": "\u255D", "boxUl;": "\u255C", "boxuL;": "\u255B", "boxul;": "\u2518", "boxUR;": "\u255A", "boxUr;": "\u2559", "boxuR;": "\u2558", "boxur;": "\u2514", "boxVH;": "\u256C", "boxVh;": "\u256B", "boxvH;": "\u256A", "boxvh;": "\u253C", "boxVL;": "\u2563", "boxVl;": "\u2562", "boxvL;": "\u2561", "boxvl;": "\u2524", "boxVR;": "\u2560", "boxVr;": "\u255F", "boxvR;": "\u255E", "boxvr;": "\u251C", "Breve;": "\u02D8", "breve;": "\u02D8", brvbar: "\xA6", "bsemi;": "\u204F", "bsime;": "\u22CD", "bsolb;": "\u29C5", "bumpE;": "\u2AAE", "bumpe;": "\u224F", "caret;": "\u2041", "caron;": "\u02C7", "ccaps;": "\u2A4D", Ccedil: "\xC7", ccedil: "\xE7", "Ccirc;": "\u0108", "ccirc;": "\u0109", "ccups;": "\u2A4C", "cedil;": "\xB8", "check;": "\u2713", "clubs;": "\u2663", "Colon;": "\u2237", "colon;": ":", "comma;": ",", "crarr;": "\u21B5", "Cross;": "\u2A2F", "cross;": "\u2717", "csube;": "\u2AD1", "csupe;": "\u2AD2", "ctdot;": "\u22EF", "cuepr;": "\u22DE", "cuesc;": "\u22DF", "cupor;": "\u2A45", curren: "\xA4", "cuvee;": "\u22CE", "cuwed;": "\u22CF", "cwint;": "\u2231", "Dashv;": "\u2AE4", "dashv;": "\u22A3", "dblac;": "\u02DD", "ddarr;": "\u21CA", "Delta;": "\u0394", "delta;": "\u03B4", "dharl;": "\u21C3", "dharr;": "\u21C2", "diams;": "\u2666", "disin;": "\u22F2", divide: "\xF7", "doteq;": "\u2250", "dtdot;": "\u22F1", "dtrif;": "\u25BE", "duarr;": "\u21F5", "duhar;": "\u296F", Eacute: "\xC9", eacute: "\xE9", "Ecirc;": "\xCA", "ecirc;": "\xEA", "eDDot;": "\u2A77", "efDot;": "\u2252", Egrave: "\xC8", egrave: "\xE8", "Emacr;": "\u0112", "emacr;": "\u0113", "empty;": "\u2205", "Eogon;": "\u0118", "eogon;": "\u0119", "eplus;": "\u2A71", "epsiv;": "\u03F5", "eqsim;": "\u2242", "Equal;": "\u2A75", "equiv;": "\u2261", "erarr;": "\u2971", "erDot;": "\u2253", "esdot;": "\u2250", "exist;": "\u2203", "fflig;": "\uFB00", "filig;": "\uFB01", "fjlig;": "fj", "fllig;": "\uFB02", "fltns;": "\u25B1", "forkv;": "\u2AD9", frac12: "\xBD", frac14: "\xBC", frac34: "\xBE", "frasl;": "\u2044", "frown;": "\u2322", "Gamma;": "\u0393", "gamma;": "\u03B3", "Gcirc;": "\u011C", "gcirc;": "\u011D", "gescc;": "\u2AA9", "gimel;": "\u2137", "gneqq;": "\u2269", "gnsim;": "\u22E7", "grave;": "`", "gsime;": "\u2A8E", "gsiml;": "\u2A90", "gtcir;": "\u2A7A", "gtdot;": "\u22D7", "Hacek;": "\u02C7", "harrw;": "\u21AD", "Hcirc;": "\u0124", "hcirc;": "\u0125", "hoarr;": "\u21FF", Iacute: "\xCD", iacute: "\xED", "Icirc;": "\xCE", "icirc;": "\xEE", "iexcl;": "\xA1", Igrave: "\xCC", igrave: "\xEC", "iiint;": "\u222D", "iiota;": "\u2129", "IJlig;": "\u0132", "ijlig;": "\u0133", "Imacr;": "\u012A", "imacr;": "\u012B", "image;": "\u2111", "imath;": "\u0131", "imped;": "\u01B5", "infin;": "\u221E", "Iogon;": "\u012E", "iogon;": "\u012F", "iprod;": "\u2A3C", iquest: "\xBF", "isinE;": "\u22F9", "isins;": "\u22F4", "isinv;": "\u2208", "Iukcy;": "\u0406", "iukcy;": "\u0456", "Jcirc;": "\u0134", "jcirc;": "\u0135", "jmath;": "\u0237", "Jukcy;": "\u0404", "jukcy;": "\u0454", "Kappa;": "\u039A", "kappa;": "\u03BA", "lAarr;": "\u21DA", "langd;": "\u2991", "laquo;": "\xAB", "larrb;": "\u21E4", "lates;": "\u2AAD\uFE00", "lBarr;": "\u290E", "lbarr;": "\u290C", "lbbrk;": "\u2772", "lbrke;": "\u298B", "lceil;": "\u2308", "ldquo;": "\u201C", "lescc;": "\u2AA8", "lhard;": "\u21BD", "lharu;": "\u21BC", "lhblk;": "\u2584", "llarr;": "\u21C7", "lltri;": "\u25FA", "lneqq;": "\u2268", "lnsim;": "\u22E6", "loang;": "\u27EC", "loarr;": "\u21FD", "lobrk;": "\u27E6", "lopar;": "\u2985", "lrarr;": "\u21C6", "lrhar;": "\u21CB", "lrtri;": "\u22BF", "lsime;": "\u2A8D", "lsimg;": "\u2A8F", "lsquo;": "\u2018", "ltcir;": "\u2A79", "ltdot;": "\u22D6", "ltrie;": "\u22B4", "ltrif;": "\u25C2", "mdash;": "\u2014", "mDDot;": "\u223A", "micro;": "\xB5", middot: "\xB7", "minus;": "\u2212", "mumap;": "\u22B8", "nabla;": "\u2207", "napid;": "\u224B\u0338", "napos;": "\u0149", "natur;": "\u266E", "nbump;": "\u224E\u0338", "ncong;": "\u2247", "ndash;": "\u2013", "neArr;": "\u21D7", "nearr;": "\u2197", "nedot;": "\u2250\u0338", "nesim;": "\u2242\u0338", "ngeqq;": "\u2267\u0338", "ngsim;": "\u2275", "nhArr;": "\u21CE", "nharr;": "\u21AE", "nhpar;": "\u2AF2", "nlArr;": "\u21CD", "nlarr;": "\u219A", "nleqq;": "\u2266\u0338", "nless;": "\u226E", "nlsim;": "\u2274", "nltri;": "\u22EA", "notin;": "\u2209", "notni;": "\u220C", "npart;": "\u2202\u0338", "nprec;": "\u2280", "nrArr;": "\u21CF", "nrarr;": "\u219B", "nrtri;": "\u22EB", "nsime;": "\u2244", "nsmid;": "\u2224", "nspar;": "\u2226", "nsubE;": "\u2AC5\u0338", "nsube;": "\u2288", "nsucc;": "\u2281", "nsupE;": "\u2AC6\u0338", "nsupe;": "\u2289", Ntilde: "\xD1", ntilde: "\xF1", "numsp;": "\u2007", "nvsim;": "\u223C\u20D2", "nwArr;": "\u21D6", "nwarr;": "\u2196", Oacute: "\xD3", oacute: "\xF3", "Ocirc;": "\xD4", "ocirc;": "\xF4", "odash;": "\u229D", "OElig;": "\u0152", "oelig;": "\u0153", "ofcir;": "\u29BF", Ograve: "\xD2", ograve: "\xF2", "ohbar;": "\u29B5", "olarr;": "\u21BA", "olcir;": "\u29BE", "oline;": "\u203E", "Omacr;": "\u014C", "omacr;": "\u014D", "Omega;": "\u03A9", "omega;": "\u03C9", "operp;": "\u29B9", "oplus;": "\u2295", "orarr;": "\u21BB", "order;": "\u2134", Oslash: "\xD8", oslash: "\xF8", Otilde: "\xD5", otilde: "\xF5", "ovbar;": "\u233D", "parsl;": "\u2AFD", "phone;": "\u260E", "plusb;": "\u229E", "pluse;": "\u2A72", plusmn: "\xB1", "pound;": "\xA3", "prcue;": "\u227C", "Prime;": "\u2033", "prime;": "\u2032", "prnap;": "\u2AB9", "prsim;": "\u227E", "quest;": "?", "rAarr;": "\u21DB", "radic;": "\u221A", "rangd;": "\u2992", "range;": "\u29A5", "raquo;": "\xBB", "rarrb;": "\u21E5", "rarrc;": "\u2933", "rarrw;": "\u219D", "ratio;": "\u2236", "RBarr;": "\u2910", "rBarr;": "\u290F", "rbarr;": "\u290D", "rbbrk;": "\u2773", "rbrke;": "\u298C", "rceil;": "\u2309", "rdquo;": "\u201D", "reals;": "\u211D", "rhard;": "\u21C1", "rharu;": "\u21C0", "rlarr;": "\u21C4", "rlhar;": "\u21CC", "rnmid;": "\u2AEE", "roang;": "\u27ED", "roarr;": "\u21FE", "robrk;": "\u27E7", "ropar;": "\u2986", "rrarr;": "\u21C9", "rsquo;": "\u2019", "rtrie;": "\u22B5", "rtrif;": "\u25B8", "sbquo;": "\u201A", "sccue;": "\u227D", "Scirc;": "\u015C", "scirc;": "\u015D", "scnap;": "\u2ABA", "scsim;": "\u227F", "sdotb;": "\u22A1", "sdote;": "\u2A66", "seArr;": "\u21D8", "searr;": "\u2198", "setmn;": "\u2216", "sharp;": "\u266F", "Sigma;": "\u03A3", "sigma;": "\u03C3", "simeq;": "\u2243", "simgE;": "\u2AA0", "simlE;": "\u2A9F", "simne;": "\u2246", "slarr;": "\u2190", "smile;": "\u2323", "smtes;": "\u2AAC\uFE00", "sqcap;": "\u2293", "sqcup;": "\u2294", "sqsub;": "\u228F", "sqsup;": "\u2290", "srarr;": "\u2192", "starf;": "\u2605", "strns;": "\xAF", "subnE;": "\u2ACB", "subne;": "\u228A", "supnE;": "\u2ACC", "supne;": "\u228B", "swArr;": "\u21D9", "swarr;": "\u2199", "szlig;": "\xDF", "Theta;": "\u0398", "theta;": "\u03B8", "thkap;": "\u2248", "THORN;": "\xDE", "thorn;": "\xFE", "Tilde;": "\u223C", "tilde;": "\u02DC", "times;": "\xD7", "TRADE;": "\u2122", "trade;": "\u2122", "trisb;": "\u29CD", "TSHcy;": "\u040B", "tshcy;": "\u045B", "twixt;": "\u226C", Uacute: "\xDA", uacute: "\xFA", "Ubrcy;": "\u040E", "ubrcy;": "\u045E", "Ucirc;": "\xDB", "ucirc;": "\xFB", "udarr;": "\u21C5", "udhar;": "\u296E", Ugrave: "\xD9", ugrave: "\xF9", "uharl;": "\u21BF", "uharr;": "\u21BE", "uhblk;": "\u2580", "ultri;": "\u25F8", "Umacr;": "\u016A", "umacr;": "\u016B", "Union;": "\u22C3", "Uogon;": "\u0172", "uogon;": "\u0173", "uplus;": "\u228E", "upsih;": "\u03D2", "UpTee;": "\u22A5", "Uring;": "\u016E", "uring;": "\u016F", "urtri;": "\u25F9", "utdot;": "\u22F0", "utrif;": "\u25B4", "uuarr;": "\u21C8", "varpi;": "\u03D6", "vBarv;": "\u2AE9", "VDash;": "\u22AB", "Vdash;": "\u22A9", "vDash;": "\u22A8", "vdash;": "\u22A2", "veeeq;": "\u225A", "vltri;": "\u22B2", "vnsub;": "\u2282\u20D2", "vnsup;": "\u2283\u20D2", "vprop;": "\u221D", "vrtri;": "\u22B3", "Wcirc;": "\u0174", "wcirc;": "\u0175", "Wedge;": "\u22C0", "wedge;": "\u2227", "xcirc;": "\u25EF", "xdtri;": "\u25BD", "xhArr;": "\u27FA", "xharr;": "\u27F7", "xlArr;": "\u27F8", "xlarr;": "\u27F5", "xodot;": "\u2A00", "xrArr;": "\u27F9", "xrarr;": "\u27F6", "xutri;": "\u25B3", Yacute: "\xDD", yacute: "\xFD", "Ycirc;": "\u0176", "ycirc;": "\u0177", "Aacute;": "\xC1", "aacute;": "\xE1", "Abreve;": "\u0102", "abreve;": "\u0103", "Agrave;": "\xC0", "agrave;": "\xE0", "andand;": "\u2A55", "angmsd;": "\u2221", "angsph;": "\u2222", "apacir;": "\u2A6F", "approx;": "\u2248", "Assign;": "\u2254", "Atilde;": "\xC3", "atilde;": "\xE3", "barvee;": "\u22BD", "Barwed;": "\u2306", "barwed;": "\u2305", "becaus;": "\u2235", "bernou;": "\u212C", "bigcap;": "\u22C2", "bigcup;": "\u22C3", "bigvee;": "\u22C1", "bkarow;": "\u290D", "bottom;": "\u22A5", "bowtie;": "\u22C8", "boxbox;": "\u29C9", "bprime;": "\u2035", "brvbar;": "\xA6", "bullet;": "\u2022", "Bumpeq;": "\u224E", "bumpeq;": "\u224F", "Cacute;": "\u0106", "cacute;": "\u0107", "capand;": "\u2A44", "capcap;": "\u2A4B", "capcup;": "\u2A47", "capdot;": "\u2A40", "Ccaron;": "\u010C", "ccaron;": "\u010D", "Ccedil;": "\xC7", "ccedil;": "\xE7", "circeq;": "\u2257", "cirmid;": "\u2AEF", "Colone;": "\u2A74", "colone;": "\u2254", "commat;": "@", "compfn;": "\u2218", "Conint;": "\u222F", "conint;": "\u222E", "coprod;": "\u2210", "copysr;": "\u2117", "cularr;": "\u21B6", "CupCap;": "\u224D", "cupcap;": "\u2A46", "cupcup;": "\u2A4A", "cupdot;": "\u228D", "curarr;": "\u21B7", "curren;": "\xA4", "cylcty;": "\u232D", "Dagger;": "\u2021", "dagger;": "\u2020", "daleth;": "\u2138", "Dcaron;": "\u010E", "dcaron;": "\u010F", "dfisht;": "\u297F", "divide;": "\xF7", "divonx;": "\u22C7", "dlcorn;": "\u231E", "dlcrop;": "\u230D", "dollar;": "$", "DotDot;": "\u20DC", "drcorn;": "\u231F", "drcrop;": "\u230C", "Dstrok;": "\u0110", "dstrok;": "\u0111", "Eacute;": "\xC9", "eacute;": "\xE9", "easter;": "\u2A6E", "Ecaron;": "\u011A", "ecaron;": "\u011B", "ecolon;": "\u2255", "Egrave;": "\xC8", "egrave;": "\xE8", "egsdot;": "\u2A98", "elsdot;": "\u2A97", "emptyv;": "\u2205", "emsp13;": "\u2004", "emsp14;": "\u2005", "eparsl;": "\u29E3", "eqcirc;": "\u2256", "equals;": "=", "equest;": "\u225F", "Exists;": "\u2203", "female;": "\u2640", "ffilig;": "\uFB03", "ffllig;": "\uFB04", "ForAll;": "\u2200", "forall;": "\u2200", "frac12;": "\xBD", "frac13;": "\u2153", "frac14;": "\xBC", "frac15;": "\u2155", "frac16;": "\u2159", "frac18;": "\u215B", "frac23;": "\u2154", "frac25;": "\u2156", "frac34;": "\xBE", "frac35;": "\u2157", "frac38;": "\u215C", "frac45;": "\u2158", "frac56;": "\u215A", "frac58;": "\u215D", "frac78;": "\u215E", "gacute;": "\u01F5", "Gammad;": "\u03DC", "gammad;": "\u03DD", "Gbreve;": "\u011E", "gbreve;": "\u011F", "Gcedil;": "\u0122", "gesdot;": "\u2A80", "gesles;": "\u2A94", "gtlPar;": "\u2995", "gtrarr;": "\u2978", "gtrdot;": "\u22D7", "gtrsim;": "\u2273", "hairsp;": "\u200A", "hamilt;": "\u210B", "HARDcy;": "\u042A", "hardcy;": "\u044A", "hearts;": "\u2665", "hellip;": "\u2026", "hercon;": "\u22B9", "homtht;": "\u223B", "horbar;": "\u2015", "hslash;": "\u210F", "Hstrok;": "\u0126", "hstrok;": "\u0127", "hybull;": "\u2043", "hyphen;": "\u2010", "Iacute;": "\xCD", "iacute;": "\xED", "Igrave;": "\xCC", "igrave;": "\xEC", "iiiint;": "\u2A0C", "iinfin;": "\u29DC", "incare;": "\u2105", "inodot;": "\u0131", "intcal;": "\u22BA", "iquest;": "\xBF", "isinsv;": "\u22F3", "Itilde;": "\u0128", "itilde;": "\u0129", "Jsercy;": "\u0408", "jsercy;": "\u0458", "kappav;": "\u03F0", "Kcedil;": "\u0136", "kcedil;": "\u0137", "kgreen;": "\u0138", "Lacute;": "\u0139", "lacute;": "\u013A", "lagran;": "\u2112", "Lambda;": "\u039B", "lambda;": "\u03BB", "langle;": "\u27E8", "larrfs;": "\u291D", "larrhk;": "\u21A9", "larrlp;": "\u21AB", "larrpl;": "\u2939", "larrtl;": "\u21A2", "lAtail;": "\u291B", "latail;": "\u2919", "lbrace;": "{", "lbrack;": "[", "Lcaron;": "\u013D", "lcaron;": "\u013E", "Lcedil;": "\u013B", "lcedil;": "\u013C", "ldquor;": "\u201E", "lesdot;": "\u2A7F", "lesges;": "\u2A93", "lfisht;": "\u297C", "lfloor;": "\u230A", "lharul;": "\u296A", "llhard;": "\u296B", "Lmidot;": "\u013F", "lmidot;": "\u0140", "lmoust;": "\u23B0", "loplus;": "\u2A2D", "lowast;": "\u2217", "lowbar;": "_", "lparlt;": "\u2993", "lrhard;": "\u296D", "lsaquo;": "\u2039", "lsquor;": "\u201A", "Lstrok;": "\u0141", "lstrok;": "\u0142", "lthree;": "\u22CB", "ltimes;": "\u22C9", "ltlarr;": "\u2976", "ltrPar;": "\u2996", "mapsto;": "\u21A6", "marker;": "\u25AE", "mcomma;": "\u2A29", "midast;": "*", "midcir;": "\u2AF0", "middot;": "\xB7", "minusb;": "\u229F", "minusd;": "\u2238", "mnplus;": "\u2213", "models;": "\u22A7", "mstpos;": "\u223E", "Nacute;": "\u0143", "nacute;": "\u0144", "nbumpe;": "\u224F\u0338", "Ncaron;": "\u0147", "ncaron;": "\u0148", "Ncedil;": "\u0145", "ncedil;": "\u0146", "nearhk;": "\u2924", "nequiv;": "\u2262", "nesear;": "\u2928", "nexist;": "\u2204", "nltrie;": "\u22EC", "notinE;": "\u22F9\u0338", "nparsl;": "\u2AFD\u20E5", "nprcue;": "\u22E0", "nrarrc;": "\u2933\u0338", "nrarrw;": "\u219D\u0338", "nrtrie;": "\u22ED", "nsccue;": "\u22E1", "nsimeq;": "\u2244", "Ntilde;": "\xD1", "ntilde;": "\xF1", "numero;": "\u2116", "nVDash;": "\u22AF", "nVdash;": "\u22AE", "nvDash;": "\u22AD", "nvdash;": "\u22AC", "nvHarr;": "\u2904", "nvlArr;": "\u2902", "nvrArr;": "\u2903", "nwarhk;": "\u2923", "nwnear;": "\u2927", "Oacute;": "\xD3", "oacute;": "\xF3", "Odblac;": "\u0150", "odblac;": "\u0151", "odsold;": "\u29BC", "Ograve;": "\xD2", "ograve;": "\xF2", "ominus;": "\u2296", "origof;": "\u22B6", "Oslash;": "\xD8", "oslash;": "\xF8", "Otilde;": "\xD5", "otilde;": "\xF5", "Otimes;": "\u2A37", "otimes;": "\u2297", "parsim;": "\u2AF3", "percnt;": "%", "period;": ".", "permil;": "\u2030", "phmmat;": "\u2133", "planck;": "\u210F", "plankv;": "\u210F", "plusdo;": "\u2214", "plusdu;": "\u2A25", "plusmn;": "\xB1", "preceq;": "\u2AAF", "primes;": "\u2119", "prnsim;": "\u22E8", "propto;": "\u221D", "prurel;": "\u22B0", "puncsp;": "\u2008", "qprime;": "\u2057", "Racute;": "\u0154", "racute;": "\u0155", "rangle;": "\u27E9", "rarrap;": "\u2975", "rarrfs;": "\u291E", "rarrhk;": "\u21AA", "rarrlp;": "\u21AC", "rarrpl;": "\u2945", "Rarrtl;": "\u2916", "rarrtl;": "\u21A3", "rAtail;": "\u291C", "ratail;": "\u291A", "rbrace;": "}", "rbrack;": "]", "Rcaron;": "\u0158", "rcaron;": "\u0159", "Rcedil;": "\u0156", "rcedil;": "\u0157", "rdquor;": "\u201D", "rfisht;": "\u297D", "rfloor;": "\u230B", "rharul;": "\u296C", "rmoust;": "\u23B1", "roplus;": "\u2A2E", "rpargt;": "\u2994", "rsaquo;": "\u203A", "rsquor;": "\u2019", "rthree;": "\u22CC", "rtimes;": "\u22CA", "Sacute;": "\u015A", "sacute;": "\u015B", "Scaron;": "\u0160", "scaron;": "\u0161", "Scedil;": "\u015E", "scedil;": "\u015F", "scnsim;": "\u22E9", "searhk;": "\u2925", "seswar;": "\u2929", "sfrown;": "\u2322", "SHCHcy;": "\u0429", "shchcy;": "\u0449", "sigmaf;": "\u03C2", "sigmav;": "\u03C2", "simdot;": "\u2A6A", "smashp;": "\u2A33", "SOFTcy;": "\u042C", "softcy;": "\u044C", "solbar;": "\u233F", "spades;": "\u2660", "sqcaps;": "\u2293\uFE00", "sqcups;": "\u2294\uFE00", "sqsube;": "\u2291", "sqsupe;": "\u2292", "Square;": "\u25A1", "square;": "\u25A1", "squarf;": "\u25AA", "ssetmn;": "\u2216", "ssmile;": "\u2323", "sstarf;": "\u22C6", "subdot;": "\u2ABD", "Subset;": "\u22D0", "subset;": "\u2282", "subsim;": "\u2AC7", "subsub;": "\u2AD5", "subsup;": "\u2AD3", "succeq;": "\u2AB0", "supdot;": "\u2ABE", "Supset;": "\u22D1", "supset;": "\u2283", "supsim;": "\u2AC8", "supsub;": "\u2AD4", "supsup;": "\u2AD6", "swarhk;": "\u2926", "swnwar;": "\u292A", "target;": "\u2316", "Tcaron;": "\u0164", "tcaron;": "\u0165", "Tcedil;": "\u0162", "tcedil;": "\u0163", "telrec;": "\u2315", "there4;": "\u2234", "thetav;": "\u03D1", "thinsp;": "\u2009", "thksim;": "\u223C", "timesb;": "\u22A0", "timesd;": "\u2A30", "topbot;": "\u2336", "topcir;": "\u2AF1", "tprime;": "\u2034", "tridot;": "\u25EC", "Tstrok;": "\u0166", "tstrok;": "\u0167", "Uacute;": "\xDA", "uacute;": "\xFA", "Ubreve;": "\u016C", "ubreve;": "\u016D", "Udblac;": "\u0170", "udblac;": "\u0171", "ufisht;": "\u297E", "Ugrave;": "\xD9", "ugrave;": "\xF9", "ulcorn;": "\u231C", "ulcrop;": "\u230F", "urcorn;": "\u231D", "urcrop;": "\u230E", "Utilde;": "\u0168", "utilde;": "\u0169", "vangrt;": "\u299C", "varphi;": "\u03D5", "varrho;": "\u03F1", "Vdashl;": "\u2AE6", "veebar;": "\u22BB", "vellip;": "\u22EE", "Verbar;": "\u2016", "verbar;": "|", "vsubnE;": "\u2ACB\uFE00", "vsubne;": "\u228A\uFE00", "vsupnE;": "\u2ACC\uFE00", "vsupne;": "\u228B\uFE00", "Vvdash;": "\u22AA", "wedbar;": "\u2A5F", "wedgeq;": "\u2259", "weierp;": "\u2118", "wreath;": "\u2240", "xoplus;": "\u2A01", "xotime;": "\u2A02", "xsqcup;": "\u2A06", "xuplus;": "\u2A04", "xwedge;": "\u22C0", "Yacute;": "\xDD", "yacute;": "\xFD", "Zacute;": "\u0179", "zacute;": "\u017A", "Zcaron;": "\u017D", "zcaron;": "\u017E", "zeetrf;": "\u2128", "alefsym;": "\u2135", "angrtvb;": "\u22BE", "angzarr;": "\u237C", "asympeq;": "\u224D", "backsim;": "\u223D", "Because;": "\u2235", "because;": "\u2235", "bemptyv;": "\u29B0", "between;": "\u226C", "bigcirc;": "\u25EF", "bigodot;": "\u2A00", "bigstar;": "\u2605", "bnequiv;": "\u2261\u20E5", "boxplus;": "\u229E", "Cayleys;": "\u212D", "Cconint;": "\u2230", "ccupssm;": "\u2A50", "Cedilla;": "\xB8", "cemptyv;": "\u29B2", "cirscir;": "\u29C2", "coloneq;": "\u2254", "congdot;": "\u2A6D", "cudarrl;": "\u2938", "cudarrr;": "\u2935", "cularrp;": "\u293D", "curarrm;": "\u293C", "dbkarow;": "\u290F", "ddagger;": "\u2021", "ddotseq;": "\u2A77", "demptyv;": "\u29B1", "Diamond;": "\u22C4", "diamond;": "\u22C4", "digamma;": "\u03DD", "dotplus;": "\u2214", "DownTee;": "\u22A4", "dwangle;": "\u29A6", "Element;": "\u2208", "Epsilon;": "\u0395", "epsilon;": "\u03B5", "eqcolon;": "\u2255", "equivDD;": "\u2A78", "gesdoto;": "\u2A82", "gtquest;": "\u2A7C", "gtrless;": "\u2277", "harrcir;": "\u2948", "Implies;": "\u21D2", "intprod;": "\u2A3C", "isindot;": "\u22F5", "larrbfs;": "\u291F", "larrsim;": "\u2973", "lbrksld;": "\u298F", "lbrkslu;": "\u298D", "ldrdhar;": "\u2967", "LeftTee;": "\u22A3", "lesdoto;": "\u2A81", "lessdot;": "\u22D6", "lessgtr;": "\u2276", "lesssim;": "\u2272", "lotimes;": "\u2A34", "lozenge;": "\u25CA", "ltquest;": "\u2A7B", "luruhar;": "\u2966", "maltese;": "\u2720", "minusdu;": "\u2A2A", "napprox;": "\u2249", "natural;": "\u266E", "nearrow;": "\u2197", "NewLine;": "\n", "nexists;": "\u2204", "NoBreak;": "\u2060", "notinva;": "\u2209", "notinvb;": "\u22F7", "notinvc;": "\u22F6", "NotLess;": "\u226E", "notniva;": "\u220C", "notnivb;": "\u22FE", "notnivc;": "\u22FD", "npolint;": "\u2A14", "npreceq;": "\u2AAF\u0338", "nsqsube;": "\u22E2", "nsqsupe;": "\u22E3", "nsubset;": "\u2282\u20D2", "nsucceq;": "\u2AB0\u0338", "nsupset;": "\u2283\u20D2", "nvinfin;": "\u29DE", "nvltrie;": "\u22B4\u20D2", "nvrtrie;": "\u22B5\u20D2", "nwarrow;": "\u2196", "olcross;": "\u29BB", "Omicron;": "\u039F", "omicron;": "\u03BF", "orderof;": "\u2134", "orslope;": "\u2A57", "OverBar;": "\u203E", "pertenk;": "\u2031", "planckh;": "\u210E", "pluscir;": "\u2A22", "plussim;": "\u2A26", "plustwo;": "\u2A27", "precsim;": "\u227E", "Product;": "\u220F", "quatint;": "\u2A16", "questeq;": "\u225F", "rarrbfs;": "\u2920", "rarrsim;": "\u2974", "rbrksld;": "\u298E", "rbrkslu;": "\u2990", "rdldhar;": "\u2969", "realine;": "\u211B", "rotimes;": "\u2A35", "ruluhar;": "\u2968", "searrow;": "\u2198", "simplus;": "\u2A24", "simrarr;": "\u2972", "subedot;": "\u2AC3", "submult;": "\u2AC1", "subplus;": "\u2ABF", "subrarr;": "\u2979", "succsim;": "\u227F", "supdsub;": "\u2AD8", "supedot;": "\u2AC4", "suphsol;": "\u27C9", "suphsub;": "\u2AD7", "suplarr;": "\u297B", "supmult;": "\u2AC2", "supplus;": "\u2AC0", "swarrow;": "\u2199", "topfork;": "\u2ADA", "triplus;": "\u2A39", "tritime;": "\u2A3B", "UpArrow;": "\u2191", "Uparrow;": "\u21D1", "uparrow;": "\u2191", "Upsilon;": "\u03A5", "upsilon;": "\u03C5", "uwangle;": "\u29A7", "vzigzag;": "\u299A", "zigrarr;": "\u21DD", "andslope;": "\u2A58", "angmsdaa;": "\u29A8", "angmsdab;": "\u29A9", "angmsdac;": "\u29AA", "angmsdad;": "\u29AB", "angmsdae;": "\u29AC", "angmsdaf;": "\u29AD", "angmsdag;": "\u29AE", "angmsdah;": "\u29AF", "angrtvbd;": "\u299D", "approxeq;": "\u224A", "awconint;": "\u2233", "backcong;": "\u224C", "barwedge;": "\u2305", "bbrktbrk;": "\u23B6", "bigoplus;": "\u2A01", "bigsqcup;": "\u2A06", "biguplus;": "\u2A04", "bigwedge;": "\u22C0", "boxminus;": "\u229F", "boxtimes;": "\u22A0", "bsolhsub;": "\u27C8", "capbrcup;": "\u2A49", "circledR;": "\xAE", "circledS;": "\u24C8", "cirfnint;": "\u2A10", "clubsuit;": "\u2663", "cupbrcap;": "\u2A48", "curlyvee;": "\u22CE", "cwconint;": "\u2232", "DDotrahd;": "\u2911", "doteqdot;": "\u2251", "DotEqual;": "\u2250", "dotminus;": "\u2238", "drbkarow;": "\u2910", "dzigrarr;": "\u27FF", "elinters;": "\u23E7", "emptyset;": "\u2205", "eqvparsl;": "\u29E5", "fpartint;": "\u2A0D", "geqslant;": "\u2A7E", "gesdotol;": "\u2A84", "gnapprox;": "\u2A8A", "hksearow;": "\u2925", "hkswarow;": "\u2926", "imagline;": "\u2110", "imagpart;": "\u2111", "infintie;": "\u29DD", "integers;": "\u2124", "Integral;": "\u222B", "intercal;": "\u22BA", "intlarhk;": "\u2A17", "laemptyv;": "\u29B4", "ldrushar;": "\u294B", "leqslant;": "\u2A7D", "lesdotor;": "\u2A83", "LessLess;": "\u2AA1", "llcorner;": "\u231E", "lnapprox;": "\u2A89", "lrcorner;": "\u231F", "lurdshar;": "\u294A", "mapstoup;": "\u21A5", "multimap;": "\u22B8", "naturals;": "\u2115", "ncongdot;": "\u2A6D\u0338", "NotEqual;": "\u2260", "notindot;": "\u22F5\u0338", "NotTilde;": "\u2241", "otimesas;": "\u2A36", "parallel;": "\u2225", "PartialD;": "\u2202", "plusacir;": "\u2A23", "pointint;": "\u2A15", "Precedes;": "\u227A", "precneqq;": "\u2AB5", "precnsim;": "\u22E8", "profalar;": "\u232E", "profline;": "\u2312", "profsurf;": "\u2313", "raemptyv;": "\u29B3", "realpart;": "\u211C", "RightTee;": "\u22A2", "rppolint;": "\u2A12", "rtriltri;": "\u29CE", "scpolint;": "\u2A13", "setminus;": "\u2216", "shortmid;": "\u2223", "smeparsl;": "\u29E4", "sqsubset;": "\u228F", "sqsupset;": "\u2290", "subseteq;": "\u2286", "Succeeds;": "\u227B", "succneqq;": "\u2AB6", "succnsim;": "\u22E9", "SuchThat;": "\u220B", "Superset;": "\u2283", "supseteq;": "\u2287", "thetasym;": "\u03D1", "thicksim;": "\u223C", "timesbar;": "\u2A31", "triangle;": "\u25B5", "triminus;": "\u2A3A", "trpezium;": "\u23E2", "Uarrocir;": "\u2949", "ulcorner;": "\u231C", "UnderBar;": "_", "urcorner;": "\u231D", "varkappa;": "\u03F0", "varsigma;": "\u03C2", "vartheta;": "\u03D1", "backprime;": "\u2035", "backsimeq;": "\u22CD", "Backslash;": "\u2216", "bigotimes;": "\u2A02", "CenterDot;": "\xB7", "centerdot;": "\xB7", "checkmark;": "\u2713", "CircleDot;": "\u2299", "complexes;": "\u2102", "Congruent;": "\u2261", "Coproduct;": "\u2210", "dotsquare;": "\u22A1", "DoubleDot;": "\xA8", "DownArrow;": "\u2193", "Downarrow;": "\u21D3", "downarrow;": "\u2193", "DownBreve;": "\u0311", "gtrapprox;": "\u2A86", "gtreqless;": "\u22DB", "gvertneqq;": "\u2269\uFE00", "heartsuit;": "\u2665", "HumpEqual;": "\u224F", "LeftArrow;": "\u2190", "Leftarrow;": "\u21D0", "leftarrow;": "\u2190", "LeftFloor;": "\u230A", "lesseqgtr;": "\u22DA", "LessTilde;": "\u2272", "lvertneqq;": "\u2268\uFE00", "Mellintrf;": "\u2133", "MinusPlus;": "\u2213", "ngeqslant;": "\u2A7E\u0338", "nleqslant;": "\u2A7D\u0338", "NotCupCap;": "\u226D", "NotExists;": "\u2204", "NotSubset;": "\u2282\u20D2", "nparallel;": "\u2226", "nshortmid;": "\u2224", "nsubseteq;": "\u2288", "nsupseteq;": "\u2289", "OverBrace;": "\u23DE", "pitchfork;": "\u22D4", "PlusMinus;": "\xB1", "rationals;": "\u211A", "spadesuit;": "\u2660", "subseteqq;": "\u2AC5", "subsetneq;": "\u228A", "supseteqq;": "\u2AC6", "supsetneq;": "\u228B", "Therefore;": "\u2234", "therefore;": "\u2234", "ThinSpace;": "\u2009", "triangleq;": "\u225C", "TripleDot;": "\u20DB", "UnionPlus;": "\u228E", "varpropto;": "\u221D", "Bernoullis;": "\u212C", "circledast;": "\u229B", "CirclePlus;": "\u2295", "complement;": "\u2201", "curlywedge;": "\u22CF", "eqslantgtr;": "\u2A96", "EqualTilde;": "\u2242", "Fouriertrf;": "\u2131", "gtreqqless;": "\u2A8C", "ImaginaryI;": "\u2148", "Laplacetrf;": "\u2112", "LeftVector;": "\u21BC", "lessapprox;": "\u2A85", "lesseqqgtr;": "\u2A8B", "Lleftarrow;": "\u21DA", "lmoustache;": "\u23B0", "longmapsto;": "\u27FC", "mapstodown;": "\u21A7", "mapstoleft;": "\u21A4", "nLeftarrow;": "\u21CD", "nleftarrow;": "\u219A", "NotElement;": "\u2209", "NotGreater;": "\u226F", "nsubseteqq;": "\u2AC5\u0338", "nsupseteqq;": "\u2AC6\u0338", "precapprox;": "\u2AB7", "Proportion;": "\u2237", "RightArrow;": "\u2192", "Rightarrow;": "\u21D2", "rightarrow;": "\u2192", "RightFloor;": "\u230B", "rmoustache;": "\u23B1", "sqsubseteq;": "\u2291", "sqsupseteq;": "\u2292", "subsetneqq;": "\u2ACB", "succapprox;": "\u2AB8", "supsetneqq;": "\u2ACC", "ThickSpace;": "\u205F\u200A", "TildeEqual;": "\u2243", "TildeTilde;": "\u2248", "UnderBrace;": "\u23DF", "UpArrowBar;": "\u2912", "UpTeeArrow;": "\u21A5", "upuparrows;": "\u21C8", "varepsilon;": "\u03F5", "varnothing;": "\u2205", "backepsilon;": "\u03F6", "blacksquare;": "\u25AA", "circledcirc;": "\u229A", "circleddash;": "\u229D", "CircleMinus;": "\u2296", "CircleTimes;": "\u2297", "curlyeqprec;": "\u22DE", "curlyeqsucc;": "\u22DF", "diamondsuit;": "\u2666", "eqslantless;": "\u2A95", "Equilibrium;": "\u21CC", "expectation;": "\u2130", "GreaterLess;": "\u2277", "LeftCeiling;": "\u2308", "LessGreater;": "\u2276", "MediumSpace;": "\u205F", "NotLessLess;": "\u226A\u0338", "NotPrecedes;": "\u2280", "NotSucceeds;": "\u2281", "NotSuperset;": "\u2283\u20D2", "nRightarrow;": "\u21CF", "nrightarrow;": "\u219B", "OverBracket;": "\u23B4", "preccurlyeq;": "\u227C", "precnapprox;": "\u2AB9", "quaternions;": "\u210D", "RightVector;": "\u21C0", "Rrightarrow;": "\u21DB", "RuleDelayed;": "\u29F4", "SmallCircle;": "\u2218", "SquareUnion;": "\u2294", "straightphi;": "\u03D5", "SubsetEqual;": "\u2286", "succcurlyeq;": "\u227D", "succnapprox;": "\u2ABA", "thickapprox;": "\u2248", "UpDownArrow;": "\u2195", "Updownarrow;": "\u21D5", "updownarrow;": "\u2195", "VerticalBar;": "\u2223", "blacklozenge;": "\u29EB", "DownArrowBar;": "\u2913", "DownTeeArrow;": "\u21A7", "ExponentialE;": "\u2147", "exponentiale;": "\u2147", "GreaterEqual;": "\u2265", "GreaterTilde;": "\u2273", "HilbertSpace;": "\u210B", "HumpDownHump;": "\u224E", "Intersection;": "\u22C2", "LeftArrowBar;": "\u21E4", "LeftTeeArrow;": "\u21A4", "LeftTriangle;": "\u22B2", "LeftUpVector;": "\u21BF", "NotCongruent;": "\u2262", "NotHumpEqual;": "\u224F\u0338", "NotLessEqual;": "\u2270", "NotLessTilde;": "\u2274", "Proportional;": "\u221D", "RightCeiling;": "\u2309", "risingdotseq;": "\u2253", "RoundImplies;": "\u2970", "ShortUpArrow;": "\u2191", "SquareSubset;": "\u228F", "triangledown;": "\u25BF", "triangleleft;": "\u25C3", "UnderBracket;": "\u23B5", "varsubsetneq;": "\u228A\uFE00", "varsupsetneq;": "\u228B\uFE00", "VerticalLine;": "|", "ApplyFunction;": "\u2061", "bigtriangleup;": "\u25B3", "blacktriangle;": "\u25B4", "DifferentialD;": "\u2146", "divideontimes;": "\u22C7", "DoubleLeftTee;": "\u2AE4", "DoubleUpArrow;": "\u21D1", "fallingdotseq;": "\u2252", "hookleftarrow;": "\u21A9", "leftarrowtail;": "\u21A2", "leftharpoonup;": "\u21BC", "LeftTeeVector;": "\u295A", "LeftVectorBar;": "\u2952", "LessFullEqual;": "\u2266", "LongLeftArrow;": "\u27F5", "Longleftarrow;": "\u27F8", "longleftarrow;": "\u27F5", "looparrowleft;": "\u21AB", "measuredangle;": "\u2221", "NotEqualTilde;": "\u2242\u0338", "NotTildeEqual;": "\u2244", "NotTildeTilde;": "\u2249", "ntriangleleft;": "\u22EA", "Poincareplane;": "\u210C", "PrecedesEqual;": "\u2AAF", "PrecedesTilde;": "\u227E", "RightArrowBar;": "\u21E5", "RightTeeArrow;": "\u21A6", "RightTriangle;": "\u22B3", "RightUpVector;": "\u21BE", "shortparallel;": "\u2225", "smallsetminus;": "\u2216", "SucceedsEqual;": "\u2AB0", "SucceedsTilde;": "\u227F", "SupersetEqual;": "\u2287", "triangleright;": "\u25B9", "UpEquilibrium;": "\u296E", "upharpoonleft;": "\u21BF", "varsubsetneqq;": "\u2ACB\uFE00", "varsupsetneqq;": "\u2ACC\uFE00", "VerticalTilde;": "\u2240", "VeryThinSpace;": "\u200A", "curvearrowleft;": "\u21B6", "DiacriticalDot;": "\u02D9", "doublebarwedge;": "\u2306", "DoubleRightTee;": "\u22A8", "downdownarrows;": "\u21CA", "DownLeftVector;": "\u21BD", "GreaterGreater;": "\u2AA2", "hookrightarrow;": "\u21AA", "HorizontalLine;": "\u2500", "InvisibleComma;": "\u2063", "InvisibleTimes;": "\u2062", "LeftDownVector;": "\u21C3", "leftleftarrows;": "\u21C7", "LeftRightArrow;": "\u2194", "Leftrightarrow;": "\u21D4", "leftrightarrow;": "\u2194", "leftthreetimes;": "\u22CB", "LessSlantEqual;": "\u2A7D", "LongRightArrow;": "\u27F6", "Longrightarrow;": "\u27F9", "longrightarrow;": "\u27F6", "looparrowright;": "\u21AC", "LowerLeftArrow;": "\u2199", "NestedLessLess;": "\u226A", "NotGreaterLess;": "\u2279", "NotLessGreater;": "\u2278", "NotSubsetEqual;": "\u2288", "NotVerticalBar;": "\u2224", "nshortparallel;": "\u2226", "ntriangleright;": "\u22EB", "OpenCurlyQuote;": "\u2018", "ReverseElement;": "\u220B", "rightarrowtail;": "\u21A3", "rightharpoonup;": "\u21C0", "RightTeeVector;": "\u295B", "RightVectorBar;": "\u2953", "ShortDownArrow;": "\u2193", "ShortLeftArrow;": "\u2190", "SquareSuperset;": "\u2290", "TildeFullEqual;": "\u2245", "trianglelefteq;": "\u22B4", "upharpoonright;": "\u21BE", "UpperLeftArrow;": "\u2196", "ZeroWidthSpace;": "\u200B", "bigtriangledown;": "\u25BD", "circlearrowleft;": "\u21BA", "CloseCurlyQuote;": "\u2019", "ContourIntegral;": "\u222E", "curvearrowright;": "\u21B7", "DoubleDownArrow;": "\u21D3", "DoubleLeftArrow;": "\u21D0", "downharpoonleft;": "\u21C3", "DownRightVector;": "\u21C1", "leftharpoondown;": "\u21BD", "leftrightarrows;": "\u21C6", "LeftRightVector;": "\u294E", "LeftTriangleBar;": "\u29CF", "LeftUpTeeVector;": "\u2960", "LeftUpVectorBar;": "\u2958", "LowerRightArrow;": "\u2198", "nLeftrightarrow;": "\u21CE", "nleftrightarrow;": "\u21AE", "NotGreaterEqual;": "\u2271", "NotGreaterTilde;": "\u2275", "NotHumpDownHump;": "\u224E\u0338", "NotLeftTriangle;": "\u22EA", "NotSquareSubset;": "\u228F\u0338", "ntrianglelefteq;": "\u22EC", "OverParenthesis;": "\u23DC", "RightDownVector;": "\u21C2", "rightleftarrows;": "\u21C4", "rightsquigarrow;": "\u219D", "rightthreetimes;": "\u22CC", "ShortRightArrow;": "\u2192", "straightepsilon;": "\u03F5", "trianglerighteq;": "\u22B5", "UpperRightArrow;": "\u2197", "vartriangleleft;": "\u22B2", "circlearrowright;": "\u21BB", "DiacriticalAcute;": "\xB4", "DiacriticalGrave;": "`", "DiacriticalTilde;": "\u02DC", "DoubleRightArrow;": "\u21D2", "DownArrowUpArrow;": "\u21F5", "downharpoonright;": "\u21C2", "EmptySmallSquare;": "\u25FB", "GreaterEqualLess;": "\u22DB", "GreaterFullEqual;": "\u2267", "LeftAngleBracket;": "\u27E8", "LeftUpDownVector;": "\u2951", "LessEqualGreater;": "\u22DA", "NonBreakingSpace;": "\xA0", "NotPrecedesEqual;": "\u2AAF\u0338", "NotRightTriangle;": "\u22EB", "NotSucceedsEqual;": "\u2AB0\u0338", "NotSucceedsTilde;": "\u227F\u0338", "NotSupersetEqual;": "\u2289", "ntrianglerighteq;": "\u22ED", "rightharpoondown;": "\u21C1", "rightrightarrows;": "\u21C9", "RightTriangleBar;": "\u29D0", "RightUpTeeVector;": "\u295C", "RightUpVectorBar;": "\u2954", "twoheadleftarrow;": "\u219E", "UnderParenthesis;": "\u23DD", "UpArrowDownArrow;": "\u21C5", "vartriangleright;": "\u22B3", "blacktriangledown;": "\u25BE", "blacktriangleleft;": "\u25C2", "DoubleUpDownArrow;": "\u21D5", "DoubleVerticalBar;": "\u2225", "DownLeftTeeVector;": "\u295E", "DownLeftVectorBar;": "\u2956", "FilledSmallSquare;": "\u25FC", "GreaterSlantEqual;": "\u2A7E", "LeftDoubleBracket;": "\u27E6", "LeftDownTeeVector;": "\u2961", "LeftDownVectorBar;": "\u2959", "leftrightharpoons;": "\u21CB", "LeftTriangleEqual;": "\u22B4", "NegativeThinSpace;": "\u200B", "NotGreaterGreater;": "\u226B\u0338", "NotLessSlantEqual;": "\u2A7D\u0338", "NotNestedLessLess;": "\u2AA1\u0338", "NotReverseElement;": "\u220C", "NotSquareSuperset;": "\u2290\u0338", "NotTildeFullEqual;": "\u2247", "RightAngleBracket;": "\u27E9", "rightleftharpoons;": "\u21CC", "RightUpDownVector;": "\u294F", "SquareSubsetEqual;": "\u2291", "twoheadrightarrow;": "\u21A0", "VerticalSeparator;": "\u2758", "blacktriangleright;": "\u25B8", "DownRightTeeVector;": "\u295F", "DownRightVectorBar;": "\u2957", "LongLeftRightArrow;": "\u27F7", "Longleftrightarrow;": "\u27FA", "longleftrightarrow;": "\u27F7", "NegativeThickSpace;": "\u200B", "NotLeftTriangleBar;": "\u29CF\u0338", "PrecedesSlantEqual;": "\u227C", "ReverseEquilibrium;": "\u21CB", "RightDoubleBracket;": "\u27E7", "RightDownTeeVector;": "\u295D", "RightDownVectorBar;": "\u2955", "RightTriangleEqual;": "\u22B5", "SquareIntersection;": "\u2293", "SucceedsSlantEqual;": "\u227D", "DoubleLongLeftArrow;": "\u27F8", "DownLeftRightVector;": "\u2950", "LeftArrowRightArrow;": "\u21C6", "leftrightsquigarrow;": "\u21AD", "NegativeMediumSpace;": "\u200B", "NotGreaterFullEqual;": "\u2267\u0338", "NotRightTriangleBar;": "\u29D0\u0338", "RightArrowLeftArrow;": "\u21C4", "SquareSupersetEqual;": "\u2292", "CapitalDifferentialD;": "\u2145", "DoubleLeftRightArrow;": "\u21D4", "DoubleLongRightArrow;": "\u27F9", "EmptyVerySmallSquare;": "\u25AB", "NestedGreaterGreater;": "\u226B", "NotDoubleVerticalBar;": "\u2226", "NotGreaterSlantEqual;": "\u2A7E\u0338", "NotLeftTriangleEqual;": "\u22EC", "NotSquareSubsetEqual;": "\u22E2", "OpenCurlyDoubleQuote;": "\u201C", "ReverseUpEquilibrium;": "\u296F", "CloseCurlyDoubleQuote;": "\u201D", "DoubleContourIntegral;": "\u222F", "FilledVerySmallSquare;": "\u25AA", "NegativeVeryThinSpace;": "\u200B", "NotPrecedesSlantEqual;": "\u22E0", "NotRightTriangleEqual;": "\u22ED", "NotSucceedsSlantEqual;": "\u22E1", "DiacriticalDoubleAcute;": "\u02DD", "NotSquareSupersetEqual;": "\u22E3", "NotNestedGreaterGreater;": "\u2AA2\u0338", "ClockwiseContourIntegral;": "\u2232", "DoubleLongLeftRightArrow;": "\u27FA", "CounterClockwiseContourIntegral;": "\u2233" };
      let h2;
      const g2 = { 128: 8364, 130: 8218, 131: 402, 132: 8222, 133: 8230, 134: 8224, 135: 8225, 136: 710, 137: 8240, 138: 352, 139: 8249, 140: 338, 142: 381, 145: 8216, 146: 8217, 147: 8220, 148: 8221, 149: 8226, 150: 8211, 151: 8212, 152: 732, 153: 8482, 154: 353, 155: 8250, 156: 339, 158: 382, 159: 376 }, x2 = r2.makeMap("style,iframe,script,noscript", true), v2 = { isVoidTag: r2.isVoidTag, isNativeTag: (t3) => r2.isHTMLTag(t3) || r2.isSVGTag(t3), isPreTag: (t3) => "pre" === t3, decodeEntities: (t3, e3) => {
        let r3 = 0;
        const n3 = t3.length;
        let i3 = "";
        function advance(e4) {
          r3 += e4, t3 = t3.slice(e4);
        }
        for (; r3 < n3; ) {
          const o3 = /&(?:#x?)?/i.exec(t3);
          if (!o3 || r3 + o3.index >= n3) {
            const e4 = n3 - r3;
            i3 += t3.slice(0, e4), advance(e4);
            break;
          }
          if (i3 += t3.slice(0, o3.index), advance(o3.index), "&" === o3[0]) {
            let r4, n4 = "";
            if (/[0-9a-z]/i.test(t3[1])) {
              h2 || (h2 = Object.keys(u2).reduce((t4, e4) => Math.max(t4, e4.length), 0));
              for (let e4 = h2; !r4 && e4 > 0; --e4)
                n4 = t3.slice(1, 1 + e4), r4 = u2[n4];
              if (r4) {
                const o4 = n4.endsWith(";");
                e3 && !o4 && /[=a-z0-9]/i.test(t3[n4.length + 1] || "") ? (i3 += "&" + n4, advance(1 + n4.length)) : (i3 += r4, advance(1 + n4.length));
              } else
                i3 += "&" + n4, advance(1 + n4.length);
            } else
              i3 += "&", advance(1);
          } else {
            const e4 = "&#x" === o3[0], r4 = (e4 ? /^&#x([0-9a-f]+);?/i : /^&#([0-9]+);?/).exec(t3);
            if (r4) {
              let t4 = Number.parseInt(r4[1], e4 ? 16 : 10);
              0 === t4 || t4 > 1114111 || t4 >= 55296 && t4 <= 57343 ? t4 = 65533 : t4 >= 64976 && t4 <= 65007 || 65534 == (65534 & t4) || (t4 >= 1 && t4 <= 8 || 11 === t4 || t4 >= 13 && t4 <= 31 || t4 >= 127 && t4 <= 159) && (t4 = g2[t4] || t4), i3 += String.fromCodePoint(t4), advance(r4[0].length);
            } else
              i3 += o3[0], advance(o3[0].length);
          }
        }
        return i3;
      }, isBuiltInComponent: (t3) => e2.isBuiltInType(t3, "Transition") ? d2 : e2.isBuiltInType(t3, "TransitionGroup") ? m2 : void 0, getNamespace(t3, e3) {
        let r3 = e3 ? e3.ns : 0;
        if (e3 && 2 === r3)
          if ("annotation-xml" === e3.tag) {
            if ("svg" === t3)
              return 1;
            e3.props.some((t4) => 6 === t4.type && "encoding" === t4.name && null != t4.value && ("text/html" === t4.value.content || "application/xhtml+xml" === t4.value.content)) && (r3 = 0);
          } else
            /^m(?:[ions]|text)$/.test(e3.tag) && "mglyph" !== t3 && "malignmark" !== t3 && (r3 = 0);
        else
          e3 && 1 === r3 && ("foreignObject" !== e3.tag && "desc" !== e3.tag && "title" !== e3.tag || (r3 = 0));
        if (0 === r3) {
          if ("svg" === t3)
            return 1;
          if ("math" === t3)
            return 2;
        }
        return r3;
      }, getTextMode({ tag: t3, ns: e3 }) {
        if (0 === e3) {
          if ("textarea" === t3 || "title" === t3)
            return 1;
          if (x2(t3))
            return 2;
        }
        return 0;
      } }, transformStyle = (t3) => {
        1 === t3.type && t3.props.forEach((r3, n3) => {
          6 === r3.type && "style" === r3.name && r3.value && (t3.props[n3] = { type: 7, name: "bind", arg: e2.createSimpleExpression("style", true, r3.loc), exp: parseInlineCSS(r3.value.content, r3.loc), modifiers: [], loc: r3.loc });
        });
      }, parseInlineCSS = (t3, n3) => {
        const i3 = r2.parseStringStyle(t3);
        return e2.createSimpleExpression(JSON.stringify(i3), false, n3, 3);
      };
      function createDOMCompilerError(t3, r3) {
        return e2.createCompilerError(t3, r3, y2);
      }
      const y2 = { 53: "v-html is missing expression.", 54: "v-html will override element children.", 55: "v-text is missing expression.", 56: "v-text will override element children.", 57: "v-model can only be used on <input>, <textarea> and <select> elements.", 58: "v-model argument is not supported on plain elements.", 59: "v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.", 60: "Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.", 61: "v-show is missing expression.", 62: "<Transition> expects exactly one child element or component.", 63: "Tags with side effect (<script> and <style>) are ignored in client component templates." }, b2 = r2.makeMap("passive,once,capture"), w2 = r2.makeMap("stop,prevent,self,ctrl,shift,alt,meta,exact,middle"), k2 = r2.makeMap("left,right"), S2 = r2.makeMap("onkeyup,onkeydown,onkeypress", true), transformClick = (t3, r3) => e2.isStaticExp(t3) && "onclick" === t3.content.toLowerCase() ? e2.createSimpleExpression(r3, true) : 4 !== t3.type ? e2.createCompoundExpression(["(", t3, `) === "onClick" ? "${r3}" : (`, t3, ")"]) : t3, C2 = /__VUE_EXP_START__(.*?)__VUE_EXP_END__/g, stringifyStatic = (t3, r3, n3) => {
        if (r3.scopes.vSlot > 0)
          return;
        let i3 = 0, o3 = 0;
        const a3 = [], stringifyCurrentChunk = (n4) => {
          if (i3 >= 20 || o3 >= 5) {
            const i4 = e2.createCallExpression(r3.helper(e2.CREATE_STATIC), [JSON.stringify(a3.map((t4) => stringifyNode(t4, r3)).join("")).replace(C2, '" + $1 + "'), String(a3.length)]);
            if (replaceHoist(a3[0], i4, r3), a3.length > 1) {
              for (let t4 = 1; t4 < a3.length; t4++)
                replaceHoist(a3[t4], null, r3);
              const e3 = a3.length - 1;
              return t3.splice(n4 - a3.length + 1, e3), e3;
            }
          }
          return 0;
        };
        let s3 = 0;
        for (; s3 < t3.length; s3++) {
          const e3 = t3[s3];
          if (getHoistedNode(e3)) {
            const t4 = e3, r4 = analyzeNode(t4);
            if (r4) {
              i3 += r4[0], o3 += r4[1], a3.push(t4);
              continue;
            }
          }
          s3 -= stringifyCurrentChunk(s3), i3 = 0, o3 = 0, a3.length = 0;
        }
        stringifyCurrentChunk(s3);
      }, getHoistedNode = (t3) => (1 === t3.type && 0 === t3.tagType || 12 == t3.type) && t3.codegenNode && 4 === t3.codegenNode.type && t3.codegenNode.hoisted, _2 = /^(data|aria)-/, isStringifiableAttr = (t3, e3) => (0 === e3 ? r2.isKnownHtmlAttr(t3) : 1 === e3 && r2.isKnownSvgAttr(t3)) || _2.test(t3), replaceHoist = (t3, e3, r3) => {
        const n3 = t3.codegenNode.hoisted;
        r3.hoists[r3.hoists.indexOf(n3)] = e3;
      }, P2 = r2.makeMap("caption,thead,tr,th,tbody,td,tfoot,colgroup,col");
      function analyzeNode(t3) {
        if (1 === t3.type && P2(t3.tag))
          return false;
        if (12 === t3.type)
          return [1, 0];
        let e3 = 1, r3 = t3.props.length > 0 ? 1 : 0, n3 = false;
        const bail = () => (n3 = true, false);
        return !!function walk2(t4) {
          for (let e4 = 0; e4 < t4.props.length; e4++) {
            const r4 = t4.props[e4];
            if (6 === r4.type && !isStringifiableAttr(r4.name, t4.ns))
              return bail();
            if (7 === r4.type && "bind" === r4.name) {
              if (r4.arg && (8 === r4.arg.type || r4.arg.isStatic && !isStringifiableAttr(r4.arg.content, t4.ns)))
                return bail();
              if (r4.exp && (8 === r4.exp.type || r4.exp.constType < 3))
                return bail();
            }
          }
          for (let i3 = 0; i3 < t4.children.length; i3++) {
            e3++;
            const o3 = t4.children[i3];
            if (1 === o3.type && (o3.props.length > 0 && r3++, walk2(o3), n3))
              return false;
          }
          return true;
        }(t3) && [e3, r3];
      }
      function stringifyNode(t3, e3) {
        if (r2.isString(t3))
          return t3;
        if (r2.isSymbol(t3))
          return "";
        switch (t3.type) {
          case 1:
            return function(t4, e4) {
              let n3 = `<${t4.tag}`, i3 = "";
              for (let e5 = 0; e5 < t4.props.length; e5++) {
                const o3 = t4.props[e5];
                if (6 === o3.type)
                  n3 += ` ${o3.name}`, o3.value && (n3 += `="${r2.escapeHtml(o3.value.content)}"`);
                else if (7 === o3.type)
                  if ("bind" === o3.name) {
                    const t5 = o3.exp;
                    if ("_" === t5.content[0]) {
                      n3 += ` ${o3.arg.content}="__VUE_EXP_START__${t5.content}__VUE_EXP_END__"`;
                      continue;
                    }
                    if (r2.isBooleanAttr(o3.arg.content) && "false" === t5.content)
                      continue;
                    let e6 = evaluateConstant(t5);
                    if (null != e6) {
                      const t6 = o3.arg && o3.arg.content;
                      "class" === t6 ? e6 = r2.normalizeClass(e6) : "style" === t6 && (e6 = r2.stringifyStyle(r2.normalizeStyle(e6))), n3 += ` ${o3.arg.content}="${r2.escapeHtml(e6)}"`;
                    }
                  } else
                    "html" === o3.name ? i3 = evaluateConstant(o3.exp) : "text" === o3.name && (i3 = r2.escapeHtml(r2.toDisplayString(evaluateConstant(o3.exp))));
              }
              e4.scopeId && (n3 += ` ${e4.scopeId}`);
              if (n3 += ">", i3)
                n3 += i3;
              else
                for (let r3 = 0; r3 < t4.children.length; r3++)
                  n3 += stringifyNode(t4.children[r3], e4);
              r2.isVoidTag(t4.tag) || (n3 += `</${t4.tag}>`);
              return n3;
            }(t3, e3);
          case 2:
            return r2.escapeHtml(t3.content);
          case 3:
            return `<!--${r2.escapeHtml(t3.content)}-->`;
          case 5:
            return r2.escapeHtml(r2.toDisplayString(evaluateConstant(t3.content)));
          case 8:
            return r2.escapeHtml(evaluateConstant(t3));
          case 12:
            return stringifyNode(t3.content, e3);
          default:
            return "";
        }
      }
      function evaluateConstant(t3) {
        if (4 === t3.type)
          return new Function(`return (${t3.content})`)();
        {
          let e3 = "";
          return t3.children.forEach((t4) => {
            r2.isString(t4) || r2.isSymbol(t4) || (2 === t4.type ? e3 += t4.content : 5 === t4.type ? e3 += r2.toDisplayString(evaluateConstant(t4.content)) : e3 += evaluateConstant(t4));
          }), e3;
        }
      }
      const ignoreSideEffectTags = (t3, e3) => {
        1 !== t3.type || 0 !== t3.tagType || "script" !== t3.tag && "style" !== t3.tag || e3.removeNode();
      }, T2 = [transformStyle], A2 = { cloak: e2.noopDirectiveTransform, html: (t3, r3, n3) => {
        const { exp: i3, loc: o3 } = t3;
        return i3 || n3.onError(createDOMCompilerError(53, o3)), r3.children.length && (n3.onError(createDOMCompilerError(54, o3)), r3.children.length = 0), { props: [e2.createObjectProperty(e2.createSimpleExpression("innerHTML", true, o3), i3 || e2.createSimpleExpression("", true))] };
      }, text: (t3, r3, n3) => {
        const { exp: i3, loc: o3 } = t3;
        return i3 || n3.onError(createDOMCompilerError(55, o3)), r3.children.length && (n3.onError(createDOMCompilerError(56, o3)), r3.children.length = 0), { props: [e2.createObjectProperty(e2.createSimpleExpression("textContent", true), i3 ? e2.getConstantType(i3, n3) > 0 ? i3 : e2.createCallExpression(n3.helperString(e2.TO_DISPLAY_STRING), [i3], o3) : e2.createSimpleExpression("", true))] };
      }, model: (t3, r3, l3) => {
        const p3 = e2.transformModel(t3, r3, l3);
        if (!p3.props.length || 1 === r3.tagType)
          return p3;
        t3.arg && l3.onError(createDOMCompilerError(58, t3.arg.loc));
        const { tag: c3 } = r3, d3 = l3.isCustomElement(c3);
        if ("input" === c3 || "textarea" === c3 || "select" === c3 || d3) {
          let m3 = o2, u3 = false;
          if ("input" === c3 || d3) {
            const o3 = e2.findProp(r3, "type");
            if (o3) {
              if (7 === o3.type)
                m3 = s2;
              else if (o3.value)
                switch (o3.value.content) {
                  case "radio":
                    m3 = n2;
                    break;
                  case "checkbox":
                    m3 = i2;
                    break;
                  case "file":
                    u3 = true, l3.onError(createDOMCompilerError(59, t3.loc));
                }
            } else
              e2.hasDynamicKeyVBind(r3) && (m3 = s2);
          } else
            "select" === c3 && (m3 = a2);
          u3 || (p3.needRuntime = l3.helper(m3));
        } else
          l3.onError(createDOMCompilerError(57, t3.loc));
        return p3.props = p3.props.filter((t4) => !(4 === t4.key.type && "modelValue" === t4.key.content)), p3;
      }, on: (t3, n3, i3) => e2.transformOn(t3, n3, i3, (n4) => {
        const { modifiers: o3 } = t3;
        if (!o3.length)
          return n4;
        let { key: a3, value: s3 } = n4.props[0];
        const { keyModifiers: c3, nonKeyModifiers: d3, eventOptionModifiers: m3 } = ((t4, r3, n5, i4) => {
          const o4 = [], a4 = [], s4 = [];
          for (let l3 = 0; l3 < r3.length; l3++) {
            const p3 = r3[l3];
            "native" === p3 && e2.checkCompatEnabled("COMPILER_V_ON_NATIVE", n5, i4) || b2(p3) ? s4.push(p3) : k2(p3) ? e2.isStaticExp(t4) ? S2(t4.content) ? o4.push(p3) : a4.push(p3) : (o4.push(p3), a4.push(p3)) : w2(p3) ? a4.push(p3) : o4.push(p3);
          }
          return { keyModifiers: o4, nonKeyModifiers: a4, eventOptionModifiers: s4 };
        })(a3, o3, i3, t3.loc);
        if (d3.includes("right") && (a3 = transformClick(a3, "onContextmenu")), d3.includes("middle") && (a3 = transformClick(a3, "onMouseup")), d3.length && (s3 = e2.createCallExpression(i3.helper(l2), [s3, JSON.stringify(d3)])), !c3.length || e2.isStaticExp(a3) && !S2(a3.content) || (s3 = e2.createCallExpression(i3.helper(p2), [s3, JSON.stringify(c3)])), m3.length) {
          const t4 = m3.map(r2.capitalize).join("");
          a3 = e2.isStaticExp(a3) ? e2.createSimpleExpression(`${a3.content}${t4}`, true) : e2.createCompoundExpression(["(", a3, `) + "${t4}"`]);
        }
        return { props: [e2.createObjectProperty(a3, s3)] };
      }), show: (t3, e3, r3) => {
        const { exp: n3, loc: i3 } = t3;
        return n3 || r3.onError(createDOMCompilerError(61, i3)), { props: [], needRuntime: r3.helper(c2) };
      } };
      t2.DOMDirectiveTransforms = A2, t2.DOMNodeTransforms = T2, t2.TRANSITION = d2, t2.TRANSITION_GROUP = m2, t2.V_MODEL_CHECKBOX = i2, t2.V_MODEL_DYNAMIC = s2, t2.V_MODEL_RADIO = n2, t2.V_MODEL_SELECT = a2, t2.V_MODEL_TEXT = o2, t2.V_ON_WITH_KEYS = p2, t2.V_ON_WITH_MODIFIERS = l2, t2.V_SHOW = c2, t2.compile = function(t3, n3 = {}) {
        return e2.baseCompile(t3, r2.extend({}, v2, n3, { nodeTransforms: [ignoreSideEffectTags, ...T2, ...n3.nodeTransforms || []], directiveTransforms: r2.extend({}, A2, n3.directiveTransforms || {}), transformHoist: stringifyStatic }));
      }, t2.createDOMCompilerError = createDOMCompilerError, t2.parse = function(t3, n3 = {}) {
        return e2.baseParse(t3, r2.extend({}, v2, n3));
      }, t2.parserOptions = v2, t2.transformStyle = transformStyle, Object.keys(e2).forEach(function(r3) {
        "default" === r3 || Object.prototype.hasOwnProperty.call(t2, r3) || (t2[r3] = e2[r3]);
      });
    }(nn), rn.exports = nn;
    var _a = rn.exports;
    Object.defineProperty(en, "__esModule", { value: true });
    var Pa = _a, Ta = gr;
    const Aa = Symbol("ssrInterpolate"), Ia = Symbol("ssrRenderVNode"), Na = Symbol("ssrRenderComponent"), Ra = Symbol("ssrRenderSlot"), Oa = Symbol("ssrRenderSlotInner"), La = Symbol("ssrRenderClass"), Ma = Symbol("ssrRenderStyle"), Ba = Symbol("ssrRenderAttrs"), Da = Symbol("ssrRenderAttr"), ja = Symbol("ssrRenderDynamicAttr"), Fa = Symbol("ssrRenderList"), $a = Symbol("ssrIncludeBooleanAttr"), Va = Symbol("ssrLooseEqual"), za = Symbol("ssrLooseContain"), Ua = Symbol("ssrRenderDynamicModel"), Ha = Symbol("ssrGetDynamicModelProps"), qa = Symbol("ssrRenderTeleport"), Wa = Symbol("ssrRenderSuspense"), Ka = Symbol("ssrGetDirectiveProps"), Ga = { [Aa]: "ssrInterpolate", [Ia]: "ssrRenderVNode", [Na]: "ssrRenderComponent", [Ra]: "ssrRenderSlot", [Oa]: "ssrRenderSlotInner", [La]: "ssrRenderClass", [Ma]: "ssrRenderStyle", [Ba]: "ssrRenderAttrs", [Da]: "ssrRenderAttr", [ja]: "ssrRenderDynamicAttr", [Fa]: "ssrRenderList", [$a]: "ssrIncludeBooleanAttr", [Va]: "ssrLooseEqual", [za]: "ssrLooseContain", [Ua]: "ssrRenderDynamicModel", [Ha]: "ssrGetDynamicModelProps", [qa]: "ssrRenderTeleport", [Wa]: "ssrRenderSuspense", [Ka]: "ssrGetDirectiveProps" };
    Pa.registerRuntimeHelpers(Ga);
    const Ja = Pa.createStructuralDirectiveTransform(/^(if|else|else-if)$/, Pa.processIf);
    function ssrProcessIf(t2, e2, r2 = false) {
      const [n2] = t2.branches, i2 = Pa.createIfStatement(n2.condition, processIfBranch(n2, e2, r2));
      e2.pushStatement(i2);
      let o2 = i2;
      for (let n3 = 1; n3 < t2.branches.length; n3++) {
        const i3 = t2.branches[n3], a2 = processIfBranch(i3, e2, r2);
        i3.condition ? o2 = o2.alternate = Pa.createIfStatement(i3.condition, a2) : o2.alternate = a2;
      }
      o2.alternate || (o2.alternate = Pa.createBlockStatement([Pa.createCallExpression("_push", ["`<!---->`"])]));
    }
    function processIfBranch(t2, e2, r2 = false) {
      const { children: n2 } = t2;
      return processChildrenAsStatement(t2, e2, !(r2 || 1 === n2.length && 1 === n2[0].type || 1 === n2.length && 11 === n2[0].type));
    }
    const Ya = Pa.createStructuralDirectiveTransform("for", Pa.processFor);
    function ssrProcessFor(t2, e2, r2 = false) {
      const n2 = !r2 && (1 !== t2.children.length || 1 !== t2.children[0].type), i2 = Pa.createFunctionExpression(Pa.createForLoopParams(t2.parseResult));
      i2.body = processChildrenAsStatement(t2, e2, n2), r2 || e2.pushStringPart("<!--[-->"), e2.pushStatement(Pa.createCallExpression(e2.helper(Fa), [t2.source, i2])), r2 || e2.pushStringPart("<!--]-->");
    }
    const ssrTransformSlotOutlet = (t2, e2) => {
      if (Pa.isSlotOutlet(t2)) {
        const { slotName: r2, slotProps: n2 } = Pa.processSlotOutlet(t2, e2), i2 = ["_ctx.$slots", r2, n2 || "{}", "null", "_push", "_parent"];
        e2.scopeId && false !== e2.slotted && i2.push(`"${e2.scopeId}-s"`);
        let o2 = Ra;
        const a2 = e2.parent;
        a2 && 1 === a2.type && 1 === a2.tagType && Pa.resolveComponentType(a2, e2, true) === Pa.TRANSITION && 1 === a2.children.filter((t3) => 1 === t3.type).length && (o2 = Oa, e2.scopeId && false !== e2.slotted || i2.push("null"), i2.push("true")), t2.ssrCodegenNode = Pa.createCallExpression(e2.helper(o2), i2);
      }
    };
    function ssrProcessSlotOutlet(t2, e2) {
      const r2 = t2.ssrCodegenNode;
      if (t2.children.length) {
        const n2 = Pa.createFunctionExpression([]);
        n2.body = processChildrenAsStatement(t2, e2), r2.arguments[3] = n2;
      }
      if (e2.withSlotScopeId) {
        const t3 = r2.arguments[6];
        r2.arguments[6] = t3 ? `${t3} + _scopeId` : "_scopeId";
      }
      e2.pushStatement(t2.ssrCodegenNode);
    }
    function createSSRCompilerError(t2, e2) {
      return Pa.createCompilerError(t2, e2, Xa);
    }
    const Xa = { 65: "Unsafe attribute name for SSR.", 66: "Missing the 'to' prop on teleport element.", 67: "Invalid AST node during SSR transform." };
    const Qa = /* @__PURE__ */ new WeakMap();
    const Za = /* @__PURE__ */ new WeakMap(), ssrTransformElement = (t2, e2) => {
      if (1 === t2.type && 0 === t2.tagType)
        return function() {
          const r2 = [`<${t2.tag}`], n2 = "textarea" === t2.tag || t2.tag.indexOf("-") > 0, i2 = Pa.hasDynamicKeyVBind(t2), o2 = t2.props.some((t3) => 7 === t3.type && !Ta.isBuiltInDirective(t3.name)), a2 = i2 || o2;
          if (a2) {
            const { props: i3, directives: o3 } = Pa.buildProps(t2, e2, t2.props, false, false, true);
            if (i3 || o3.length) {
              const a3 = buildSSRProps(i3, o3, e2), s3 = Pa.createCallExpression(e2.helper(Ba), [a3]);
              if ("textarea" === t2.tag) {
                const r3 = t2.children[0];
                if (!r3 || 5 !== r3.type) {
                  const n3 = "_temp" + e2.temps++;
                  s3.arguments = [Pa.createAssignmentExpression(Pa.createSimpleExpression(n3, false), a3)], Za.set(t2, Pa.createCallExpression(e2.helper(Aa), [Pa.createConditionalExpression(Pa.createSimpleExpression(`"value" in ${n3}`, false), Pa.createSimpleExpression(`${n3}.value`, false), Pa.createSimpleExpression(r3 ? r3.content : "", true), false)]));
                }
              } else if ("input" === t2.tag) {
                const r3 = function(t3) {
                  return t3.props.find((t4) => 7 === t4.type && "model" === t4.name && t4.exp);
                }(t2);
                if (r3) {
                  const t3 = "_temp" + e2.temps++, n3 = Pa.createSimpleExpression(t3, false);
                  s3.arguments = [Pa.createSequenceExpression([Pa.createAssignmentExpression(n3, a3), Pa.createCallExpression(e2.helper(Pa.MERGE_PROPS), [n3, Pa.createCallExpression(e2.helper(Ha), [n3, r3.exp])])])];
                }
              }
              n2 && s3.arguments.push(`"${t2.tag}"`), r2.push(s3);
            }
          }
          let s2, l2, p2;
          for (let i3 = 0; i3 < t2.props.length; i3++) {
            const o3 = t2.props[i3];
            if ("input" !== t2.tag || !isTrueFalseValue(o3)) {
              if (7 === o3.type) {
                if ("html" === o3.name && o3.exp)
                  Za.set(t2, o3.exp);
                else if ("text" === o3.name && o3.exp)
                  t2.children = [Pa.createInterpolation(o3.exp, o3.loc)];
                else if ("slot" === o3.name)
                  e2.onError(Pa.createCompilerError(40, o3.loc));
                else if (isTextareaWithValue(t2, o3) && o3.exp)
                  a2 || (t2.children = [Pa.createInterpolation(o3.exp, o3.loc)]);
                else if (!a2 && "on" !== o3.name) {
                  const i4 = e2.directiveTransforms[o3.name];
                  if (i4) {
                    const { props: a3, ssrTagParts: l3 } = i4(o3, t2, e2);
                    l3 && r2.push(...l3);
                    for (let i5 = 0; i5 < a3.length; i5++) {
                      const { key: o4, value: l4 } = a3[i5];
                      if (Pa.isStaticExp(o4)) {
                        let n3 = o4.content;
                        if ("key" === n3 || "ref" === n3)
                          continue;
                        "class" === n3 ? r2.push(' class="', s2 = Pa.createCallExpression(e2.helper(La), [l4]), '"') : "style" === n3 ? p2 ? mergeCall(p2, l4) : r2.push(' style="', p2 = Pa.createCallExpression(e2.helper(Ma), [l4]), '"') : (n3 = t2.tag.indexOf("-") > 0 ? n3 : Ta.propsToAttrMap[n3] || n3.toLowerCase(), Ta.isBooleanAttr(n3) ? r2.push(Pa.createConditionalExpression(Pa.createCallExpression(e2.helper($a), [l4]), Pa.createSimpleExpression(" " + n3, true), Pa.createSimpleExpression("", true), false)) : Ta.isSSRSafeAttrName(n3) ? r2.push(Pa.createCallExpression(e2.helper(Da), [o4, l4])) : e2.onError(createSSRCompilerError(65, o4.loc)));
                      } else {
                        const i6 = [o4, l4];
                        n2 && i6.push(`"${t2.tag}"`), r2.push(Pa.createCallExpression(e2.helper(ja), i6));
                      }
                    }
                  }
                }
              } else if ("textarea" === t2.tag && "value" === o3.name && o3.value)
                Za.set(t2, Ta.escapeHtml(o3.value.content));
              else if (!a2) {
                if ("key" === o3.name || "ref" === o3.name)
                  continue;
                "class" === o3.name && o3.value && (l2 = JSON.stringify(o3.value.content)), r2.push(` ${o3.name}` + (o3.value ? `="${Ta.escapeHtml(o3.value.content)}"` : ""));
              }
            }
          }
          s2 && l2 && (mergeCall(s2, l2), function(t3, e3) {
            const r3 = new RegExp(`^ ${e3}=".+"$`), n3 = t3.findIndex((t4) => "string" == typeof t4 && r3.test(t4));
            n3 > -1 && t3.splice(n3, 1);
          }(r2, "class")), e2.scopeId && r2.push(` ${e2.scopeId}`), t2.ssrCodegenNode = Pa.createTemplateLiteral(r2);
        };
    };
    function buildSSRProps(t2, e2, r2) {
      let n2 = [];
      if (t2 && (14 === t2.type ? n2 = t2.arguments : n2.push(t2)), e2.length)
        for (const t3 of e2)
          n2.push(Pa.createCallExpression(r2.helper(Ka), ["_ctx", ...Pa.buildDirectiveArgs(t3, r2).elements]));
      return n2.length > 1 ? Pa.createCallExpression(r2.helper(Pa.MERGE_PROPS), n2) : n2[0];
    }
    function isTrueFalseValue(t2) {
      return 7 === t2.type ? "bind" === t2.name && t2.arg && Pa.isStaticExp(t2.arg) && ("true-value" === t2.arg.content || "false-value" === t2.arg.content) : "true-value" === t2.name || "false-value" === t2.name;
    }
    function isTextareaWithValue(t2, e2) {
      return !("textarea" !== t2.tag || "bind" !== e2.name || !Pa.isStaticArgOf(e2.arg, "value"));
    }
    function mergeCall(t2, e2) {
      const r2 = t2.arguments[0];
      17 === r2.type ? r2.elements.push(e2) : t2.arguments[0] = Pa.createArrayExpression([r2, e2]);
    }
    function ssrProcessElement(t2, e2) {
      const r2 = e2.options.isVoidTag || Ta.NO, n2 = t2.ssrCodegenNode.elements;
      for (let t3 = 0; t3 < n2.length; t3++)
        e2.pushStringPart(n2[t3]);
      e2.withSlotScopeId && e2.pushStringPart(Pa.createSimpleExpression("_scopeId", false)), e2.pushStringPart(">");
      const i2 = Za.get(t2);
      i2 ? e2.pushStringPart(i2) : t2.children.length && processChildren(t2, e2), r2(t2.tag) || e2.pushStringPart(`</${t2.tag}>`);
    }
    const ts = /* @__PURE__ */ new WeakMap();
    const es = /* @__PURE__ */ new WeakMap();
    const rs = /* @__PURE__ */ new WeakMap(), ns = Symbol(), is = /* @__PURE__ */ new WeakMap(), ssrTransformComponent = (t2, e2) => {
      if (1 !== t2.type || 1 !== t2.tagType)
        return;
      const r2 = Pa.resolveComponentType(t2, e2, true), n2 = Ta.isObject(r2) && r2.callee === Pa.RESOLVE_DYNAMIC_COMPONENT;
      if (is.set(t2, r2), Ta.isSymbol(r2))
        return r2 === Pa.SUSPENSE ? function(t3, e3) {
          return () => {
            if (t3.children.length) {
              const r3 = { slotsExp: null, wipSlots: [] };
              Qa.set(t3, r3), r3.slotsExp = Pa.buildSlots(t3, e3, (t4, e4, n3, i3) => {
                const o3 = Pa.createFunctionExpression([], void 0, true, false, i3);
                return r3.wipSlots.push({ fn: o3, children: n3 }), o3;
              }).slots;
            }
          };
        }(t2, e2) : r2 === Pa.TRANSITION_GROUP ? function(t3, e3) {
          return () => {
            const r3 = Pa.findProp(t3, "tag");
            if (r3) {
              const n3 = t3.props.filter((t4) => t4 !== r3), { props: i3, directives: o3 } = Pa.buildProps(t3, e3, n3, true, false, true);
              let a2 = null;
              (i3 || o3.length) && (a2 = Pa.createCallExpression(e3.helper(Ba), [buildSSRProps(i3, o3, e3)])), ts.set(t3, { tag: r3, propsExp: a2, scopeId: e3.scopeId || null });
            }
          };
        }(t2, e2) : r2 === Pa.TRANSITION ? function(t3, e3) {
          return () => {
            const e4 = Pa.findProp(t3, "appear", false, true);
            es.set(t3, !!e4);
          };
        }(t2) : void 0;
      const i2 = [], o2 = clone(t2);
      return function() {
        o2.children.length && Pa.buildSlots(o2, e2, (t3, r3, n3) => (i2.push(function(t4, e3, r4, n4) {
          const i3 = os.get(n4.root), o3 = { ...i3, nodeTransforms: [...ls, ...i3.nodeTransforms || []], directiveTransforms: { ...ps, ...i3.directiveTransforms || {} } }, a3 = { type: 1, ns: 0, tag: "template", tagType: 3, isSelfClosing: false, props: [{ type: 7, name: "slot", exp: t4, arg: void 0, modifiers: [], loc: Pa.locStub }, { type: 7, name: "for", exp: e3, arg: void 0, modifiers: [], loc: Pa.locStub }], children: r4, loc: Pa.locStub, codegenNode: void 0 };
          return function(t5, e4, r5) {
            const n5 = Pa.createRoot([t5]), i4 = Pa.createTransformContext(n5, e4);
            i4.ssr = false, i4.scopes = { ...r5.scopes }, i4.identifiers = { ...r5.identifiers }, i4.imports = r5.imports, Pa.traverseNode(n5, i4), ["helpers", "components", "directives"].forEach((t6) => {
              i4[t6].forEach((e5, n6) => {
                if ("helpers" === t6) {
                  const t7 = r5.helpers.get(n6);
                  void 0 === t7 ? r5.helpers.set(n6, e5) : r5.helpers.set(n6, e5 + t7);
                } else
                  r5[t6].add(e5);
              });
            });
          }(a3, o3, n4), Pa.createReturnStatement(r4);
        }(t3, r3, n3, e2)), Pa.createFunctionExpression(void 0)));
        let a2 = "null";
        if (t2.props.length) {
          const { props: r3, directives: i3 } = Pa.buildProps(t2, e2, void 0, true, n2);
          (r3 || i3.length) && (a2 = buildSSRProps(r3, i3, e2));
        }
        const s2 = [];
        rs.set(t2, s2);
        const l2 = t2.children.length ? Pa.buildSlots(t2, e2, (t3, e3, r3, n3) => {
          const o3 = t3 && Pa.stringifyExpression(t3) || "_", a3 = Pa.createFunctionExpression([o3, "_push", "_parent", "_scopeId"], void 0, true, true, n3);
          return s2.push({ type: ns, fn: a3, children: r3, vnodeBranch: i2[s2.length] }), a3;
        }).slots : "null";
        t2.ssrCodegenNode = "string" != typeof r2 ? Pa.createCallExpression(e2.helper(Ia), ["_push", Pa.createCallExpression(e2.helper(Pa.CREATE_VNODE), [r2, a2, l2]), "_parent"]) : Pa.createCallExpression(e2.helper(Na), [r2, a2, l2, "_parent"]);
      };
    };
    function ssrProcessComponent(t2, e2, r2) {
      const n2 = is.get(t2);
      if (t2.ssrCodegenNode) {
        const r3 = rs.get(t2) || [];
        for (let t3 = 0; t3 < r3.length; t3++) {
          const { fn: n3, vnodeBranch: i2 } = r3[t3];
          n3.body = Pa.createIfStatement(Pa.createSimpleExpression("_push", false), processChildrenAsStatement(r3[t3], e2, false, true), i2);
        }
        e2.withSlotScopeId && t2.ssrCodegenNode.arguments.push("_scopeId"), "string" == typeof n2 ? e2.pushStatement(Pa.createCallExpression("_push", [t2.ssrCodegenNode])) : e2.pushStatement(t2.ssrCodegenNode);
      } else {
        if (n2 === Pa.TELEPORT)
          return function(t3, e3) {
            const r3 = Pa.findProp(t3, "to");
            if (!r3)
              return void e3.onError(createSSRCompilerError(66, t3.loc));
            let n3;
            if (n3 = 6 === r3.type ? r3.value && Pa.createSimpleExpression(r3.value.content, true) : r3.exp, !n3)
              return void e3.onError(createSSRCompilerError(66, r3.loc));
            const i2 = Pa.findProp(t3, "disabled", false, true), o2 = i2 ? 6 === i2.type ? "true" : i2.exp || "false" : "false", a2 = Pa.createFunctionExpression(["_push"], void 0, true, false, t3.loc);
            a2.body = processChildrenAsStatement(t3, e3), e3.pushStatement(Pa.createCallExpression(e3.helper(qa), ["_push", a2, n3, o2, "_parent"]));
          }(t2, e2);
        if (n2 === Pa.SUSPENSE)
          return function(t3, e3) {
            const r3 = Qa.get(t3);
            if (!r3)
              return;
            const { slotsExp: n3, wipSlots: i2 } = r3;
            for (let t4 = 0; t4 < i2.length; t4++) {
              const r4 = i2[t4];
              r4.fn.body = processChildrenAsStatement(r4, e3);
            }
            e3.pushStatement(Pa.createCallExpression(e3.helper(Wa), ["_push", n3]));
          }(t2, e2);
        if (n2 === Pa.TRANSITION_GROUP)
          return function(t3, e3) {
            const r3 = ts.get(t3);
            if (r3) {
              const { tag: n3, propsExp: i2, scopeId: o2 } = r3;
              7 === n3.type ? (e3.pushStringPart("<"), e3.pushStringPart(n3.exp), i2 && e3.pushStringPart(i2), o2 && e3.pushStringPart(` ${o2}`), e3.pushStringPart(">"), processChildren(t3, e3, false, true), e3.pushStringPart("</"), e3.pushStringPart(n3.exp), e3.pushStringPart(">")) : (e3.pushStringPart(`<${n3.value.content}`), i2 && e3.pushStringPart(i2), o2 && e3.pushStringPart(` ${o2}`), e3.pushStringPart(">"), processChildren(t3, e3, false, true), e3.pushStringPart(`</${n3.value.content}>`));
            } else
              processChildren(t3, e3, true, true);
          }(t2, e2);
        if (r2.type === ns && e2.pushStringPart(""), n2 === Pa.TRANSITION)
          return function(t3, e3) {
            t3.children = t3.children.filter((t4) => 3 !== t4.type), es.get(t3) ? (e3.pushStringPart("<template>"), processChildren(t3, e3, false, true), e3.pushStringPart("</template>")) : processChildren(t3, e3, false, true);
          }(t2, e2);
        processChildren(t2, e2);
      }
    }
    const os = /* @__PURE__ */ new WeakMap(), [as, ss] = Pa.getBaseTransformPreset(true), ls = [...as, ...Pa.DOMNodeTransforms], ps = { ...ss, ...Pa.DOMDirectiveTransforms };
    function clone(t2) {
      if (Ta.isArray(t2))
        return t2.map(clone);
      if (Ta.isObject(t2)) {
        const e2 = {};
        for (const r2 in t2)
          e2[r2] = clone(t2[r2]);
        return e2;
      }
      return t2;
    }
    function createSSRTransformContext(t2, e2, r2 = /* @__PURE__ */ new Set(), n2 = false) {
      const i2 = [];
      let o2 = null;
      return { root: t2, options: e2, body: i2, helpers: r2, withSlotScopeId: n2, onError: e2.onError || ((t3) => {
        throw t3;
      }), helper: (t3) => (r2.add(t3), t3), pushStringPart(t3) {
        if (!o2) {
          const t4 = Pa.createCallExpression("_push");
          i2.push(t4), o2 = Pa.createTemplateLiteral([]), t4.arguments.push(o2);
        }
        const e3 = o2.elements, r3 = e3[e3.length - 1];
        Ta.isString(t3) && Ta.isString(r3) ? e3[e3.length - 1] += t3 : e3.push(t3);
      }, pushStatement(t3) {
        o2 = null, i2.push(t3);
      } };
    }
    function processChildren(t2, e2, r2 = false, n2 = false) {
      r2 && e2.pushStringPart("<!--[-->");
      const { children: i2 } = t2;
      for (let r3 = 0; r3 < i2.length; r3++) {
        const o2 = i2[r3];
        switch (o2.type) {
          case 1:
            switch (o2.tagType) {
              case 0:
                ssrProcessElement(o2, e2);
                break;
              case 1:
                ssrProcessComponent(o2, e2, t2);
                break;
              case 2:
                ssrProcessSlotOutlet(o2, e2);
                break;
              case 3:
                break;
              default:
                e2.onError(createSSRCompilerError(67, o2.loc));
                return o2;
            }
            break;
          case 2:
            e2.pushStringPart(Ta.escapeHtml(o2.content));
            break;
          case 3:
            e2.pushStringPart(`<!--${o2.content}-->`);
            break;
          case 5:
            e2.pushStringPart(Pa.createCallExpression(e2.helper(Aa), [o2.content]));
            break;
          case 9:
            ssrProcessIf(o2, e2, n2);
            break;
          case 11:
            ssrProcessFor(o2, e2, n2);
            break;
          case 10:
          case 12:
          case 8:
            break;
          default:
            e2.onError(createSSRCompilerError(67, o2.loc));
            return o2;
        }
      }
      r2 && e2.pushStringPart("<!--]-->");
    }
    function processChildrenAsStatement(t2, e2, r2 = false, n2 = e2.withSlotScopeId) {
      const i2 = function(t3, e3 = t3.withSlotScopeId) {
        return createSSRTransformContext(t3.root, t3.options, t3.helpers, e3);
      }(e2, n2);
      return processChildren(t2, i2, r2), Pa.createBlockStatement(i2.body);
    }
    const ssrTransformModel = (t2, e2, r2) => {
      const n2 = t2.exp;
      function checkDuplicatedValue() {
        const t3 = Pa.findProp(e2, "value");
        t3 && r2.onError(Pa.createDOMCompilerError(60, t3.loc));
      }
      function processOption(t3) {
        if ("option" === t3.tag) {
          if (-1 === t3.props.findIndex((t4) => "selected" === t4.name)) {
            const e3 = findValueBinding(t3);
            t3.ssrCodegenNode.elements.push(Pa.createConditionalExpression(Pa.createCallExpression(r2.helper($a), [Pa.createConditionalExpression(Pa.createCallExpression("Array.isArray", [n2]), Pa.createCallExpression(r2.helper(za), [n2, e3]), Pa.createCallExpression(r2.helper(Va), [n2, e3]))]), Pa.createSimpleExpression(" selected", true), Pa.createSimpleExpression("", true), false));
          }
        } else
          "optgroup" === t3.tag && t3.children.forEach((t4) => processOption(t4));
      }
      if (0 === e2.tagType) {
        const i2 = { props: [] }, o2 = [Pa.createObjectProperty("value", n2)];
        if ("input" === e2.tag) {
          const a2 = Pa.findProp(e2, "type");
          if (a2) {
            const s2 = findValueBinding(e2);
            if (7 === a2.type)
              i2.ssrTagParts = [Pa.createCallExpression(r2.helper(Ua), [a2.exp, n2, s2])];
            else if (a2.value)
              switch (a2.value.content) {
                case "radio":
                  i2.props = [Pa.createObjectProperty("checked", Pa.createCallExpression(r2.helper(Va), [n2, s2]))];
                  break;
                case "checkbox":
                  const a3 = Pa.findProp(e2, "true-value");
                  if (a3) {
                    const t3 = 6 === a3.type ? JSON.stringify(a3.value.content) : a3.exp;
                    i2.props = [Pa.createObjectProperty("checked", Pa.createCallExpression(r2.helper(Va), [n2, t3]))];
                  } else
                    i2.props = [Pa.createObjectProperty("checked", Pa.createConditionalExpression(Pa.createCallExpression("Array.isArray", [n2]), Pa.createCallExpression(r2.helper(za), [n2, s2]), n2))];
                  break;
                case "file":
                  r2.onError(Pa.createDOMCompilerError(59, t2.loc));
                  break;
                default:
                  checkDuplicatedValue(), i2.props = o2;
              }
          } else
            Pa.hasDynamicKeyVBind(e2) || (checkDuplicatedValue(), i2.props = o2);
        } else
          "textarea" === e2.tag ? (checkDuplicatedValue(), e2.children = [Pa.createInterpolation(n2, n2.loc)]) : "select" === e2.tag ? e2.children.forEach((t3) => {
            1 === t3.type && processOption(t3);
          }) : r2.onError(Pa.createDOMCompilerError(57, t2.loc));
        return i2;
      }
      return Pa.transformModel(t2, e2, r2);
    };
    function findValueBinding(t2) {
      const e2 = Pa.findProp(t2, "value");
      return e2 ? 7 === e2.type ? e2.exp : Pa.createSimpleExpression(e2.value.content, true) : Pa.createSimpleExpression("null", false);
    }
    const ssrTransformShow = (t2, e2, r2) => (t2.exp || r2.onError(Pa.createDOMCompilerError(61)), { props: [Pa.createObjectProperty("style", Pa.createConditionalExpression(t2.exp, Pa.createSimpleExpression("null", false), Pa.createObjectExpression([Pa.createObjectProperty("display", Pa.createSimpleExpression("none", true))]), false))] }), filterChild = (t2) => t2.children.filter((t3) => 3 !== t3.type), hasSingleChild = (t2) => 1 === filterChild(t2).length, ssrInjectFallthroughAttrs = (t2, e2) => {
      if (0 === t2.type && (e2.identifiers._attrs = 1), 1 === t2.type && 1 === t2.tagType && (Pa.isBuiltInType(t2.tag, "Transition") || Pa.isBuiltInType(t2.tag, "KeepAlive"))) {
        const r3 = filterChild(e2.root);
        if (1 === r3.length && r3[0] === t2)
          return void (hasSingleChild(t2) && injectFallthroughAttrs(t2.children[0]));
      }
      const r2 = e2.parent;
      if (r2 && 0 === r2.type)
        if (10 === t2.type && hasSingleChild(t2)) {
          let e3 = false;
          for (const t3 of filterChild(r2))
            if (9 === t3.type || 1 === t3.type && Pa.findDir(t3, "if")) {
              if (e3)
                return;
              e3 = true;
            } else if (!e3 || 1 !== t3.type || !Pa.findDir(t3, /else/, true))
              return;
          injectFallthroughAttrs(t2.children[0]);
        } else
          hasSingleChild(r2) && injectFallthroughAttrs(t2);
    };
    function injectFallthroughAttrs(t2) {
      1 !== t2.type || 0 !== t2.tagType && 1 !== t2.tagType || Pa.findDir(t2, "for") || t2.props.push({ type: 7, name: "bind", arg: void 0, exp: Pa.createSimpleExpression("_attrs", false), modifiers: [], loc: Pa.locStub });
    }
    const ssrInjectCssVars = (t2, e2) => {
      if (!e2.ssrCssVars)
        return;
      0 === t2.type && (e2.identifiers._cssVars = 1);
      const r2 = e2.parent;
      if (r2 && 0 === r2.type)
        if (10 === t2.type)
          for (const e3 of t2.children)
            injectCssVars(e3);
        else
          injectCssVars(t2);
    };
    function injectCssVars(t2) {
      if (1 === t2.type && (0 === t2.tagType || 1 === t2.tagType) && !Pa.findDir(t2, "for"))
        if (Pa.isBuiltInType(t2.tag, "Suspense"))
          for (const e2 of t2.children)
            1 === e2.type && 3 === e2.tagType ? e2.children.forEach(injectCssVars) : injectCssVars(e2);
        else
          t2.props.push({ type: 7, name: "bind", arg: void 0, exp: Pa.createSimpleExpression("_cssVars", false), modifiers: [], loc: Pa.locStub });
    }
    en.compile = function(t2, e2 = {}) {
      e2 = { ...e2, ...Pa.parserOptions, ssr: true, inSSR: true, scopeId: "function" === e2.mode ? null : e2.scopeId, prefixIdentifiers: true, cacheHandlers: false, hoistStatic: false };
      const r2 = Pa.baseParse(t2, e2);
      return os.set(r2, e2), Pa.transform(r2, { ...e2, hoistStatic: false, nodeTransforms: [Ja, Ya, Pa.trackVForSlotScopes, Pa.transformExpression, ssrTransformSlotOutlet, ssrInjectFallthroughAttrs, ssrInjectCssVars, ssrTransformElement, ssrTransformComponent, Pa.trackSlotScopes, Pa.transformStyle, ...e2.nodeTransforms || []], directiveTransforms: { bind: Pa.transformBind, on: Pa.transformOn, model: ssrTransformModel, show: ssrTransformShow, cloak: Pa.noopDirectiveTransform, once: Pa.noopDirectiveTransform, memo: Pa.noopDirectiveTransform, ...e2.directiveTransforms || {} } }), function(t3, e3) {
        const r3 = createSSRTransformContext(t3, e3);
        if (e3.ssrCssVars) {
          const n3 = Pa.createTransformContext(Pa.createRoot([]), e3), i2 = Pa.processExpression(Pa.createSimpleExpression(e3.ssrCssVars, false), n3);
          r3.body.push(Pa.createCompoundExpression(["const _cssVars = { style: ", i2, "}"])), Array.from(n3.helpers.keys()).forEach((e4) => {
            t3.helpers.add(e4);
          });
        }
        const n2 = t3.children.length > 1 && t3.children.some((t4) => !Pa.isText(t4));
        processChildren(t3, r3, n2), t3.codegenNode = Pa.createBlockStatement(r3.body), t3.ssrHelpers = Array.from(/* @__PURE__ */ new Set([...Array.from(t3.helpers).filter((t4) => t4 in Ga), ...r3.helpers])), t3.helpers = new Set(Array.from(t3.helpers).filter((t4) => !(t4 in Ga)));
      }(r2, e2), Pa.generate(r2, e2);
    };
    var cs, ds = { exports: {} }, ms = { exports: {} }, us = ms.exports;
    var hs, fs = {};
    function requireUtils() {
      if (hs)
        return fs;
      function createNotImplementedError2(t2) {
        throw new Error(`[unenv] ${t2} is not implemented yet!`);
      }
      return hs = 1, Object.defineProperty(fs, "__esModule", { value: true }), fs.createNotImplementedError = createNotImplementedError2, fs.mergeFns = function(...t2) {
        return function(...e2) {
          for (const r2 of t2)
            r2(...e2);
        };
      }, fs.notImplemented = function(t2) {
        return Object.assign(() => {
          throw createNotImplementedError2(t2);
        }, { __unenv__: true });
      }, fs.notImplementedClass = function(t2) {
        return class {
          __unenv__ = true;
          constructor() {
            throw new Error(`[unenv] ${t2} is not implemented yet!`);
          }
        };
      }, fs.rawHeaders = function(t2) {
        const e2 = [];
        for (const r2 in t2)
          if (Array.isArray(t2[r2]))
            for (const n2 of t2[r2])
              e2.push(r2, n2);
          else
            e2.push(r2, t2[r2]);
        return e2;
      }, fs;
    }
    var gs, xs, vs, ys = {}, bs = { exports: {} }, ws = {};
    function require_events() {
      if (gs)
        return ws;
      gs = 1, Object.defineProperty(ws, "__esModule", { value: true }), ws.EventEmitter = void 0, ws.once = function(t3, e2) {
        return new Promise(function(r2, n2) {
          function errorListener(r3) {
            t3.removeListener(e2, resolver), n2(r3);
          }
          function resolver() {
            "function" == typeof t3.removeListener && t3.removeListener("error", errorListener), r2(Array.prototype.slice.call(arguments));
          }
          _eventTargetAgnosticAddListener(t3, e2, resolver, { once: true }), "error" !== e2 && function(t4, e3, r3) {
            "function" == typeof t4.on && _eventTargetAgnosticAddListener(t4, "error", e3, r3);
          }(t3, errorListener, { once: true });
        });
      };
      let t2 = 10;
      class EventEmitter {
        __unenv__ = true;
        _events = /* @__PURE__ */ Object.create(null);
        _maxListeners;
        static get defaultMaxListeners() {
          return t2;
        }
        static set defaultMaxListeners(e2) {
          if ("number" != typeof e2 || e2 < 0 || Number.isNaN(e2))
            throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e2 + ".");
          t2 = e2;
        }
        setMaxListeners(t3) {
          if ("number" != typeof t3 || t3 < 0 || Number.isNaN(t3))
            throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t3 + ".");
          return this._maxListeners = t3, this;
        }
        getMaxListeners() {
          return _getMaxListeners2(this);
        }
        emit(t3, ...e2) {
          if (!this._events[t3] || 0 === this._events[t3].length)
            return false;
          if ("error" === t3) {
            let t4;
            if (e2.length > 0 && (t4 = e2[0]), t4 instanceof Error)
              throw t4;
            const r2 = new Error("Unhandled error." + (t4 ? " (" + t4.message + ")" : ""));
            throw r2.context = t4, r2;
          }
          for (const r2 of this._events[t3])
            (r2.listener || r2).apply(this, e2);
          return true;
        }
        addListener(t3, e2) {
          return _addListener2(this, t3, e2, false);
        }
        on(t3, e2) {
          return _addListener2(this, t3, e2, false);
        }
        prependListener(t3, e2) {
          return _addListener2(this, t3, e2, true);
        }
        once(t3, e2) {
          return this.on(t3, _wrapOnce2(this, t3, e2));
        }
        prependOnceListener(t3, e2) {
          return this.prependListener(t3, _wrapOnce2(this, t3, e2));
        }
        removeListener(t3, e2) {
          return function(t4, e3, r2) {
            if (_checkListener2(r2), !t4._events[e3] || 0 === t4._events[e3].length)
              return t4;
            const n2 = t4._events[e3].length;
            if (t4._events[e3] = t4._events[e3].filter((t5) => t5 !== r2), n2 === t4._events[e3].length)
              return t4;
            t4._events.removeListener && t4.emit("removeListener", e3, r2.listener || r2);
            0 === t4._events[e3].length && delete t4._events[e3];
            return t4;
          }(this, t3, e2);
        }
        off(t3, e2) {
          return this.removeListener(t3, e2);
        }
        removeAllListeners(t3) {
          return function(t4, e2) {
            if (!t4._events[e2] || 0 === t4._events[e2].length)
              return t4;
            if (t4._events.removeListener)
              for (const r2 of t4._events[e2])
                t4.emit("removeListener", e2, r2.listener || r2);
            return delete t4._events[e2], t4;
          }(this, t3);
        }
        listeners(t3) {
          return _listeners2(this, t3, true);
        }
        rawListeners(t3) {
          return _listeners2(this, t3, false);
        }
        listenerCount(t3) {
          return this.rawListeners(t3).length;
        }
        eventNames() {
          return Object.keys(this._events);
        }
      }
      function _addListener2(t3, e2, r2, n2) {
        _checkListener2(r2), void 0 !== t3._events.newListener && t3.emit("newListener", e2, r2.listener || r2), t3._events[e2] || (t3._events[e2] = []), n2 ? t3._events[e2].unshift(r2) : t3._events[e2].push(r2);
        const i2 = _getMaxListeners2(t3);
        if (i2 > 0 && t3._events[e2].length > i2 && !t3._events[e2].warned) {
          t3._events[e2].warned = true;
          const r3 = new Error(`[unenv] Possible EventEmitter memory leak detected. ${t3._events[e2].length} ${e2} listeners added. Use emitter.setMaxListeners() to increase limit`);
          r3.name = "MaxListenersExceededWarning", r3.emitter = t3, r3.type = e2, r3.count = t3._events[e2]?.length, console.warn(r3);
        }
        return t3;
      }
      function _wrapOnce2(t3, e2, r2) {
        let n2 = false;
        const wrapper = (...i2) => {
          if (!n2)
            return t3.removeListener(e2, wrapper), n2 = true, 0 === i2.length ? r2.call(t3) : r2.apply(t3, i2);
        };
        return wrapper.listener = r2, wrapper;
      }
      function _getMaxListeners2(t3) {
        return t3._maxListeners ?? EventEmitter.defaultMaxListeners;
      }
      function _listeners2(t3, e2, r2) {
        let n2 = t3._events[e2];
        return "function" == typeof n2 && (n2 = [n2]), r2 ? n2.map((t4) => t4.listener || t4) : n2;
      }
      function _checkListener2(t3) {
        if ("function" != typeof t3)
          throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t3);
      }
      function _eventTargetAgnosticAddListener(t3, e2, r2, n2) {
        if ("function" == typeof t3.on)
          n2.once ? t3.once(e2, r2) : t3.on(e2, r2);
        else {
          if ("function" != typeof t3.addEventListener)
            throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof t3);
          t3.addEventListener(e2, r2);
        }
      }
      return ws.EventEmitter = EventEmitter, ws;
    }
    function requireEvents() {
      return xs || (xs = 1, function(t2, e2) {
        Object.defineProperty(e2, "__esModule", { value: true }), e2.once = e2.default = e2.EventEmitter = void 0;
        var r2 = require_events();
        const n2 = e2.EventEmitter = globalThis.EventEmitter || r2.EventEmitter, i2 = e2.once = r2.once;
        t2.exports = { EventEmitter: n2, once: i2 };
      }(bs, bs.exports)), bs.exports;
    }
    function requireReadable() {
      if (vs)
        return ys;
      vs = 1, Object.defineProperty(ys, "__esModule", { value: true }), ys._Readable = ys.Readable = void 0;
      var t2 = requireUtils(), e2 = requireEvents();
      class _Readable2 extends e2.EventEmitter {
        __unenv__ = true;
        readableEncoding = null;
        readableEnded = true;
        readableFlowing = false;
        readableHighWaterMark = 0;
        readableLength = 0;
        readableObjectMode = false;
        readableAborted = false;
        readableDidRead = false;
        closed = false;
        errored = null;
        readable = false;
        destroyed = false;
        static from(t3, e3) {
          return new _Readable2(e3);
        }
        constructor(t3) {
          super();
        }
        _read(t3) {
        }
        read(t3) {
        }
        setEncoding(t3) {
          return this;
        }
        pause() {
          return this;
        }
        resume() {
          return this;
        }
        isPaused() {
          return true;
        }
        unpipe(t3) {
          return this;
        }
        unshift(t3, e3) {
        }
        wrap(t3) {
          return this;
        }
        push(t3, e3) {
          return false;
        }
        _destroy(t3, e3) {
          this.removeAllListeners();
        }
        destroy(t3) {
          return this.destroyed = true, this._destroy(t3), this;
        }
        pipe(t3, e3) {
          return {};
        }
        compose(t3, e3) {
          throw new Error("[unenv] Method not implemented.");
        }
        [Symbol.asyncDispose]() {
          return this.destroy(), Promise.resolve();
        }
        async *[Symbol.asyncIterator]() {
          throw (0, t2.createNotImplementedError)("Readable.asyncIterator");
        }
        iterator(e3) {
          throw (0, t2.createNotImplementedError)("Readable.iterator");
        }
        map(e3, r2) {
          throw (0, t2.createNotImplementedError)("Readable.map");
        }
        filter(e3, r2) {
          throw (0, t2.createNotImplementedError)("Readable.filter");
        }
        forEach(e3, r2) {
          throw (0, t2.createNotImplementedError)("Readable.forEach");
        }
        reduce(e3, r2, n2) {
          throw (0, t2.createNotImplementedError)("Readable.reduce");
        }
        find(e3, r2) {
          throw (0, t2.createNotImplementedError)("Readable.find");
        }
        findIndex(e3, r2) {
          throw (0, t2.createNotImplementedError)("Readable.findIndex");
        }
        some(e3, r2) {
          throw (0, t2.createNotImplementedError)("Readable.some");
        }
        toArray(e3) {
          throw (0, t2.createNotImplementedError)("Readable.toArray");
        }
        every(e3, r2) {
          throw (0, t2.createNotImplementedError)("Readable.every");
        }
        flatMap(e3, r2) {
          throw (0, t2.createNotImplementedError)("Readable.flatMap");
        }
        drop(e3, r2) {
          throw (0, t2.createNotImplementedError)("Readable.drop");
        }
        take(e3, r2) {
          throw (0, t2.createNotImplementedError)("Readable.take");
        }
        asIndexedPairs(e3) {
          throw (0, t2.createNotImplementedError)("Readable.asIndexedPairs");
        }
      }
      return ys._Readable = _Readable2, ys.Readable = globalThis.Readable || _Readable2, ys;
    }
    var ks, Ss = {};
    function requireWritable() {
      if (ks)
        return Ss;
      ks = 1, Object.defineProperty(Ss, "__esModule", { value: true }), Ss.Writable = void 0;
      var t2 = requireEvents();
      class _Writable extends t2.EventEmitter {
        __unenv__ = true;
        writable = true;
        writableEnded = false;
        writableFinished = false;
        writableHighWaterMark = 0;
        writableLength = 0;
        writableObjectMode = false;
        writableCorked = 0;
        closed = false;
        errored = null;
        writableNeedDrain = false;
        destroyed = false;
        _data;
        _encoding = "utf-8";
        constructor(t3) {
          super();
        }
        pipe(t3, e2) {
          return {};
        }
        _write(t3, e2, r2) {
          if (this.writableEnded)
            r2 && r2();
          else {
            if (void 0 === this._data)
              this._data = t3;
            else {
              const r3 = "string" == typeof this._data ? c.from(this._data, this._encoding || e2 || "utf8") : this._data, n2 = "string" == typeof t3 ? c.from(t3, e2 || this._encoding || "utf8") : t3;
              this._data = c.concat([r3, n2]);
            }
            this._encoding = e2, r2 && r2();
          }
        }
        _writev(t3, e2) {
        }
        _destroy(t3, e2) {
        }
        _final(t3) {
        }
        write(t3, e2, r2) {
          const n2 = "string" == typeof e2 ? this._encoding : "utf-8", i2 = "function" == typeof e2 ? e2 : "function" == typeof r2 ? r2 : void 0;
          return this._write(t3, n2, i2), true;
        }
        setDefaultEncoding(t3) {
          return this;
        }
        end(t3, e2, r2) {
          const n2 = "function" == typeof t3 ? t3 : "function" == typeof e2 ? e2 : "function" == typeof r2 ? r2 : void 0;
          if (this.writableEnded)
            return n2 && n2(), this;
          const i2 = t3 === n2 ? void 0 : t3;
          if (i2) {
            const t4 = e2 === n2 ? void 0 : e2;
            this.write(i2, t4, n2);
          }
          return this.writableEnded = true, this.writableFinished = true, this.emit("close"), this.emit("finish"), this;
        }
        cork() {
        }
        uncork() {
        }
        destroy(t3) {
          return this.destroyed = true, delete this._data, this.removeAllListeners(), this;
        }
        compose(t3, e2) {
          throw new Error("[h3] Method not implemented.");
        }
      }
      return Ss.Writable = globalThis.Writable || _Writable, Ss;
    }
    var Cs, Es = {};
    function requireDuplex() {
      if (Cs)
        return Es;
      Cs = 1, Object.defineProperty(Es, "__esModule", { value: true }), Es._Duplex = Es.Duplex = void 0;
      var t2 = requireUtils(), e2 = requireReadable(), r2 = requireWritable();
      const n2 = class {
        allowHalfOpen = true;
        _destroy;
        constructor(n3 = new e2.Readable(), i3 = new r2.Writable()) {
          Object.assign(this, n3), Object.assign(this, i3), this._destroy = (0, t2.mergeFns)(n3._destroy, i3._destroy);
        }
      };
      function getDuplex2() {
        return Object.assign(n2.prototype, e2.Readable.prototype), Object.assign(n2.prototype, r2.Writable.prototype), n2;
      }
      const i2 = Es._Duplex = getDuplex2();
      return Es.Duplex = globalThis.Duplex || i2, Es;
    }
    var _s, Ps = {};
    var Ts, As, Is = { exports: {} };
    function requireStream() {
      return As || (As = 1, function(t2, e2) {
        Object.defineProperty(e2, "__esModule", { value: true }), Object.defineProperty(e2, "Duplex", { enumerable: true, get: function() {
          return a2.Duplex;
        } }), e2.PassThrough = void 0, Object.defineProperty(e2, "Readable", { enumerable: true, get: function() {
          return i2.Readable;
        } }), e2.Stream = void 0, Object.defineProperty(e2, "Transform", { enumerable: true, get: function() {
          return s2.Transform;
        } }), Object.defineProperty(e2, "Writable", { enumerable: true, get: function() {
          return o2.Writable;
        } }), e2.pipeline = e2.isReadable = e2.isErrored = e2.isDisturbed = e2.finished = e2.destroy = e2.default = e2.compose = e2.addAbortSignal = e2._uint8ArrayToBuffer = e2._isUint8Array = void 0;
        var r2 = _interopRequireDefault(function() {
          if (cs)
            return ms.exports;
          cs = 1, Object.defineProperty(us, "__esModule", { value: true });
          const fn = function() {
          };
          return ms.exports = function createMock(t3, e3 = {}) {
            fn.prototype.name = t3;
            const r3 = {};
            return new Proxy(fn, { get: (n3, i3) => "caller" === i3 ? null : "__createMock__" === i3 ? createMock : "__unenv__" === i3 || (i3 in e3 ? e3[i3] : r3[i3] = r3[i3] || createMock(`${t3}.${i3.toString()}`)), apply: (e4, r4, n3) => createMock(`${t3}()`), construct: (e4, r4, n3) => createMock(`[${t3}]`), enumerate: () => [] });
          }("mock"), ms.exports;
        }()), n2 = requireUtils(), i2 = requireReadable(), o2 = requireWritable(), a2 = requireDuplex(), s2 = function() {
          if (_s)
            return Ps;
          _s = 1, Object.defineProperty(Ps, "__esModule", { value: true }), Ps._Transform = Ps.Transform = void 0;
          var t3 = requireDuplex();
          class _Transform extends t3.Duplex {
            __unenv__ = true;
            _transform(t4, e3, r3) {
            }
            _flush(t4) {
            }
          }
          return Ps._Transform = _Transform, Ps.Transform = globalThis.Transform || _Transform, Ps;
        }(), l2 = _interopRequireDefault((Ts || (Ts = 1, function(t3, e3) {
          Object.defineProperty(e3, "__esModule", { value: true }), e3.pipeline = e3.finished = e3.default = void 0;
          var r3 = requireUtils();
          const n3 = e3.finished = (0, r3.notImplemented)("stream.promises.finished"), i3 = e3.pipeline = (0, r3.notImplemented)("stream.promises.pipeline");
          t3.exports = { finished: n3, pipeline: i3 };
        }(Is, Is.exports)), Is.exports));
        function _interopRequireDefault(t3) {
          return t3 && t3.__esModule ? t3 : { default: t3 };
        }
        const p2 = e2.Stream = r2.default.__createMock__("Stream"), c2 = e2.PassThrough = r2.default.__createMock__("PassThrough"), d2 = e2.pipeline = (0, n2.notImplemented)("stream.pipeline"), m2 = e2.finished = (0, n2.notImplemented)("stream.finished"), u2 = e2.addAbortSignal = (0, n2.notImplemented)("stream.addAbortSignal"), h2 = e2.isDisturbed = (0, n2.notImplemented)("stream.isDisturbed"), g2 = e2.isReadable = (0, n2.notImplemented)("stream.isReadable"), x2 = e2.compose = (0, n2.notImplemented)("stream.compose"), v2 = e2.isErrored = (0, n2.notImplemented)("stream.isErrored"), y2 = e2.destroy = (0, n2.notImplemented)("stream.destroy"), b2 = e2._isUint8Array = (0, n2.notImplemented)("stream._isUint8Array"), w2 = e2._uint8ArrayToBuffer = (0, n2.notImplemented)("stream._uint8ArrayToBuffer");
        t2.exports = { Readable: i2.Readable, Writable: o2.Writable, Duplex: a2.Duplex, Transform: s2.Transform, Stream: p2, PassThrough: c2, pipeline: d2, finished: m2, addAbortSignal: u2, promises: l2.default, isDisturbed: h2, isReadable: g2, compose: x2, _uint8ArrayToBuffer: w2, isErrored: v2, destroy: y2, _isUint8Array: b2 };
      }(ds, ds.exports)), ds.exports;
    }
    Object.defineProperty(Te, "__esModule", { value: true });
    var Ns = tn, Rs = gr, Os = en;
    function _interopNamespaceDefault$1(t2) {
      var e2 = /* @__PURE__ */ Object.create(null);
      if (t2)
        for (var r2 in t2)
          e2[r2] = t2[r2];
      return e2.default = t2, Object.freeze(e2);
    }
    var Ls = _interopNamespaceDefault$1(Ns);
    const Ms = Rs.makeMap(",key,ref,innerHTML,textContent,ref_key,ref_for");
    function ssrRenderAttrs(t2, e2) {
      let r2 = "";
      for (const n2 in t2) {
        if (Ms(n2) || Rs.isOn(n2) || "textarea" === e2 && "value" === n2)
          continue;
        const i2 = t2[n2];
        r2 += "class" === n2 ? ` class="${ssrRenderClass(i2)}"` : "style" === n2 ? ` style="${ssrRenderStyle(i2)}"` : ssrRenderDynamicAttr(n2, i2, e2);
      }
      return r2;
    }
    function ssrRenderDynamicAttr(t2, e2, r2) {
      if (!isRenderableValue(e2))
        return "";
      const n2 = r2 && (r2.indexOf("-") > 0 || Rs.isSVGTag(r2)) ? t2 : Rs.propsToAttrMap[t2] || t2.toLowerCase();
      return Rs.isBooleanAttr(n2) ? Rs.includeBooleanAttr(e2) ? ` ${n2}` : "" : Rs.isSSRSafeAttrName(n2) ? "" === e2 ? ` ${n2}` : ` ${n2}="${Rs.escapeHtml(e2)}"` : (console.warn(`[@vue/server-renderer] Skipped rendering unsafe attribute name: ${n2}`), "");
    }
    function ssrRenderAttr(t2, e2) {
      return isRenderableValue(e2) ? ` ${t2}="${Rs.escapeHtml(e2)}"` : "";
    }
    function isRenderableValue(t2) {
      if (null == t2)
        return false;
      const e2 = typeof t2;
      return "string" === e2 || "number" === e2 || "boolean" === e2;
    }
    function ssrRenderClass(t2) {
      return Rs.escapeHtml(Rs.normalizeClass(t2));
    }
    function ssrRenderStyle(t2) {
      if (!t2)
        return "";
      if (Rs.isString(t2))
        return Rs.escapeHtml(t2);
      const e2 = Rs.normalizeStyle(t2);
      return Rs.escapeHtml(Rs.stringifyStyle(e2));
    }
    function ssrRenderComponent(t2, e2 = null, r2 = null, n2 = null, i2) {
      return renderComponentVNode(Ns.createVNode(t2, e2, r2), n2, i2);
    }
    function ssrRenderSlot(t2, e2, r2, n2, i2, o2, a2) {
      i2("<!--[-->"), ssrRenderSlotInner(t2, e2, r2, n2, i2, o2, a2), i2("<!--]-->");
    }
    function ssrRenderSlotInner(t2, e2, r2, n2, i2, o2, a2, s2) {
      const l2 = t2[e2];
      if (l2) {
        const t3 = [], e3 = l2(r2, (e4) => {
          t3.push(e4);
        }, o2, a2 ? " " + a2 : "");
        if (Rs.isArray(e3))
          renderVNodeChildren(i2, e3, o2, a2);
        else {
          let e4 = true;
          if (s2)
            e4 = false;
          else
            for (let r3 = 0; r3 < t3.length; r3++)
              if (!isComment(t3[r3])) {
                e4 = false;
                break;
              }
          if (e4)
            n2 && n2();
          else
            for (let e5 = 0; e5 < t3.length; e5++)
              i2(t3[e5]);
        }
      } else
        n2 && n2();
    }
    const Bs = /^<!--.*-->$/s, Ds = /<!--[^]*?-->/gm;
    function isComment(t2) {
      return !("string" != typeof t2 || !Bs.test(t2)) && (t2.length <= 8 || !t2.replace(Ds, "").trim());
    }
    function ssrRenderTeleport(t2, e2, r2, n2, i2) {
      t2("<!--teleport start-->");
      const o2 = i2.appContext.provides[Ns.ssrContextKey], a2 = o2.__teleportBuffers || (o2.__teleportBuffers = {}), s2 = a2[r2] || (a2[r2] = []), l2 = s2.length;
      let p2;
      if (n2)
        e2(t2), p2 = "<!--teleport anchor-->";
      else {
        const { getBuffer: t3, push: r3 } = createBuffer();
        e2(r3), r3("<!--teleport anchor-->"), p2 = t3();
      }
      s2.splice(l2, 0, p2), t2("<!--teleport end-->");
    }
    function ssrInterpolate(t2) {
      return Rs.escapeHtml(Rs.toDisplayString(t2));
    }
    function ssrRenderList(t2, e2) {
      if (Rs.isArray(t2) || Rs.isString(t2))
        for (let r2 = 0, n2 = t2.length; r2 < n2; r2++)
          e2(t2[r2], r2);
      else if ("number" == typeof t2)
        for (let r2 = 0; r2 < t2; r2++)
          e2(r2 + 1, r2);
      else if (Rs.isObject(t2))
        if (t2[Symbol.iterator]) {
          const r2 = Array.from(t2);
          for (let t3 = 0, n2 = r2.length; t3 < n2; t3++)
            e2(r2[t3], t3);
        } else {
          const r2 = Object.keys(t2);
          for (let n2 = 0, i2 = r2.length; n2 < i2; n2++) {
            const i3 = r2[n2];
            e2(t2[i3], i3, n2);
          }
        }
    }
    async function ssrRenderSuspense(t2, { default: e2 }) {
      e2 ? e2() : t2("<!---->");
    }
    function ssrGetDirectiveProps(t2, e2, r2, n2, i2 = {}) {
      return "function" != typeof e2 && e2.getSSRProps && e2.getSSRProps({ dir: e2, instance: t2, value: r2, oldValue: void 0, arg: n2, modifiers: i2 }, null) || {};
    }
    const js = Rs.looseEqual;
    function ssrLooseContain(t2, e2) {
      return Rs.looseIndexOf(t2, e2) > -1;
    }
    function ssrRenderDynamicModel(t2, e2, r2) {
      switch (t2) {
        case "radio":
          return Rs.looseEqual(e2, r2) ? " checked" : "";
        case "checkbox":
          return (Rs.isArray(e2) ? ssrLooseContain(e2, r2) : e2) ? " checked" : "";
        default:
          return ssrRenderAttr("value", e2);
      }
    }
    function ssrGetDynamicModelProps(t2 = {}, e2) {
      const { type: r2, value: n2 } = t2;
      switch (r2) {
        case "radio":
          return Rs.looseEqual(e2, n2) ? { checked: true } : null;
        case "checkbox":
          return (Rs.isArray(e2) ? ssrLooseContain(e2, n2) : e2) ? { checked: true } : null;
        default:
          return { value: e2 };
      }
    }
    var Fs = Object.freeze({ __proto__: null, ssrGetDirectiveProps, ssrGetDynamicModelProps, ssrIncludeBooleanAttr: Rs.includeBooleanAttr, ssrInterpolate, ssrLooseContain, ssrLooseEqual: js, ssrRenderAttr, ssrRenderAttrs, ssrRenderClass, ssrRenderComponent, ssrRenderDynamicAttr, ssrRenderDynamicModel, ssrRenderList, ssrRenderSlot, ssrRenderSlotInner, ssrRenderStyle, ssrRenderSuspense, ssrRenderTeleport, ssrRenderVNode: renderVNode });
    const $s = /* @__PURE__ */ Object.create(null);
    const { createComponentInstance: Vs, setCurrentRenderingInstance: zs, setupComponent: Us, renderComponentRoot: Hs, normalizeVNode: qs } = Ns.ssrUtils;
    function createBuffer() {
      let t2 = false;
      const e2 = [];
      return { getBuffer: () => e2, push(r2) {
        const n2 = Rs.isString(r2);
        t2 && n2 ? e2[e2.length - 1] += r2 : e2.push(r2), t2 = n2, (Rs.isPromise(r2) || Rs.isArray(r2) && r2.hasAsync) && (e2.hasAsync = true);
      } };
    }
    function renderComponentVNode(t2, e2 = null, r2) {
      const n2 = Vs(t2, e2, null), i2 = Us(n2, true), o2 = Rs.isPromise(i2), a2 = n2.sp;
      if (o2 || a2) {
        let t3 = o2 ? i2 : Promise.resolve();
        return a2 && (t3 = t3.then(() => Promise.all(a2.map((t4) => t4.call(n2.proxy)))).catch(() => {
        })), t3.then(() => renderComponentSubTree(n2, r2));
      }
      return renderComponentSubTree(n2, r2);
    }
    function renderComponentSubTree(t2, e2) {
      const r2 = t2.type, { getBuffer: n2, push: i2 } = createBuffer();
      if (Rs.isFunction(r2)) {
        let n3 = Hs(t2);
        if (!r2.props)
          for (const e3 in t2.attrs)
            e3.startsWith("data-v-") && ((n3.props || (n3.props = {}))[e3] = "");
        renderVNode(i2, t2.subTree = n3, t2, e2);
      } else {
        t2.render && t2.render !== Rs.NOOP || t2.ssrRender || r2.ssrRender || !Rs.isString(r2.template) || (r2.ssrRender = function(t3, e3) {
          const r3 = e3.type, { isCustomElement: n4, compilerOptions: i3 } = e3.appContext.config, { delimiters: o2, compilerOptions: a2 } = r3, s2 = Rs.extend(Rs.extend({ isCustomElement: n4, delimiters: o2 }, i3), a2);
          s2.isCustomElement = s2.isCustomElement || Rs.NO, s2.isNativeTag = s2.isNativeTag || Rs.NO;
          const l2 = JSON.stringify({ template: t3, compilerOptions: s2 }, (t4, e4) => Rs.isFunction(e4) ? e4.toString() : e4), p2 = $s[l2];
          if (p2)
            return p2;
          s2.onError = (t4) => {
            throw t4;
          };
          const { code: c2 } = Os.compile(t3, s2), d2 = { vue: Ls, "vue/server-renderer": Fs };
          return $s[l2] = Function("require", c2)((t4) => d2[t4]);
        }(r2.template, t2));
        for (const e3 of t2.scope.effects)
          e3.computed && (e3.computed._dirty = true, e3.computed._cacheable = true);
        const n3 = t2.ssrRender || r2.ssrRender;
        if (n3) {
          let r3 = false !== t2.inheritAttrs ? t2.attrs : void 0, o2 = false, a2 = t2;
          for (; ; ) {
            const t3 = a2.vnode.scopeId;
            t3 && (o2 || (r3 = { ...r3 }, o2 = true), r3[t3] = "");
            const e3 = a2.parent;
            if (!e3 || !e3.subTree || e3.subTree !== a2.vnode)
              break;
            a2 = e3;
          }
          e2 && (o2 || (r3 = { ...r3 }), r3[e2.trim()] = "");
          const s2 = zs(t2);
          try {
            n3(t2.proxy, i2, t2, r3, t2.props, t2.setupState, t2.data, t2.ctx);
          } finally {
            zs(s2);
          }
        } else if (t2.render && t2.render !== Rs.NOOP)
          renderVNode(i2, t2.subTree = Hs(t2), t2, e2);
        else {
          const t3 = r2.name || r2.__file || "<Anonymous>";
          Ns.warn(`Component ${t3} is missing template or render function.`), i2("<!---->");
        }
      }
      return n2();
    }
    function renderVNode(t2, e2, r2, n2) {
      const { type: i2, shapeFlag: o2, children: a2 } = e2;
      switch (i2) {
        case Ns.Text:
          t2(Rs.escapeHtml(a2));
          break;
        case Ns.Comment:
          t2(a2 ? `<!--${Rs.escapeHtmlComment(a2)}-->` : "<!---->");
          break;
        case Ns.Static:
          t2(a2);
          break;
        case Ns.Fragment:
          e2.slotScopeIds && (n2 = (n2 ? n2 + " " : "") + e2.slotScopeIds.join(" ")), t2("<!--[-->"), renderVNodeChildren(t2, a2, r2, n2), t2("<!--]-->");
          break;
        default:
          1 & o2 ? function(t3, e3, r3, n3) {
            const i3 = e3.type;
            let { props: o3, children: a3, shapeFlag: s2, scopeId: l2, dirs: p2 } = e3, c2 = `<${i3}`;
            p2 && (o3 = function(t4, e4, r4) {
              const n4 = [];
              for (let e5 = 0; e5 < r4.length; e5++) {
                const i4 = r4[e5], { dir: { getSSRProps: o4 } } = i4;
                if (o4) {
                  const e6 = o4(i4, t4);
                  e6 && n4.push(e6);
                }
              }
              return Ns.mergeProps(e4 || {}, ...n4);
            }(e3, o3, p2));
            o3 && (c2 += ssrRenderAttrs(o3, i3));
            l2 && (c2 += ` ${l2}`);
            let d2 = r3, m2 = e3;
            for (; d2 && m2 === d2.subTree; )
              m2 = d2.vnode, m2.scopeId && (c2 += ` ${m2.scopeId}`), d2 = d2.parent;
            n3 && (c2 += ` ${n3}`);
            if (t3(c2 + ">"), !Rs.isVoidTag(i3)) {
              let e4 = false;
              o3 && (o3.innerHTML ? (e4 = true, t3(o3.innerHTML)) : o3.textContent ? (e4 = true, t3(Rs.escapeHtml(o3.textContent))) : "textarea" === i3 && o3.value && (e4 = true, t3(Rs.escapeHtml(o3.value)))), e4 || (8 & s2 ? t3(Rs.escapeHtml(a3)) : 16 & s2 && renderVNodeChildren(t3, a3, r3, n3)), t3(`</${i3}>`);
            }
          }(t2, e2, r2, n2) : 6 & o2 ? t2(renderComponentVNode(e2, r2, n2)) : 64 & o2 ? function(t3, e3, r3, n3) {
            const i3 = e3.props && e3.props.to, o3 = e3.props && e3.props.disabled;
            if (!i3)
              return o3 || Ns.warn("[@vue/server-renderer] Teleport is missing target prop."), [];
            if (!Rs.isString(i3))
              return Ns.warn("[@vue/server-renderer] Teleport target must be a query selector string."), [];
            ssrRenderTeleport(t3, (t4) => {
              renderVNodeChildren(t4, e3.children, r3, n3);
            }, i3, o3 || "" === o3, r3);
          }(t2, e2, r2, n2) : 128 & o2 ? renderVNode(t2, e2.ssContent, r2, n2) : Ns.warn("[@vue/server-renderer] Invalid VNode type:", i2, `(${typeof i2})`);
      }
    }
    function renderVNodeChildren(t2, e2, r2, n2) {
      for (let i2 = 0; i2 < e2.length; i2++)
        renderVNode(t2, qs(e2[i2]), r2, n2);
    }
    const { isVNode: Ws } = Ns.ssrUtils;
    async function unrollBuffer$1(t2) {
      if (t2.hasAsync) {
        let e2 = "";
        for (let r2 = 0; r2 < t2.length; r2++) {
          let n2 = t2[r2];
          Rs.isPromise(n2) && (n2 = await n2), Rs.isString(n2) ? e2 += n2 : e2 += await unrollBuffer$1(n2);
        }
        return e2;
      }
      return unrollBufferSync$1(t2);
    }
    function unrollBufferSync$1(t2) {
      let e2 = "";
      for (let r2 = 0; r2 < t2.length; r2++) {
        let n2 = t2[r2];
        Rs.isString(n2) ? e2 += n2 : e2 += unrollBufferSync$1(n2);
      }
      return e2;
    }
    async function resolveTeleports(t2) {
      if (t2.__teleportBuffers) {
        t2.teleports = t2.teleports || {};
        for (const e2 in t2.__teleportBuffers)
          t2.teleports[e2] = await unrollBuffer$1(await Promise.all([t2.__teleportBuffers[e2]]));
      }
    }
    const { isVNode: Ks } = Ns.ssrUtils;
    async function unrollBuffer(t2, e2) {
      if (t2.hasAsync)
        for (let r2 = 0; r2 < t2.length; r2++) {
          let n2 = t2[r2];
          Rs.isPromise(n2) && (n2 = await n2), Rs.isString(n2) ? e2.push(n2) : await unrollBuffer(n2, e2);
        }
      else
        unrollBufferSync(t2, e2);
    }
    function unrollBufferSync(t2, e2) {
      for (let r2 = 0; r2 < t2.length; r2++) {
        let n2 = t2[r2];
        Rs.isString(n2) ? e2.push(n2) : unrollBufferSync(n2, e2);
      }
    }
    function renderToSimpleStream(t2, e2, r2) {
      if (Ks(t2))
        return renderToSimpleStream(Ns.createApp({ render: () => t2 }), e2, r2);
      const n2 = Ns.createVNode(t2._component, t2._props);
      return n2.appContext = t2._context, t2.provide(Ns.ssrContextKey, e2), Promise.resolve(renderComponentVNode(n2)).then((t3) => unrollBuffer(t3, r2)).then(() => resolveTeleports(e2)).then(() => {
        if (e2.__watcherHandles)
          for (const t3 of e2.__watcherHandles)
            t3();
      }).then(() => r2.push(null)).catch((t3) => {
        r2.destroy(t3);
      }), r2;
    }
    function renderToNodeStream(t2, e2 = {}) {
      const r2 = new (requireStream()).Readable({ read() {
      } });
      if (!r2)
        throw new Error("ESM build of renderToStream() does not support renderToNodeStream(). Use pipeToNodeWritable() with an existing Node.js Writable stream instance instead.");
      return renderToSimpleStream(t2, e2, r2);
    }
    Ns.initDirectivesForSSR(), Te.ssrIncludeBooleanAttr = Rs.includeBooleanAttr, Te.pipeToNodeWritable = function(t2, e2 = {}, r2) {
      renderToSimpleStream(t2, e2, { push(t3) {
        null != t3 ? r2.write(t3) : r2.end();
      }, destroy(t3) {
        r2.destroy(t3);
      } });
    }, Te.pipeToWebWritable = function(t2, e2 = {}, r2) {
      const n2 = r2.getWriter(), i2 = new TextEncoder();
      let o2 = false;
      try {
        o2 = Rs.isPromise(n2.ready);
      } catch (t3) {
      }
      renderToSimpleStream(t2, e2, { push: async (t3) => (o2 && await n2.ready, null != t3 ? n2.write(i2.encode(t3)) : n2.close()), destroy(t3) {
        console.log(t3), n2.close();
      } });
    }, Te.renderToNodeStream = renderToNodeStream, Te.renderToSimpleStream = renderToSimpleStream, Te.renderToStream = function(t2, e2 = {}) {
      return console.warn("[@vue/server-renderer] renderToStream is deprecated - use renderToNodeStream instead."), renderToNodeStream(t2, e2);
    }, Te.renderToString = async function renderToString(t2, e2 = {}) {
      if (Ws(t2))
        return renderToString(Ns.createApp({ render: () => t2 }), e2);
      const r2 = Ns.createVNode(t2._component, t2._props);
      r2.appContext = t2._context, t2.provide(Ns.ssrContextKey, e2);
      const n2 = await renderComponentVNode(r2), i2 = await unrollBuffer$1(n2);
      if (await resolveTeleports(e2), e2.__watcherHandles)
        for (const t3 of e2.__watcherHandles)
          t3();
      return i2;
    }, Te.renderToWebStream = function(t2, e2 = {}) {
      if ("function" != typeof ReadableStream)
        throw new Error("ReadableStream constructor is not available in the global scope. If the target environment does support web streams, consider using pipeToWebWritable() with an existing WritableStream instance instead.");
      const r2 = new TextEncoder();
      let n2 = false;
      return new ReadableStream({ start(i2) {
        renderToSimpleStream(t2, e2, { push(t3) {
          n2 || (null != t3 ? i2.enqueue(r2.encode(t3)) : i2.close());
        }, destroy(t3) {
          i2.error(t3);
        } });
      }, cancel() {
        n2 = true;
      } });
    }, Te.ssrGetDirectiveProps = ssrGetDirectiveProps, Te.ssrGetDynamicModelProps = ssrGetDynamicModelProps, Te.ssrInterpolate = ssrInterpolate, Te.ssrLooseContain = ssrLooseContain, Te.ssrLooseEqual = js, Te.ssrRenderAttr = ssrRenderAttr, Te.ssrRenderAttrs = ssrRenderAttrs, Te.ssrRenderClass = ssrRenderClass, Te.ssrRenderComponent = ssrRenderComponent, Te.ssrRenderDynamicAttr = ssrRenderDynamicAttr, Te.ssrRenderDynamicModel = ssrRenderDynamicModel, Te.ssrRenderList = ssrRenderList, Te.ssrRenderSlot = ssrRenderSlot, Te.ssrRenderSlotInner = ssrRenderSlotInner, Te.ssrRenderStyle = ssrRenderStyle, Te.ssrRenderSuspense = ssrRenderSuspense, Te.ssrRenderTeleport = ssrRenderTeleport, Te.ssrRenderVNode = renderVNode, Pe.exports = Te;
    var Gs = Pe.exports;
    const Js = ["meta", "link", "base"], Ys = ["title", "titleTemplate", "script", "style", "noscript"], Xs = ["base", "meta", "link", "style", "script", "noscript"], Qs = ["title", "titleTemplate", "templateParams", "base", "htmlAttrs", "bodyAttrs", "meta", "link", "style", "script", "noscript"], Zs = ["base", "title", "titleTemplate", "bodyAttrs", "htmlAttrs", "templateParams"], tl = ["tagPosition", "tagPriority", "tagDuplicateStrategy", "children", "innerHTML", "textContent", "processTemplateParams"];
    function hashCode(t2) {
      let e2 = 9;
      for (let r2 = 0; r2 < t2.length; )
        e2 = Math.imul(e2 ^ t2.charCodeAt(r2++), 9 ** 9);
      return (65536 + (e2 ^ e2 >>> 9)).toString(16).substring(1, 8).toLowerCase();
    }
    function resolveTitleTemplate(t2, e2) {
      return null == t2 ? e2 || null : "function" == typeof t2 ? t2(e2) : t2;
    }
    function normaliseClassProp(t2) {
      return "object" != typeof t2 || Array.isArray(t2) || (t2 = Object.keys(t2).filter((e2) => t2[e2])), (Array.isArray(t2) ? t2.join(" ") : t2).split(" ").filter((t3) => t3.trim()).filter(Boolean).join(" ");
    }
    async function normaliseProps(t2, e2) {
      for (const r2 of Object.keys(t2))
        if ("class" !== r2) {
          if (t2[r2] instanceof Promise && (t2[r2] = await t2[r2]), !e2 && !tl.includes(r2)) {
            const e3 = String(t2[r2]), n2 = r2.startsWith("data-");
            "true" === e3 || "" === e3 ? t2[r2] = !n2 || "true" : t2[r2] || (n2 && "false" === e3 ? t2[r2] = "false" : delete t2[r2]);
          }
        } else
          t2[r2] = normaliseClassProp(t2[r2]);
      return t2;
    }
    const el = 10;
    async function normaliseEntryTags(t2) {
      const e2 = [];
      return Object.entries(t2.resolvedInput).filter(([t3, e3]) => void 0 !== e3 && Qs.includes(t3)).forEach(([r2, n2]) => {
        const i2 = function(t3) {
          return Array.isArray(t3) ? t3 : [t3];
        }(n2);
        e2.push(...i2.map((e3) => async function(t3, e4, r3) {
          const n3 = { tag: t3, props: await normaliseProps("object" != typeof e4 || "function" == typeof e4 || e4 instanceof Promise ? { [["script", "noscript", "style"].includes(t3) ? "innerHTML" : "textContent"]: e4 } : { ...e4 }, ["templateParams", "titleTemplate"].includes(t3)) };
          return tl.forEach((t4) => {
            const e5 = void 0 !== n3.props[t4] ? n3.props[t4] : r3[t4];
            void 0 !== e5 && (["innerHTML", "textContent", "children"].includes(t4) && !Ys.includes(n3.tag) || (n3["children" === t4 ? "innerHTML" : t4] = e5), delete n3.props[t4]);
          }), n3.props.body && (n3.tagPosition = "bodyClose", delete n3.props.body), "script" === n3.tag && "object" == typeof n3.innerHTML && (n3.innerHTML = JSON.stringify(n3.innerHTML), n3.props.type = n3.props.type || "application/json"), Array.isArray(n3.props.content) ? n3.props.content.map((t4) => ({ ...n3, props: { ...n3.props, content: t4 } })) : n3;
        }(r2, e3, t2)).flat());
      }), (await Promise.all(e2)).flat().filter(Boolean).map((e3, r2) => (e3._e = t2._i, t2.mode && (e3._m = t2.mode), e3._p = (t2._i << el) + r2, e3));
    }
    const rl = { base: -10, title: 10 }, nl = { critical: -80, high: -10, low: 20 };
    function tagWeight(t2) {
      let e2 = 100;
      const r2 = t2.tagPriority;
      return "number" == typeof r2 ? r2 : ("meta" === t2.tag ? ("content-security-policy" === t2.props["http-equiv"] && (e2 = -30), t2.props.charset && (e2 = -20), "viewport" === t2.props.name && (e2 = -15)) : "link" === t2.tag && "preconnect" === t2.props.rel ? e2 = 20 : t2.tag in rl && (e2 = rl[t2.tag]), "string" == typeof r2 && r2 in nl ? e2 + nl[r2] : e2);
    }
    const il = [{ prefix: "before:", offset: -1 }, { prefix: "after:", offset: 1 }], ol = ["onload", "onerror", "onabort", "onprogress", "onloadstart"], al = "%separator";
    function processTemplateParams(t2, e2, r2) {
      if ("string" != typeof t2 || !t2.includes("%"))
        return t2;
      let n2 = t2;
      try {
        n2 = decodeURI(t2);
      } catch {
      }
      return (n2.match(/%(\w+\.+\w+)|%(\w+)/g) || []).sort().reverse().forEach((r3) => {
        const n3 = function(t3) {
          let r4;
          return r4 = ["s", "pageTitle"].includes(t3) ? e2.pageTitle : t3.includes(".") ? t3.split(".").reduce((t4, e3) => t4 && t4[e3] || void 0, e2) : e2[t3], void 0 !== r4 && (r4 || "").replace(/"/g, '\\"');
        }(r3.slice(1));
        "string" == typeof n3 && (t2 = t2.replace(new RegExp(`\\${r3}(\\W|$)`, "g"), (t3, e3) => `${n3}${e3}`).trim());
      }), t2.includes(al) && (t2.endsWith(al) && (t2 = t2.slice(0, -10).trim()), t2.startsWith(al) && (t2 = t2.slice(10).trim()), t2 = processTemplateParams(t2 = t2.replace(new RegExp(`\\${al}\\s*\\${al}`, "g"), al), { separator: r2 }, r2)), t2;
    }
    function encodeAttribute(t2) {
      return String(t2).replace(/"/g, "&quot;");
    }
    function propsToString(t2) {
      const e2 = [];
      for (const [r2, n2] of Object.entries(t2))
        false !== n2 && null !== n2 && e2.push(true === n2 ? r2 : `${r2}="${encodeAttribute(n2)}"`);
      return `${e2.length > 0 ? " " : ""}${e2.join(" ")}`;
    }
    function tagToString(t2) {
      const e2 = propsToString(t2.props), r2 = `<${t2.tag}${e2}>`;
      if (!Ys.includes(t2.tag))
        return Js.includes(t2.tag) ? r2 : `${r2}</${t2.tag}>`;
      let n2 = String(t2.innerHTML || "");
      return t2.textContent && (n2 = String(t2.textContent).replace(/[&<>"'/]/g, (t3) => {
        switch (t3) {
          case "&":
            return "&amp;";
          case "<":
            return "&lt;";
          case ">":
            return "&gt;";
          case '"':
            return "&quot;";
          case "'":
            return "&#x27;";
          case "/":
            return "&#x2F;";
          default:
            return t3;
        }
      })), Js.includes(t2.tag) ? r2 : `${r2}${n2}</${t2.tag}>`;
    }
    async function renderSSRHead(t2) {
      const e2 = { shouldRender: true };
      if (await t2.hooks.callHook("ssr:beforeRender", e2), !e2.shouldRender)
        return { headTags: "", bodyTags: "", bodyTagsOpen: "", htmlAttrs: "", bodyAttrs: "" };
      const r2 = { tags: await t2.resolveTags() };
      await t2.hooks.callHook("ssr:render", r2);
      const n2 = function(t3) {
        const e3 = { htmlAttrs: {}, bodyAttrs: {}, tags: { head: [], bodyClose: [], bodyOpen: [] } };
        for (const r3 of t3)
          "htmlAttrs" !== r3.tag && "bodyAttrs" !== r3.tag ? e3.tags[r3.tagPosition || "head"].push(tagToString(r3)) : e3[r3.tag] = { ...e3[r3.tag], ...r3.props };
        return { headTags: e3.tags.head.join("\n"), bodyTags: e3.tags.bodyClose.join("\n"), bodyTagsOpen: e3.tags.bodyOpen.join("\n"), htmlAttrs: propsToString(e3.htmlAttrs), bodyAttrs: propsToString(e3.bodyAttrs) };
      }(r2.tags), i2 = { tags: r2.tags, html: n2 };
      return await t2.hooks.callHook("ssr:rendered", i2), i2.html;
    }
    const sl = ["templateParams", "htmlAttrs", "bodyAttrs"], ll = { hooks: { "tag:normalise": function({ tag: t2 }) {
      ["hid", "vmid", "key"].forEach((e3) => {
        t2.props[e3] && (t2.key = t2.props[e3], delete t2.props[e3]);
      });
      const e2 = function(t3, e3) {
        const { props: r3, tag: n2 } = t3;
        if (Zs.includes(n2))
          return n2;
        if ("link" === n2 && "canonical" === r3.rel)
          return "canonical";
        if (r3.charset)
          return "charset";
        const i2 = ["id"];
        "meta" === n2 && i2.push("name", "property", "http-equiv");
        for (const t4 of i2)
          if (void 0 !== r3[t4]) {
            const i3 = String(r3[t4]);
            return !(e3 && !e3(i3)) && `${n2}:${t4}:${i3}`;
          }
        return false;
      }(t2), r2 = e2 || !!t2.key && `${t2.tag}:${t2.key}`;
      r2 && (t2._d = r2);
    }, "tags:resolve": function(t2) {
      const e2 = {};
      t2.tags.forEach((t3) => {
        const r3 = (t3.key ? `${t3.tag}:${t3.key}` : t3._d) || t3._p, n2 = e2[r3];
        if (n2) {
          let i3 = t3?.tagDuplicateStrategy;
          if (!i3 && sl.includes(t3.tag) && (i3 = "merge"), "merge" === i3) {
            const i4 = n2.props;
            return ["class", "style"].forEach((e3) => {
              i4[e3] && (t3.props[e3] ? ("style" !== e3 || i4[e3].endsWith(";") || (i4[e3] += ";"), t3.props[e3] = `${i4[e3]} ${t3.props[e3]}`) : t3.props[e3] = i4[e3]);
            }), void (e2[r3].props = { ...i4, ...t3.props });
          }
          if (t3._e === n2._e)
            return n2._duped = n2._duped || [], t3._d = `${n2._d}:${n2._duped.length + 1}`, void n2._duped.push(t3);
          if (tagWeight(t3) > tagWeight(n2))
            return;
        }
        const i2 = Object.keys(t3.props).length + (t3.innerHTML ? 1 : 0) + (t3.textContent ? 1 : 0);
        Xs.includes(t3.tag) && 0 === i2 ? delete e2[r3] : e2[r3] = t3;
      });
      const r2 = [];
      Object.values(e2).forEach((t3) => {
        const e3 = t3._duped;
        delete t3._duped, r2.push(t3), e3 && r2.push(...e3);
      }), t2.tags = r2, t2.tags = t2.tags.filter((t3) => !("meta" === t3.tag && (t3.props.name || t3.props.property) && !t3.props.content));
    } } }, pl = { mode: "server", hooks: { "tags:resolve": function(t2) {
      const e2 = {};
      t2.tags.filter((t3) => ["titleTemplate", "templateParams", "title"].includes(t3.tag) && "server" === t3._m).forEach((t3) => {
        e2[t3.tag] = t3.tag.startsWith("title") ? t3.textContent : t3.props;
      }), Object.keys(e2).length && t2.tags.push({ tag: "script", innerHTML: JSON.stringify(e2), props: { id: "unhead:payload", type: "application/json" } });
    } } }, cl = ["script", "link", "bodyAttrs"];
    function stripEventHandlers(t2) {
      const e2 = {}, r2 = {};
      return Object.entries(t2.props).forEach(([t3, n2]) => {
        t3.startsWith("on") && "function" == typeof n2 ? (ol.includes(t3) && (e2[t3] = `this.dataset.${t3} = true`), r2[t3] = n2) : e2[t3] = n2;
      }), { props: e2, eventHandlers: r2 };
    }
    const EventHandlersPlugin = (t2) => ({ hooks: { "tags:resolve": function(t3) {
      for (const e2 of t3.tags)
        if (cl.includes(e2.tag)) {
          const { props: t4, eventHandlers: r2 } = stripEventHandlers(e2);
          e2.props = t4, Object.keys(r2).length && ((e2.props.src || e2.props.href) && (e2.key = e2.key || hashCode(e2.props.src || e2.props.href)), e2._eventHandlers = r2);
        }
    }, "dom:renderTag": function(t3, e2, r2) {
      if (!t3.tag._eventHandlers)
        return;
      const n2 = "bodyAttrs" === t3.tag.tag ? e2.defaultView : t3.$el;
      Object.entries(t3.tag._eventHandlers).forEach(([e3, i2]) => {
        const o2 = `${t3.tag._d || t3.tag._p}:${e3}`, a2 = e3.slice(2).toLowerCase(), s2 = `data-h-${a2}`;
        if (r2(t3.id, o2, () => {
        }), t3.$el.hasAttribute(s2))
          return;
        let l2;
        t3.$el.setAttribute(s2, "");
        const handler = (t4) => {
          i2(t4), l2?.disconnect();
        };
        e3 in t3.$el.dataset ? handler(new Event(e3.replace("on", ""))) : ol.includes(e3) && "undefined" != typeof MutationObserver ? (l2 = new MutationObserver((t4) => {
          t4.some((t5) => t5.attributeName === `data-${e3}`) && (handler(new Event(e3.replace("on", ""))), l2?.disconnect());
        }), l2.observe(t3.$el, { attributes: true })) : n2.addEventListener(a2, handler), r2(t3.id, o2, () => {
          l2?.disconnect(), n2.removeEventListener(a2, handler), t3.$el.removeAttribute(s2);
        });
      });
    } } }), dl = ["link", "style", "script", "noscript"], ml = { hooks: { "tag:normalise": ({ tag: t2 }) => {
      t2.key && dl.includes(t2.tag) && (t2.props["data-hid"] = t2._h = hashCode(t2.key));
    } } }, ul = { hooks: { "tags:resolve": (t2) => {
      const tagPositionForKey = (e2) => t2.tags.find((t3) => t3._d === e2)?._p;
      for (const { prefix: e2, offset: r2 } of il)
        for (const n2 of t2.tags.filter((t3) => "string" == typeof t3.tagPriority && t3.tagPriority.startsWith(e2))) {
          const t3 = tagPositionForKey(n2.tagPriority.replace(e2, ""));
          void 0 !== t3 && (n2._p = t3 + r2);
        }
      t2.tags.sort((t3, e2) => t3._p - e2._p).sort((t3, e2) => tagWeight(t3) - tagWeight(e2));
    } } }, hl = { meta: "content", link: "href", htmlAttrs: "lang" }, TemplateParamsPlugin = (t2) => ({ hooks: { "tags:resolve": (e2) => {
      const { tags: r2 } = e2, n2 = r2.find((t3) => "title" === t3.tag)?.textContent, i2 = r2.findIndex((t3) => "templateParams" === t3.tag), o2 = -1 !== i2 ? r2[i2].props : {}, a2 = o2.separator || "|";
      delete o2.separator, o2.pageTitle = processTemplateParams(o2.pageTitle || n2 || "", o2, a2);
      for (const t3 of r2.filter((t4) => false !== t4.processTemplateParams)) {
        const e3 = hl[t3.tag];
        e3 && "string" == typeof t3.props[e3] ? t3.props[e3] = processTemplateParams(t3.props[e3], o2, a2) : (true === t3.processTemplateParams || ["titleTemplate", "title"].includes(t3.tag)) && ["innerHTML", "textContent"].forEach((e4) => {
          "string" == typeof t3[e4] && (t3[e4] = processTemplateParams(t3[e4], o2, a2));
        });
      }
      t2._templateParams = o2, t2._separator = a2, e2.tags = r2.filter((t3) => "templateParams" !== t3.tag);
    } } }), fl = { hooks: { "tags:resolve": (t2) => {
      const { tags: e2 } = t2;
      let r2 = e2.findIndex((t3) => "titleTemplate" === t3.tag);
      const n2 = e2.findIndex((t3) => "title" === t3.tag);
      if (-1 !== n2 && -1 !== r2) {
        const t3 = resolveTitleTemplate(e2[r2].textContent, e2[n2].textContent);
        null !== t3 ? e2[n2].textContent = t3 || e2[n2].textContent : delete e2[n2];
      } else if (-1 !== r2) {
        const t3 = resolveTitleTemplate(e2[r2].textContent);
        null !== t3 && (e2[r2].textContent = t3, e2[r2].tag = "title", r2 = -1);
      }
      -1 !== r2 && delete e2[r2], t2.tags = e2.filter(Boolean);
    } } }, gl = { hooks: { "tags:afterResolve": function(t2) {
      for (const e2 of t2.tags)
        "string" == typeof e2.innerHTML && (e2.innerHTML && ["application/ld+json", "application/json"].includes(e2.props.type) ? e2.innerHTML = e2.innerHTML.replace(/</g, "\\u003C") : e2.innerHTML = e2.innerHTML.replace(new RegExp(`</${e2.tag}`, "g"), `<\\/${e2.tag}`));
    } } };
    let xl;
    function createServerHead$1(t2 = {}) {
      return xl = function(t3 = {}) {
        const e2 = createHooks();
        e2.addHooks(t3.hooks || {}), t3.document = t3.document || void 0;
        const r2 = !t3.document, updated = () => {
          a2.dirty = true, e2.callHook("entries:updated", a2);
        };
        let n2 = 0, i2 = [];
        const o2 = [], a2 = { plugins: o2, dirty: false, resolvedOptions: t3, hooks: e2, headEntries: () => i2, use(t4) {
          const n3 = "function" == typeof t4 ? t4(a2) : t4;
          n3.key && o2.some((t5) => t5.key === n3.key) || (o2.push(n3), filterMode(n3.mode, r2) && e2.addHooks(n3.hooks || {}));
        }, push(t4, o3) {
          delete o3?.head;
          const s2 = { _i: n2++, input: t4, ...o3 };
          return filterMode(s2.mode, r2) && (i2.push(s2), updated()), { dispose() {
            i2 = i2.filter((t5) => t5._i !== s2._i), e2.callHook("entries:updated", a2), updated();
          }, patch(t5) {
            i2 = i2.map((e3) => (e3._i === s2._i && (e3.input = s2.input = t5), e3)), updated();
          } };
        }, async resolveTags() {
          const t4 = { tags: [], entries: [...i2] };
          await e2.callHook("entries:resolve", t4);
          for (const r3 of t4.entries) {
            const n3 = r3.resolvedInput || r3.input;
            if (r3.resolvedInput = await (r3.transform ? r3.transform(n3) : n3), r3.resolvedInput)
              for (const n4 of await normaliseEntryTags(r3)) {
                const i3 = { tag: n4, entry: r3, resolvedOptions: a2.resolvedOptions };
                await e2.callHook("tag:normalise", i3), t4.tags.push(i3.tag);
              }
          }
          return await e2.callHook("tags:beforeResolve", t4), await e2.callHook("tags:resolve", t4), await e2.callHook("tags:afterResolve", t4), t4.tags;
        }, ssr: r2 };
        return [ll, pl, EventHandlersPlugin, ml, ul, TemplateParamsPlugin, fl, gl, ...t3?.plugins || []].forEach((t4) => a2.use(t4)), a2.hooks.callHook("init", a2), a2;
      }(t2);
    }
    function filterMode(t2, e2) {
      return !t2 || "server" === t2 && e2 || "client" === t2 && !e2;
    }
    const vl = Zr.version.startsWith("3");
    function resolveUnrefHeadInput$1(t2, e2 = "") {
      if (t2 instanceof Promise)
        return t2;
      const r2 = "function" == typeof (n2 = t2) ? n2() : Zr.unref(n2);
      var n2;
      return t2 && r2 ? Array.isArray(r2) ? r2.map((t3) => resolveUnrefHeadInput$1(t3, e2)) : "object" == typeof r2 ? Object.fromEntries(Object.entries(r2).map(([t3, e3]) => "titleTemplate" === t3 || t3.startsWith("on") ? [t3, Zr.unref(e3)] : [t3, resolveUnrefHeadInput$1(e3, t3)])) : r2 : r2;
    }
    const yl = { hooks: { "entries:resolve": function(t2) {
      for (const e2 of t2.entries)
        e2.resolvedInput = resolveUnrefHeadInput$1(e2.input);
    } } }, bl = "usehead";
    function createServerHead(t2 = {}) {
      const e2 = createServerHead$1(t2);
      return e2.use(yl), e2.install = function(t3) {
        return { install(e3) {
          vl && (e3.config.globalProperties.$unhead = t3, e3.config.globalProperties.$head = t3, e3.provide(bl, t3));
        } }.install;
      }(e2), e2;
    }
    const wl = [], kl = { meta: [{ name: "viewport", content: "width=device-width, initial-scale=1" }, { charset: "utf-8" }], link: [{ key: "mdi", rel: "stylesheet", href: "https://cdn.jsdelivr.net/npm/@mdi/font@5.x/css/materialdesignicons.min.css", type: "text/css", crossorigin: "anonymous" }], style: [], script: [], noscript: [] }, Sl = "__nuxt", Cl = "div";
    function buildAssetsURL(...t2) {
      return joinURL(publicAssetsURL(), useRuntimeConfig$1().app.buildAssetsDir, ...t2);
    }
    function publicAssetsURL(...t2) {
      const e2 = useRuntimeConfig$1().app.cdnURL || useRuntimeConfig$1().app.baseURL;
      return t2.length ? joinURL(e2, ...t2) : e2;
    }
    globalThis.__buildAssetsURL = buildAssetsURL, globalThis.__publicAssetsURL = publicAssetsURL;
    const getClientManifest = () => Promise.resolve().then(function() {
      return Rl;
    }).then((t2) => t2.default || t2).then((t2) => "function" == typeof t2 ? t2() : t2), El = lazyCachedFunction(() => Promise.resolve().then(function() {
      return ld;
    }).then((t2) => t2.default || t2)), _l = lazyCachedFunction(async () => {
      const t2 = await getClientManifest();
      if (!t2)
        throw new Error("client.manifest is not available");
      const e2 = await Promise.resolve().then(function() {
        return ad;
      }).then((t3) => t3.default || t3);
      if (!e2)
        throw new Error("Server bundle is not available");
      return createRenderer(e2, { manifest: t2, renderToString: async function(t3, e3) {
        const r2 = await Gs.renderToString(t3, e3);
        return `<${Cl} id="${Sl}">${r2}</${Cl}>`;
      }, buildAssetsURL });
    }), Pl = lazyCachedFunction(async () => {
      const t2 = await getClientManifest(), e2 = await Promise.resolve().then(function() {
        return pd;
      }).then((t3) => t3.template).catch(() => ""), r2 = createRenderer(() => () => {
      }, { manifest: t2, renderToString: () => `<${Cl} id="${Sl}">${e2}</${Cl}>`, buildAssetsURL }), n2 = await r2.renderToString({});
      return { rendererContext: r2.rendererContext, renderToString: (t3) => {
        const e3 = useRuntimeConfig$1();
        return t3.modules = t3.modules || /* @__PURE__ */ new Set(), t3.payload = { _errors: {}, serverRendered: false, data: {}, state: {} }, t3.config = { public: e3.public, app: e3.app }, Promise.resolve(n2);
      } };
    }), Tl = /\/_payload(\.[a-zA-Z0-9]+)?.json(\?.*)?$/, Al = (Il = async (t2) => {
      const e2 = useNitroApp(), r2 = t2.path.startsWith("/__nuxt_error") ? function(t3) {
        return getQuery$1(t3.path || "");
      }(t2) : null;
      if (r2 && r2.statusCode && (r2.statusCode = parseInt(r2.statusCode)), r2 && !("__unenv__" in t2.node.req))
        throw createError$1({ statusCode: 404, statusMessage: "Page Not Found: /__nuxt_error" });
      const n2 = void 0;
      let i2 = r2?.url || t2.path;
      const o2 = Tl.test(i2) && true;
      o2 && (i2 = i2.substring(0, i2.lastIndexOf("/")) || "/", t2._path = i2, t2.node.req.url = i2);
      const a2 = getRouteRules(t2), s2 = createServerHead({ plugins: wl }), l2 = { mode: "server" };
      s2.push(kl, l2);
      const p2 = { url: i2, event: t2, runtimeConfig: useRuntimeConfig$1(), noSSR: t2.context.nuxt?.noSSR || false === a2.ssr && true || false, head: s2, error: !!r2, nuxt: void 0, payload: r2 ? { error: r2 } : {}, _payloadReducers: {}, islandContext: n2 }, c2 = p2.noSSR ? await Pl() : await _l(), d2 = await c2.renderToString(p2).catch(async (t3) => {
        if (p2._renderResponse && "skipping render" === t3.message)
          return {};
        const e3 = !r2 && p2.payload?.error || t3;
        throw await p2.nuxt?.hooks.callHook("app:error", e3), e3;
      });
      if (await p2.nuxt?.hooks.callHook("app:rendered", { ssrContext: p2, renderResult: d2 }), p2._renderResponse)
        return p2._renderResponse;
      if (p2.payload?.error && !r2)
        throw p2.payload.error;
      if (o2) {
        const t3 = function(t4) {
          return { body: stringify(splitPayload(t4).payload, t4._payloadReducers), statusCode: getResponseStatus(t4.event), statusMessage: getResponseStatusText(t4.event), headers: { "content-type": "application/json;charset=utf-8", "x-powered-by": "Nuxt" } };
        }(p2);
        return t3;
      }
      {
        const t3 = p2.modules ?? p2._registeredComponents;
        if (t3)
          for (const e3 of await getClientManifest().then((t4) => Object.values(t4).filter((t5) => t5._globalCSS).map((t5) => t5.src)))
            t3.add(e3);
      }
      const m2 = await async function(t3) {
        const e3 = await El(), r3 = /* @__PURE__ */ new Set();
        for (const n3 of t3)
          if (n3 in e3)
            for (const t4 of await e3[n3]())
              r3.add(t4);
        return Array.from(r3).map((t4) => ({ innerHTML: t4 }));
      }(p2.modules ?? p2._registeredComponents ?? []), u2 = a2.experimentalNoScripts, { styles: h2, scripts: g2 } = getRequestDependencies(p2, c2.rendererContext);
      s2.push({ style: m2 }), s2.push({ link: Object.values(h2).map((t3) => ({ rel: "stylesheet", href: c2.rendererContext.buildAssetsURL(t3.file) })) }, l2), u2 || (s2.push({ link: getPreloadLinks(p2, c2.rendererContext) }, l2), s2.push({ link: getPrefetchLinks(p2, c2.rendererContext) }, l2), s2.push({ script: renderPayloadJsonScript({ id: "__NUXT_DATA__", ssrContext: p2, data: p2.payload }) }, { ...l2, tagPosition: "bodyClose", tagPriority: "high" })), a2.experimentalNoScripts || s2.push({ script: Object.values(g2).map((t3) => ({ type: t3.module ? "module" : null, src: c2.rendererContext.buildAssetsURL(t3.file), defer: !t3.module || null, crossorigin: "" })) }, l2);
      const { headTags: x2, bodyTags: v2, bodyTagsOpen: y2, htmlAttrs: b2, bodyAttrs: w2 } = await renderSSRHead(s2), k2 = { island: Boolean(n2), htmlAttrs: [b2], head: normalizeChunks([x2, p2.styles]), bodyAttrs: [w2], bodyPrepend: normalizeChunks([y2, p2.teleports?.body]), body: [d2.html], bodyAppend: [v2] };
      var S2;
      return await e2.hooks.callHook("render:html", k2, { event: t2 }), { body: (S2 = k2, `<!DOCTYPE html>
<html ${joinAttrs(S2.htmlAttrs)}>
<head>${joinTags(S2.head)}</head>
<body ${joinAttrs(S2.bodyAttrs)}>${joinTags(S2.bodyPrepend)}${joinTags(S2.body)}${joinTags(S2.bodyAppend)}</body>
</html>`), statusCode: getResponseStatus(t2), statusMessage: getResponseStatusText(t2), headers: { "content-type": "text/html;charset=utf-8", "x-powered-by": "Nuxt" } };
    }, vt(async (t2) => {
      if (t2.path.endsWith("/favicon.ico"))
        return setResponseHeader(t2, "Content-Type", "image/x-icon"), send(t2, "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7");
      const e2 = await Il(t2);
      if (!e2) {
        const e3 = getResponseStatus(t2);
        return setResponseStatus(t2, 200 === e3 ? 500 : e3), send(t2, "No response returned from render handler: " + t2.path);
      }
      const r2 = useNitroApp();
      return await r2.hooks.callHook("render:response", e2, { event: t2 }), e2.headers && setResponseHeaders(t2, e2.headers), (e2.statusCode || e2.statusMessage) && setResponseStatus(t2, e2.statusCode, e2.statusMessage), e2.body;
    }));
    var Il;
    function lazyCachedFunction(t2) {
      let e2 = null;
      return () => (null === e2 && (e2 = t2().catch((t3) => {
        throw e2 = null, t3;
      })), e2);
    }
    function normalizeChunks(t2) {
      return t2.filter(Boolean).map((t3) => t3.trim());
    }
    function joinTags(t2) {
      return t2.join("");
    }
    function joinAttrs(t2) {
      return t2.join(" ");
    }
    function renderPayloadJsonScript(t2) {
      const e2 = t2.data ? stringify(t2.data, t2.ssrContext._payloadReducers) : "", r2 = { type: "application/json", id: t2.id, innerHTML: e2, "data-ssr": !t2.ssrContext.noSSR };
      return t2.src && (r2["data-src"] = t2.src), [r2, { innerHTML: `window.__NUXT__={};window.__NUXT__.config=${uneval(t2.ssrContext.config)}` }];
    }
    function splitPayload(t2) {
      const { data: e2, prerenderedAt: r2, ...n2 } = t2.payload;
      return { initial: { ...n2, prerenderedAt: r2 }, payload: { data: e2, prerenderedAt: r2 } };
    }
    const Nl = Object.freeze(Object.defineProperty({ __proto__: null, default: Al }, Symbol.toStringTag, { value: "Module" })), Rl = Object.freeze(Object.defineProperty({ __proto__: null, default: { "_vue.f36acd1f.c7335cae.js": { resourceType: "script", module: true, prefetch: true, preload: true, file: "vue.f36acd1f.c7335cae.js", imports: ["node_modules/nuxt/dist/app/entry.js"] }, "node_modules/@nuxt/ui-templates/dist/templates/error-404.css": { resourceType: "style", prefetch: true, preload: true, file: "error-404.7fc72018.css", src: "node_modules/@nuxt/ui-templates/dist/templates/error-404.css" }, "node_modules/@nuxt/ui-templates/dist/templates/error-404.vue": { resourceType: "script", module: true, prefetch: true, preload: true, css: [], file: "error-404.4ccdc085.js", imports: ["node_modules/nuxt/dist/app/entry.js", "_vue.f36acd1f.c7335cae.js"], isDynamicEntry: true, src: "node_modules/@nuxt/ui-templates/dist/templates/error-404.vue" }, "error-404.7fc72018.css": { file: "error-404.7fc72018.css", resourceType: "style", prefetch: true, preload: true }, "node_modules/@nuxt/ui-templates/dist/templates/error-500.css": { resourceType: "style", prefetch: true, preload: true, file: "error-500.c5df6088.css", src: "node_modules/@nuxt/ui-templates/dist/templates/error-500.css" }, "node_modules/@nuxt/ui-templates/dist/templates/error-500.vue": { resourceType: "script", module: true, prefetch: true, preload: true, css: [], file: "error-500.a7a5a13b.js", imports: ["_vue.f36acd1f.c7335cae.js", "node_modules/nuxt/dist/app/entry.js"], isDynamicEntry: true, src: "node_modules/@nuxt/ui-templates/dist/templates/error-500.vue" }, "error-500.c5df6088.css": { file: "error-500.c5df6088.css", resourceType: "style", prefetch: true, preload: true }, "node_modules/nuxt/dist/app/entry.css": { resourceType: "style", prefetch: true, preload: true, file: "entry.f067666a.css", src: "node_modules/nuxt/dist/app/entry.css" }, "node_modules/nuxt/dist/app/entry.js": { resourceType: "script", module: true, prefetch: true, preload: true, css: ["entry.f067666a.css"], dynamicImports: ["node_modules/@nuxt/ui-templates/dist/templates/error-404.vue", "node_modules/@nuxt/ui-templates/dist/templates/error-500.vue"], file: "entry.ecd8c850.js", isEntry: true, src: "node_modules/nuxt/dist/app/entry.js", _globalCSS: true }, "entry.f067666a.css": { file: "entry.f067666a.css", resourceType: "style", prefetch: true, preload: true }, "pages/index.css": { resourceType: "style", prefetch: true, preload: true, file: "index.6437d98a.css", src: "pages/index.css" }, "pages/index.vue": { resourceType: "script", module: true, prefetch: true, preload: true, css: [], file: "index.2b4ade22.js", imports: ["node_modules/nuxt/dist/app/entry.js"], isDynamicEntry: true, src: "pages/index.vue" }, "index.6437d98a.css": { file: "index.6437d98a.css", resourceType: "style", prefetch: true, preload: true } } }, Symbol.toStringTag, { value: "Module" }));
    function isESModule(t2) {
      return t2.__esModule || "Module" === t2[Symbol.toStringTag];
    }
    const Ol = Object.assign;
    function applyToParams(t2, e2) {
      const r2 = {};
      for (const n2 in e2) {
        const i2 = e2[n2];
        r2[n2] = Ll(i2) ? i2.map(t2) : t2(i2);
      }
      return r2;
    }
    const noop = () => {
    }, Ll = Array.isArray, Ml = /\/$/, removeTrailingSlash = (t2) => t2.replace(Ml, "");
    function parseURL(t2, e2, r2 = "/") {
      let n2, i2 = {}, o2 = "", a2 = "";
      const s2 = e2.indexOf("#");
      let l2 = e2.indexOf("?");
      return s2 < l2 && s2 >= 0 && (l2 = -1), l2 > -1 && (n2 = e2.slice(0, l2), o2 = e2.slice(l2 + 1, s2 > -1 ? s2 : e2.length), i2 = t2(o2)), s2 > -1 && (n2 = n2 || e2.slice(0, s2), a2 = e2.slice(s2, e2.length)), n2 = function(t3, e3) {
        if (t3.startsWith("/"))
          return t3;
        if (!t3)
          return e3;
        const r3 = e3.split("/"), n3 = t3.split("/"), i3 = n3[n3.length - 1];
        ".." !== i3 && "." !== i3 || n3.push("");
        let o3, a3, s3 = r3.length - 1;
        for (o3 = 0; o3 < n3.length; o3++)
          if (a3 = n3[o3], "." !== a3) {
            if (".." !== a3)
              break;
            s3 > 1 && s3--;
          }
        return r3.slice(0, s3).join("/") + "/" + n3.slice(o3 - (o3 === n3.length ? 1 : 0)).join("/");
      }(null != n2 ? n2 : e2, r2), { fullPath: n2 + (o2 && "?") + o2 + a2, path: n2, query: i2, hash: a2 };
    }
    function isSameRouteRecord(t2, e2) {
      return (t2.aliasOf || t2) === (e2.aliasOf || e2);
    }
    function isSameRouteLocationParams(t2, e2) {
      if (Object.keys(t2).length !== Object.keys(e2).length)
        return false;
      for (const r2 in t2)
        if (!isSameRouteLocationParamsValue(t2[r2], e2[r2]))
          return false;
      return true;
    }
    function isSameRouteLocationParamsValue(t2, e2) {
      return Ll(t2) ? isEquivalentArray(t2, e2) : Ll(e2) ? isEquivalentArray(e2, t2) : t2 === e2;
    }
    function isEquivalentArray(t2, e2) {
      return Ll(e2) ? t2.length === e2.length && t2.every((t3, r2) => t3 === e2[r2]) : 1 === t2.length && t2[0] === e2;
    }
    var Bl, Dl;
    !function(t2) {
      t2.pop = "pop", t2.push = "push";
    }(Bl || (Bl = {})), function(t2) {
      t2.back = "back", t2.forward = "forward", t2.unknown = "";
    }(Dl || (Dl = {}));
    const jl = /^[^#]+#/;
    function createHref(t2, e2) {
      return t2.replace(jl, "#") + e2;
    }
    function createMemoryHistory(t2 = "") {
      let e2 = [], r2 = [""], n2 = 0;
      function setLocation(t3) {
        n2++, n2 !== r2.length && r2.splice(n2), r2.push(t3);
      }
      const i2 = { location: "", state: {}, base: t2 = function(t3) {
        return t3 || (t3 = "/"), "/" !== t3[0] && "#" !== t3[0] && (t3 = "/" + t3), removeTrailingSlash(t3);
      }(t2), createHref: createHref.bind(null, t2), replace(t3) {
        r2.splice(n2--, 1), setLocation(t3);
      }, push(t3, e3) {
        setLocation(t3);
      }, listen: (t3) => (e2.push(t3), () => {
        const r3 = e2.indexOf(t3);
        r3 > -1 && e2.splice(r3, 1);
      }), destroy() {
        e2 = [], r2 = [""], n2 = 0;
      }, go(t3, i3 = true) {
        const o2 = this.location, a2 = t3 < 0 ? Dl.back : Dl.forward;
        n2 = Math.max(0, Math.min(n2 + t3, r2.length - 1)), i3 && function(t4, r3, { direction: n3, delta: i4 }) {
          const o3 = { direction: n3, delta: i4, type: Bl.pop };
          for (const n4 of e2)
            n4(t4, r3, o3);
        }(this.location, o2, { direction: a2, delta: t3 });
      } };
      return Object.defineProperty(i2, "location", { enumerable: true, get: () => r2[n2] }), i2;
    }
    function isRouteName(t2) {
      return "string" == typeof t2 || "symbol" == typeof t2;
    }
    const Fl = { path: "/", name: void 0, params: {}, query: {}, hash: "", fullPath: "/", matched: [], meta: {}, redirectedFrom: void 0 }, $l = Symbol("");
    var Vl;
    function createRouterError(t2, e2) {
      return Ol(new Error(), { type: t2, [$l]: true }, e2);
    }
    function isNavigationFailure(t2, e2) {
      return t2 instanceof Error && $l in t2 && (null == e2 || !!(t2.type & e2));
    }
    !function(t2) {
      t2[t2.aborted = 4] = "aborted", t2[t2.cancelled = 8] = "cancelled", t2[t2.duplicated = 16] = "duplicated";
    }(Vl || (Vl = {}));
    const zl = "[^/]+?", Ul = { sensitive: false, strict: false, start: true, end: true }, Hl = /[.+*?^${}()[\]/\\]/g;
    function compareScoreArray(t2, e2) {
      let r2 = 0;
      for (; r2 < t2.length && r2 < e2.length; ) {
        const n2 = e2[r2] - t2[r2];
        if (n2)
          return n2;
        r2++;
      }
      return t2.length < e2.length ? 1 === t2.length && 80 === t2[0] ? -1 : 1 : t2.length > e2.length ? 1 === e2.length && 80 === e2[0] ? 1 : -1 : 0;
    }
    function comparePathParserScore(t2, e2) {
      let r2 = 0;
      const n2 = t2.score, i2 = e2.score;
      for (; r2 < n2.length && r2 < i2.length; ) {
        const t3 = compareScoreArray(n2[r2], i2[r2]);
        if (t3)
          return t3;
        r2++;
      }
      if (1 === Math.abs(i2.length - n2.length)) {
        if (isLastScoreNegative(n2))
          return 1;
        if (isLastScoreNegative(i2))
          return -1;
      }
      return i2.length - n2.length;
    }
    function isLastScoreNegative(t2) {
      const e2 = t2[t2.length - 1];
      return t2.length > 0 && e2[e2.length - 1] < 0;
    }
    const ql = { type: 0, value: "" }, Wl = /[a-zA-Z0-9_]/;
    function createRouteRecordMatcher(t2, e2, r2) {
      const n2 = function(t3, e3) {
        const r3 = Ol({}, Ul, e3), n3 = [];
        let i3 = r3.start ? "^" : "";
        const o2 = [];
        for (const e4 of t3) {
          const t4 = e4.length ? [] : [90];
          r3.strict && !e4.length && (i3 += "/");
          for (let n4 = 0; n4 < e4.length; n4++) {
            const a3 = e4[n4];
            let s2 = 40 + (r3.sensitive ? 0.25 : 0);
            if (0 === a3.type)
              n4 || (i3 += "/"), i3 += a3.value.replace(Hl, "\\$&"), s2 += 40;
            else if (1 === a3.type) {
              const { value: t5, repeatable: r4, optional: l2, regexp: p2 } = a3;
              o2.push({ name: t5, repeatable: r4, optional: l2 });
              const c2 = p2 || zl;
              if (c2 !== zl) {
                s2 += 10;
                try {
                  new RegExp(`(${c2})`);
                } catch (e5) {
                  throw new Error(`Invalid custom RegExp for param "${t5}" (${c2}): ` + e5.message);
                }
              }
              let d2 = r4 ? `((?:${c2})(?:/(?:${c2}))*)` : `(${c2})`;
              n4 || (d2 = l2 && e4.length < 2 ? `(?:/${d2})` : "/" + d2), l2 && (d2 += "?"), i3 += d2, s2 += 20, l2 && (s2 += -8), r4 && (s2 += -20), ".*" === c2 && (s2 += -50);
            }
            t4.push(s2);
          }
          n3.push(t4);
        }
        if (r3.strict && r3.end) {
          const t4 = n3.length - 1;
          n3[t4][n3[t4].length - 1] += 0.7000000000000001;
        }
        r3.strict || (i3 += "/?"), r3.end ? i3 += "$" : r3.strict && (i3 += "(?:/|$)");
        const a2 = new RegExp(i3, r3.sensitive ? "" : "i");
        return { re: a2, score: n3, keys: o2, parse: function(t4) {
          const e4 = t4.match(a2), r4 = {};
          if (!e4)
            return null;
          for (let t5 = 1; t5 < e4.length; t5++) {
            const n4 = e4[t5] || "", i4 = o2[t5 - 1];
            r4[i4.name] = n4 && i4.repeatable ? n4.split("/") : n4;
          }
          return r4;
        }, stringify: function(e4) {
          let r4 = "", n4 = false;
          for (const i4 of t3) {
            n4 && r4.endsWith("/") || (r4 += "/"), n4 = false;
            for (const t4 of i4)
              if (0 === t4.type)
                r4 += t4.value;
              else if (1 === t4.type) {
                const { value: o3, repeatable: a3, optional: s2 } = t4, l2 = o3 in e4 ? e4[o3] : "";
                if (Ll(l2) && !a3)
                  throw new Error(`Provided param "${o3}" is an array but it is not repeatable (* or + modifiers)`);
                const p2 = Ll(l2) ? l2.join("/") : l2;
                if (!p2) {
                  if (!s2)
                    throw new Error(`Missing required param "${o3}"`);
                  i4.length < 2 && (r4.endsWith("/") ? r4 = r4.slice(0, -1) : n4 = true);
                }
                r4 += p2;
              }
          }
          return r4 || "/";
        } };
      }(function(t3) {
        if (!t3)
          return [[]];
        if ("/" === t3)
          return [[ql]];
        if (!t3.startsWith("/"))
          throw new Error(`Invalid path "${t3}"`);
        function crash(t4) {
          throw new Error(`ERR (${e3})/"${s2}": ${t4}`);
        }
        let e3 = 0, r3 = e3;
        const n3 = [];
        let i3;
        function finalizeSegment() {
          i3 && n3.push(i3), i3 = [];
        }
        let o2, a2 = 0, s2 = "", l2 = "";
        function consumeBuffer() {
          s2 && (0 === e3 ? i3.push({ type: 0, value: s2 }) : 1 === e3 || 2 === e3 || 3 === e3 ? (i3.length > 1 && ("*" === o2 || "+" === o2) && crash(`A repeatable param (${s2}) must be alone in its segment. eg: '/:ids+.`), i3.push({ type: 1, value: s2, regexp: l2, repeatable: "*" === o2 || "+" === o2, optional: "*" === o2 || "?" === o2 })) : crash("Invalid state to consume buffer"), s2 = "");
        }
        function addCharToBuffer() {
          s2 += o2;
        }
        for (; a2 < t3.length; )
          if (o2 = t3[a2++], "\\" !== o2 || 2 === e3)
            switch (e3) {
              case 0:
                "/" === o2 ? (s2 && consumeBuffer(), finalizeSegment()) : ":" === o2 ? (consumeBuffer(), e3 = 1) : addCharToBuffer();
                break;
              case 4:
                addCharToBuffer(), e3 = r3;
                break;
              case 1:
                "(" === o2 ? e3 = 2 : Wl.test(o2) ? addCharToBuffer() : (consumeBuffer(), e3 = 0, "*" !== o2 && "?" !== o2 && "+" !== o2 && a2--);
                break;
              case 2:
                ")" === o2 ? "\\" == l2[l2.length - 1] ? l2 = l2.slice(0, -1) + o2 : e3 = 3 : l2 += o2;
                break;
              case 3:
                consumeBuffer(), e3 = 0, "*" !== o2 && "?" !== o2 && "+" !== o2 && a2--, l2 = "";
                break;
              default:
                crash("Unknown state");
            }
          else
            r3 = e3, e3 = 4;
        return 2 === e3 && crash(`Unfinished custom RegExp for param "${s2}"`), consumeBuffer(), finalizeSegment(), n3;
      }(t2.path), r2), i2 = Ol(n2, { record: t2, parent: e2, children: [], alias: [] });
      return e2 && !i2.record.aliasOf == !e2.record.aliasOf && e2.children.push(i2), i2;
    }
    function createRouterMatcher(t2, e2) {
      const r2 = [], n2 = /* @__PURE__ */ new Map();
      function addRoute(t3, r3, n3) {
        const i2 = !n3, o2 = function(t4) {
          return { path: t4.path, redirect: t4.redirect, name: t4.name, meta: t4.meta || {}, aliasOf: void 0, beforeEnter: t4.beforeEnter, props: normalizeRecordProps(t4), children: t4.children || [], instances: {}, leaveGuards: /* @__PURE__ */ new Set(), updateGuards: /* @__PURE__ */ new Set(), enterCallbacks: {}, components: "components" in t4 ? t4.components || null : t4.component && { default: t4.component } };
        }(t3);
        o2.aliasOf = n3 && n3.record;
        const a2 = mergeOptions(e2, t3), s2 = [o2];
        if ("alias" in t3) {
          const e3 = "string" == typeof t3.alias ? [t3.alias] : t3.alias;
          for (const t4 of e3)
            s2.push(Ol({}, o2, { components: n3 ? n3.record.components : o2.components, path: t4, aliasOf: n3 ? n3.record : o2 }));
        }
        let l2, p2;
        for (const e3 of s2) {
          const { path: s3 } = e3;
          if (r3 && "/" !== s3[0]) {
            const t4 = r3.record.path, n4 = "/" === t4[t4.length - 1] ? "" : "/";
            e3.path = r3.record.path + (s3 && n4 + s3);
          }
          if (l2 = createRouteRecordMatcher(e3, r3, a2), n3 ? n3.alias.push(l2) : (p2 = p2 || l2, p2 !== l2 && p2.alias.push(l2), i2 && t3.name && !isAliasRecord(l2) && removeRoute(t3.name)), o2.children) {
            const t4 = o2.children;
            for (let e4 = 0; e4 < t4.length; e4++)
              addRoute(t4[e4], l2, n3 && n3.children[e4]);
          }
          n3 = n3 || l2, (l2.record.components && Object.keys(l2.record.components).length || l2.record.name || l2.record.redirect) && insertMatcher(l2);
        }
        return p2 ? () => {
          removeRoute(p2);
        } : noop;
      }
      function removeRoute(t3) {
        if (isRouteName(t3)) {
          const e3 = n2.get(t3);
          e3 && (n2.delete(t3), r2.splice(r2.indexOf(e3), 1), e3.children.forEach(removeRoute), e3.alias.forEach(removeRoute));
        } else {
          const e3 = r2.indexOf(t3);
          e3 > -1 && (r2.splice(e3, 1), t3.record.name && n2.delete(t3.record.name), t3.children.forEach(removeRoute), t3.alias.forEach(removeRoute));
        }
      }
      function insertMatcher(t3) {
        let e3 = 0;
        for (; e3 < r2.length && comparePathParserScore(t3, r2[e3]) >= 0 && (t3.record.path !== r2[e3].record.path || !isRecordChildOf(t3, r2[e3])); )
          e3++;
        r2.splice(e3, 0, t3), t3.record.name && !isAliasRecord(t3) && n2.set(t3.record.name, t3);
      }
      return e2 = mergeOptions({ strict: false, end: true, sensitive: false }, e2), t2.forEach((t3) => addRoute(t3)), { addRoute, resolve: function(t3, e3) {
        let i2, o2, a2, s2 = {};
        if ("name" in t3 && t3.name) {
          if (i2 = n2.get(t3.name), !i2)
            throw createRouterError(1, { location: t3 });
          a2 = i2.record.name, s2 = Ol(paramsFromLocation(e3.params, i2.keys.filter((t4) => !t4.optional).map((t4) => t4.name)), t3.params && paramsFromLocation(t3.params, i2.keys.map((t4) => t4.name))), o2 = i2.stringify(s2);
        } else if ("path" in t3)
          o2 = t3.path, i2 = r2.find((t4) => t4.re.test(o2)), i2 && (s2 = i2.parse(o2), a2 = i2.record.name);
        else {
          if (i2 = e3.name ? n2.get(e3.name) : r2.find((t4) => t4.re.test(e3.path)), !i2)
            throw createRouterError(1, { location: t3, currentLocation: e3 });
          a2 = i2.record.name, s2 = Ol({}, e3.params, t3.params), o2 = i2.stringify(s2);
        }
        const l2 = [];
        let p2 = i2;
        for (; p2; )
          l2.unshift(p2.record), p2 = p2.parent;
        return { name: a2, path: o2, params: s2, matched: l2, meta: mergeMetaFields(l2) };
      }, removeRoute, getRoutes: function() {
        return r2;
      }, getRecordMatcher: function(t3) {
        return n2.get(t3);
      } };
    }
    function paramsFromLocation(t2, e2) {
      const r2 = {};
      for (const n2 of e2)
        n2 in t2 && (r2[n2] = t2[n2]);
      return r2;
    }
    function normalizeRecordProps(t2) {
      const e2 = {}, r2 = t2.props || false;
      if ("component" in t2)
        e2.default = r2;
      else
        for (const n2 in t2.components)
          e2[n2] = "object" == typeof r2 ? r2[n2] : r2;
      return e2;
    }
    function isAliasRecord(t2) {
      for (; t2; ) {
        if (t2.record.aliasOf)
          return true;
        t2 = t2.parent;
      }
      return false;
    }
    function mergeMetaFields(t2) {
      return t2.reduce((t3, e2) => Ol(t3, e2.meta), {});
    }
    function mergeOptions(t2, e2) {
      const r2 = {};
      for (const n2 in t2)
        r2[n2] = n2 in e2 ? e2[n2] : t2[n2];
      return r2;
    }
    function isRecordChildOf(t2, e2) {
      return e2.children.some((e3) => e3 === t2 || isRecordChildOf(t2, e3));
    }
    const Kl = /#/g, Gl = /&/g, Jl = /\//g, Yl = /=/g, Xl = /\?/g, Ql = /\+/g, Zl = /%5B/g, tp = /%5D/g, ep = /%5E/g, rp = /%60/g, np = /%7B/g, ip = /%7C/g, op = /%7D/g, ap = /%20/g;
    function commonEncode(t2) {
      return encodeURI("" + t2).replace(ip, "|").replace(Zl, "[").replace(tp, "]");
    }
    function encodeQueryValue(t2) {
      return commonEncode(t2).replace(Ql, "%2B").replace(ap, "+").replace(Kl, "%23").replace(Gl, "%26").replace(rp, "`").replace(np, "{").replace(op, "}").replace(ep, "^");
    }
    function encodeParam(t2) {
      return null == t2 ? "" : function(t3) {
        return commonEncode(t3).replace(Kl, "%23").replace(Xl, "%3F");
      }(t2).replace(Jl, "%2F");
    }
    function decode(t2) {
      try {
        return decodeURIComponent("" + t2);
      } catch (t3) {
      }
      return "" + t2;
    }
    function parseQuery(t2) {
      const e2 = {};
      if ("" === t2 || "?" === t2)
        return e2;
      const r2 = ("?" === t2[0] ? t2.slice(1) : t2).split("&");
      for (let t3 = 0; t3 < r2.length; ++t3) {
        const n2 = r2[t3].replace(Ql, " "), i2 = n2.indexOf("="), o2 = decode(i2 < 0 ? n2 : n2.slice(0, i2)), a2 = i2 < 0 ? null : decode(n2.slice(i2 + 1));
        if (o2 in e2) {
          let t4 = e2[o2];
          Ll(t4) || (t4 = e2[o2] = [t4]), t4.push(a2);
        } else
          e2[o2] = a2;
      }
      return e2;
    }
    function stringifyQuery(t2) {
      let e2 = "";
      for (let r2 in t2) {
        const n2 = t2[r2];
        if (r2 = encodeQueryValue(r2).replace(Yl, "%3D"), null == n2) {
          void 0 !== n2 && (e2 += (e2.length ? "&" : "") + r2);
          continue;
        }
        (Ll(n2) ? n2.map((t3) => t3 && encodeQueryValue(t3)) : [n2 && encodeQueryValue(n2)]).forEach((t3) => {
          void 0 !== t3 && (e2 += (e2.length ? "&" : "") + r2, null != t3 && (e2 += "=" + t3));
        });
      }
      return e2;
    }
    function normalizeQuery(t2) {
      const e2 = {};
      for (const r2 in t2) {
        const n2 = t2[r2];
        void 0 !== n2 && (e2[r2] = Ll(n2) ? n2.map((t3) => null == t3 ? null : "" + t3) : null == n2 ? n2 : "" + n2);
      }
      return e2;
    }
    const sp = Symbol(""), lp = Symbol(""), pp = Symbol(""), cp = Symbol(""), dp = Symbol("");
    function useCallbacks() {
      let t2 = [];
      return { add: function(e2) {
        return t2.push(e2), () => {
          const r2 = t2.indexOf(e2);
          r2 > -1 && t2.splice(r2, 1);
        };
      }, list: () => t2.slice(), reset: function() {
        t2 = [];
      } };
    }
    function guardToPromiseFn(t2, e2, r2, n2, i2) {
      const o2 = n2 && (n2.enterCallbacks[i2] = n2.enterCallbacks[i2] || []);
      return () => new Promise((a2, s2) => {
        const next = (t3) => {
          var l3;
          false === t3 ? s2(createRouterError(4, { from: r2, to: e2 })) : t3 instanceof Error ? s2(t3) : "string" == typeof (l3 = t3) || l3 && "object" == typeof l3 ? s2(createRouterError(2, { from: e2, to: t3 })) : (o2 && n2.enterCallbacks[i2] === o2 && "function" == typeof t3 && o2.push(t3), a2());
        }, l2 = t2.call(n2 && n2.instances[i2], e2, r2, next);
        let p2 = Promise.resolve(l2);
        t2.length < 3 && (p2 = p2.then(next)), p2.catch((t3) => s2(t3));
      });
    }
    function extractComponentsGuards(t2, e2, r2, n2) {
      const i2 = [];
      for (const a2 of t2)
        for (const t3 in a2.components) {
          let s2 = a2.components[t3];
          if ("beforeRouteEnter" === e2 || a2.instances[t3])
            if ("object" == typeof (o2 = s2) || "displayName" in o2 || "props" in o2 || "__vccOpts" in o2) {
              const o3 = (s2.__vccOpts || s2)[e2];
              o3 && i2.push(guardToPromiseFn(o3, r2, n2, a2, t3));
            } else {
              let o3 = s2();
              i2.push(() => o3.then((i3) => {
                if (!i3)
                  return Promise.reject(new Error(`Couldn't resolve component "${t3}" at "${a2.path}"`));
                const o4 = isESModule(i3) ? i3.default : i3;
                a2.components[t3] = o4;
                const s3 = (o4.__vccOpts || o4)[e2];
                return s3 && guardToPromiseFn(s3, r2, n2, a2, t3)();
              }));
            }
        }
      var o2;
      return i2;
    }
    function useLink$1(t2) {
      const e2 = Zr.inject(pp), r2 = Zr.inject(cp), n2 = Zr.computed(() => e2.resolve(Zr.unref(t2.to))), i2 = Zr.computed(() => {
        const { matched: t3 } = n2.value, { length: e3 } = t3, i3 = t3[e3 - 1], o3 = r2.matched;
        if (!i3 || !o3.length)
          return -1;
        const a3 = o3.findIndex(isSameRouteRecord.bind(null, i3));
        if (a3 > -1)
          return a3;
        const s2 = getOriginalPath(t3[e3 - 2]);
        return e3 > 1 && getOriginalPath(i3) === s2 && o3[o3.length - 1].path !== s2 ? o3.findIndex(isSameRouteRecord.bind(null, t3[e3 - 2])) : a3;
      }), o2 = Zr.computed(() => i2.value > -1 && function(t3, e3) {
        for (const r3 in e3) {
          const n3 = e3[r3], i3 = t3[r3];
          if ("string" == typeof n3) {
            if (n3 !== i3)
              return false;
          } else if (!Ll(i3) || i3.length !== n3.length || n3.some((t4, e4) => t4 !== i3[e4]))
            return false;
        }
        return true;
      }(r2.params, n2.value.params)), a2 = Zr.computed(() => i2.value > -1 && i2.value === r2.matched.length - 1 && isSameRouteLocationParams(r2.params, n2.value.params));
      return { route: n2, href: Zr.computed(() => n2.value.href), isActive: o2, isExactActive: a2, navigate: function(r3 = {}) {
        return function(t3) {
          if (t3.metaKey || t3.altKey || t3.ctrlKey || t3.shiftKey)
            return;
          if (t3.defaultPrevented)
            return;
          if (void 0 !== t3.button && 0 !== t3.button)
            return;
          if (t3.currentTarget && t3.currentTarget.getAttribute) {
            const e3 = t3.currentTarget.getAttribute("target");
            if (/\b_blank\b/i.test(e3))
              return;
          }
          t3.preventDefault && t3.preventDefault();
          return true;
        }(r3) ? e2[Zr.unref(t2.replace) ? "replace" : "push"](Zr.unref(t2.to)).catch(noop) : Promise.resolve();
      } };
    }
    const mp = Zr.defineComponent({ name: "RouterLink", compatConfig: { MODE: 3 }, props: { to: { type: [String, Object], required: true }, replace: Boolean, activeClass: String, exactActiveClass: String, custom: Boolean, ariaCurrentValue: { type: String, default: "page" } }, useLink: useLink$1, setup(t2, { slots: e2 }) {
      const r2 = Zr.reactive(useLink$1(t2)), { options: n2 } = Zr.inject(pp), i2 = Zr.computed(() => ({ [getLinkClass(t2.activeClass, n2.linkActiveClass, "router-link-active")]: r2.isActive, [getLinkClass(t2.exactActiveClass, n2.linkExactActiveClass, "router-link-exact-active")]: r2.isExactActive }));
      return () => {
        const n3 = e2.default && e2.default(r2);
        return t2.custom ? n3 : Zr.h("a", { "aria-current": r2.isExactActive ? t2.ariaCurrentValue : null, href: r2.href, onClick: r2.navigate, class: i2.value }, n3);
      };
    } });
    function getOriginalPath(t2) {
      return t2 ? t2.aliasOf ? t2.aliasOf.path : t2.path : "";
    }
    const getLinkClass = (t2, e2, r2) => null != t2 ? t2 : null != e2 ? e2 : r2, up = Zr.defineComponent({ name: "RouterView", inheritAttrs: false, props: { name: { type: String, default: "default" }, route: Object }, compatConfig: { MODE: 3 }, setup(t2, { attrs: e2, slots: r2 }) {
      const n2 = Zr.inject(dp), i2 = Zr.computed(() => t2.route || n2.value), o2 = Zr.inject(lp, 0), a2 = Zr.computed(() => {
        let t3 = Zr.unref(o2);
        const { matched: e3 } = i2.value;
        let r3;
        for (; (r3 = e3[t3]) && !r3.components; )
          t3++;
        return t3;
      }), s2 = Zr.computed(() => i2.value.matched[a2.value]);
      Zr.provide(lp, Zr.computed(() => a2.value + 1)), Zr.provide(sp, s2), Zr.provide(dp, i2);
      const l2 = Zr.ref();
      return Zr.watch(() => [l2.value, s2.value, t2.name], ([t3, e3, r3], [n3, i3, o3]) => {
        e3 && (e3.instances[r3] = t3, i3 && i3 !== e3 && t3 && t3 === n3 && (e3.leaveGuards.size || (e3.leaveGuards = i3.leaveGuards), e3.updateGuards.size || (e3.updateGuards = i3.updateGuards))), !t3 || !e3 || i3 && isSameRouteRecord(e3, i3) && n3 || (e3.enterCallbacks[r3] || []).forEach((e4) => e4(t3));
      }, { flush: "post" }), () => {
        const n3 = i2.value, o3 = t2.name, a3 = s2.value, p2 = a3 && a3.components[o3];
        if (!p2)
          return normalizeSlot(r2.default, { Component: p2, route: n3 });
        const c2 = a3.props[o3], d2 = c2 ? true === c2 ? n3.params : "function" == typeof c2 ? c2(n3) : c2 : null, m2 = Zr.h(p2, Ol({}, d2, e2, { onVnodeUnmounted: (t3) => {
          t3.component.isUnmounted && (a3.instances[o3] = null);
        }, ref: l2 }));
        return normalizeSlot(r2.default, { Component: m2, route: n3 }) || m2;
      };
    } });
    function normalizeSlot(t2, e2) {
      if (!t2)
        return null;
      const r2 = t2(e2);
      return 1 === r2.length ? r2[0] : r2;
    }
    const hp = up;
    function createRouter(t2) {
      const e2 = createRouterMatcher(t2.routes, t2), r2 = t2.parseQuery || parseQuery, n2 = t2.stringifyQuery || stringifyQuery, i2 = t2.history, o2 = useCallbacks(), a2 = useCallbacks(), s2 = useCallbacks(), l2 = Zr.shallowRef(Fl);
      let p2 = Fl;
      const c2 = applyToParams.bind(null, (t3) => "" + t3), d2 = applyToParams.bind(null, encodeParam), m2 = applyToParams.bind(null, decode);
      function resolve(t3, o3) {
        if (o3 = Ol({}, o3 || l2.value), "string" == typeof t3) {
          const n3 = parseURL(r2, t3, o3.path), a4 = e2.resolve({ path: n3.path }, o3), s4 = i2.createHref(n3.fullPath);
          return Ol(n3, a4, { params: m2(a4.params), hash: decode(n3.hash), redirectedFrom: void 0, href: s4 });
        }
        let a3;
        if ("path" in t3)
          a3 = Ol({}, t3, { path: parseURL(r2, t3.path, o3.path).path });
        else {
          const e3 = Ol({}, t3.params);
          for (const t4 in e3)
            null == e3[t4] && delete e3[t4];
          a3 = Ol({}, t3, { params: d2(e3) }), o3.params = d2(o3.params);
        }
        const s3 = e2.resolve(a3, o3), p3 = t3.hash || "";
        s3.params = c2(m2(s3.params));
        const u3 = function(t4, e3) {
          const r3 = e3.query ? t4(e3.query) : "";
          return e3.path + (r3 && "?") + r3 + (e3.hash || "");
        }(n2, Ol({}, t3, { hash: (h3 = p3, commonEncode(h3).replace(np, "{").replace(op, "}").replace(ep, "^")), path: s3.path }));
        var h3;
        const g3 = i2.createHref(u3);
        return Ol({ fullPath: u3, hash: p3, query: n2 === stringifyQuery ? normalizeQuery(t3.query) : t3.query || {} }, s3, { redirectedFrom: void 0, href: g3 });
      }
      function locationAsObject(t3) {
        return "string" == typeof t3 ? parseURL(r2, t3, l2.value.path) : Ol({}, t3);
      }
      function checkCanceledNavigation(t3, e3) {
        if (p2 !== t3)
          return createRouterError(8, { from: e3, to: t3 });
      }
      function push(t3) {
        return pushWithRedirect(t3);
      }
      function handleRedirectRecord(t3) {
        const e3 = t3.matched[t3.matched.length - 1];
        if (e3 && e3.redirect) {
          const { redirect: r3 } = e3;
          let n3 = "function" == typeof r3 ? r3(t3) : r3;
          return "string" == typeof n3 && (n3 = n3.includes("?") || n3.includes("#") ? n3 = locationAsObject(n3) : { path: n3 }, n3.params = {}), Ol({ query: t3.query, hash: t3.hash, params: "path" in n3 ? {} : t3.params }, n3);
        }
      }
      function pushWithRedirect(t3, e3) {
        const r3 = p2 = resolve(t3), i3 = l2.value, o3 = t3.state, a3 = t3.force, s3 = true === t3.replace, c3 = handleRedirectRecord(r3);
        if (c3)
          return pushWithRedirect(Ol(locationAsObject(c3), { state: "object" == typeof c3 ? Ol({}, o3, c3.state) : o3, force: a3, replace: s3 }), e3 || r3);
        const d3 = r3;
        let m3;
        return d3.redirectedFrom = e3, !a3 && function(t4, e4, r4) {
          const n3 = e4.matched.length - 1, i4 = r4.matched.length - 1;
          return n3 > -1 && n3 === i4 && isSameRouteRecord(e4.matched[n3], r4.matched[i4]) && isSameRouteLocationParams(e4.params, r4.params) && t4(e4.query) === t4(r4.query) && e4.hash === r4.hash;
        }(n2, i3, r3) && (m3 = createRouterError(16, { to: d3, from: i3 }), handleScroll()), (m3 ? Promise.resolve(m3) : navigate(d3, i3)).catch((t4) => isNavigationFailure(t4) ? isNavigationFailure(t4, 2) ? t4 : markAsReady(t4) : triggerError(t4, d3, i3)).then((t4) => {
          if (t4) {
            if (isNavigationFailure(t4, 2))
              return pushWithRedirect(Ol({ replace: s3 }, locationAsObject(t4.to), { state: "object" == typeof t4.to ? Ol({}, o3, t4.to.state) : o3, force: a3 }), e3 || d3);
          } else
            t4 = finalizeNavigation(d3, i3, true, s3, o3);
          return triggerAfterEach(d3, i3, t4), t4;
        });
      }
      function checkCanceledNavigationAndReject(t3, e3) {
        const r3 = checkCanceledNavigation(t3, e3);
        return r3 ? Promise.reject(r3) : Promise.resolve();
      }
      function runWithContext(t3) {
        const e3 = v2.values().next().value;
        return e3 && "function" == typeof e3.runWithContext ? e3.runWithContext(t3) : t3();
      }
      function navigate(t3, e3) {
        let r3;
        const [n3, i3, s3] = function(t4, e4) {
          const r4 = [], n4 = [], i4 = [], o3 = Math.max(e4.matched.length, t4.matched.length);
          for (let a3 = 0; a3 < o3; a3++) {
            const o4 = e4.matched[a3];
            o4 && (t4.matched.find((t5) => isSameRouteRecord(t5, o4)) ? n4.push(o4) : r4.push(o4));
            const s4 = t4.matched[a3];
            s4 && (e4.matched.find((t5) => isSameRouteRecord(t5, s4)) || i4.push(s4));
          }
          return [r4, n4, i4];
        }(t3, e3);
        r3 = extractComponentsGuards(n3.reverse(), "beforeRouteLeave", t3, e3);
        for (const i4 of n3)
          i4.leaveGuards.forEach((n4) => {
            r3.push(guardToPromiseFn(n4, t3, e3));
          });
        const l3 = checkCanceledNavigationAndReject.bind(null, t3, e3);
        return r3.push(l3), runGuardQueue(r3).then(() => {
          r3 = [];
          for (const n4 of o2.list())
            r3.push(guardToPromiseFn(n4, t3, e3));
          return r3.push(l3), runGuardQueue(r3);
        }).then(() => {
          r3 = extractComponentsGuards(i3, "beforeRouteUpdate", t3, e3);
          for (const n4 of i3)
            n4.updateGuards.forEach((n5) => {
              r3.push(guardToPromiseFn(n5, t3, e3));
            });
          return r3.push(l3), runGuardQueue(r3);
        }).then(() => {
          r3 = [];
          for (const n4 of s3)
            if (n4.beforeEnter)
              if (Ll(n4.beforeEnter))
                for (const i4 of n4.beforeEnter)
                  r3.push(guardToPromiseFn(i4, t3, e3));
              else
                r3.push(guardToPromiseFn(n4.beforeEnter, t3, e3));
          return r3.push(l3), runGuardQueue(r3);
        }).then(() => (t3.matched.forEach((t4) => t4.enterCallbacks = {}), r3 = extractComponentsGuards(s3, "beforeRouteEnter", t3, e3), r3.push(l3), runGuardQueue(r3))).then(() => {
          r3 = [];
          for (const n4 of a2.list())
            r3.push(guardToPromiseFn(n4, t3, e3));
          return r3.push(l3), runGuardQueue(r3);
        }).catch((t4) => isNavigationFailure(t4, 8) ? t4 : Promise.reject(t4));
      }
      function triggerAfterEach(t3, e3, r3) {
        s2.list().forEach((n3) => runWithContext(() => n3(t3, e3, r3)));
      }
      function finalizeNavigation(t3, e3, r3, n3, o3) {
        const a3 = checkCanceledNavigation(t3, e3);
        if (a3)
          return a3;
        const s3 = e3 === Fl, p3 = {};
        r3 && (n3 || s3 ? i2.replace(t3.fullPath, Ol({ scroll: s3 && p3 && p3.scroll }, o3)) : i2.push(t3.fullPath, o3)), l2.value = t3, handleScroll(), markAsReady();
      }
      let u2;
      let h2, g2 = useCallbacks(), x2 = useCallbacks();
      function triggerError(t3, e3, r3) {
        markAsReady(t3);
        const n3 = x2.list();
        return n3.length ? n3.forEach((n4) => n4(t3, e3, r3)) : console.error(t3), Promise.reject(t3);
      }
      function markAsReady(t3) {
        return h2 || (h2 = !t3, u2 || (u2 = i2.listen((t4, e3, r3) => {
          if (!y2.listening)
            return;
          const n3 = resolve(t4), o3 = handleRedirectRecord(n3);
          if (o3)
            return void pushWithRedirect(Ol(o3, { replace: true }), n3).catch(noop);
          p2 = n3;
          const a3 = l2.value;
          navigate(n3, a3).catch((t5) => isNavigationFailure(t5, 12) ? t5 : isNavigationFailure(t5, 2) ? (pushWithRedirect(t5.to, n3).then((t6) => {
            isNavigationFailure(t6, 20) && !r3.delta && r3.type === Bl.pop && i2.go(-1, false);
          }).catch(noop), Promise.reject()) : (r3.delta && i2.go(-r3.delta, false), triggerError(t5, n3, a3))).then((t5) => {
            (t5 = t5 || finalizeNavigation(n3, a3, false)) && (r3.delta && !isNavigationFailure(t5, 8) ? i2.go(-r3.delta, false) : r3.type === Bl.pop && isNavigationFailure(t5, 20) && i2.go(-1, false)), triggerAfterEach(n3, a3, t5);
          }).catch(noop);
        })), g2.list().forEach(([e3, r3]) => t3 ? r3(t3) : e3()), g2.reset()), t3;
      }
      function handleScroll(t3, e3, r3, n3) {
        return Promise.resolve();
      }
      const go = (t3) => i2.go(t3), v2 = /* @__PURE__ */ new Set(), y2 = { currentRoute: l2, listening: true, addRoute: function(t3, r3) {
        let n3, i3;
        return isRouteName(t3) ? (n3 = e2.getRecordMatcher(t3), i3 = r3) : i3 = t3, e2.addRoute(i3, n3);
      }, removeRoute: function(t3) {
        const r3 = e2.getRecordMatcher(t3);
        r3 && e2.removeRoute(r3);
      }, hasRoute: function(t3) {
        return !!e2.getRecordMatcher(t3);
      }, getRoutes: function() {
        return e2.getRoutes().map((t3) => t3.record);
      }, resolve, options: t2, push, replace: function(t3) {
        return push(Ol(locationAsObject(t3), { replace: true }));
      }, go, back: () => go(-1), forward: () => go(1), beforeEach: o2.add, beforeResolve: a2.add, afterEach: s2.add, onError: x2.add, isReady: function() {
        return h2 && l2.value !== Fl ? Promise.resolve() : new Promise((t3, e3) => {
          g2.add([t3, e3]);
        });
      }, install(t3) {
        t3.component("RouterLink", mp), t3.component("RouterView", hp), t3.config.globalProperties.$router = this, Object.defineProperty(t3.config.globalProperties, "$route", { enumerable: true, get: () => Zr.unref(l2) });
        const e3 = {};
        for (const t4 in Fl)
          Object.defineProperty(e3, t4, { get: () => l2.value[t4], enumerable: true });
        t3.provide(pp, this), t3.provide(cp, Zr.shallowReactive(e3)), t3.provide(dp, l2);
        const r3 = t3.unmount;
        v2.add(t3), t3.unmount = function() {
          v2.delete(t3), v2.size < 1 && (p2 = Fl, u2 && u2(), u2 = null, l2.value = Fl, h2 = false), r3();
        };
      } };
      function runGuardQueue(t3) {
        return t3.reduce((t4, e3) => t4.then(() => runWithContext(e3)), Promise.resolve());
      }
      return y2;
    }
    const fp = useRuntimeConfig$1().app;
    globalThis.$fetch || (globalThis.$fetch = At.create({ baseURL: fp.baseURL }));
    const gp = getContext("nuxt-app", { asyncContext: false });
    function createNuxtApp(t2) {
      let e2 = 0;
      const r2 = { _scope: Zr.effectScope(), provide: void 0, globalName: "nuxt", versions: { get nuxt() {
        return "3.8.2";
      }, get vue() {
        return r2.vueApp.version;
      } }, payload: Zr.reactive({ data: {}, state: {}, _errors: {}, serverRendered: true }), static: { data: {} }, runWithContext: (t3) => r2._scope.run(() => function(t4, e3, r3) {
        const fn = () => r3 ? e3(...r3) : e3();
        return t4.vueApp.runWithContext(() => gp.callAsync(t4, fn));
      }(r2, t3)), isHydrating: false, deferHydration() {
        if (!r2.isHydrating)
          return () => {
          };
        e2++;
        let t3 = false;
        return () => {
          if (!t3)
            return t3 = true, e2--, 0 === e2 ? (r2.isHydrating = false, r2.callHook("app:suspense:resolve")) : void 0;
        };
      }, _asyncDataPromises: {}, _asyncData: {}, _payloadRevivers: {}, ...t2 };
      r2.hooks = createHooks(), r2.hook = r2.hooks.hook;
      {
        const contextCaller = async function(t3, e3) {
          for (const n3 of t3)
            await r2.runWithContext(() => n3(...e3));
        };
        r2.hooks.callHook = (t3, ...e3) => r2.hooks.callHookWith(contextCaller, t3, ...e3);
      }
      r2.callHook = r2.hooks.callHook, r2.provide = (t3, e3) => {
        const n3 = "$" + t3;
        defineGetter(r2, n3, e3), defineGetter(r2.vueApp.config.globalProperties, n3, e3);
      }, defineGetter(r2.vueApp, "$nuxt", r2), defineGetter(r2.vueApp.config.globalProperties, "$nuxt", r2), r2.ssrContext && (r2.ssrContext.nuxt = r2, r2.ssrContext._payloadReducers = {}, r2.payload.path = r2.ssrContext.url), r2.ssrContext = r2.ssrContext || {}, r2.ssrContext.payload && Object.assign(r2.payload, r2.ssrContext.payload), r2.ssrContext.payload = r2.payload, r2.ssrContext.config = { public: t2.ssrContext.runtimeConfig.public, app: t2.ssrContext.runtimeConfig.app };
      const n2 = t2.ssrContext.runtimeConfig;
      return r2.provide("config", n2), r2;
    }
    async function applyPlugin(t2, e2) {
      if (e2.hooks && t2.hooks.addHooks(e2.hooks), "function" == typeof e2) {
        const { provide: r2 } = await t2.runWithContext(() => e2(t2)) || {};
        if (r2 && "object" == typeof r2)
          for (const e3 in r2)
            t2.provide(e3, r2[e3]);
      }
    }
    function defineNuxtPlugin(t2) {
      return "function" == typeof t2 ? t2 : (delete t2.name, Object.assign(t2.setup || (() => {
      }), t2, { __nuxt_plugin: true }));
    }
    function useNuxtApp() {
      var t2;
      let e2;
      if (Zr.hasInjectionContext() && (e2 = null == (t2 = Zr.getCurrentInstance()) ? void 0 : t2.appContext.app.$nuxt), e2 = e2 || gp.tryUse(), !e2)
        throw new Error("[nuxt] instance unavailable");
      return e2;
    }
    function useRuntimeConfig() {
      return useNuxtApp().$config;
    }
    function defineGetter(t2, e2, r2) {
      Object.defineProperty(t2, e2, { get: () => r2 });
    }
    function resolveUnrefHeadInput(t2, e2 = "") {
      if (t2 instanceof Promise)
        return t2;
      const r2 = "function" == typeof (n2 = t2) ? n2() : Zr.unref(n2);
      var n2;
      return t2 && r2 ? Array.isArray(r2) ? r2.map((t3) => resolveUnrefHeadInput(t3, e2)) : "object" == typeof r2 ? Object.fromEntries(Object.entries(r2).map(([t3, e3]) => "titleTemplate" === t3 || t3.startsWith("on") ? [t3, Zr.unref(e3)] : [t3, resolveUnrefHeadInput(e3, t3)])) : r2 : r2;
    }
    Zr.version.startsWith("3");
    const xp = "usehead", vp = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {}, yp = "__unhead_injection_handler__";
    function injectHead() {
      if (yp in vp)
        return vp[yp]();
      const t2 = Zr.inject(xp);
      return t2 || xl;
    }
    const bp = defineNuxtPlugin({ name: "nuxt:head", enforce: "pre", setup(t2) {
      const e2 = t2.ssrContext.head;
      !function(t3) {
        vp[yp] = t3;
      }(() => useNuxtApp().vueApp._context.provides.usehead), t2.vueApp.use(e2);
    } });
    const wp = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof global ? global : {}, kp = "__unctx__";
    wp[kp] || (wp[kp] = function(t2 = {}) {
      const e2 = {};
      return { get: (r2, n2 = {}) => (e2[r2] || (e2[r2] = function(t3 = {}) {
        let e3, r3 = false;
        const checkConflict = (t4) => {
          if (e3 && e3 !== t4)
            throw new Error("Context conflict");
        };
        let n3;
        if (t3.asyncContext) {
          const e4 = t3.AsyncLocalStorage || globalThis.AsyncLocalStorage;
          e4 ? n3 = new e4() : console.warn("[unctx] `AsyncLocalStorage` is not provided.");
        }
        const _getCurrentInstance = () => {
          if (n3 && void 0 === e3) {
            const t4 = n3.getStore();
            if (void 0 !== t4)
              return t4;
          }
          return e3;
        };
        return { use: () => {
          const t4 = _getCurrentInstance();
          if (void 0 === t4)
            throw new Error("Context is not available");
          return t4;
        }, tryUse: () => _getCurrentInstance(), set: (t4, n4) => {
          n4 || checkConflict(t4), e3 = t4, r3 = true;
        }, unset: () => {
          e3 = void 0, r3 = false;
        }, call: (t4, i2) => {
          checkConflict(t4), e3 = t4;
          try {
            return n3 ? n3.run(t4, i2) : i2();
          } finally {
            r3 || (e3 = void 0);
          }
        }, async callAsync(t4, i2) {
          e3 = t4;
          const onRestore = () => {
            e3 = t4;
          }, onLeave = () => e3 === t4 ? onRestore : void 0;
          Cp.add(onLeave);
          try {
            const o2 = n3 ? n3.run(t4, i2) : i2();
            return r3 || (e3 = void 0), await o2;
          } finally {
            Cp.delete(onLeave);
          }
        } };
      }({ ...t2, ...n2 })), e2[r2], e2[r2]) };
    }());
    const Sp = "__unctx_async_handlers__", Cp = wp[Sp] || (wp[Sp] = /* @__PURE__ */ new Set());
    function executeAsync(t2) {
      const e2 = [];
      for (const t3 of Cp) {
        const r3 = t3();
        r3 && e2.push(r3);
      }
      const restore = () => {
        for (const t3 of e2)
          t3();
      };
      let r2 = t2();
      return r2 && "object" == typeof r2 && "catch" in r2 && (r2 = r2.catch((t3) => {
        throw restore(), t3;
      })), [r2, restore];
    }
    const Ep = Symbol("layout-meta"), _p = Symbol("route"), useRouter$1 = () => {
      var t2;
      return null == (t2 = useNuxtApp()) ? void 0 : t2.$router;
    };
    function defineNuxtRouteMiddleware(t2) {
      return t2;
    }
    const navigateTo = (t2, e2) => {
      t2 || (t2 = "/");
      const r2 = "string" == typeof t2 ? t2 : withQuery(t2.path || "/", t2.query || {}) + (t2.hash || "");
      if (null == e2 ? void 0 : e2.open)
        return Promise.resolve();
      const n2 = (null == e2 ? void 0 : e2.external) || hasProtocol(r2, { acceptRelative: true });
      if (n2) {
        if (!(null == e2 ? void 0 : e2.external))
          throw new Error("Navigating to an external URL is not allowed by default. Use `navigateTo(url, { external: true })`.");
        const t3 = parseURL$1(r2).protocol;
        if (t3 && function(t4) {
          return !!t4 && q.test(t4);
        }(t3))
          throw new Error(`Cannot navigate to a URL with '${t3}' protocol.`);
      }
      const i2 = (() => {
        try {
          if (useNuxtApp()._processingMiddleware)
            return true;
        } catch {
          return true;
        }
        return false;
      })(), o2 = useRouter$1(), a2 = useNuxtApp();
      if (a2.ssrContext) {
        const s2 = "string" == typeof t2 || n2 ? r2 : o2.resolve(t2).fullPath || "/", l2 = n2 ? r2 : joinURL(useRuntimeConfig().app.baseURL, s2), redirect = async function(t3) {
          await a2.callHook("app:redirected");
          const r3 = l2.replace(/"/g, "%22");
          return a2.ssrContext._renderResponse = { statusCode: sanitizeStatusCode((null == e2 ? void 0 : e2.redirectCode) || 302, 302), body: `<!DOCTYPE html><html><head><meta http-equiv="refresh" content="0; url=${r3}"></head></html>`, headers: { location: l2 } }, t3;
        };
        return !n2 && i2 ? (o2.afterEach((t3) => t3.fullPath === s2 ? redirect(false) : void 0), t2) : redirect(!i2 && void 0);
      }
      return n2 ? (a2._scope.stop(), (null == e2 ? void 0 : e2.replace) ? location.replace(r2) : location.href = r2, i2 ? !!a2.isHydrating && new Promise(() => {
      }) : Promise.resolve()) : (null == e2 ? void 0 : e2.replace) ? o2.replace(t2) : o2.push(t2);
    }, useError = () => Zr.toRef(useNuxtApp().payload, "error"), showError = (t2) => {
      const e2 = createError(t2);
      try {
        const t3 = useError();
        0, t3.value = t3.value || e2;
      } catch {
        throw e2;
      }
      return e2;
    }, createError = (t2) => {
      const e2 = createError$1(t2);
      return e2.__nuxt_error = true, e2;
    }, Pp = [{ name: "index", path: "/", meta: {}, alias: [], redirect: void 0, component: () => Promise.resolve().then(function() {
      return sh;
    }).then((t2) => t2.default || t2) }];
    function generateRouteKey$1(t2) {
      const e2 = (null == t2 ? void 0 : t2.meta.key) ?? t2.path.replace(/(:\w+)\([^)]+\)/g, "$1").replace(/(:\w+)[?+*]/g, "$1").replace(/:\w+/g, (e3) => {
        var r2;
        return (null == (r2 = t2.params[e3.slice(1)]) ? void 0 : r2.toString()) || "";
      });
      return "function" == typeof e2 ? e2(t2) : e2;
    }
    const Tp = false, Ap = { componentName: "NuxtLink" }, Ip = { scrollBehavior(t2, e2, r2) {
      var n2;
      const i2 = useNuxtApp(), o2 = (null == (n2 = useRouter$1().options) ? void 0 : n2.scrollBehaviorType) ?? "auto";
      let a2 = r2 || void 0;
      const s2 = "function" == typeof t2.meta.scrollToTop ? t2.meta.scrollToTop(t2, e2) : t2.meta.scrollToTop;
      if (!a2 && e2 && t2 && false !== s2 && function(t3, e3) {
        if (t3 === e3)
          return false;
        if (generateRouteKey$1(t3) !== generateRouteKey$1(e3))
          return true;
        const r3 = t3.matched.every((t4, r4) => {
          var n3, i3;
          return t4.components && t4.components.default === (null == (i3 = null == (n3 = e3.matched[r4]) ? void 0 : n3.components) ? void 0 : i3.default);
        });
        return !r3;
      }(t2, e2) && (a2 = { left: 0, top: 0 }), t2.path === e2.path) {
        if (e2.hash && !t2.hash)
          return { left: 0, top: 0 };
        if (t2.hash)
          return { el: t2.hash, top: _getHashElementScrollMarginTop(t2.hash), behavior: o2 };
      }
      const hasTransition = (t3) => !!(t3.meta.pageTransition ?? Tp), l2 = hasTransition(e2) && hasTransition(t2) ? "page:transition:finish" : "page:finish";
      return new Promise((e3) => {
        i2.hooks.hookOnce(l2, async () => {
          await Zr.nextTick(), t2.hash && (a2 = { el: t2.hash, top: _getHashElementScrollMarginTop(t2.hash), behavior: o2 }), e3(a2);
        });
      });
    } };
    function _getHashElementScrollMarginTop(t2) {
      try {
        const e2 = document.querySelector(t2);
        if (e2)
          return parseFloat(getComputedStyle(e2).scrollMarginTop);
      } catch {
      }
      return 0;
    }
    const Np = { hashMode: false, scrollBehaviorType: "auto", ...Ip }, Rp = [defineNuxtRouteMiddleware(async (t2) => {
      var e2;
      let r2, n2;
      if (!(null == (e2 = t2.meta) ? void 0 : e2.validate))
        return;
      useRouter$1();
      const i2 = ([r2, n2] = executeAsync(() => Promise.resolve(t2.meta.validate(t2))), r2 = await r2, n2(), r2);
      return true !== i2 ? i2 : void 0;
    }), defineNuxtRouteMiddleware(async (t2) => {
    })], Op = {}, Lp = defineNuxtPlugin({ name: "nuxt:router", enforce: "pre", async setup(t2) {
      var e2, r2;
      let n2, i2, o2 = useRuntimeConfig().app.baseURL;
      Np.hashMode && !o2.includes("#") && (o2 += "#");
      const a2 = (null == (e2 = Np.history) ? void 0 : e2.call(Np, o2)) ?? createMemoryHistory(o2), s2 = (null == (r2 = Np.routes) ? void 0 : r2.call(Np, Pp)) ?? Pp;
      let l2;
      const p2 = t2.ssrContext.url, c2 = createRouter({ ...Np, scrollBehavior: (t3, e3, r3) => {
        var n3;
        if (e3 !== Fl)
          return c2.options.scrollBehavior = Np.scrollBehavior, null == (n3 = Np.scrollBehavior) ? void 0 : n3.call(Np, t3, Fl, l2 || r3);
        l2 = r3;
      }, history: a2, routes: s2 });
      t2.vueApp.use(c2);
      const d2 = Zr.shallowRef(c2.currentRoute.value);
      c2.afterEach((t3, e3) => {
        d2.value = e3;
      }), Object.defineProperty(t2.vueApp.config.globalProperties, "previousRoute", { get: () => d2.value });
      const m2 = Zr.shallowRef(c2.resolve(p2)), syncCurrentRoute = () => {
        m2.value = c2.currentRoute.value;
      };
      t2.hook("page:finish", syncCurrentRoute), c2.afterEach((t3, e3) => {
        var r3, n3, i3, o3;
        (null == (n3 = null == (r3 = t3.matched[0]) ? void 0 : r3.components) ? void 0 : n3.default) === (null == (o3 = null == (i3 = e3.matched[0]) ? void 0 : i3.components) ? void 0 : o3.default) && syncCurrentRoute();
      });
      const u2 = {};
      for (const t3 in m2.value)
        Object.defineProperty(u2, t3, { get: () => m2.value[t3] });
      t2._route = Zr.shallowReactive(u2), t2._middleware = t2._middleware || { global: [], named: {} }, useError();
      try {
        [n2, i2] = executeAsync(() => c2.push(p2)), await n2, i2(), [n2, i2] = executeAsync(() => c2.isReady()), await n2, i2();
      } catch (e3) {
        [n2, i2] = executeAsync(() => t2.runWithContext(() => showError(e3))), await n2, i2();
      }
      const h2 = t2.payload.state._layout;
      return c2.beforeEach(async (e3, r3) => {
        var n3, i3;
        if (e3.meta = Zr.reactive(e3.meta), t2.isHydrating && h2 && !Zr.isReadonly(e3.meta.layout) && (e3.meta.layout = h2), t2._processingMiddleware = true, !(null == (n3 = t2.ssrContext) ? void 0 : n3.islandContext)) {
          const n4 = /* @__PURE__ */ new Set([...Rp, ...t2._middleware.global]);
          for (const t3 of e3.matched) {
            const e4 = t3.meta.middleware;
            if (e4)
              if (Array.isArray(e4))
                for (const t4 of e4)
                  n4.add(t4);
              else
                n4.add(e4);
          }
          for (const o3 of n4) {
            const n5 = "string" == typeof o3 ? t2._middleware.named[o3] || await (null == (i3 = Op[o3]) ? void 0 : i3.call(Op).then((t3) => t3.default || t3)) : o3;
            if (!n5)
              throw new Error(`Unknown route middleware: '${o3}'.`);
            const a3 = await t2.runWithContext(() => n5(e3, r3));
            if (false === a3 || a3 instanceof Error) {
              const e4 = a3 || createError$1({ statusCode: 404, statusMessage: `Page Not Found: ${p2}` });
              return await t2.runWithContext(() => showError(e4)), false;
            }
            if (true !== a3 && (a3 || false === a3))
              return a3;
          }
        }
      }), c2.onError(() => {
        delete t2._processingMiddleware;
      }), c2.afterEach(async (e3, r3, n3) => {
        var i3;
        delete t2._processingMiddleware, 4 !== (null == n3 ? void 0 : n3.type) && (0 !== e3.matched.length || (null == (i3 = t2.ssrContext) ? void 0 : i3.islandContext) ? e3.redirectedFrom && e3.fullPath !== p2 && await t2.runWithContext(() => navigateTo(e3.fullPath || "/")) : await t2.runWithContext(() => showError(createError$1({ statusCode: 404, fatal: false, statusMessage: `Page not found: ${e3.fullPath}` }))));
      }), t2.hooks.hookOnce("app:created", async () => {
        try {
          await c2.replace({ ...c2.resolve(p2), name: void 0, force: true }), c2.options.scrollBehavior = Np.scrollBehavior;
        } catch (e3) {
          await t2.runWithContext(() => showError(e3));
        }
      }), { provide: { router: c2 } };
    } });
    const Mp = { NuxtError: (t2) => {
      return !(!(e2 = t2) || "object" != typeof e2 || !("__nuxt_error" in e2)) && t2.toJSON();
      var e2;
    }, EmptyShallowRef: (t2) => Zr.isRef(t2) && Zr.isShallow(t2) && !t2.value && ("bigint" == typeof t2.value ? "0n" : JSON.stringify(t2.value) || "_"), EmptyRef: (t2) => Zr.isRef(t2) && !t2.value && ("bigint" == typeof t2.value ? "0n" : JSON.stringify(t2.value) || "_"), ShallowRef: (t2) => Zr.isRef(t2) && Zr.isShallow(t2) && t2.value, ShallowReactive: (t2) => Zr.isReactive(t2) && Zr.isShallow(t2) && Zr.toRaw(t2), Ref: (t2) => Zr.isRef(t2) && t2.value, Reactive: (t2) => Zr.isReactive(t2) && Zr.toRaw(t2) }, Bp = defineNuxtPlugin({ name: "nuxt:revive-payload:server", setup() {
      for (const r2 in Mp)
        t2 = r2, e2 = Mp[r2], useNuxtApp().ssrContext._payloadReducers[t2] = e2;
      var t2, e2;
    } }), Dp = defineNuxtPlugin({ name: "nuxt:global-components" }), jp = false, Fp = jp, $p = jp;
    function getNestedValue(t2, e2, r2) {
      const n2 = e2.length - 1;
      if (n2 < 0)
        return void 0 === t2 ? r2 : t2;
      for (let i2 = 0; i2 < n2; i2++) {
        if (null == t2)
          return r2;
        t2 = t2[e2[i2]];
      }
      return null == t2 || void 0 === t2[e2[n2]] ? r2 : t2[e2[n2]];
    }
    function deepEqual(t2, e2) {
      if (t2 === e2)
        return true;
      if (t2 instanceof Date && e2 instanceof Date && t2.getTime() !== e2.getTime())
        return false;
      if (t2 !== Object(t2) || e2 !== Object(e2))
        return false;
      const r2 = Object.keys(t2);
      return r2.length === Object.keys(e2).length && r2.every((r3) => deepEqual(t2[r3], e2[r3]));
    }
    function getObjectValueByPath(t2, e2, r2) {
      return null != t2 && e2 && "string" == typeof e2 ? void 0 !== t2[e2] ? t2[e2] : getNestedValue(t2, (e2 = (e2 = e2.replace(/\[(\w+)\]/g, ".$1")).replace(/^\./, "")).split("."), r2) : r2;
    }
    function getPropertyFromItem(t2, e2, r2) {
      if (true === e2)
        return void 0 === t2 ? r2 : t2;
      if (null == e2 || "boolean" == typeof e2)
        return r2;
      if (t2 !== Object(t2)) {
        if ("function" != typeof e2)
          return r2;
        const n3 = e2(t2, r2);
        return void 0 === n3 ? r2 : n3;
      }
      if ("string" == typeof e2)
        return getObjectValueByPath(t2, e2, r2);
      if (Array.isArray(e2))
        return getNestedValue(t2, e2, r2);
      if ("function" != typeof e2)
        return r2;
      const n2 = e2(t2, r2);
      return void 0 === n2 ? r2 : n2;
    }
    function createRange(t2) {
      let e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
      return Array.from({ length: t2 }, (t3, r2) => e2 + r2);
    }
    function convertToUnit(t2) {
      let e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "px";
      return null == t2 || "" === t2 ? void 0 : isNaN(+t2) ? String(t2) : isFinite(+t2) ? `${Number(t2)}${e2}` : void 0;
    }
    function isObject(t2) {
      return null !== t2 && "object" == typeof t2 && !Array.isArray(t2);
    }
    function refElement(t2) {
      if (t2 && "$el" in t2) {
        const e2 = t2.$el;
        return (null == e2 ? void 0 : e2.nodeType) === Node.TEXT_NODE ? e2.nextElementSibling : e2;
      }
      return t2;
    }
    const Vp = Object.freeze({ enter: 13, tab: 9, delete: 46, esc: 27, space: 32, up: 38, down: 40, left: 37, right: 39, end: 35, home: 36, del: 46, backspace: 8, insert: 45, pageup: 33, pagedown: 34, shift: 16 });
    function has(t2, e2) {
      return e2.every((e3) => t2.hasOwnProperty(e3));
    }
    function pick(t2, e2) {
      const r2 = {}, n2 = new Set(Object.keys(t2));
      for (const i2 of e2)
        n2.has(i2) && (r2[i2] = t2[i2]);
      return r2;
    }
    function pickWithRest(t2, e2, r2) {
      const n2 = /* @__PURE__ */ Object.create(null), i2 = /* @__PURE__ */ Object.create(null);
      for (const o2 in t2)
        e2.some((t3) => t3 instanceof RegExp ? t3.test(o2) : t3 === o2) && !(null == r2 ? void 0 : r2.some((t3) => t3 === o2)) ? n2[o2] = t2[o2] : i2[o2] = t2[o2];
      return [n2, i2];
    }
    function omit(t2, e2) {
      const r2 = { ...t2 };
      return e2.forEach((t3) => delete r2[t3]), r2;
    }
    const zp = /^on[^a-z]/, isOn = (t2) => zp.test(t2), Up = ["onAfterscriptexecute", "onAnimationcancel", "onAnimationend", "onAnimationiteration", "onAnimationstart", "onAuxclick", "onBeforeinput", "onBeforescriptexecute", "onChange", "onClick", "onCompositionend", "onCompositionstart", "onCompositionupdate", "onContextmenu", "onCopy", "onCut", "onDblclick", "onFocusin", "onFocusout", "onFullscreenchange", "onFullscreenerror", "onGesturechange", "onGestureend", "onGesturestart", "onGotpointercapture", "onInput", "onKeydown", "onKeypress", "onKeyup", "onLostpointercapture", "onMousedown", "onMousemove", "onMouseout", "onMouseover", "onMouseup", "onMousewheel", "onPaste", "onPointercancel", "onPointerdown", "onPointerenter", "onPointerleave", "onPointermove", "onPointerout", "onPointerover", "onPointerup", "onReset", "onSelect", "onSubmit", "onTouchcancel", "onTouchend", "onTouchmove", "onTouchstart", "onTransitioncancel", "onTransitionend", "onTransitionrun", "onTransitionstart", "onWheel"];
    function filterInputAttrs(t2) {
      const [e2, r2] = pickWithRest(t2, [zp]), n2 = omit(e2, Up), [i2, o2] = pickWithRest(r2, ["class", "style", "id", /^data-/]);
      return Object.assign(i2, e2), Object.assign(o2, n2), [i2, o2];
    }
    function wrapInArray(t2) {
      return null == t2 ? [] : Array.isArray(t2) ? t2 : [t2];
    }
    function clamp(t2) {
      let e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, r2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
      return Math.max(e2, Math.min(r2, t2));
    }
    function padEnd(t2, e2) {
      return t2 + (arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "0").repeat(Math.max(0, e2 - t2.length));
    }
    function padStart(t2, e2) {
      return (arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "0").repeat(Math.max(0, e2 - t2.length)) + t2;
    }
    function mergeDeep() {
      let t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r2 = arguments.length > 2 ? arguments[2] : void 0;
      const n2 = {};
      for (const e3 in t2)
        n2[e3] = t2[e3];
      for (const i2 in e2) {
        const o2 = t2[i2], a2 = e2[i2];
        isObject(o2) && isObject(a2) ? n2[i2] = mergeDeep(o2, a2, r2) : Array.isArray(o2) && Array.isArray(a2) && r2 ? n2[i2] = r2(o2, a2) : n2[i2] = a2;
      }
      return n2;
    }
    function flattenFragments(t2) {
      return t2.map((t3) => t3.type === Zr.Fragment ? flattenFragments(t3.children) : t3).flat();
    }
    function toKebabCase() {
      let t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
      if (toKebabCase.cache.has(t2))
        return toKebabCase.cache.get(t2);
      const e2 = t2.replace(/[^a-z]/gi, "-").replace(/\B([A-Z])/g, "-$1").toLowerCase();
      return toKebabCase.cache.set(t2, e2), e2;
    }
    function findChildrenWithProvide(t2, e2) {
      if (!e2 || "object" != typeof e2)
        return [];
      if (Array.isArray(e2))
        return e2.map((e3) => findChildrenWithProvide(t2, e3)).flat(1);
      if (Array.isArray(e2.children))
        return e2.children.map((e3) => findChildrenWithProvide(t2, e3)).flat(1);
      if (e2.component) {
        if (Object.getOwnPropertySymbols(e2.component.provides).includes(t2))
          return [e2.component];
        if (e2.component.subTree)
          return findChildrenWithProvide(t2, e2.component.subTree).flat(1);
      }
      return [];
    }
    function destructComputed(t2) {
      const e2 = Zr.reactive({}), r2 = Zr.computed(t2);
      return Zr.watchEffect(() => {
        for (const t3 in r2.value)
          e2[t3] = r2.value[t3];
      }, { flush: "sync" }), Zr.toRefs(e2);
    }
    function includes(t2, e2) {
      return t2.includes(e2);
    }
    function eventName(t2) {
      return t2[2].toLowerCase() + t2.slice(3);
    }
    toKebabCase.cache = /* @__PURE__ */ new Map();
    const EventProp = () => [Function, Array];
    function hasEvent(t2, e2) {
      return !!(t2[e2 = "on" + Zr.capitalize(e2)] || t2[`${e2}Once`] || t2[`${e2}Capture`] || t2[`${e2}OnceCapture`] || t2[`${e2}CaptureOnce`]);
    }
    function callEvent(t2) {
      for (var e2 = arguments.length, r2 = new Array(e2 > 1 ? e2 - 1 : 0), n2 = 1; n2 < e2; n2++)
        r2[n2 - 1] = arguments[n2];
      if (Array.isArray(t2))
        for (const e3 of t2)
          e3(...r2);
      else
        "function" == typeof t2 && t2(...r2);
    }
    function focusableChildren(t2) {
      let e2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
      const r2 = ["button", "[href]", 'input:not([type="hidden"])', "select", "textarea", "[tabindex]"].map((t3) => `${t3}${e2 ? ':not([tabindex="-1"])' : ""}:not([disabled])`).join(", ");
      return [...t2.querySelectorAll(r2)];
    }
    function getNextElement(t2, e2, r2) {
      let n2, i2 = t2.indexOf(document.activeElement);
      const o2 = "next" === e2 ? 1 : -1;
      do {
        i2 += o2, n2 = t2[i2];
      } while ((!n2 || null == n2.offsetParent || !((null == r2 ? void 0 : r2(n2)) ?? 1)) && i2 < t2.length && i2 >= 0);
      return n2;
    }
    function focusChild(t2, e2) {
      var r2, n2, i2;
      const o2 = focusableChildren(t2);
      if (e2)
        if ("first" === e2)
          null == (n2 = o2[0]) || n2.focus();
        else if ("last" === e2)
          null == (i2 = o2.at(-1)) || i2.focus();
        else {
          const r3 = getNextElement(o2, e2);
          r3 ? r3.focus() : focusChild(t2, "next" === e2 ? "first" : "last");
        }
      else
        t2 !== document.activeElement && t2.contains(document.activeElement) || null == (r2 = o2[0]) || r2.focus();
    }
    function matchesSelector(t2, e2) {
      return null;
    }
    const Hp = 2.4, qp = 0.2126729, Wp = 0.7151522, Kp = 0.072175, Gp = 0.55, Jp = 0.58, Yp = 0.57, Xp = 0.62, Qp = 0.03, Zp = 1.45, tc = 5e-4, ec = 1.25, rc = 1.25, nc = 0.078, ic = 12.82051282051282, oc = 0.06, ac = 1e-3;
    function APCAcontrast(t2, e2) {
      const r2 = (t2.r / 255) ** Hp, n2 = (t2.g / 255) ** Hp, i2 = (t2.b / 255) ** Hp, o2 = (e2.r / 255) ** Hp, a2 = (e2.g / 255) ** Hp, s2 = (e2.b / 255) ** Hp;
      let l2, p2 = r2 * qp + n2 * Wp + i2 * Kp, c2 = o2 * qp + a2 * Wp + s2 * Kp;
      if (p2 <= Qp && (p2 += (Qp - p2) ** Zp), c2 <= Qp && (c2 += (Qp - c2) ** Zp), Math.abs(c2 - p2) < tc)
        return 0;
      if (c2 > p2) {
        const t3 = (c2 ** Gp - p2 ** Jp) * ec;
        l2 = t3 < ac ? 0 : t3 < nc ? t3 - t3 * ic * oc : t3 - oc;
      } else {
        const t3 = (c2 ** Xp - p2 ** Yp) * rc;
        l2 = t3 > -ac ? 0 : t3 > -nc ? t3 - t3 * ic * oc : t3 + oc;
      }
      return 100 * l2;
    }
    function consoleWarn(t2) {
      Zr.warn(`Vuetify: ${t2}`);
    }
    function consoleError(t2) {
      Zr.warn(`Vuetify error: ${t2}`);
    }
    function deprecate(t2, e2) {
      e2 = Array.isArray(e2) ? e2.slice(0, -1).map((t3) => `'${t3}'`).join(", ") + ` or '${e2.at(-1)}'` : `'${e2}'`, Zr.warn(`[Vuetify UPGRADE] '${t2}' is deprecated, use ${e2} instead.`);
    }
    const sc = 0.20689655172413793, cielabForwardTransform = (t2) => t2 > sc ** 3 ? Math.cbrt(t2) : t2 / (3 * sc ** 2) + 4 / 29, cielabReverseTransform = (t2) => t2 > sc ? t2 ** 3 : 3 * sc ** 2 * (t2 - 4 / 29);
    function fromXYZ$1(t2) {
      const e2 = cielabForwardTransform, r2 = e2(t2[1]);
      return [116 * r2 - 16, 500 * (e2(t2[0] / 0.95047) - r2), 200 * (r2 - e2(t2[2] / 1.08883))];
    }
    function toXYZ$1(t2) {
      const e2 = cielabReverseTransform, r2 = (t2[0] + 16) / 116;
      return [0.95047 * e2(r2 + t2[1] / 500), e2(r2), 1.08883 * e2(r2 - t2[2] / 200)];
    }
    const lc = [[3.2406, -1.5372, -0.4986], [-0.9689, 1.8758, 0.0415], [0.0557, -0.204, 1.057]], srgbForwardTransform = (t2) => t2 <= 31308e-7 ? 12.92 * t2 : 1.055 * t2 ** (1 / 2.4) - 0.055, pc = [[0.4124, 0.3576, 0.1805], [0.2126, 0.7152, 0.0722], [0.0193, 0.1192, 0.9505]], srgbReverseTransform = (t2) => t2 <= 0.04045 ? t2 / 12.92 : ((t2 + 0.055) / 1.055) ** 2.4;
    function fromXYZ(t2) {
      const e2 = Array(3), r2 = srgbForwardTransform, n2 = lc;
      for (let i2 = 0; i2 < 3; ++i2)
        e2[i2] = Math.round(255 * clamp(r2(n2[i2][0] * t2[0] + n2[i2][1] * t2[1] + n2[i2][2] * t2[2])));
      return { r: e2[0], g: e2[1], b: e2[2] };
    }
    function toXYZ(t2) {
      let { r: e2, g: r2, b: n2 } = t2;
      const i2 = [0, 0, 0], o2 = srgbReverseTransform, a2 = pc;
      e2 = o2(e2 / 255), r2 = o2(r2 / 255), n2 = o2(n2 / 255);
      for (let t3 = 0; t3 < 3; ++t3)
        i2[t3] = a2[t3][0] * e2 + a2[t3][1] * r2 + a2[t3][2] * n2;
      return i2;
    }
    function isCssColor(t2) {
      return !!t2 && /^(#|var\(--|(rgb|hsl)a?\()/.test(t2);
    }
    function isParsableColor(t2) {
      return isCssColor(t2) && !/^((rgb|hsl)a?\()?var\(--/.test(t2);
    }
    const cc = /^(?<fn>(?:rgb|hsl)a?)\((?<values>.+)\)/, dc = { rgb: (t2, e2, r2, n2) => ({ r: t2, g: e2, b: r2, a: n2 }), rgba: (t2, e2, r2, n2) => ({ r: t2, g: e2, b: r2, a: n2 }), hsl: (t2, e2, r2, n2) => HSLtoRGB({ h: t2, s: e2, l: r2, a: n2 }), hsla: (t2, e2, r2, n2) => HSLtoRGB({ h: t2, s: e2, l: r2, a: n2 }), hsv: (t2, e2, r2, n2) => HSVtoRGB({ h: t2, s: e2, v: r2, a: n2 }), hsva: (t2, e2, r2, n2) => HSVtoRGB({ h: t2, s: e2, v: r2, a: n2 }) };
    function parseColor(t2) {
      if ("number" == typeof t2)
        return (isNaN(t2) || t2 < 0 || t2 > 16777215) && consoleWarn(`'${t2}' is not a valid hex color`), { r: (16711680 & t2) >> 16, g: (65280 & t2) >> 8, b: 255 & t2 };
      if ("string" == typeof t2 && cc.test(t2)) {
        const { groups: e2 } = t2.match(cc), { fn: r2, values: n2 } = e2, i2 = n2.split(/,\s*/).map((t3) => t3.endsWith("%") && ["hsl", "hsla", "hsv", "hsva"].includes(r2) ? parseFloat(t3) / 100 : parseFloat(t3));
        return dc[r2](...i2);
      }
      if ("string" == typeof t2) {
        let e2 = t2.startsWith("#") ? t2.slice(1) : t2;
        [3, 4].includes(e2.length) ? e2 = e2.split("").map((t3) => t3 + t3).join("") : [6, 8].includes(e2.length) || consoleWarn(`'${t2}' is not a valid hex(a) color`);
        const r2 = parseInt(e2, 16);
        return (isNaN(r2) || r2 < 0 || r2 > 4294967295) && consoleWarn(`'${t2}' is not a valid hex(a) color`), function(t3) {
          t3 = function(t4) {
            t4.startsWith("#") && (t4 = t4.slice(1));
            t4 = t4.replace(/([^0-9a-f])/gi, "F"), (3 === t4.length || 4 === t4.length) && (t4 = t4.split("").map((t5) => t5 + t5).join(""));
            6 !== t4.length && (t4 = padEnd(padEnd(t4, 6), 8, "F"));
            return t4;
          }(t3);
          let [e3, r3, n2, i2] = function(t4) {
            let e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
            const r4 = [];
            let n3 = 0;
            for (; n3 < t4.length; )
              r4.push(t4.substr(n3, e4)), n3 += e4;
            return r4;
          }(t3, 2).map((t4) => parseInt(t4, 16));
          return i2 = void 0 === i2 ? i2 : i2 / 255, { r: e3, g: r3, b: n2, a: i2 };
        }(e2);
      }
      if ("object" == typeof t2) {
        if (has(t2, ["r", "g", "b"]))
          return t2;
        if (has(t2, ["h", "s", "l"]))
          return HSVtoRGB(HSLtoHSV(t2));
        if (has(t2, ["h", "s", "v"]))
          return HSVtoRGB(t2);
      }
      throw new TypeError(`Invalid color: ${null == t2 ? t2 : String(t2) || t2.constructor.name}
Expected #hex, #hexa, rgb(), rgba(), hsl(), hsla(), object or number`);
    }
    function HSVtoRGB(t2) {
      const { h: e2, s: r2, v: n2, a: i2 } = t2, f = (t3) => {
        const i3 = (t3 + e2 / 60) % 6;
        return n2 - n2 * r2 * Math.max(Math.min(i3, 4 - i3, 1), 0);
      }, o2 = [f(5), f(3), f(1)].map((t3) => Math.round(255 * t3));
      return { r: o2[0], g: o2[1], b: o2[2], a: i2 };
    }
    function HSLtoRGB(t2) {
      return HSVtoRGB(HSLtoHSV(t2));
    }
    function HSLtoHSV(t2) {
      const { h: e2, s: r2, l: n2, a: i2 } = t2, o2 = n2 + r2 * Math.min(n2, 1 - n2);
      return { h: e2, s: 0 === o2 ? 0 : 2 - 2 * n2 / o2, v: o2, a: i2 };
    }
    function toHex(t2) {
      const e2 = Math.round(t2).toString(16);
      return ("00".substr(0, 2 - e2.length) + e2).toUpperCase();
    }
    function RGBtoHex(t2) {
      let { r: e2, g: r2, b: n2, a: i2 } = t2;
      return `#${[toHex(e2), toHex(r2), toHex(n2), void 0 !== i2 ? toHex(Math.round(255 * i2)) : ""].join("")}`;
    }
    function lighten(t2, e2) {
      const r2 = fromXYZ$1(toXYZ(t2));
      return r2[0] = r2[0] + 10 * e2, fromXYZ(toXYZ$1(r2));
    }
    function darken(t2, e2) {
      const r2 = fromXYZ$1(toXYZ(t2));
      return r2[0] = r2[0] - 10 * e2, fromXYZ(toXYZ$1(r2));
    }
    function getForeground(t2) {
      const e2 = Math.abs(APCAcontrast(parseColor(0), parseColor(t2)));
      return Math.abs(APCAcontrast(parseColor(16777215), parseColor(t2))) > Math.min(e2, 50) ? "#fff" : "#000";
    }
    function propsFactory(t2, e2) {
      return (r2) => Object.keys(t2).reduce((n2, i2) => {
        const o2 = "object" == typeof t2[i2] && null != t2[i2] && !Array.isArray(t2[i2]) ? t2[i2] : { type: t2[i2] };
        return n2[i2] = r2 && i2 in r2 ? { ...o2, default: r2[i2] } : o2, e2 && !n2[i2].source && (n2[i2].source = e2), n2;
      }, {});
    }
    const mc = propsFactory({ class: [String, Array], style: { type: [String, Array, Object], default: null } }, "component"), uc = Symbol.for("vuetify:defaults");
    function injectDefaults() {
      const t2 = Zr.inject(uc);
      if (!t2)
        throw new Error("[Vuetify] Could not find defaults instance");
      return t2;
    }
    function provideDefaults(t2, e2) {
      const r2 = injectDefaults(), n2 = Zr.ref(t2), i2 = Zr.computed(() => {
        if (Zr.unref(null == e2 ? void 0 : e2.disabled))
          return r2.value;
        const t3 = Zr.unref(null == e2 ? void 0 : e2.scoped), i3 = Zr.unref(null == e2 ? void 0 : e2.reset), o2 = Zr.unref(null == e2 ? void 0 : e2.root);
        if (null == n2.value && !(t3 || i3 || o2))
          return r2.value;
        let a2 = mergeDeep(n2.value, { prev: r2.value });
        if (t3)
          return a2;
        if (i3 || o2) {
          const t4 = Number(i3 || 1 / 0);
          for (let e3 = 0; e3 <= t4 && (a2 && "prev" in a2); e3++)
            a2 = a2.prev;
          return a2 && "string" == typeof o2 && o2 in a2 && (a2 = mergeDeep(mergeDeep(a2, { prev: a2 }), a2[o2])), a2;
        }
        return a2.prev ? mergeDeep(a2.prev, a2) : a2;
      });
      return Zr.provide(uc, i2), i2;
    }
    function internalUseDefaults() {
      let t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, e2 = arguments.length > 1 ? arguments[1] : void 0, r2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : injectDefaults();
      const n2 = getCurrentInstance("useDefaults");
      if (e2 = e2 ?? n2.type.name ?? n2.type.__name, !e2)
        throw new Error("[Vuetify] Could not determine component name");
      const i2 = Zr.computed(() => {
        var n3;
        return null == (n3 = r2.value) ? void 0 : n3[t2._as ?? e2];
      }), o2 = new Proxy(t2, { get(t3, e3) {
        var o3, a3, s2, l2;
        const p2 = Reflect.get(t3, e3);
        return "class" === e3 || "style" === e3 ? [null == (o3 = i2.value) ? void 0 : o3[e3], p2].filter((t4) => null != t4) : "string" != typeof e3 || function(t4, e4) {
          var r3, n3;
          return void 0 !== (null == (r3 = t4.props) ? void 0 : r3[e4]) || void 0 !== (null == (n3 = t4.props) ? void 0 : n3[toKebabCase(e4)]);
        }(n2.vnode, e3) ? p2 : (null == (a3 = i2.value) ? void 0 : a3[e3]) ?? (null == (l2 = null == (s2 = r2.value) ? void 0 : s2.global) ? void 0 : l2[e3]) ?? p2;
      } }), a2 = Zr.shallowRef();
      return Zr.watchEffect(() => {
        if (i2.value) {
          const t3 = Object.entries(i2.value).filter((t4) => {
            let [e3] = t4;
            return e3.startsWith(e3[0].toUpperCase());
          });
          a2.value = t3.length ? Object.fromEntries(t3) : void 0;
        } else
          a2.value = void 0;
      }), { props: o2, provideSubDefaults: function() {
        const t3 = function(t4) {
          let e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : getCurrentInstance("injectSelf");
          const { provides: r3 } = e3;
          if (r3 && t4 in r3)
            return r3[t4];
          return;
        }(uc, n2);
        Zr.provide(uc, Zr.computed(() => a2.value ? mergeDeep((null == t3 ? void 0 : t3.value) ?? {}, a2.value) : null == t3 ? void 0 : t3.value));
      } };
    }
    function defineComponent(t2) {
      if (t2._setup = t2._setup ?? t2.setup, !t2.name)
        return consoleWarn("The component is missing an explicit name, unable to generate default prop value"), t2;
      if (t2._setup) {
        t2.props = propsFactory(t2.props ?? {}, t2.name)();
        const e2 = Object.keys(t2.props).filter((t3) => "class" !== t3 && "style" !== t3);
        t2.filterProps = function(t3) {
          return pick(t3, e2);
        }, t2.props._as = String, t2.setup = function(e3, r2) {
          const n2 = injectDefaults();
          if (!n2.value)
            return t2._setup(e3, r2);
          const { props: i2, provideSubDefaults: o2 } = internalUseDefaults(e3, e3._as ?? t2.name, n2), a2 = t2._setup(i2, r2);
          return o2(), a2;
        };
      }
      return t2;
    }
    function genericComponent() {
      let t2 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
      return (e2) => (t2 ? defineComponent : Zr.defineComponent)(e2);
    }
    function getCurrentInstance(t2, e2) {
      const r2 = Zr.getCurrentInstance();
      if (!r2)
        throw new Error(`[Vuetify] ${t2} ${e2 || "must be called from inside a setup function"}`);
      return r2;
    }
    function getCurrentInstanceName() {
      const t2 = getCurrentInstance(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "composables").type;
      return toKebabCase((null == t2 ? void 0 : t2.aliasName) || (null == t2 ? void 0 : t2.name));
    }
    let hc = 0, fc = /* @__PURE__ */ new WeakMap();
    function getUid() {
      const t2 = getCurrentInstance("getUid");
      if (fc.has(t2))
        return fc.get(t2);
      {
        const e2 = hc++;
        return fc.set(t2, e2), e2;
      }
    }
    function useRender(t2) {
      getCurrentInstance("useRender").render = t2;
    }
    getUid.reset = () => {
      hc = 0, fc = /* @__PURE__ */ new WeakMap();
    };
    const gc = [String, Function, Object, Array], xc = Symbol.for("vuetify:icons"), vc = propsFactory({ icon: { type: gc }, tag: { type: String, required: true } }, "icon"), yc = genericComponent()({ name: "VComponentIcon", props: vc(), setup(t2, e2) {
      let { slots: r2 } = e2;
      return () => {
        const e3 = t2.icon;
        return Zr.createVNode(t2.tag, null, { default: () => {
          var n2;
          return [t2.icon ? Zr.createVNode(e3, null, null) : null == (n2 = r2.default) ? void 0 : n2.call(r2)];
        } });
      };
    } }), bc = defineComponent({ name: "VSvgIcon", inheritAttrs: false, props: vc(), setup(t2, e2) {
      let { attrs: r2 } = e2;
      return () => Zr.createVNode(t2.tag, Zr.mergeProps(r2, { style: null }), { default: () => [Zr.createVNode("svg", { class: "v-icon__svg", xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", role: "img", "aria-hidden": "true" }, [Array.isArray(t2.icon) ? t2.icon.map((t3) => Array.isArray(t3) ? Zr.createVNode("path", { d: t3[0], "fill-opacity": t3[1] }, null) : Zr.createVNode("path", { d: t3 }, null)) : Zr.createVNode("path", { d: t2.icon }, null)])] });
    } });
    defineComponent({ name: "VLigatureIcon", props: vc(), setup: (t2) => () => Zr.createVNode(t2.tag, null, { default: () => [t2.icon] }) });
    const wc = defineComponent({ name: "VClassIcon", props: vc(), setup: (t2) => () => Zr.createVNode(t2.tag, { class: t2.icon }, null) }), kc = { svg: { component: bc }, class: { component: wc } };
    const useIcon = (t2) => {
      const e2 = Zr.inject(xc);
      if (!e2)
        throw new Error("Missing Vuetify Icons provide!");
      return { iconData: Zr.computed(() => {
        var r2;
        const n2 = Zr.unref(t2);
        if (!n2)
          return { component: yc };
        let i2 = n2;
        if ("string" == typeof i2 && (i2 = i2.trim(), i2.startsWith("$") && (i2 = null == (r2 = e2.aliases) ? void 0 : r2[i2.slice(1)])), !i2)
          throw new Error(`Could not find aliased icon "${n2}"`);
        if (Array.isArray(i2))
          return { component: bc, icon: i2 };
        if ("string" != typeof i2)
          return { component: yc, icon: i2 };
        const o2 = Object.keys(e2.sets).find((t3) => "string" == typeof i2 && i2.startsWith(`${t3}:`)), a2 = o2 ? i2.slice(o2.length + 1) : i2;
        return { component: e2.sets[o2 ?? e2.defaultSet].component, icon: a2 };
      }) };
    }, Sc = { collapse: "mdi-chevron-up", complete: "mdi-check", cancel: "mdi-close-circle", close: "mdi-close", delete: "mdi-close-circle", clear: "mdi-close-circle", success: "mdi-check-circle", info: "mdi-information", warning: "mdi-alert-circle", error: "mdi-close-circle", prev: "mdi-chevron-left", next: "mdi-chevron-right", checkboxOn: "mdi-checkbox-marked", checkboxOff: "mdi-checkbox-blank-outline", checkboxIndeterminate: "mdi-minus-box", delimiter: "mdi-circle", sortAsc: "mdi-arrow-up", sortDesc: "mdi-arrow-down", expand: "mdi-chevron-down", menu: "mdi-menu", subgroup: "mdi-menu-down", dropdown: "mdi-menu-down", radioOn: "mdi-radiobox-marked", radioOff: "mdi-radiobox-blank", edit: "mdi-pencil", ratingEmpty: "mdi-star-outline", ratingFull: "mdi-star", ratingHalf: "mdi-star-half-full", loading: "mdi-cached", first: "mdi-page-first", last: "mdi-page-last", unfold: "mdi-unfold-more-horizontal", file: "mdi-paperclip", plus: "mdi-plus", minus: "mdi-minus", calendar: "mdi-calendar", eyeDropper: "mdi-eyedropper" }, Cc = { component: (t2) => Zr.h(wc, { ...t2, class: "mdi" }) };
    function configureIcons(t2) {
      {
        const e2 = { defaultSet: "mdi", aliases: Sc, sets: { mdi: Cc } };
        if ("custom" === (null == e2 ? void 0 : e2.defaultSet))
          return;
        t2.icons = e2;
      }
    }
    const Ec = defineNuxtPlugin((t2) => {
      t2.hook("vuetify:configuration", ({ vuetifyOptions: t3 }) => {
        configureIcons(t3);
      });
    }), _c = defineNuxtPlugin(() => ({ provide: Zr.reactive({ ssrClientHints: { firstRequest: false, prefersColorSchemeAvailable: false, prefersReducedMotionAvailable: false, viewportHeightAvailable: false, viewportWidthAvailable: false } }) })), Pc = { badge: "Badge", open: "Open", close: "Close", confirmEdit: { ok: "OK", cancel: "Cancel" }, dataIterator: { noResultsText: "No matching records found", loadingText: "Loading items..." }, dataTable: { itemsPerPageText: "Rows per page:", ariaLabel: { sortDescending: "Sorted descending.", sortAscending: "Sorted ascending.", sortNone: "Not sorted.", activateNone: "Activate to remove sorting.", activateDescending: "Activate to sort descending.", activateAscending: "Activate to sort ascending." }, sortBy: "Sort by" }, dataFooter: { itemsPerPageText: "Items per page:", itemsPerPageAll: "All", nextPage: "Next page", prevPage: "Previous page", firstPage: "First page", lastPage: "Last page", pageText: "{0}-{1} of {2}" }, dateRangeInput: { divider: "to" }, datePicker: { itemsSelected: "{0} selected", range: { title: "Select dates", header: "Enter dates" }, title: "Select date", header: "Enter date", input: { placeholder: "Enter date" } }, noDataText: "No data available", carousel: { prev: "Previous visual", next: "Next visual", ariaLabel: { delimiter: "Carousel slide {0} of {1}" } }, calendar: { moreEvents: "{0} more" }, input: { clear: "Clear {0}", prependAction: "{0} prepended action", appendAction: "{0} appended action", otp: "Please enter OTP character {0}" }, fileInput: { counter: "{0} files", counterSize: "{0} files ({1} in total)" }, timePicker: { am: "AM", pm: "PM" }, pagination: { ariaLabel: { root: "Pagination Navigation", next: "Next page", previous: "Previous page", page: "Go to page {0}", currentPage: "Page {0}, Current page", first: "First page", last: "Last page" } }, stepper: { next: "Next", prev: "Previous" }, rating: { ariaLabel: { item: "Rating {0} of {1}" } }, loading: "Loading...", infiniteScroll: { loadMore: "Load more", empty: "No more" } }, Tc = { af: false, ar: true, bg: false, ca: false, ckb: false, cs: false, de: false, el: false, en: false, es: false, et: false, fa: true, fi: false, fr: false, hr: false, hu: false, he: true, id: false, it: false, ja: false, ko: false, lv: false, lt: false, nl: false, no: false, pl: false, pt: false, ro: false, ru: false, sk: false, sl: false, srCyrl: false, srLatn: false, sv: false, th: false, tr: false, az: false, uk: false, vi: false, zhHans: false, zhHant: false };
    function useToggleScope(t2, e2) {
      let r2;
      function start() {
        r2 = Zr.effectScope(), r2.run(() => e2.length ? e2(() => {
          null == r2 || r2.stop(), start();
        }) : e2());
      }
      Zr.watch(t2, (t3) => {
        t3 && !r2 ? start() : t3 || (null == r2 || r2.stop(), r2 = void 0);
      }, { immediate: true }), Zr.onScopeDispose(() => {
        null == r2 || r2.stop();
      });
    }
    function useProxiedModel(t2, e2, r2) {
      let n2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : (t3) => t3, i2 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : (t3) => t3;
      const o2 = getCurrentInstance("useProxiedModel"), a2 = Zr.ref(void 0 !== t2[e2] ? t2[e2] : r2), s2 = toKebabCase(e2), l2 = s2 !== e2 ? Zr.computed(() => {
        var r3, n3, i3, a3;
        return t2[e2], !(!(null == (r3 = o2.vnode.props) ? void 0 : r3.hasOwnProperty(e2)) && !(null == (n3 = o2.vnode.props) ? void 0 : n3.hasOwnProperty(s2)) || !(null == (i3 = o2.vnode.props) ? void 0 : i3.hasOwnProperty(`onUpdate:${e2}`)) && !(null == (a3 = o2.vnode.props) ? void 0 : a3.hasOwnProperty(`onUpdate:${s2}`)));
      }) : Zr.computed(() => {
        var r3, n3;
        return t2[e2], !(!(null == (r3 = o2.vnode.props) ? void 0 : r3.hasOwnProperty(e2)) || !(null == (n3 = o2.vnode.props) ? void 0 : n3.hasOwnProperty(`onUpdate:${e2}`)));
      });
      useToggleScope(() => !l2.value, () => {
        Zr.watch(() => t2[e2], (t3) => {
          a2.value = t3;
        });
      });
      const p2 = Zr.computed({ get() {
        const r3 = t2[e2];
        return n2(l2.value ? r3 : a2.value);
      }, set(r3) {
        const s3 = i2(r3), p3 = Zr.toRaw(l2.value ? t2[e2] : a2.value);
        p3 !== s3 && n2(p3) !== r3 && (a2.value = s3, null == o2 || o2.emit(`update:${e2}`, s3));
      } });
      return Object.defineProperty(p2, "externalValue", { get: () => l2.value ? t2[e2] : a2.value }), p2;
    }
    const Ac = "$vuetify.", replace = (t2, e2) => t2.replace(/\{(\d+)\}/g, (t3, r2) => String(e2[+r2])), createTranslateFunction = (t2, e2, r2) => function(n2) {
      for (var i2 = arguments.length, o2 = new Array(i2 > 1 ? i2 - 1 : 0), a2 = 1; a2 < i2; a2++)
        o2[a2 - 1] = arguments[a2];
      if (!n2.startsWith(Ac))
        return replace(n2, o2);
      const s2 = n2.replace(Ac, ""), l2 = t2.value && r2.value[t2.value], p2 = e2.value && r2.value[e2.value];
      let c2 = getObjectValueByPath(l2, s2, null);
      return c2 || (consoleWarn(`Translation key "${n2}" not found in "${t2.value}", trying fallback locale`), c2 = getObjectValueByPath(p2, s2, null)), c2 || (consoleError(`Translation key "${n2}" not found in fallback`), c2 = n2), "string" != typeof c2 && (consoleError(`Translation key "${n2}" has a non-string value`), c2 = n2), replace(c2, o2);
    };
    function createNumberFunction(t2, e2) {
      return (r2, n2) => new Intl.NumberFormat([t2.value, e2.value], n2).format(r2);
    }
    function useProvided(t2, e2, r2) {
      const n2 = useProxiedModel(t2, e2, t2[e2] ?? r2.value);
      return n2.value = t2[e2] ?? r2.value, Zr.watch(r2, (i2) => {
        null == t2[e2] && (n2.value = r2.value);
      }), n2;
    }
    function createProvideFunction(t2) {
      return (e2) => {
        const r2 = useProvided(e2, "locale", t2.current), n2 = useProvided(e2, "fallback", t2.fallback), i2 = useProvided(e2, "messages", t2.messages);
        return { name: "vuetify", current: r2, fallback: n2, messages: i2, t: createTranslateFunction(r2, n2, i2), n: createNumberFunction(r2, n2), provide: createProvideFunction({ current: r2, fallback: n2, messages: i2 }) };
      };
    }
    const Ic = Symbol.for("vuetify:locale");
    function createLocale(t2) {
      const e2 = (null == t2 ? void 0 : t2.adapter) && function(t3) {
        return null != t3.name;
      }(null == t2 ? void 0 : t2.adapter) ? null == t2 ? void 0 : t2.adapter : function(t3) {
        const e3 = Zr.shallowRef((null == t3 ? void 0 : t3.locale) ?? "en"), r3 = Zr.shallowRef((null == t3 ? void 0 : t3.fallback) ?? "en"), n2 = Zr.ref({ en: Pc, ...null == t3 ? void 0 : t3.messages });
        return { name: "vuetify", current: e3, fallback: r3, messages: n2, t: createTranslateFunction(e3, r3, n2), n: createNumberFunction(e3, r3), provide: createProvideFunction({ current: e3, fallback: r3, messages: n2 }) };
      }(t2), r2 = function(t3, e3) {
        const r3 = Zr.ref((null == e3 ? void 0 : e3.rtl) ?? Tc), n2 = Zr.computed(() => r3.value[t3.current.value] ?? false);
        return { isRtl: n2, rtl: r3, rtlClasses: Zr.computed(() => "v-locale--is-" + (n2.value ? "rtl" : "ltr")) };
      }(e2, t2);
      return { ...e2, ...r2 };
    }
    function useLocale() {
      const t2 = Zr.inject(Ic);
      if (!t2)
        throw new Error("[Vuetify] Could not find injected locale instance");
      return t2;
    }
    function useRtl() {
      const t2 = Zr.inject(Ic);
      if (!t2)
        throw new Error("[Vuetify] Could not find injected rtl instance");
      return { isRtl: t2.isRtl, rtlClasses: t2.rtlClasses };
    }
    const Nc = { "001": 1, AD: 1, AE: 6, AF: 6, AG: 0, AI: 1, AL: 1, AM: 1, AN: 1, AR: 1, AS: 0, AT: 1, AU: 1, AX: 1, AZ: 1, BA: 1, BD: 0, BE: 1, BG: 1, BH: 6, BM: 1, BN: 1, BR: 0, BS: 0, BT: 0, BW: 0, BY: 1, BZ: 0, CA: 0, CH: 1, CL: 1, CM: 1, CN: 1, CO: 0, CR: 1, CY: 1, CZ: 1, DE: 1, DJ: 6, DK: 1, DM: 0, DO: 0, DZ: 6, EC: 1, EE: 1, EG: 6, ES: 1, ET: 0, FI: 1, FJ: 1, FO: 1, FR: 1, GB: 1, "GB-alt-variant": 0, GE: 1, GF: 1, GP: 1, GR: 1, GT: 0, GU: 0, HK: 0, HN: 0, HR: 1, HU: 1, ID: 0, IE: 1, IL: 0, IN: 0, IQ: 6, IR: 6, IS: 1, IT: 1, JM: 0, JO: 6, JP: 0, KE: 0, KG: 1, KH: 0, KR: 0, KW: 6, KZ: 1, LA: 0, LB: 1, LI: 1, LK: 1, LT: 1, LU: 1, LV: 1, LY: 6, MC: 1, MD: 1, ME: 1, MH: 0, MK: 1, MM: 0, MN: 1, MO: 0, MQ: 1, MT: 0, MV: 5, MX: 0, MY: 1, MZ: 0, NI: 0, NL: 1, NO: 1, NP: 0, NZ: 1, OM: 6, PA: 0, PE: 0, PH: 0, PK: 0, PL: 1, PR: 0, PT: 0, PY: 0, QA: 6, RE: 1, RO: 1, RS: 1, RU: 1, SA: 0, SD: 6, SE: 1, SG: 0, SI: 1, SK: 1, SM: 1, SV: 0, SY: 6, TH: 0, TJ: 1, TM: 1, TR: 1, TT: 0, TW: 0, UA: 1, UM: 0, US: 0, UY: 1, UZ: 1, VA: 1, VE: 0, VI: 0, VN: 1, WS: 0, XK: 1, YE: 0, ZA: 0, ZW: 0 };
    function startOfMonth(t2) {
      return new Date(t2.getFullYear(), t2.getMonth(), 1);
    }
    function endOfMonth(t2) {
      return new Date(t2.getFullYear(), t2.getMonth() + 1, 0);
    }
    const Rc = /^([12]\d{3}-([1-9]|0[1-9]|1[0-2])-([1-9]|0[1-9]|[12]\d|3[01]))$/;
    function date(t2) {
      if (null == t2)
        return /* @__PURE__ */ new Date();
      if (t2 instanceof Date)
        return t2;
      if ("string" == typeof t2) {
        let e2;
        if (Rc.test(t2))
          return function(t3) {
            const e3 = t3.split("-").map(Number);
            return new Date(e3[0], e3[1] - 1, e3[2]);
          }(t2);
        if (e2 = Date.parse(t2), !isNaN(e2))
          return new Date(e2);
      }
      return null;
    }
    const Oc = new Date(2e3, 0, 2);
    function isAfter(t2, e2) {
      return t2.getTime() > e2.getTime();
    }
    function isEqual(t2, e2) {
      return t2.getTime() === e2.getTime();
    }
    class VuetifyDateAdapter {
      constructor(t2) {
        this.locale = t2.locale, this.formats = t2.formats;
      }
      date(t2) {
        return date(t2);
      }
      toJsDate(t2) {
        return t2;
      }
      toISO(t2) {
        return function(t3, e2) {
          const r2 = t3.toJsDate(e2);
          return `${r2.getFullYear()}-${padStart(String(r2.getMonth() + 1), 2, "0")}-${padStart(String(r2.getDate()), 2, "0")}`;
        }(this, t2);
      }
      parseISO(t2) {
        return function(t3) {
          const [e2, r2, n2] = t3.split("-").map(Number);
          return new Date(e2, r2 - 1, n2);
        }(t2);
      }
      addDays(t2, e2) {
        return function(t3, e3) {
          const r2 = new Date(t3);
          return r2.setDate(r2.getDate() + e3), r2;
        }(t2, e2);
      }
      addMonths(t2, e2) {
        return function(t3, e3) {
          const r2 = new Date(t3);
          return r2.setMonth(r2.getMonth() + e3), r2;
        }(t2, e2);
      }
      getWeekArray(t2) {
        return function(t3, e2) {
          const r2 = [];
          let n2 = [];
          const i2 = startOfMonth(t3), o2 = endOfMonth(t3), a2 = (i2.getDay() - Nc[e2.slice(-2).toUpperCase()] + 7) % 7, s2 = (o2.getDay() - Nc[e2.slice(-2).toUpperCase()] + 7) % 7;
          for (let t4 = 0; t4 < a2; t4++) {
            const e3 = new Date(i2);
            e3.setDate(e3.getDate() - (a2 - t4)), n2.push(e3);
          }
          for (let e3 = 1; e3 <= o2.getDate(); e3++) {
            const i3 = new Date(t3.getFullYear(), t3.getMonth(), e3);
            n2.push(i3), 7 === n2.length && (r2.push(n2), n2 = []);
          }
          for (let t4 = 1; t4 < 7 - s2; t4++) {
            const e3 = new Date(o2);
            e3.setDate(e3.getDate() + t4), n2.push(e3);
          }
          return n2.length > 0 && r2.push(n2), r2;
        }(t2, this.locale);
      }
      startOfMonth(t2) {
        return startOfMonth(t2);
      }
      endOfMonth(t2) {
        return endOfMonth(t2);
      }
      format(t2, e2) {
        return function(t3, e3, r2, n2) {
          const i2 = date(t3) ?? /* @__PURE__ */ new Date(), o2 = null == n2 ? void 0 : n2[e3];
          if ("function" == typeof o2)
            return o2(i2, e3, r2);
          let a2 = {};
          switch (e3) {
            case "fullDateWithWeekday":
              a2 = { weekday: "long", day: "numeric", month: "long", year: "numeric" };
              break;
            case "normalDateWithWeekday":
              a2 = { weekday: "short", day: "numeric", month: "short" };
              break;
            case "keyboardDate":
              a2 = { day: "2-digit", month: "2-digit", year: "numeric" };
              break;
            case "monthAndDate":
              a2 = { month: "long", day: "numeric" };
              break;
            case "monthAndYear":
              a2 = { month: "long", year: "numeric" };
              break;
            case "month":
              a2 = { month: "long" };
              break;
            case "monthShort":
              a2 = { month: "short" };
              break;
            case "dayOfMonth":
              a2 = { day: "numeric" };
              break;
            case "shortDate":
              a2 = { year: "2-digit", month: "numeric", day: "numeric" };
              break;
            case "year":
              a2 = { year: "numeric" };
              break;
            default:
              a2 = o2 ?? { timeZone: "UTC", timeZoneName: "short" };
          }
          return new Intl.DateTimeFormat(r2, a2).format(i2);
        }(t2, e2, this.locale, this.formats);
      }
      isEqual(t2, e2) {
        return isEqual(t2, e2);
      }
      isValid(t2) {
        return function(t3) {
          const e2 = new Date(t3);
          return e2 instanceof Date && !isNaN(e2.getTime());
        }(t2);
      }
      isWithinRange(t2, e2) {
        return function(t3, e3) {
          return isAfter(t3, e3[0]) && function(t4, e4) {
            return t4.getTime() < e4.getTime();
          }(t3, e3[1]);
        }(t2, e2);
      }
      isAfter(t2, e2) {
        return isAfter(t2, e2);
      }
      isBefore(t2, e2) {
        return !isAfter(t2, e2) && !isEqual(t2, e2);
      }
      isSameDay(t2, e2) {
        return function(t3, e3) {
          return t3.getDate() === e3.getDate() && t3.getMonth() === e3.getMonth() && t3.getFullYear() === e3.getFullYear();
        }(t2, e2);
      }
      isSameMonth(t2, e2) {
        return function(t3, e3) {
          return t3.getMonth() === e3.getMonth() && t3.getFullYear() === e3.getFullYear();
        }(t2, e2);
      }
      setMonth(t2, e2) {
        return function(t3, e3) {
          const r2 = new Date(t3);
          return r2.setMonth(e3), r2;
        }(t2, e2);
      }
      setYear(t2, e2) {
        return function(t3, e3) {
          const r2 = new Date(t3);
          return r2.setFullYear(e3), r2;
        }(t2, e2);
      }
      getDiff(t2, e2, r2) {
        return function(t3, e3, r3) {
          const n2 = new Date(t3), i2 = new Date(e3);
          return "month" === r3 ? n2.getMonth() - i2.getMonth() + 12 * (n2.getFullYear() - i2.getFullYear()) : Math.floor((n2.getTime() - i2.getTime()) / 864e5);
        }(t2, e2, r2);
      }
      getWeekdays() {
        return function(t2) {
          const e2 = Nc[t2.slice(-2).toUpperCase()];
          return createRange(7).map((r2) => {
            const n2 = new Date(Oc);
            return n2.setDate(Oc.getDate() + e2 + r2), new Intl.DateTimeFormat(t2, { weekday: "narrow" }).format(n2);
          });
        }(this.locale);
      }
      getYear(t2) {
        return function(t3) {
          return t3.getFullYear();
        }(t2);
      }
      getMonth(t2) {
        return function(t3) {
          return t3.getMonth();
        }(t2);
      }
      getNextMonth(t2) {
        return function(t3) {
          return new Date(t3.getFullYear(), t3.getMonth() + 1, 1);
        }(t2);
      }
      startOfDay(t2) {
        return function(t3) {
          return new Date(t3.getFullYear(), t3.getMonth(), t3.getDate());
        }(t2);
      }
      endOfDay(t2) {
        return function(t3) {
          return new Date(t3.getFullYear(), t3.getMonth(), t3.getDate(), 23, 59, 59, 999);
        }(t2);
      }
      startOfYear(t2) {
        return function(t3) {
          return new Date(t3.getFullYear(), 0, 1);
        }(t2);
      }
      endOfYear(t2) {
        return function(t3) {
          return new Date(t3.getFullYear(), 11, 31);
        }(t2);
      }
    }
    const Lc = Symbol.for("vuetify:date-options"), Mc = Symbol.for("vuetify:date-adapter");
    function createInstance(t2, e2) {
      const r2 = Zr.reactive("function" == typeof t2.adapter ? new t2.adapter({ locale: t2.locale[e2.current.value] ?? e2.current.value, formats: t2.formats }) : t2.adapter);
      return Zr.watch(e2.current, (e3) => {
        r2.locale = t2.locale[e3] ?? e3 ?? r2.locale;
      }), r2;
    }
    const Bc = Symbol.for("vuetify:display"), Dc = { mobileBreakpoint: "lg", thresholds: { xs: 0, sm: 600, md: 960, lg: 1280, xl: 1920, xxl: 2560 } }, parseDisplayOptions = function() {
      return mergeDeep(Dc, arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Dc);
    };
    function getClientWidth(t2) {
      return "object" == typeof t2 && t2.clientWidth || 0;
    }
    function getClientHeight(t2) {
      return "object" == typeof t2 && t2.clientHeight || 0;
    }
    function getPlatform(t2) {
      function match(t3) {
        return Boolean("ssr".match(t3));
      }
      return { android: match(/android/i), ios: match(/iphone|ipad|ipod/i), cordova: match(/cordova/i), electron: match(/electron/i), chrome: match(/chrome/i), edge: match(/edge/i), firefox: match(/firefox/i), opera: match(/opera/i), win: match(/win/i), mac: match(/mac/i), linux: match(/linux/i), touch: $p, ssr: true };
    }
    function createDisplay(t2, e2) {
      const { thresholds: r2, mobileBreakpoint: n2 } = parseDisplayOptions(t2), i2 = Zr.shallowRef(getClientHeight(e2)), o2 = Zr.shallowRef(getPlatform()), a2 = Zr.reactive({}), s2 = Zr.shallowRef(getClientWidth(e2));
      return Zr.watchEffect(() => {
        const t3 = s2.value < r2.sm, e3 = s2.value < r2.md && !t3, l2 = s2.value < r2.lg && !(e3 || t3), p2 = s2.value < r2.xl && !(l2 || e3 || t3), c2 = s2.value < r2.xxl && !(p2 || l2 || e3 || t3), d2 = s2.value >= r2.xxl, m2 = t3 ? "xs" : e3 ? "sm" : l2 ? "md" : p2 ? "lg" : c2 ? "xl" : "xxl", u2 = "number" == typeof n2 ? n2 : r2[n2], h2 = s2.value < u2;
        a2.xs = t3, a2.sm = e3, a2.md = l2, a2.lg = p2, a2.xl = c2, a2.xxl = d2, a2.smAndUp = !t3, a2.mdAndUp = !(t3 || e3), a2.lgAndUp = !(t3 || e3 || l2), a2.xlAndUp = !(t3 || e3 || l2 || p2), a2.smAndDown = !(l2 || p2 || c2 || d2), a2.mdAndDown = !(p2 || c2 || d2), a2.lgAndDown = !(c2 || d2), a2.xlAndDown = !d2, a2.name = m2, a2.height = i2.value, a2.width = s2.value, a2.mobile = h2, a2.mobileBreakpoint = n2, a2.platform = o2.value, a2.thresholds = r2;
      }), { ...Zr.toRefs(a2), update: function() {
        i2.value = getClientHeight(), s2.value = getClientWidth(), o2.value = getPlatform();
      }, ssr: !!e2 };
    }
    const jc = propsFactory({ mobileBreakpoint: [Number, String] }, "display");
    function useDisplay() {
      let t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : getCurrentInstanceName();
      const r2 = Zr.inject(Bc);
      if (!r2)
        throw new Error("Could not find Vuetify display injection");
      const n2 = Zr.computed(() => {
        if (!t2.mobileBreakpoint)
          return r2.mobile.value;
        const e3 = "number" == typeof t2.mobileBreakpoint ? t2.mobileBreakpoint : r2.thresholds.value[t2.mobileBreakpoint];
        return r2.width.value < e3;
      }), i2 = Zr.computed(() => e2 ? { [`${e2}--mobile`]: n2.value } : {});
      return { ...r2, displayClasses: i2, mobile: n2 };
    }
    const Fc = Symbol.for("vuetify:theme"), $c = propsFactory({ theme: String }, "theme");
    function createTheme(t2) {
      const e2 = function() {
        var t3, e3;
        let r3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : { defaultTheme: "light", variations: { colors: [], lighten: 0, darken: 0 }, themes: { light: { dark: false, colors: { background: "#FFFFFF", surface: "#FFFFFF", "surface-bright": "#FFFFFF", "surface-variant": "#424242", "on-surface-variant": "#EEEEEE", primary: "#1867C0", "primary-darken-1": "#1F5592", secondary: "#48A9A6", "secondary-darken-1": "#018786", error: "#B00020", info: "#2196F3", success: "#4CAF50", warning: "#FB8C00" }, variables: { "border-color": "#000000", "border-opacity": 0.12, "high-emphasis-opacity": 0.87, "medium-emphasis-opacity": 0.6, "disabled-opacity": 0.38, "idle-opacity": 0.04, "hover-opacity": 0.04, "focus-opacity": 0.12, "selected-opacity": 0.08, "activated-opacity": 0.12, "pressed-opacity": 0.12, "dragged-opacity": 0.08, "theme-kbd": "#212529", "theme-on-kbd": "#FFFFFF", "theme-code": "#F5F5F5", "theme-on-code": "#000000" } }, dark: { dark: true, colors: { background: "#121212", surface: "#212121", "surface-bright": "#ccbfd6", "surface-variant": "#a3a3a3", "on-surface-variant": "#424242", primary: "#2196F3", "primary-darken-1": "#277CC1", secondary: "#54B6B2", "secondary-darken-1": "#48A9A6", error: "#CF6679", info: "#2196F3", success: "#4CAF50", warning: "#FB8C00" }, variables: { "border-color": "#FFFFFF", "border-opacity": 0.12, "high-emphasis-opacity": 1, "medium-emphasis-opacity": 0.7, "disabled-opacity": 0.5, "idle-opacity": 0.1, "hover-opacity": 0.04, "focus-opacity": 0.12, "selected-opacity": 0.08, "activated-opacity": 0.12, "pressed-opacity": 0.16, "dragged-opacity": 0.08, "theme-kbd": "#212529", "theme-on-kbd": "#FFFFFF", "theme-code": "#343434", "theme-on-code": "#CCCCCC" } } } };
        const n3 = { defaultTheme: "light", variations: { colors: [], lighten: 0, darken: 0 }, themes: { light: { dark: false, colors: { background: "#FFFFFF", surface: "#FFFFFF", "surface-bright": "#FFFFFF", "surface-variant": "#424242", "on-surface-variant": "#EEEEEE", primary: "#1867C0", "primary-darken-1": "#1F5592", secondary: "#48A9A6", "secondary-darken-1": "#018786", error: "#B00020", info: "#2196F3", success: "#4CAF50", warning: "#FB8C00" }, variables: { "border-color": "#000000", "border-opacity": 0.12, "high-emphasis-opacity": 0.87, "medium-emphasis-opacity": 0.6, "disabled-opacity": 0.38, "idle-opacity": 0.04, "hover-opacity": 0.04, "focus-opacity": 0.12, "selected-opacity": 0.08, "activated-opacity": 0.12, "pressed-opacity": 0.12, "dragged-opacity": 0.08, "theme-kbd": "#212529", "theme-on-kbd": "#FFFFFF", "theme-code": "#F5F5F5", "theme-on-code": "#000000" } }, dark: { dark: true, colors: { background: "#121212", surface: "#212121", "surface-bright": "#ccbfd6", "surface-variant": "#a3a3a3", "on-surface-variant": "#424242", primary: "#2196F3", "primary-darken-1": "#277CC1", secondary: "#54B6B2", "secondary-darken-1": "#48A9A6", error: "#CF6679", info: "#2196F3", success: "#4CAF50", warning: "#FB8C00" }, variables: { "border-color": "#FFFFFF", "border-opacity": 0.12, "high-emphasis-opacity": 1, "medium-emphasis-opacity": 0.7, "disabled-opacity": 0.5, "idle-opacity": 0.1, "hover-opacity": 0.04, "focus-opacity": 0.12, "selected-opacity": 0.08, "activated-opacity": 0.12, "pressed-opacity": 0.16, "dragged-opacity": 0.08, "theme-kbd": "#212529", "theme-on-kbd": "#FFFFFF", "theme-code": "#343434", "theme-on-code": "#CCCCCC" } } } };
        if (!r3)
          return { ...n3, isDisabled: true };
        const i3 = {};
        for (const [o3, a3] of Object.entries(r3.themes ?? {})) {
          const r4 = a3.dark || "dark" === o3 ? null == (t3 = n3.themes) ? void 0 : t3.dark : null == (e3 = n3.themes) ? void 0 : e3.light;
          i3[o3] = mergeDeep(r4, a3);
        }
        return mergeDeep(n3, { ...r3, themes: i3 });
      }(t2), r2 = Zr.ref(e2.defaultTheme), n2 = Zr.ref(e2.themes), i2 = Zr.computed(() => {
        const t3 = {};
        for (const [r3, i3] of Object.entries(n2.value)) {
          const n3 = t3[r3] = { ...i3, colors: { ...i3.colors } };
          if (e2.variations)
            for (const t4 of e2.variations.colors) {
              const r4 = n3.colors[t4];
              if (r4)
                for (const i4 of ["lighten", "darken"]) {
                  const o3 = "lighten" === i4 ? lighten : darken;
                  for (const a3 of createRange(e2.variations[i4], 1))
                    n3.colors[`${t4}-${i4}-${a3}`] = RGBtoHex(o3(parseColor(r4), a3));
                }
            }
          for (const t4 of Object.keys(n3.colors)) {
            if (/^on-[a-z]/.test(t4) || n3.colors[`on-${t4}`])
              continue;
            const e3 = `on-${t4}`, r4 = parseColor(n3.colors[t4]);
            n3.colors[e3] = getForeground(r4);
          }
        }
        return t3;
      }), o2 = Zr.computed(() => i2.value[r2.value]), a2 = Zr.computed(() => {
        const t3 = [];
        o2.value.dark && createCssClass(t3, ":root", ["color-scheme: dark"]), createCssClass(t3, ":root", genCssVariables(o2.value));
        for (const [e4, r4] of Object.entries(i2.value))
          createCssClass(t3, `.v-theme--${e4}`, ["color-scheme: " + (r4.dark ? "dark" : "normal"), ...genCssVariables(r4)]);
        const e3 = [], r3 = [], n3 = new Set(Object.values(i2.value).flatMap((t4) => Object.keys(t4.colors)));
        for (const t4 of n3)
          /^on-[a-z]/.test(t4) ? createCssClass(r3, `.${t4}`, [`color: rgb(var(--v-theme-${t4})) !important`]) : (createCssClass(e3, `.bg-${t4}`, [`--v-theme-overlay-multiplier: var(--v-theme-${t4}-overlay-multiplier)`, `background-color: rgb(var(--v-theme-${t4})) !important`, `color: rgb(var(--v-theme-on-${t4})) !important`]), createCssClass(r3, `.text-${t4}`, [`color: rgb(var(--v-theme-${t4})) !important`]), createCssClass(r3, `.border-${t4}`, [`--v-border-color: var(--v-theme-${t4})`]));
        return t3.push(...e3, ...r3), t3.map((t4, e4) => 0 === e4 ? t4 : `    ${t4}`).join("");
      });
      function getHead() {
        return { style: [{ children: a2.value, id: "vuetify-theme-stylesheet", nonce: e2.cspNonce || false }] };
      }
      const s2 = Zr.computed(() => e2.isDisabled ? void 0 : `v-theme--${r2.value}`);
      return { install: function(t3) {
        if (e2.isDisabled)
          return;
        const r3 = t3._context.provides.usehead;
        r3 && (r3.push ? r3.push(getHead) : r3.addHeadObjs(getHead()));
      }, isDisabled: e2.isDisabled, name: r2, themes: n2, current: o2, computedThemes: i2, themeClasses: s2, styles: a2, global: { name: r2, current: o2 } };
    }
    function provideTheme(t2) {
      getCurrentInstance("provideTheme");
      const e2 = Zr.inject(Fc, null);
      if (!e2)
        throw new Error("Could not find Vuetify theme injection");
      const r2 = Zr.computed(() => t2.theme ?? e2.name.value), n2 = Zr.computed(() => e2.themes.value[r2.value]), i2 = Zr.computed(() => e2.isDisabled ? void 0 : `v-theme--${r2.value}`), o2 = { ...e2, name: r2, current: n2, themeClasses: i2 };
      return Zr.provide(Fc, o2), o2;
    }
    function createCssClass(t2, e2, r2) {
      t2.push(`${e2} {
`, ...r2.map((t3) => `  ${t3};
`), "}\n");
    }
    function genCssVariables(t2) {
      const e2 = t2.dark ? 2 : 1, r2 = t2.dark ? 1 : 2, n2 = [];
      for (const [o2, a2] of Object.entries(t2.colors)) {
        const t3 = parseColor(a2);
        n2.push(`--v-theme-${o2}: ${t3.r},${t3.g},${t3.b}`), o2.startsWith("on-") || n2.push(`--v-theme-${o2}-overlay-multiplier: ${i2 = a2, toXYZ(parseColor(i2))[1] > 0.18 ? e2 : r2}`);
      }
      var i2;
      for (const [e3, r3] of Object.entries(t2.variables)) {
        const t3 = "string" == typeof r3 && r3.startsWith("#") ? parseColor(r3) : void 0, i3 = t3 ? `${t3.r}, ${t3.g}, ${t3.b}` : void 0;
        n2.push(`--v-${e3}: ${i3 ?? r3}`);
      }
      return n2;
    }
    function useResizeObserver(t2) {
      const e2 = Zr.ref(), r2 = Zr.ref();
      return { resizeRef: e2, contentRect: Zr.readonly(r2) };
    }
    const Vc = Symbol.for("vuetify:layout"), zc = Symbol.for("vuetify:layout-item"), Uc = propsFactory({ overlaps: { type: Array, default: () => [] }, fullHeight: Boolean }, "layout"), Hc = propsFactory({ name: { type: String }, order: { type: [Number, String], default: 0 }, absolute: Boolean }, "layout-item");
    function useLayout() {
      const t2 = Zr.inject(Vc);
      if (!t2)
        throw new Error("[Vuetify] Could not find injected layout");
      return { getLayoutItem: t2.getLayoutItem, mainRect: t2.mainRect, mainStyles: t2.mainStyles };
    }
    function useLayoutItem(t2) {
      const e2 = Zr.inject(Vc);
      if (!e2)
        throw new Error("[Vuetify] Could not find injected layout");
      const r2 = t2.id ?? `layout-item-${getUid()}`, n2 = getCurrentInstance("useLayoutItem");
      Zr.provide(zc, { id: r2 });
      const i2 = Zr.shallowRef(false), { layoutItemStyles: o2, layoutItemScrimStyles: a2 } = e2.register(n2, { ...t2, active: Zr.computed(() => !i2.value && t2.active.value), id: r2 });
      return { layoutItemStyles: o2, layoutRect: e2.layoutRect, layoutItemScrimStyles: a2 };
    }
    function createLayout(t2) {
      const e2 = Zr.inject(Vc, null), r2 = Zr.computed(() => e2 ? e2.rootZIndex.value - 100 : 1e3), n2 = Zr.ref([]), i2 = Zr.reactive(/* @__PURE__ */ new Map()), o2 = Zr.reactive(/* @__PURE__ */ new Map()), a2 = Zr.reactive(/* @__PURE__ */ new Map()), s2 = Zr.reactive(/* @__PURE__ */ new Map()), l2 = Zr.reactive(/* @__PURE__ */ new Map()), { resizeRef: p2, contentRect: c2 } = useResizeObserver(), d2 = Zr.computed(() => {
        const e3 = /* @__PURE__ */ new Map(), r3 = t2.overlaps ?? [];
        for (const t3 of r3.filter((t4) => t4.includes(":"))) {
          const [r4, a3] = t3.split(":");
          if (!n2.value.includes(r4) || !n2.value.includes(a3))
            continue;
          const s3 = i2.get(r4), l3 = i2.get(a3), p3 = o2.get(r4), c3 = o2.get(a3);
          s3 && l3 && p3 && c3 && (e3.set(a3, { position: s3.value, amount: parseInt(p3.value, 10) }), e3.set(r4, { position: l3.value, amount: -parseInt(c3.value, 10) }));
        }
        return e3;
      }), m2 = Zr.computed(() => {
        const t3 = [...new Set([...a2.values()].map((t4) => t4.value))].sort((t4, e4) => t4 - e4), e3 = [];
        for (const r3 of t3) {
          const t4 = n2.value.filter((t5) => {
            var e4;
            return (null == (e4 = a2.get(t5)) ? void 0 : e4.value) === r3;
          });
          e3.push(...t4);
        }
        return ((t4, e4, r3, n3) => {
          let i3 = { top: 0, left: 0, right: 0, bottom: 0 };
          const o3 = [{ id: "", layer: { ...i3 } }];
          for (const a3 of t4) {
            const t5 = e4.get(a3), s3 = r3.get(a3), l3 = n3.get(a3);
            if (!t5 || !s3 || !l3)
              continue;
            const p3 = { ...i3, [t5.value]: parseInt(i3[t5.value], 10) + (l3.value ? parseInt(s3.value, 10) : 0) };
            o3.push({ id: a3, layer: p3 }), i3 = p3;
          }
          return o3;
        })(e3, i2, o2, s2);
      }), u2 = Zr.computed(() => !Array.from(l2.values()).some((t3) => t3.value)), h2 = Zr.computed(() => m2.value[m2.value.length - 1].layer), g2 = Zr.computed(() => ({ "--v-layout-left": convertToUnit(h2.value.left), "--v-layout-right": convertToUnit(h2.value.right), "--v-layout-top": convertToUnit(h2.value.top), "--v-layout-bottom": convertToUnit(h2.value.bottom), ...u2.value ? void 0 : { transition: "none" } })), x2 = Zr.computed(() => m2.value.slice(1).map((t3, e3) => {
        let { id: r3 } = t3;
        const { layer: n3 } = m2.value[e3], a3 = o2.get(r3), s3 = i2.get(r3);
        return { id: r3, ...n3, size: Number(a3.value), position: s3.value };
      })), getLayoutItem = (t3) => x2.value.find((e3) => e3.id === t3), v2 = getCurrentInstance("createLayout"), y2 = Zr.shallowRef(false);
      Zr.provide(Vc, { register: (t3, e3) => {
        let { id: p3, order: c3, position: h3, layoutSize: g3, elementSize: b2, active: w2, disableTransitions: k2, absolute: S2 } = e3;
        a2.set(p3, c3), i2.set(p3, h3), o2.set(p3, g3), s2.set(p3, w2), k2 && l2.set(p3, k2);
        const C2 = findChildrenWithProvide(zc, null == v2 ? void 0 : v2.vnode).indexOf(t3);
        C2 > -1 ? n2.value.splice(C2, 0, p3) : n2.value.push(p3);
        const _2 = Zr.computed(() => x2.value.findIndex((t4) => t4.id === p3)), P2 = Zr.computed(() => r2.value + 2 * m2.value.length - 2 * _2.value), T2 = Zr.computed(() => {
          const t4 = "left" === h3.value || "right" === h3.value, e4 = "right" === h3.value, n3 = "bottom" === h3.value, i3 = { [h3.value]: 0, zIndex: P2.value, transform: `translate${t4 ? "X" : "Y"}(${(w2.value ? 0 : -110) * (e4 || n3 ? -1 : 1)}%)`, position: S2.value || 1e3 !== r2.value ? "absolute" : "fixed", ...u2.value ? void 0 : { transition: "none" } };
          if (!y2.value)
            return i3;
          const o3 = x2.value[_2.value];
          if (!o3)
            throw new Error(`[Vuetify] Could not find layout item "${p3}"`);
          const a3 = d2.value.get(p3);
          return a3 && (o3[a3.position] += a3.amount), { ...i3, height: t4 ? `calc(100% - ${o3.top}px - ${o3.bottom}px)` : b2.value ? `${b2.value}px` : void 0, left: e4 ? void 0 : `${o3.left}px`, right: e4 ? `${o3.right}px` : void 0, top: "bottom" !== h3.value ? `${o3.top}px` : void 0, bottom: "top" !== h3.value ? `${o3.bottom}px` : void 0, width: t4 ? b2.value ? `${b2.value}px` : void 0 : `calc(100% - ${o3.left}px - ${o3.right}px)` };
        });
        return { layoutItemStyles: T2, layoutItemScrimStyles: Zr.computed(() => ({ zIndex: P2.value - 1 })), zIndex: P2 };
      }, unregister: (t3) => {
        a2.delete(t3), i2.delete(t3), o2.delete(t3), s2.delete(t3), l2.delete(t3), n2.value = n2.value.filter((e3) => e3 !== t3);
      }, mainRect: h2, mainStyles: g2, getLayoutItem, items: x2, layoutRect: c2, rootZIndex: r2 });
      return { layoutClasses: Zr.computed(() => ["v-layout", { "v-layout--full-height": t2.fullHeight }]), layoutStyles: Zr.computed(() => ({ zIndex: e2 ? r2.value : void 0, position: e2 ? "relative" : void 0, overflow: e2 ? "hidden" : void 0 })), getLayoutItem, items: x2, layoutRect: c2, layoutRef: p2 };
    }
    function createVuetify() {
      let t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      const { blueprint: e2, ...r2 } = t2, n2 = mergeDeep(e2, r2), { aliases: i2 = {}, components: o2 = {}, directives: a2 = {} } = n2, s2 = function(t3) {
        return Zr.ref(t3);
      }(n2.defaults), l2 = createDisplay(n2.display, n2.ssr), p2 = createTheme(n2.theme), c2 = function(t3) {
        return mergeDeep({ defaultSet: "mdi", sets: { ...kc, mdi: Cc }, aliases: { ...Sc, vuetify: ["M8.2241 14.2009L12 21L22 3H14.4459L8.2241 14.2009Z", ["M7.26303 12.4733L7.00113 12L2 3H12.5261C12.5261 3 12.5261 3 12.5261 3L7.26303 12.4733Z", 0.6]], "vuetify-outline": "svg:M7.26 12.47 12.53 3H2L7.26 12.47ZM14.45 3 8.22 14.2 12 21 22 3H14.45ZM18.6 5 12 16.88 10.51 14.2 15.62 5ZM7.26 8.35 5.4 5H9.13L7.26 8.35Z" } }, t3);
      }(n2.icons), d2 = createLocale(n2.locale), m2 = function(t3, e3) {
        const r3 = mergeDeep({ adapter: VuetifyDateAdapter, locale: { af: "af-ZA", bg: "bg-BG", ca: "ca-ES", ckb: "", cs: "cs-CZ", de: "de-DE", el: "el-GR", en: "en-US", et: "et-EE", fa: "fa-IR", fi: "fi-FI", hr: "hr-HR", hu: "hu-HU", he: "he-IL", id: "id-ID", it: "it-IT", ja: "ja-JP", ko: "ko-KR", lv: "lv-LV", lt: "lt-LT", nl: "nl-NL", no: "no-NO", pl: "pl-PL", pt: "pt-PT", ro: "ro-RO", ru: "ru-RU", sk: "sk-SK", sl: "sl-SI", srCyrl: "sr-SP", srLatn: "sr-SP", sv: "sv-SE", th: "th-TH", tr: "tr-TR", az: "az-AZ", uk: "uk-UA", vi: "vi-VN", zhHans: "zh-CN", zhHant: "zh-TW" } }, t3);
        return { options: r3, instance: createInstance(r3, e3) };
      }(n2.date, d2);
      return { install: (t3) => {
        for (const e3 in a2)
          t3.directive(e3, a2[e3]);
        for (const e3 in o2)
          t3.component(e3, o2[e3]);
        for (const e3 in i2)
          t3.component(e3, defineComponent({ ...i2[e3], name: e3, aliasName: i2[e3].name }));
        p2.install(t3), t3.provide(uc, s2), t3.provide(Bc, l2), t3.provide(Fc, p2), t3.provide(xc, c2), t3.provide(Ic, d2), t3.provide(Lc, m2.options), t3.provide(Mc, m2.instance), getUid.reset(), t3.mixin({ computed: { $vuetify() {
          return Zr.reactive({ defaults: inject.call(this, uc), display: inject.call(this, Bc), theme: inject.call(this, Fc), icons: inject.call(this, xc), locale: inject.call(this, Ic), date: inject.call(this, Mc) });
        } } });
      }, defaults: s2, display: l2, theme: p2, icons: c2, locale: d2, date: m2 };
    }
    function inject(t2) {
      var e2, r2;
      const n2 = this.$, i2 = (null == (e2 = n2.parent) ? void 0 : e2.provides) ?? (null == (r2 = n2.vnode.appContext) ? void 0 : r2.provides);
      if (i2 && t2 in i2)
        return i2[t2];
    }
    createVuetify.version = "3.4.7";
    async function configureVuetify() {
      const t2 = useNuxtApp(), e2 = JSON.parse('{"theme":{"defaultTheme":"dark"},"ssr":true}');
      await t2.hooks.callHook("vuetify:configuration", { isDev: false, vuetifyOptions: e2 }), await t2.hooks.callHook("vuetify:before-create", { isDev: false, vuetifyOptions: e2 });
      const r2 = createVuetify(e2);
      t2.vueApp.use(r2), t2.provide("vuetify", r2), await t2.hooks.callHook("vuetify:ready", r2);
    }
    const qc = [bp, Lp, Bp, Dp, Ec, _c, defineNuxtPlugin({ name: "vuetify:configuration:plugin", enforce: "post", setup() {
      useNuxtApp().hook("app:created", configureVuetify);
    } })], Wc = Zr.defineComponent({ props: { vnode: { type: Object, required: true }, route: { type: Object, required: true }, vnodeRef: Object, renderKey: String, trackRootNodes: Boolean }, setup(t2) {
      const e2 = t2.renderKey, r2 = t2.route, n2 = {};
      for (const i2 in t2.route)
        Object.defineProperty(n2, i2, { get: () => e2 === t2.renderKey ? t2.route[i2] : r2[i2] });
      return Zr.provide(_p, Zr.shallowReactive(n2)), () => Zr.h(t2.vnode, { ref: t2.vnodeRef });
    } }), Kc = Zr.defineComponent({ name: "NuxtPage", inheritAttrs: false, props: { name: { type: String }, transition: { type: [Boolean, Object], default: void 0 }, keepalive: { type: [Boolean, Object], default: void 0 }, route: { type: Object }, pageKey: { type: [Function, String], default: null } }, setup(t2, { attrs: e2, expose: r2 }) {
      const n2 = useNuxtApp(), i2 = Zr.ref();
      let o2;
      Zr.inject(_p, null), r2({ pageRef: i2 }), Zr.inject(Ep, null);
      const a2 = n2.deferHydration();
      return () => Zr.h(hp, { name: t2.name, route: t2.route, ...e2 }, { default: (e3) => {
        if (!e3.Component)
          return void a2();
        const r3 = ((t3, e4) => {
          const r4 = t3.route.matched.find((e5) => {
            var r5;
            return (null == (r5 = e5.components) ? void 0 : r5.default) === t3.Component.type;
          }), n3 = e4 ?? (null == r4 ? void 0 : r4.meta.key) ?? (r4 && (i3 = t3.route, r4.path.replace(/(:\w+)\([^)]+\)/g, "$1").replace(/(:\w+)[?+*]/g, "$1").replace(/:\w+/g, (t4) => {
            var e5;
            return (null == (e5 = i3.params[t4.slice(1)]) ? void 0 : e5.toString()) || "";
          })));
          var i3;
          return "function" == typeof n3 ? n3(t3.route) : n3;
        })(e3, t2.pageKey), s2 = !!(t2.transition ?? e3.route.meta.pageTransition ?? Tp), l2 = s2 && function(t3) {
          const e4 = t3.map((t4) => ({ ...t4, onAfterLeave: _toArray(t4.onAfterLeave) }));
          return Q(...e4);
        }([t2.transition, e3.route.meta.pageTransition, Tp, { onAfterLeave: () => {
          n2.callHook("page:transition:finish", e3.Component);
        } }].filter(Boolean));
        t2.keepalive ?? e3.route.meta.keepalive;
        var p2;
        return o2 = ((t3, e4, r4) => (e4 = true === e4 ? {} : e4, { default: () => {
          var n3;
          return e4 ? Zr.h(t3, e4, r4) : null == (n3 = r4.default) ? void 0 : n3.call(r4);
        } }))(Zr.Transition, s2 && l2, (p2 = Zr.h(Zr.Suspense, { suspensible: true, onPending: () => n2.callHook("page:start", e3.Component), onResolve: () => {
          Zr.nextTick(() => n2.callHook("page:finish", e3.Component).finally(a2));
        } }, { default: () => Zr.h(Wc, { key: r3 || void 0, vnode: e3.Component, route: e3.route, renderKey: r3 || void 0, trackRootNodes: s2, vnodeRef: i2 }) }), { default: () => p2 })).default(), o2;
      } });
    } });
    function _toArray(t2) {
      return Array.isArray(t2) ? t2 : t2 ? [t2] : [];
    }
    const _export_sfc = (t2, e2) => {
      const r2 = t2.__vccOpts || t2;
      for (const [t3, n2] of e2)
        r2[t3] = n2;
      return r2;
    }, Gc = propsFactory({ ...mc(), ...Uc({ fullHeight: true }), ...$c() }, "VApp"), Jc = genericComponent()({ name: "VApp", props: Gc(), setup(t2, e2) {
      let { slots: r2 } = e2;
      const n2 = provideTheme(t2), { layoutClasses: i2, getLayoutItem: o2, items: a2, layoutRef: s2 } = createLayout(t2), { rtlClasses: l2 } = useRtl();
      return useRender(() => {
        var e3;
        return Zr.createVNode("div", { ref: s2, class: ["v-application", n2.themeClasses.value, i2.value, l2.value, t2.class], style: [t2.style] }, [Zr.createVNode("div", { class: "v-application__wrap" }, [null == (e3 = r2.default) ? void 0 : e3.call(r2)])]);
      }), { getLayoutItem: o2, items: a2, theme: n2 };
    } }), Yc = {};
    const Xc = Yc.setup;
    Yc.setup = (t2, e2) => {
      const r2 = Zr.useSSRContext();
      return (r2.modules || (r2.modules = /* @__PURE__ */ new Set())).add("app.vue"), Xc ? Xc(t2, e2) : void 0;
    };
    const Qc = _export_sfc(Yc, [["ssrRender", function(t2, e2, r2, n2) {
      const i2 = Kc;
      e2(Gs.ssrRenderComponent(Jc, n2, { default: Zr.withCtx((t3, e3, r3, n3) => {
        if (!e3)
          return [Zr.createVNode(i2)];
        e3(Gs.ssrRenderComponent(i2, null, null, r3, n3));
      }), _: 1 }, r2));
    }], ["__scopeId", "data-v-09fad6ab"]]), Zc = { __name: "nuxt-error-page", __ssrInlineRender: true, props: { error: Object }, setup(t2) {
      const e2 = t2.error;
      (e2.stack || "").split("\n").splice(1).map((t3) => ({ text: t3.replace("webpack:/", "").replace(".vue", ".js").trim(), internal: t3.includes("node_modules") && !t3.includes(".cache") || t3.includes("internal") || t3.includes("new Promise") })).map((t3) => `<span class="stack${t3.internal ? " internal" : ""}">${t3.text}</span>`).join("\n");
      const r2 = Number(e2.statusCode || 500), n2 = 404 === r2, i2 = e2.statusMessage ?? (n2 ? "Page Not Found" : "Internal Server Error"), o2 = e2.message || e2.toString(), a2 = Zr.defineAsyncComponent(() => Promise.resolve().then(function() {
        return mh;
      }).then((t3) => t3.default || t3)), s2 = Zr.defineAsyncComponent(() => Promise.resolve().then(function() {
        return gh;
      }).then((t3) => t3.default || t3)), l2 = n2 ? a2 : s2;
      return (t3, e3, n3, a3) => {
        e3(Gs.ssrRenderComponent(Zr.unref(l2), Zr.mergeProps({ statusCode: Zr.unref(r2), statusMessage: Zr.unref(i2), description: Zr.unref(o2), stack: Zr.unref(void 0) }, a3), null, n3));
      };
    } }, td = Zc.setup;
    Zc.setup = (t2, e2) => {
      const r2 = Zr.useSSRContext();
      return (r2.modules || (r2.modules = /* @__PURE__ */ new Set())).add("node_modules/nuxt/dist/app/components/nuxt-error-page.vue"), td ? td(t2, e2) : void 0;
    };
    const ed = Zc, rd = { __name: "nuxt-root", __ssrInlineRender: true, setup(t2) {
      const e2 = Zr.defineAsyncComponent(() => Promise.resolve().then(function() {
        return yh;
      }).then((t3) => t3.default || t3)), r2 = useNuxtApp();
      r2.deferHydration(), r2.ssrContext.url;
      Zr.provide(_p, Zr.hasInjectionContext() ? Zr.inject(_p, useNuxtApp()._route) : useNuxtApp()._route), r2.hooks.callHookWith((t3) => t3.map((t4) => t4()), "vue:setup");
      const n2 = useError();
      Zr.onErrorCaptured((t3, e3, n3) => {
        r2.hooks.callHook("vue:error", t3, e3, n3).catch((t4) => console.error("[nuxt] Error in `vue:error` hook", t4));
        {
          const e4 = r2.runWithContext(() => showError(t3));
          return Zr.onServerPrefetch(() => e4), false;
        }
      });
      const i2 = r2.ssrContext.islandContext;
      return (t3, r3, o2, a2) => {
        Gs.ssrRenderSuspense(r3, { default: () => {
          Zr.unref(n2) ? r3(Gs.ssrRenderComponent(Zr.unref(ed), { error: Zr.unref(n2) }, null, o2)) : Zr.unref(i2) ? r3(Gs.ssrRenderComponent(Zr.unref(e2), { context: Zr.unref(i2) }, null, o2)) : Zr.unref(false) ? Gs.ssrRenderVNode(r3, Zr.createVNode(Zr.resolveDynamicComponent(Zr.unref(false)), null, null), o2) : r3(Gs.ssrRenderComponent(Zr.unref(Qc), null, null, o2));
        }, _: 1 });
      };
    } }, nd = rd.setup;
    rd.setup = (t2, e2) => {
      const r2 = Zr.useSSRContext();
      return (r2.modules || (r2.modules = /* @__PURE__ */ new Set())).add("node_modules/nuxt/dist/app/components/nuxt-root.vue"), nd ? nd(t2, e2) : void 0;
    };
    const id = rd;
    let od;
    od = async function(t2) {
      const e2 = Zr.createApp(id), r2 = createNuxtApp({ vueApp: e2, ssrContext: t2 });
      try {
        await async function(t3, e3) {
          var r3, n2;
          const i2 = [], o2 = [];
          for (const a2 of e3) {
            if ((null == (r3 = t3.ssrContext) ? void 0 : r3.islandContext) && false === (null == (n2 = a2.env) ? void 0 : n2.islands))
              continue;
            const e4 = applyPlugin(t3, a2);
            a2.parallel ? i2.push(e4.catch((t4) => o2.push(t4))) : await e4;
          }
          if (await Promise.all(i2), o2.length)
            throw o2[0];
        }(r2, qc), await r2.hooks.callHook("app:created", e2);
      } catch (t3) {
        await r2.hooks.callHook("app:error", t3), r2.payload.error = r2.payload.error || t3;
      }
      if (null == t2 ? void 0 : t2._renderResponse)
        throw new Error("skipping render");
      return e2;
    };
    const ad = Object.freeze(Object.defineProperty({ __proto__: null, $: focusableChildren, A: deepEqual, B: wrapInArray, C: findChildrenWithProvide, D: consoleWarn, E: convertToUnit, F: useIcon, G: flattenFragments, H: useResizeObserver, I: gc, J: useRtl, K: hasEvent, L: isObject, M: Vp, N: defineComponent, O: EventProp, P: deprecate, Q: focusChild, R: getPropertyFromItem, S: Fp, T: omit, U: consoleError, V: clamp, W: refElement, X: jp, Y: matchesSelector, Z: useToggleScope, _: _export_sfc, a: useRuntimeConfig, a0: getNextElement, a1: useLocale, a2: pick, a3: filterInputAttrs, a4: callEvent, a5: useLayout, a6: jc, a7: Hc, a8: useDisplay, a9: useLayoutItem, b: navigateTo, c: createError, d: includes, default: (t2) => od(t2), e: isOn, f: eventName, g: genericComponent, h: getCurrentInstanceName, i: injectHead, j: destructComputed, k: isCssColor, l: isParsableColor, m: mc, n: Ap, o: parseColor, p: propsFactory, q: getForeground, r: resolveUnrefHeadInput, s: $c, t: provideTheme, u: useRouter$1, v: provideDefaults, w: useRender, x: getCurrentInstance, y: getUid, z: useProxiedModel }, Symbol.toStringTag, { value: "Module" })), interopDefault = (t2) => t2.default || t2 || [], sd = { "node_modules/nuxt/dist/app/entry.js": () => Promise.resolve().then(function() {
      return wh;
    }).then(interopDefault), "pages/index.vue": () => Promise.resolve().then(function() {
      return Sh;
    }).then(interopDefault), "node_modules/@nuxt/ui-templates/dist/templates/error-404.vue": () => Promise.resolve().then(function() {
      return _h;
    }).then(interopDefault), "node_modules/@nuxt/ui-templates/dist/templates/error-500.vue": () => Promise.resolve().then(function() {
      return Ah;
    }).then(interopDefault) }, ld = Object.freeze(Object.defineProperty({ __proto__: null, default: sd }, Symbol.toStringTag, { value: "Module" })), pd = Object.freeze(Object.defineProperty({ __proto__: null, template: "" }, Symbol.toStringTag, { value: "Module" })), cd = ["top", "bottom"], dd = ["start", "end", "left", "right"];
    function parseAnchor(t2, e2) {
      let [r2, n2] = t2.split(" ");
      return n2 || (n2 = includes(cd, r2) ? "start" : includes(dd, r2) ? "top" : "center"), { side: toPhysical(r2, e2), align: toPhysical(n2, e2) };
    }
    function toPhysical(t2, e2) {
      return "start" === t2 ? e2 ? "right" : "left" : "end" === t2 ? e2 ? "left" : "right" : t2;
    }
    function flipSide(t2) {
      return { side: { center: "center", top: "bottom", bottom: "top", left: "right", right: "left" }[t2.side], align: t2.align };
    }
    function flipAlign(t2) {
      return { side: t2.side, align: { center: "center", top: "bottom", bottom: "top", left: "right", right: "left" }[t2.align] };
    }
    function flipCorner(t2) {
      return { side: t2.align, align: t2.side };
    }
    function getAxis(t2) {
      return includes(cd, t2.side) ? "y" : "x";
    }
    class Box {
      constructor(t2) {
        let { x: e2, y: r2, width: n2, height: i2 } = t2;
        this.x = e2, this.y = r2, this.width = n2, this.height = i2;
      }
      get top() {
        return this.y;
      }
      get bottom() {
        return this.y + this.height;
      }
      get left() {
        return this.x;
      }
      get right() {
        return this.x + this.width;
      }
    }
    function getOverflow(t2, e2) {
      return { x: { before: Math.max(0, e2.left - t2.left), after: Math.max(0, t2.right - e2.right) }, y: { before: Math.max(0, e2.top - t2.top), after: Math.max(0, t2.bottom - e2.bottom) } };
    }
    function getTargetBox(t2) {
      return Array.isArray(t2) ? new Box({ x: t2[0], y: t2[1], width: 0, height: 0 }) : t2.getBoundingClientRect();
    }
    function nullifyTransforms(t2) {
      const e2 = t2.getBoundingClientRect(), r2 = getComputedStyle(t2), n2 = r2.transform;
      if (n2) {
        let i2, o2, a2, s2, l2;
        if (n2.startsWith("matrix3d("))
          i2 = n2.slice(9, -1).split(/, /), o2 = +i2[0], a2 = +i2[5], s2 = +i2[12], l2 = +i2[13];
        else {
          if (!n2.startsWith("matrix("))
            return new Box(e2);
          i2 = n2.slice(7, -1).split(/, /), o2 = +i2[0], a2 = +i2[3], s2 = +i2[4], l2 = +i2[5];
        }
        const p2 = r2.transformOrigin, c2 = e2.x - s2 - (1 - o2) * parseFloat(p2), d2 = e2.y - l2 - (1 - a2) * parseFloat(p2.slice(p2.indexOf(" ") + 1)), m2 = o2 ? e2.width / o2 : t2.offsetWidth + 1, u2 = a2 ? e2.height / a2 : t2.offsetHeight + 1;
        return new Box({ x: c2, y: d2, width: m2, height: u2 });
      }
      return new Box(e2);
    }
    function animate(t2, e2, r2) {
      if (void 0 === t2.animate)
        return { finished: Promise.resolve() };
      let n2;
      try {
        n2 = t2.animate(e2, r2);
      } catch (t3) {
        return { finished: Promise.resolve() };
      }
      return void 0 === n2.finished && (n2.finished = new Promise((t3) => {
        n2.onfinish = () => {
          t3(n2);
        };
      })), n2;
    }
    function createSimpleFunctional(t2) {
      let e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "div", r2 = arguments.length > 2 ? arguments[2] : void 0;
      return genericComponent()({ name: null != r2 ? r2 : Zr.capitalize(Zr.camelize(t2.replace(/__/g, "-"))), props: { tag: { type: String, default: e2 }, ...mc() }, setup(e3, r3) {
        let { slots: n2 } = r3;
        return () => {
          var r4;
          return Zr.h(e3.tag, { class: [t2, e3.class], style: e3.style }, null == (r4 = n2.default) ? void 0 : r4.call(n2));
        };
      } });
    }
    function attachedRoot(t2) {
      if ("function" != typeof t2.getRootNode) {
        for (; t2.parentNode; )
          t2 = t2.parentNode;
        return t2 !== document ? null : document;
      }
      const e2 = t2.getRootNode();
      return e2 !== document && e2.getRootNode({ composed: true }) !== document ? null : e2;
    }
    const md = "cubic-bezier(0.4, 0, 0.2, 1)";
    function getScrollParents(t2, e2) {
      const r2 = [];
      if (e2 && t2 && !e2.contains(t2))
        return r2;
      for (; t2 && (hasScrollbar(t2) && r2.push(t2), t2 !== e2); )
        t2 = t2.parentElement;
      return r2;
    }
    function hasScrollbar(t2) {
      if (!t2 || t2.nodeType !== Node.ELEMENT_NODE)
        return false;
      const e2 = window.getComputedStyle(t2);
      return "scroll" === e2.overflowY || "auto" === e2.overflowY && t2.scrollHeight > t2.clientHeight;
    }
    function isPotentiallyScrollable(t2) {
      if (!t2 || t2.nodeType !== Node.ELEMENT_NODE)
        return false;
      const e2 = window.getComputedStyle(t2);
      return ["scroll", "auto"].includes(e2.overflowY);
    }
    const ud = "teal-darken-4", hd = "blue-darken-4";
    function kind_to_color(t2) {
      switch (t2) {
        case "number":
          return "orange";
        case "string":
          return "green";
        default:
          return "red";
      }
    }
    const fd = Zr.defineComponent({ __name: "Connection", __ssrInlineRender: true, props: { from: {}, to: {}, page_scale: {}, kind: {} }, setup(t2) {
      let e2 = t2, r2 = Zr.ref(0), n2 = Zr.ref(0), i2 = Zr.ref(0), o2 = Zr.ref(0);
      let a2 = setInterval(function() {
        let t3 = 5 * e2.page_scale, a3 = e2.from.getBoundingClientRect();
        r2.value = a3.x + t3, n2.value = a3.y + t3;
        let s3 = e2.to.getBoundingClientRect();
        i2.value = s3.x + t3, o2.value = s3.y + t3;
      }, 10);
      Zr.onUnmounted(() => clearInterval(a2));
      let s2 = Zr.computed(() => kind_to_color(e2.kind));
      return (t3, e3, a3, l2) => {
        const p2 = { style: { "--490c7733": Zr.unref(s2), "--1dd4592b": Zr.unref(r2), "--1dd4594a": Zr.unref(n2), "--1dd4591d": Zr.unref(i2), "--1dd4593c": Zr.unref(o2) } };
        e3(`<!--[--><div${Gs.ssrRenderAttrs(Zr.mergeProps({ class: "line", id: "start" }, p2))} data-v-360ecffe></div><div${Gs.ssrRenderAttrs(Zr.mergeProps({ class: "line", id: "middle" }, p2))} data-v-360ecffe></div><div${Gs.ssrRenderAttrs(Zr.mergeProps({ class: "line", id: "end" }, p2))} data-v-360ecffe></div><!--]-->`);
      };
    } }), gd = fd.setup;
    fd.setup = (t2, e2) => {
      const r2 = Zr.useSSRContext();
      return (r2.modules || (r2.modules = /* @__PURE__ */ new Set())).add("components/Connection.vue"), gd ? gd(t2, e2) : void 0;
    };
    const xd = _export_sfc(fd, [["__scopeId", "data-v-360ecffe"]]), vd = propsFactory({ border: [Boolean, Number, String] }, "border");
    function useBorder(t2) {
      let e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : getCurrentInstanceName();
      return { borderClasses: Zr.computed(() => {
        const r2 = Zr.isRef(t2) ? t2.value : t2.border, n2 = [];
        if (true === r2 || "" === r2)
          n2.push(`${e2}--border`);
        else if ("string" == typeof r2 || 0 === r2)
          for (const t3 of String(r2).split(" "))
            n2.push(`border-${t3}`);
        return n2;
      }) };
    }
    const yd = [null, "default", "comfortable", "compact"], bd = propsFactory({ density: { type: String, default: "default", validator: (t2) => yd.includes(t2) } }, "density");
    function useDensity(t2) {
      let e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : getCurrentInstanceName();
      return { densityClasses: Zr.computed(() => `${e2}--density-${t2.density}`) };
    }
    const wd = propsFactory({ elevation: { type: [Number, String], validator(t2) {
      const e2 = parseInt(t2);
      return !isNaN(e2) && e2 >= 0 && e2 <= 24;
    } } }, "elevation");
    function useElevation(t2) {
      return { elevationClasses: Zr.computed(() => {
        const e2 = Zr.isRef(t2) ? t2.value : t2.elevation, r2 = [];
        return null == e2 || r2.push(`elevation-${e2}`), r2;
      }) };
    }
    const kd = propsFactory({ rounded: { type: [Boolean, Number, String], default: void 0 } }, "rounded");
    function useRounded(t2) {
      let e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : getCurrentInstanceName();
      return { roundedClasses: Zr.computed(() => {
        const r2 = Zr.isRef(t2) ? t2.value : t2.rounded, n2 = [];
        if (true === r2 || "" === r2)
          n2.push(`${e2}--rounded`);
        else if ("string" == typeof r2 || 0 === r2)
          for (const t3 of String(r2).split(" "))
            n2.push(`rounded-${t3}`);
        return n2;
      }) };
    }
    const Sd = propsFactory({ tag: { type: String, default: "div" } }, "tag");
    function useColor(t2) {
      return destructComputed(() => {
        const e2 = [], r2 = {};
        if (t2.value.background)
          if (isCssColor(t2.value.background)) {
            if (r2.backgroundColor = t2.value.background, !t2.value.text && isParsableColor(t2.value.background)) {
              const e3 = parseColor(t2.value.background);
              if (null == e3.a || 1 === e3.a) {
                const t3 = getForeground(e3);
                r2.color = t3, r2.caretColor = t3;
              }
            }
          } else
            e2.push(`bg-${t2.value.background}`);
        return t2.value.text && (isCssColor(t2.value.text) ? (r2.color = t2.value.text, r2.caretColor = t2.value.text) : e2.push(`text-${t2.value.text}`)), { colorClasses: e2, colorStyles: r2 };
      });
    }
    function useTextColor(t2, e2) {
      const r2 = Zr.computed(() => ({ text: Zr.isRef(t2) ? t2.value : e2 ? t2[e2] : null })), { colorClasses: n2, colorStyles: i2 } = useColor(r2);
      return { textColorClasses: n2, textColorStyles: i2 };
    }
    function useBackgroundColor(t2, e2) {
      const r2 = Zr.computed(() => ({ background: Zr.isRef(t2) ? t2.value : e2 ? t2[e2] : null })), { colorClasses: n2, colorStyles: i2 } = useColor(r2);
      return { backgroundColorClasses: n2, backgroundColorStyles: i2 };
    }
    const Cd = ["elevated", "flat", "tonal", "outlined", "text", "plain"];
    function genOverlays(t2, e2) {
      return Zr.createVNode(Zr.Fragment, null, [t2 && Zr.createVNode("span", { key: "overlay", class: `${e2}__overlay` }, null), Zr.createVNode("span", { key: "underlay", class: `${e2}__underlay` }, null)]);
    }
    const Ed = propsFactory({ color: String, variant: { type: String, default: "elevated", validator: (t2) => Cd.includes(t2) } }, "variant");
    function useVariant(t2) {
      let e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : getCurrentInstanceName();
      const r2 = Zr.computed(() => {
        const { variant: r3 } = Zr.unref(t2);
        return `${e2}--variant-${r3}`;
      }), { colorClasses: n2, colorStyles: i2 } = useColor(Zr.computed(() => {
        const { variant: e3, color: r3 } = Zr.unref(t2);
        return { [["elevated", "flat"].includes(e3) ? "background" : "text"]: r3 };
      }));
      return { colorClasses: n2, colorStyles: i2, variantClasses: r2 };
    }
    const _d = propsFactory({ divided: Boolean, ...vd(), ...mc(), ...bd(), ...wd(), ...kd(), ...Sd(), ...$c(), ...Ed() }, "VBtnGroup"), Pd = genericComponent()({ name: "VBtnGroup", props: _d(), setup(t2, e2) {
      let { slots: r2 } = e2;
      const { themeClasses: n2 } = provideTheme(t2), { densityClasses: i2 } = useDensity(t2), { borderClasses: o2 } = useBorder(t2), { elevationClasses: a2 } = useElevation(t2), { roundedClasses: s2 } = useRounded(t2);
      provideDefaults({ VBtn: { height: "auto", color: Zr.toRef(t2, "color"), density: Zr.toRef(t2, "density"), flat: true, variant: Zr.toRef(t2, "variant") } }), useRender(() => Zr.createVNode(t2.tag, { class: ["v-btn-group", { "v-btn-group--divided": t2.divided }, n2.value, o2.value, i2.value, a2.value, s2.value, t2.class], style: t2.style }, r2));
    } }), Td = propsFactory({ modelValue: { type: null, default: void 0 }, multiple: Boolean, mandatory: [Boolean, String], max: Number, selectedClass: String, disabled: Boolean }, "group"), Ad = propsFactory({ value: null, disabled: Boolean, selectedClass: String }, "group-item");
    function useGroup(t2, e2) {
      const r2 = Zr.reactive([]), n2 = useProxiedModel(t2, "modelValue", [], (t3) => null == t3 ? [] : getIds(r2, wrapInArray(t3)), (e3) => {
        const n3 = function(t3, e4) {
          const r3 = [];
          return e4.forEach((e5) => {
            const n4 = t3.findIndex((t4) => t4.id === e5);
            if (~n4) {
              const e6 = t3[n4];
              r3.push(null != e6.value ? e6.value : n4);
            }
          }), r3;
        }(r2, e3);
        return t2.multiple ? n3 : n3[0];
      }), i2 = getCurrentInstance("useGroup");
      function step(e3) {
        if (t2.multiple && consoleWarn('This method is not supported when using "multiple" prop'), n2.value.length) {
          const t3 = n2.value[0], i3 = r2.findIndex((e4) => e4.id === t3);
          let o3 = (i3 + e3) % r2.length, a2 = r2[o3];
          for (; a2.disabled && o3 !== i3; )
            o3 = (o3 + e3) % r2.length, a2 = r2[o3];
          if (a2.disabled)
            return;
          n2.value = [r2[o3].id];
        } else {
          const t3 = r2.find((t4) => !t4.disabled);
          t3 && (n2.value = [t3.id]);
        }
      }
      const o2 = { register: function(t3, n3) {
        const o3 = t3, a2 = findChildrenWithProvide(Symbol.for(`${e2.description}:id`), null == i2 ? void 0 : i2.vnode).indexOf(n3);
        a2 > -1 ? r2.splice(a2, 0, o3) : r2.push(o3);
      }, unregister: function(e3) {
        !function() {
          const e4 = r2.find((t3) => !t3.disabled);
          e4 && "force" === t2.mandatory && !n2.value.length && (n2.value = [e4.id]);
        }();
        const i3 = r2.findIndex((t3) => t3.id === e3);
        r2.splice(i3, 1);
      }, selected: n2, select: function(e3, i3) {
        const o3 = r2.find((t3) => t3.id === e3);
        if (!i3 || !(null == o3 ? void 0 : o3.disabled))
          if (t2.multiple) {
            const r3 = n2.value.slice(), o4 = r3.findIndex((t3) => t3 === e3), a2 = ~o4;
            if (i3 = null != i3 ? i3 : !a2, a2 && t2.mandatory && r3.length <= 1)
              return;
            if (!a2 && null != t2.max && r3.length + 1 > t2.max)
              return;
            o4 < 0 && i3 ? r3.push(e3) : o4 >= 0 && !i3 && r3.splice(o4, 1), n2.value = r3;
          } else {
            const r3 = n2.value.includes(e3);
            if (t2.mandatory && r3)
              return;
            n2.value = (null != i3 ? i3 : !r3) ? [e3] : [];
          }
      }, disabled: Zr.toRef(t2, "disabled"), prev: () => step(r2.length - 1), next: () => step(1), isSelected: (t3) => n2.value.includes(t3), selectedClass: Zr.computed(() => t2.selectedClass), items: Zr.computed(() => r2), getItemIndex: (t3) => function(t4, e3) {
        const r3 = getIds(t4, [e3]);
        return r3.length ? t4.findIndex((t5) => t5.id === r3[0]) : -1;
      }(r2, t3) };
      return Zr.provide(e2, o2), o2;
    }
    function getIds(t2, e2) {
      const r2 = [];
      return e2.forEach((e3) => {
        const n2 = t2.find((t3) => deepEqual(e3, t3.value)), i2 = t2[e3];
        null != (null == n2 ? void 0 : n2.value) ? r2.push(n2.id) : null != i2 && r2.push(i2.id);
      }), r2;
    }
    const Id = Symbol.for("vuetify:v-btn-toggle"), Nd = propsFactory({ ..._d(), ...Td() }, "VBtnToggle");
    genericComponent()({ name: "VBtnToggle", props: Nd(), emits: { "update:modelValue": (t2) => true }, setup(t2, e2) {
      let { slots: r2 } = e2;
      const { isSelected: n2, next: i2, prev: o2, select: a2, selected: s2 } = useGroup(t2, Id);
      return useRender(() => {
        const e3 = Pd.filterProps(t2);
        return Zr.createVNode(Pd, Zr.mergeProps({ class: ["v-btn-toggle", t2.class] }, e3, { style: t2.style }), { default: () => {
          var t3;
          return [null == (t3 = r2.default) ? void 0 : t3.call(r2, { isSelected: n2, next: i2, prev: o2, select: a2, selected: s2 })];
        } });
      }), { next: i2, prev: o2, select: a2 };
    } });
    const Rd = propsFactory({ defaults: Object, disabled: Boolean, reset: [Number, String], root: [Boolean, String], scoped: Boolean }, "VDefaultsProvider"), Od = genericComponent(false)({ name: "VDefaultsProvider", props: Rd(), setup(t2, e2) {
      let { slots: r2 } = e2;
      const { defaults: n2, disabled: i2, reset: o2, root: a2, scoped: s2 } = Zr.toRefs(t2);
      return provideDefaults(n2, { reset: o2, root: a2, scoped: s2, disabled: i2 }), () => {
        var t3;
        return null == (t3 = r2.default) ? void 0 : t3.call(r2);
      };
    } }), Ld = ["x-small", "small", "default", "large", "x-large"], Md = propsFactory({ size: { type: [String, Number], default: "default" } }, "size");
    function useSize(t2) {
      let e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : getCurrentInstanceName();
      return destructComputed(() => {
        let r2, n2;
        return includes(Ld, t2.size) ? r2 = `${e2}--size-${t2.size}` : t2.size && (n2 = { width: convertToUnit(t2.size), height: convertToUnit(t2.size) }), { sizeClasses: r2, sizeStyles: n2 };
      });
    }
    const Bd = propsFactory({ color: String, start: Boolean, end: Boolean, icon: gc, ...mc(), ...Md(), ...Sd({ tag: "i" }), ...$c() }, "VIcon"), Dd = genericComponent()({ name: "VIcon", props: Bd(), setup(t2, e2) {
      let { attrs: r2, slots: n2 } = e2;
      const i2 = Zr.ref(), { themeClasses: o2 } = provideTheme(t2), { iconData: a2 } = useIcon(Zr.computed(() => i2.value || t2.icon)), { sizeClasses: s2 } = useSize(t2), { textColorClasses: l2, textColorStyles: p2 } = useTextColor(Zr.toRef(t2, "color"));
      return useRender(() => {
        var e3, c2;
        const d2 = null == (e3 = n2.default) ? void 0 : e3.call(n2);
        return d2 && (i2.value = null == (c2 = flattenFragments(d2).filter((t3) => t3.type === Zr.Text && t3.children && "string" == typeof t3.children)[0]) ? void 0 : c2.children), Zr.createVNode(a2.value.component, { tag: t2.tag, icon: a2.value.icon, class: ["v-icon", "notranslate", o2.value, s2.value, l2.value, { "v-icon--clickable": !!r2.onClick, "v-icon--start": t2.start, "v-icon--end": t2.end }, t2.class], style: [s2.value ? void 0 : { fontSize: convertToUnit(t2.size), height: convertToUnit(t2.size), width: convertToUnit(t2.size) }, p2.value, t2.style], role: r2.onClick ? "button" : void 0, "aria-hidden": !r2.onClick }, { default: () => [d2] });
      }), {};
    } });
    function useIntersectionObserver(t2, e2) {
      const r2 = Zr.ref(), n2 = Zr.shallowRef(false);
      return { intersectionRef: r2, isIntersecting: n2 };
    }
    const jd = propsFactory({ bgColor: String, color: String, indeterminate: [Boolean, String], modelValue: { type: [Number, String], default: 0 }, rotate: { type: [Number, String], default: 0 }, width: { type: [Number, String], default: 4 }, ...mc(), ...Md(), ...Sd({ tag: "div" }), ...$c() }, "VProgressCircular"), Fd = genericComponent()({ name: "VProgressCircular", props: jd(), setup(t2, e2) {
      let { slots: r2 } = e2;
      const n2 = 2 * Math.PI * 20, i2 = Zr.ref(), { themeClasses: o2 } = provideTheme(t2), { sizeClasses: a2, sizeStyles: s2 } = useSize(t2), { textColorClasses: l2, textColorStyles: p2 } = useTextColor(Zr.toRef(t2, "color")), { textColorClasses: c2, textColorStyles: d2 } = useTextColor(Zr.toRef(t2, "bgColor")), { intersectionRef: m2, isIntersecting: u2 } = useIntersectionObserver(), { resizeRef: h2, contentRect: g2 } = useResizeObserver(), x2 = Zr.computed(() => Math.max(0, Math.min(100, parseFloat(t2.modelValue)))), v2 = Zr.computed(() => Number(t2.width)), y2 = Zr.computed(() => s2.value ? Number(t2.size) : g2.value ? g2.value.width : Math.max(v2.value, 32)), b2 = Zr.computed(() => 20 / (1 - v2.value / y2.value) * 2), w2 = Zr.computed(() => v2.value / y2.value * b2.value), k2 = Zr.computed(() => convertToUnit((100 - x2.value) / 100 * n2));
      return Zr.watchEffect(() => {
        m2.value = i2.value, h2.value = i2.value;
      }), useRender(() => Zr.createVNode(t2.tag, { ref: i2, class: ["v-progress-circular", { "v-progress-circular--indeterminate": !!t2.indeterminate, "v-progress-circular--visible": u2.value, "v-progress-circular--disable-shrink": "disable-shrink" === t2.indeterminate }, o2.value, a2.value, l2.value, t2.class], style: [s2.value, p2.value, t2.style], role: "progressbar", "aria-valuemin": "0", "aria-valuemax": "100", "aria-valuenow": t2.indeterminate ? void 0 : x2.value }, { default: () => [Zr.createVNode("svg", { style: { transform: `rotate(calc(-90deg + ${Number(t2.rotate)}deg))` }, xmlns: "http://www.w3.org/2000/svg", viewBox: `0 0 ${b2.value} ${b2.value}` }, [Zr.createVNode("circle", { class: ["v-progress-circular__underlay", c2.value], style: d2.value, fill: "transparent", cx: "50%", cy: "50%", r: 20, "stroke-width": w2.value, "stroke-dasharray": n2, "stroke-dashoffset": 0 }, null), Zr.createVNode("circle", { class: "v-progress-circular__overlay", fill: "transparent", cx: "50%", cy: "50%", r: 20, "stroke-width": w2.value, "stroke-dasharray": n2, "stroke-dashoffset": k2.value }, null)]), r2.default && Zr.createVNode("div", { class: "v-progress-circular__content" }, [r2.default({ value: x2.value })])] })), {};
    } }), $d = propsFactory({ height: [Number, String], maxHeight: [Number, String], maxWidth: [Number, String], minHeight: [Number, String], minWidth: [Number, String], width: [Number, String] }, "dimension");
    function useDimension(t2) {
      return { dimensionStyles: Zr.computed(() => ({ height: convertToUnit(t2.height), maxHeight: convertToUnit(t2.maxHeight), maxWidth: convertToUnit(t2.maxWidth), minHeight: convertToUnit(t2.minHeight), minWidth: convertToUnit(t2.minWidth), width: convertToUnit(t2.width) })) };
    }
    const Vd = { center: "center", top: "bottom", bottom: "top", left: "right", right: "left" }, zd = propsFactory({ location: String }, "location");
    function useLocation(t2) {
      let e2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], r2 = arguments.length > 2 ? arguments[2] : void 0;
      const { isRtl: n2 } = useRtl(), i2 = Zr.computed(() => {
        if (!t2.location)
          return {};
        const { side: i3, align: o2 } = parseAnchor(t2.location.split(" ").length > 1 ? t2.location : `${t2.location} center`, n2.value);
        function getOffset2(t3) {
          return r2 ? r2(t3) : 0;
        }
        const a2 = {};
        return "center" !== i3 && (e2 ? a2[Vd[i3]] = `calc(100% - ${getOffset2(i3)}px)` : a2[i3] = 0), "center" !== o2 ? e2 ? a2[Vd[o2]] = `calc(100% - ${getOffset2(o2)}px)` : a2[o2] = 0 : ("center" === i3 ? a2.top = a2.left = "50%" : a2[{ top: "left", bottom: "left", left: "top", right: "top" }[i3]] = "50%", a2.transform = { top: "translateX(-50%)", bottom: "translateX(-50%)", left: "translateY(-50%)", right: "translateY(-50%)", center: "translate(-50%, -50%)" }[i3]), a2;
      });
      return { locationStyles: i2 };
    }
    const Ud = propsFactory({ absolute: Boolean, active: { type: Boolean, default: true }, bgColor: String, bgOpacity: [Number, String], bufferValue: { type: [Number, String], default: 0 }, clickable: Boolean, color: String, height: { type: [Number, String], default: 4 }, indeterminate: Boolean, max: { type: [Number, String], default: 100 }, modelValue: { type: [Number, String], default: 0 }, reverse: Boolean, stream: Boolean, striped: Boolean, roundedBar: Boolean, ...mc(), ...zd({ location: "top" }), ...kd(), ...Sd(), ...$c() }, "VProgressLinear"), Hd = genericComponent()({ name: "VProgressLinear", props: Ud(), emits: { "update:modelValue": (t2) => true }, setup(t2, e2) {
      let { slots: r2 } = e2;
      const n2 = useProxiedModel(t2, "modelValue"), { isRtl: i2, rtlClasses: o2 } = useRtl(), { themeClasses: a2 } = provideTheme(t2), { locationStyles: s2 } = useLocation(t2), { textColorClasses: l2, textColorStyles: p2 } = useTextColor(t2, "color"), { backgroundColorClasses: c2, backgroundColorStyles: d2 } = useBackgroundColor(Zr.computed(() => t2.bgColor || t2.color)), { backgroundColorClasses: m2, backgroundColorStyles: u2 } = useBackgroundColor(t2, "color"), { roundedClasses: h2 } = useRounded(t2), { intersectionRef: g2, isIntersecting: x2 } = useIntersectionObserver(), v2 = Zr.computed(() => parseInt(t2.max, 10)), y2 = Zr.computed(() => parseInt(t2.height, 10)), b2 = Zr.computed(() => parseFloat(t2.bufferValue) / v2.value * 100), w2 = Zr.computed(() => parseFloat(n2.value) / v2.value * 100), k2 = Zr.computed(() => i2.value !== t2.reverse), S2 = Zr.computed(() => t2.indeterminate ? "fade-transition" : "slide-x-transition"), C2 = Zr.computed(() => null == t2.bgOpacity ? t2.bgOpacity : parseFloat(t2.bgOpacity));
      function handleClick(t3) {
        if (!g2.value)
          return;
        const { left: e3, right: r3, width: i3 } = g2.value.getBoundingClientRect(), o3 = k2.value ? i3 - t3.clientX + (r3 - i3) : t3.clientX - e3;
        n2.value = Math.round(o3 / i3 * v2.value);
      }
      return useRender(() => Zr.createVNode(t2.tag, { ref: g2, class: ["v-progress-linear", { "v-progress-linear--absolute": t2.absolute, "v-progress-linear--active": t2.active && x2.value, "v-progress-linear--reverse": k2.value, "v-progress-linear--rounded": t2.rounded, "v-progress-linear--rounded-bar": t2.roundedBar, "v-progress-linear--striped": t2.striped }, h2.value, a2.value, o2.value, t2.class], style: [{ bottom: "bottom" === t2.location ? 0 : void 0, top: "top" === t2.location ? 0 : void 0, height: t2.active ? convertToUnit(y2.value) : 0, "--v-progress-linear-height": convertToUnit(y2.value), ...s2.value }, t2.style], role: "progressbar", "aria-hidden": t2.active ? "false" : "true", "aria-valuemin": "0", "aria-valuemax": t2.max, "aria-valuenow": t2.indeterminate ? void 0 : w2.value, onClick: t2.clickable && handleClick }, { default: () => [t2.stream && Zr.createVNode("div", { key: "stream", class: ["v-progress-linear__stream", l2.value], style: { ...p2.value, [k2.value ? "left" : "right"]: convertToUnit(-y2.value), borderTop: `${convertToUnit(y2.value / 2)} dotted`, opacity: C2.value, top: `calc(50% - ${convertToUnit(y2.value / 4)})`, width: convertToUnit(100 - b2.value, "%"), "--v-progress-linear-stream-to": convertToUnit(y2.value * (k2.value ? 1 : -1)) } }, null), Zr.createVNode("div", { class: ["v-progress-linear__background", c2.value], style: [d2.value, { opacity: C2.value, width: convertToUnit(t2.stream ? b2.value : 100, "%") }] }, null), Zr.createVNode(Zr.Transition, { name: S2.value }, { default: () => [t2.indeterminate ? Zr.createVNode("div", { class: "v-progress-linear__indeterminate" }, [["long", "short"].map((t3) => Zr.createVNode("div", { key: t3, class: ["v-progress-linear__indeterminate", t3, m2.value], style: u2.value }, null))]) : Zr.createVNode("div", { class: ["v-progress-linear__determinate", m2.value], style: [u2.value, { width: convertToUnit(w2.value, "%") }] }, null)] }), r2.default && Zr.createVNode("div", { class: "v-progress-linear__content" }, [r2.default({ value: w2.value, buffer: b2.value })])] })), {};
    } }), qd = propsFactory({ loading: [Boolean, String] }, "loader");
    function useLoader(t2) {
      let e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : getCurrentInstanceName();
      return { loaderClasses: Zr.computed(() => ({ [`${e2}--loading`]: t2.loading })) };
    }
    function LoaderSlot(t2, e2) {
      var r2;
      let { slots: n2 } = e2;
      return Zr.createVNode("div", { class: `${t2.name}__loader` }, [(null == (r2 = n2.default) ? void 0 : r2.call(n2, { color: t2.color, isActive: t2.active })) || Zr.createVNode(Hd, { absolute: t2.absolute, active: t2.active, color: t2.color, height: "2", indeterminate: true }, null)]);
    }
    const Wd = ["static", "relative", "fixed", "absolute", "sticky"], Kd = propsFactory({ position: { type: String, validator: (t2) => Wd.includes(t2) } }, "position");
    function usePosition(t2) {
      let e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : getCurrentInstanceName();
      return { positionClasses: Zr.computed(() => t2.position ? `${e2}--${t2.position}` : void 0) };
    }
    function useRouter() {
      var t2, e2;
      return null == (e2 = null == (t2 = getCurrentInstance("useRouter")) ? void 0 : t2.proxy) ? void 0 : e2.$router;
    }
    function useLink(t2, e2) {
      const r2 = Zr.resolveDynamicComponent("RouterLink"), n2 = Zr.computed(() => !(!t2.href && !t2.to)), i2 = Zr.computed(() => (null == n2 ? void 0 : n2.value) || hasEvent(e2, "click") || hasEvent(t2, "click"));
      if ("string" == typeof r2)
        return { isLink: n2, isClickable: i2, href: Zr.toRef(t2, "href") };
      const o2 = t2.to ? r2.useLink(t2) : void 0, a2 = function() {
        const t3 = getCurrentInstance("useRoute");
        return Zr.computed(() => {
          var e3;
          return null == (e3 = null == t3 ? void 0 : t3.proxy) ? void 0 : e3.$route;
        });
      }();
      return { isLink: n2, isClickable: i2, route: null == o2 ? void 0 : o2.route, navigate: null == o2 ? void 0 : o2.navigate, isActive: o2 && Zr.computed(() => {
        var e3, r3, n3;
        return t2.exact ? a2.value ? (null == (n3 = o2.isExactActive) ? void 0 : n3.value) && deepEqual(o2.route.value.query, a2.value.query) : null == (r3 = o2.isExactActive) ? void 0 : r3.value : null == (e3 = o2.isActive) ? void 0 : e3.value;
      }), href: Zr.computed(() => t2.to ? null == o2 ? void 0 : o2.route.value.href : t2.href) };
    }
    const Gd = propsFactory({ href: String, replace: Boolean, to: [String, Object], exact: Boolean }, "router");
    const Jd = Symbol("rippleStop"), Yd = 80;
    function transform(t2, e2) {
      t2.style.transform = e2, t2.style.webkitTransform = e2;
    }
    function isTouchEvent(t2) {
      return "TouchEvent" === t2.constructor.name;
    }
    function isKeyboardEvent(t2) {
      return "KeyboardEvent" === t2.constructor.name;
    }
    const Xd = { show(t2, e2) {
      var r2;
      let n2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
      if (!(null == (r2 = null == e2 ? void 0 : e2._ripple) ? void 0 : r2.enabled))
        return;
      const i2 = document.createElement("span"), o2 = document.createElement("span");
      i2.appendChild(o2), i2.className = "v-ripple__container", n2.class && (i2.className += ` ${n2.class}`);
      const { radius: a2, scale: s2, x: l2, y: p2, centerX: c2, centerY: d2 } = function(t3, e3) {
        var r3;
        let n3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, i3 = 0, o3 = 0;
        if (!isKeyboardEvent(t3)) {
          const r4 = e3.getBoundingClientRect(), n4 = isTouchEvent(t3) ? t3.touches[t3.touches.length - 1] : t3;
          i3 = n4.clientX - r4.left, o3 = n4.clientY - r4.top;
        }
        let a3 = 0, s3 = 0.3;
        (null == (r3 = e3._ripple) ? void 0 : r3.circle) ? (s3 = 0.15, a3 = e3.clientWidth / 2, a3 = n3.center ? a3 : a3 + Math.sqrt((i3 - a3) ** 2 + (o3 - a3) ** 2) / 4) : a3 = Math.sqrt(e3.clientWidth ** 2 + e3.clientHeight ** 2) / 2;
        const l3 = (e3.clientWidth - 2 * a3) / 2 + "px", p3 = (e3.clientHeight - 2 * a3) / 2 + "px";
        return { radius: a3, scale: s3, x: n3.center ? l3 : i3 - a3 + "px", y: n3.center ? p3 : o3 - a3 + "px", centerX: l3, centerY: p3 };
      }(t2, e2, n2), m2 = 2 * a2 + "px";
      o2.className = "v-ripple__animation", o2.style.width = m2, o2.style.height = m2, e2.appendChild(i2);
      const u2 = window.getComputedStyle(e2);
      u2 && "static" === u2.position && (e2.style.position = "relative", e2.dataset.previousPosition = "static"), o2.classList.add("v-ripple__animation--enter"), o2.classList.add("v-ripple__animation--visible"), transform(o2, `translate(${l2}, ${p2}) scale3d(${s2},${s2},${s2})`), o2.dataset.activated = String(performance.now()), setTimeout(() => {
        o2.classList.remove("v-ripple__animation--enter"), o2.classList.add("v-ripple__animation--in"), transform(o2, `translate(${c2}, ${d2}) scale3d(1,1,1)`);
      }, 0);
    }, hide(t2) {
      var e2;
      if (!(null == (e2 = null == t2 ? void 0 : t2._ripple) ? void 0 : e2.enabled))
        return;
      const r2 = t2.getElementsByClassName("v-ripple__animation");
      if (0 === r2.length)
        return;
      const n2 = r2[r2.length - 1];
      if (n2.dataset.isHiding)
        return;
      n2.dataset.isHiding = "true";
      const i2 = performance.now() - Number(n2.dataset.activated), o2 = Math.max(250 - i2, 0);
      setTimeout(() => {
        n2.classList.remove("v-ripple__animation--in"), n2.classList.add("v-ripple__animation--out"), setTimeout(() => {
          var e3;
          1 === t2.getElementsByClassName("v-ripple__animation").length && t2.dataset.previousPosition && (t2.style.position = t2.dataset.previousPosition, delete t2.dataset.previousPosition), (null == (e3 = n2.parentNode) ? void 0 : e3.parentNode) === t2 && t2.removeChild(n2.parentNode);
        }, 300);
      }, o2);
    } };
    function isRippleEnabled(t2) {
      return void 0 === t2 || !!t2;
    }
    function rippleShow(t2) {
      const e2 = {}, r2 = t2.currentTarget;
      if ((null == r2 ? void 0 : r2._ripple) && !r2._ripple.touched && !t2[Jd]) {
        if (t2[Jd] = true, isTouchEvent(t2))
          r2._ripple.touched = true, r2._ripple.isTouch = true;
        else if (r2._ripple.isTouch)
          return;
        if (e2.center = r2._ripple.centered || isKeyboardEvent(t2), r2._ripple.class && (e2.class = r2._ripple.class), isTouchEvent(t2)) {
          if (r2._ripple.showTimerCommit)
            return;
          r2._ripple.showTimerCommit = () => {
            Xd.show(t2, r2, e2);
          }, r2._ripple.showTimer = window.setTimeout(() => {
            var t3;
            (null == (t3 = null == r2 ? void 0 : r2._ripple) ? void 0 : t3.showTimerCommit) && (r2._ripple.showTimerCommit(), r2._ripple.showTimerCommit = null);
          }, Yd);
        } else
          Xd.show(t2, r2, e2);
      }
    }
    function rippleStop(t2) {
      t2[Jd] = true;
    }
    function rippleHide(t2) {
      const e2 = t2.currentTarget;
      if (null == e2 ? void 0 : e2._ripple) {
        if (window.clearTimeout(e2._ripple.showTimer), "touchend" === t2.type && e2._ripple.showTimerCommit)
          return e2._ripple.showTimerCommit(), e2._ripple.showTimerCommit = null, void (e2._ripple.showTimer = window.setTimeout(() => {
            rippleHide(t2);
          }));
        window.setTimeout(() => {
          e2._ripple && (e2._ripple.touched = false);
        }), Xd.hide(e2);
      }
    }
    function rippleCancelShow(t2) {
      const e2 = t2.currentTarget;
      (null == e2 ? void 0 : e2._ripple) && (e2._ripple.showTimerCommit && (e2._ripple.showTimerCommit = null), window.clearTimeout(e2._ripple.showTimer));
    }
    let Qd = false;
    function keyboardRippleShow(t2) {
      Qd || t2.keyCode !== Vp.enter && t2.keyCode !== Vp.space || (Qd = true, rippleShow(t2));
    }
    function keyboardRippleHide(t2) {
      Qd = false, rippleHide(t2);
    }
    function focusRippleHide(t2) {
      Qd && (Qd = false, rippleHide(t2));
    }
    function updateRipple(t2, e2, r2) {
      var n2;
      const { value: i2, modifiers: o2 } = e2, a2 = isRippleEnabled(i2);
      if (a2 || Xd.hide(t2), t2._ripple = null != (n2 = t2._ripple) ? n2 : {}, t2._ripple.enabled = a2, t2._ripple.centered = o2.center, t2._ripple.circle = o2.circle, isObject(i2) && i2.class && (t2._ripple.class = i2.class), a2 && !r2) {
        if (o2.stop)
          return t2.addEventListener("touchstart", rippleStop, { passive: true }), void t2.addEventListener("mousedown", rippleStop);
        t2.addEventListener("touchstart", rippleShow, { passive: true }), t2.addEventListener("touchend", rippleHide, { passive: true }), t2.addEventListener("touchmove", rippleCancelShow, { passive: true }), t2.addEventListener("touchcancel", rippleHide), t2.addEventListener("mousedown", rippleShow), t2.addEventListener("mouseup", rippleHide), t2.addEventListener("mouseleave", rippleHide), t2.addEventListener("keydown", keyboardRippleShow), t2.addEventListener("keyup", keyboardRippleHide), t2.addEventListener("blur", focusRippleHide), t2.addEventListener("dragstart", rippleHide, { passive: true });
      } else
        !a2 && r2 && removeListeners(t2);
    }
    function removeListeners(t2) {
      t2.removeEventListener("mousedown", rippleShow), t2.removeEventListener("touchstart", rippleShow), t2.removeEventListener("touchend", rippleHide), t2.removeEventListener("touchmove", rippleCancelShow), t2.removeEventListener("touchcancel", rippleHide), t2.removeEventListener("mouseup", rippleHide), t2.removeEventListener("mouseleave", rippleHide), t2.removeEventListener("keydown", keyboardRippleShow), t2.removeEventListener("keyup", keyboardRippleHide), t2.removeEventListener("dragstart", rippleHide), t2.removeEventListener("blur", focusRippleHide);
    }
    const Zd = { mounted: function(t2, e2) {
      updateRipple(t2, e2, false);
    }, unmounted: function(t2) {
      delete t2._ripple, removeListeners(t2);
    }, updated: function(t2, e2) {
      if (e2.value === e2.oldValue)
        return;
      updateRipple(t2, e2, isRippleEnabled(e2.oldValue));
    } }, tm = propsFactory({ active: { type: Boolean, default: void 0 }, symbol: { type: null, default: Id }, flat: Boolean, icon: [Boolean, String, Function, Object], prependIcon: gc, appendIcon: gc, block: Boolean, slim: Boolean, stacked: Boolean, ripple: { type: [Boolean, Object], default: true }, text: String, ...vd(), ...mc(), ...bd(), ...$d(), ...wd(), ...Ad(), ...qd(), ...zd(), ...Kd(), ...kd(), ...Gd(), ...Md(), ...Sd({ tag: "button" }), ...$c(), ...Ed({ variant: "elevated" }) }, "VBtn"), em = genericComponent()({ name: "VBtn", directives: { Ripple: Zd }, props: tm(), emits: { "group:selected": (t2) => true }, setup(t2, e2) {
      let { attrs: r2, slots: n2 } = e2;
      const { themeClasses: i2 } = provideTheme(t2), { borderClasses: o2 } = useBorder(t2), { colorClasses: a2, colorStyles: s2, variantClasses: l2 } = useVariant(t2), { densityClasses: p2 } = useDensity(t2), { dimensionStyles: c2 } = useDimension(t2), { elevationClasses: d2 } = useElevation(t2), { loaderClasses: m2 } = useLoader(t2), { locationStyles: u2 } = useLocation(t2), { positionClasses: h2 } = usePosition(t2), { roundedClasses: g2 } = useRounded(t2), { sizeClasses: x2, sizeStyles: v2 } = useSize(t2), y2 = function(t3, e3) {
        let r3 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
        const n3 = getCurrentInstance("useGroupItem");
        if (!n3)
          throw new Error("[Vuetify] useGroupItem composable must be used inside a component setup function");
        const i3 = getUid();
        Zr.provide(Symbol.for(`${e3.description}:id`), i3);
        const o3 = Zr.inject(e3, null);
        if (!o3) {
          if (!r3)
            return o3;
          throw new Error(`[Vuetify] Could not find useGroup injection with symbol ${e3.description}`);
        }
        const a3 = Zr.toRef(t3, "value"), s3 = Zr.computed(() => !(!o3.disabled.value && !t3.disabled));
        o3.register({ id: i3, value: a3, disabled: s3 }, n3);
        const l3 = Zr.computed(() => o3.isSelected(i3)), p3 = Zr.computed(() => l3.value && [o3.selectedClass.value, t3.selectedClass]);
        return Zr.watch(l3, (t4) => {
          n3.emit("group:selected", { value: t4 });
        }), { id: i3, isSelected: l3, toggle: () => o3.select(i3, !l3.value), select: (t4) => o3.select(i3, t4), selectedClass: p3, value: a3, disabled: s3, group: o3 };
      }(t2, t2.symbol, false), b2 = useLink(t2, r2), w2 = Zr.computed(() => {
        var e3;
        return void 0 !== t2.active ? t2.active : b2.isLink.value ? null == (e3 = b2.isActive) ? void 0 : e3.value : null == y2 ? void 0 : y2.isSelected.value;
      }), k2 = Zr.computed(() => (null == y2 ? void 0 : y2.disabled.value) || t2.disabled), S2 = Zr.computed(() => "elevated" === t2.variant && !(t2.disabled || t2.flat || t2.border)), C2 = Zr.computed(() => {
        if (void 0 !== t2.value && "symbol" != typeof t2.value)
          return Object(t2.value) === t2.value ? JSON.stringify(t2.value, null, 0) : t2.value;
      });
      function onClick(t3) {
        var e3;
        k2.value || b2.isLink.value && (t3.metaKey || t3.ctrlKey || t3.shiftKey || 0 !== t3.button || "_blank" === r2.target) || (null == (e3 = b2.navigate) || e3.call(b2, t3), null == y2 || y2.toggle());
      }
      return function(t3, e3) {
        Zr.watch(() => {
          var e4;
          return null == (e4 = t3.isActive) ? void 0 : e4.value;
        }, (r3) => {
          t3.isLink.value && r3 && e3 && Zr.nextTick(() => {
            e3(true);
          });
        }, { immediate: true });
      }(b2, null == y2 ? void 0 : y2.select), useRender(() => {
        var e3, r3;
        const _2 = b2.isLink.value ? "a" : t2.tag, P2 = !(!t2.prependIcon && !n2.prepend), T2 = !(!t2.appendIcon && !n2.append), A2 = !(!t2.icon || true === t2.icon), I2 = (null == y2 ? void 0 : y2.isSelected.value) && (!b2.isLink.value || (null == (e3 = b2.isActive) ? void 0 : e3.value)) || !y2 || (null == (r3 = b2.isActive) ? void 0 : r3.value);
        return Zr.withDirectives(Zr.createVNode(_2, { type: "a" === _2 ? void 0 : "button", class: ["v-btn", null == y2 ? void 0 : y2.selectedClass.value, { "v-btn--active": w2.value, "v-btn--block": t2.block, "v-btn--disabled": k2.value, "v-btn--elevated": S2.value, "v-btn--flat": t2.flat, "v-btn--icon": !!t2.icon, "v-btn--loading": t2.loading, "v-btn--slim": t2.slim, "v-btn--stacked": t2.stacked }, i2.value, o2.value, I2 ? a2.value : void 0, p2.value, d2.value, m2.value, h2.value, g2.value, x2.value, l2.value, t2.class], style: [I2 ? s2.value : void 0, c2.value, u2.value, v2.value, t2.style], disabled: k2.value || void 0, href: b2.href.value, onClick, value: C2.value }, { default: () => {
          var e4, r4;
          return [genOverlays(true, "v-btn"), !t2.icon && P2 && Zr.createVNode("span", { key: "prepend", class: "v-btn__prepend" }, [n2.prepend ? Zr.createVNode(Od, { key: "prepend-defaults", disabled: !t2.prependIcon, defaults: { VIcon: { icon: t2.prependIcon } } }, n2.prepend) : Zr.createVNode(Dd, { key: "prepend-icon", icon: t2.prependIcon }, null)]), Zr.createVNode("span", { class: "v-btn__content", "data-no-activator": "" }, [!n2.default && A2 ? Zr.createVNode(Dd, { key: "content-icon", icon: t2.icon }, null) : Zr.createVNode(Od, { key: "content-defaults", disabled: !A2, defaults: { VIcon: { icon: t2.icon } } }, { default: () => {
            var e5, r5;
            return [null != (e5 = null == (r5 = n2.default) ? void 0 : r5.call(n2)) ? e5 : t2.text];
          } })]), !t2.icon && T2 && Zr.createVNode("span", { key: "append", class: "v-btn__append" }, [n2.append ? Zr.createVNode(Od, { key: "append-defaults", disabled: !t2.appendIcon, defaults: { VIcon: { icon: t2.appendIcon } } }, n2.append) : Zr.createVNode(Dd, { key: "append-icon", icon: t2.appendIcon }, null)]), !!t2.loading && Zr.createVNode("span", { key: "loader", class: "v-btn__loader" }, [null != (e4 = null == (r4 = n2.loader) ? void 0 : r4.call(n2)) ? e4 : Zr.createVNode(Fd, { color: "boolean" == typeof t2.loading ? void 0 : t2.loading, indeterminate: true, size: "23", width: "2" }, null)])];
        } }), [[Zr.resolveDirective("ripple"), !k2.value && t2.ripple, null]]);
      }), {};
    } }), rm = propsFactory({ disabled: Boolean, group: Boolean, hideOnLeave: Boolean, leaveAbsolute: Boolean, mode: String, origin: String }, "transition");
    function createCssTransition(t2, e2, r2) {
      return genericComponent()({ name: t2, props: rm({ mode: r2, origin: e2 }), setup(e3, r3) {
        let { slots: n2 } = r3;
        const i2 = { onBeforeEnter(t3) {
          e3.origin && (t3.style.transformOrigin = e3.origin);
        }, onLeave(t3) {
          if (e3.leaveAbsolute) {
            const { offsetTop: e4, offsetLeft: r4, offsetWidth: n3, offsetHeight: i3 } = t3;
            t3._transitionInitialStyles = { position: t3.style.position, top: t3.style.top, left: t3.style.left, width: t3.style.width, height: t3.style.height }, t3.style.position = "absolute", t3.style.top = `${e4}px`, t3.style.left = `${r4}px`, t3.style.width = `${n3}px`, t3.style.height = `${i3}px`;
          }
          e3.hideOnLeave && t3.style.setProperty("display", "none", "important");
        }, onAfterLeave(t3) {
          if (e3.leaveAbsolute && (null == t3 ? void 0 : t3._transitionInitialStyles)) {
            const { position: e4, top: r4, left: n3, width: i3, height: o2 } = t3._transitionInitialStyles;
            delete t3._transitionInitialStyles, t3.style.position = e4 || "", t3.style.top = r4 || "", t3.style.left = n3 || "", t3.style.width = i3 || "", t3.style.height = o2 || "";
          }
        } };
        return () => {
          const r4 = e3.group ? Zr.TransitionGroup : Zr.Transition;
          return Zr.h(r4, { name: e3.disabled ? "" : t2, css: !e3.disabled, ...e3.group ? void 0 : { mode: e3.mode }, ...e3.disabled ? {} : i2 }, n2.default);
        };
      } });
    }
    function createJavascriptTransition(t2, e2) {
      let r2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "in-out";
      return genericComponent()({ name: t2, props: { mode: { type: String, default: r2 }, disabled: Boolean }, setup(r3, n2) {
        let { slots: i2 } = n2;
        return () => Zr.h(Zr.Transition, { name: r3.disabled ? "" : t2, css: !r3.disabled, ...r3.disabled ? {} : e2 }, i2.default);
      } });
    }
    function ExpandTransitionGenerator() {
      let t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
      const e2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1] ? "width" : "height", r2 = Zr.camelize(`offset-${e2}`);
      return { onBeforeEnter(t3) {
        t3._parent = t3.parentNode, t3._initialStyle = { transition: t3.style.transition, overflow: t3.style.overflow, [e2]: t3.style[e2] };
      }, onEnter(n2) {
        const i2 = n2._initialStyle;
        n2.style.setProperty("transition", "none", "important"), n2.style.overflow = "hidden";
        const o2 = `${n2[r2]}px`;
        n2.style[e2] = "0", n2.offsetHeight, n2.style.transition = i2.transition, t2 && n2._parent && n2._parent.classList.add(t2), requestAnimationFrame(() => {
          n2.style[e2] = o2;
        });
      }, onAfterEnter: resetStyles, onEnterCancelled: resetStyles, onLeave(t3) {
        t3._initialStyle = { transition: "", overflow: t3.style.overflow, [e2]: t3.style[e2] }, t3.style.overflow = "hidden", t3.style[e2] = `${t3[r2]}px`, t3.offsetHeight, requestAnimationFrame(() => t3.style[e2] = "0");
      }, onAfterLeave, onLeaveCancelled: onAfterLeave };
      function onAfterLeave(e3) {
        t2 && e3._parent && e3._parent.classList.remove(t2), resetStyles(e3);
      }
      function resetStyles(t3) {
        const r3 = t3._initialStyle[e2];
        t3.style.overflow = t3._initialStyle.overflow, null != r3 && (t3.style[e2] = r3), delete t3._initialStyle;
      }
    }
    const nm = propsFactory({ target: [Object, Array] }, "v-dialog-transition"), im = genericComponent()({ name: "VDialogTransition", props: nm(), setup(t2, e2) {
      let { slots: r2 } = e2;
      const n2 = { onBeforeEnter(t3) {
        t3.style.pointerEvents = "none", t3.style.visibility = "hidden";
      }, async onEnter(e3, r3) {
        var n3;
        await new Promise((t3) => requestAnimationFrame(t3)), await new Promise((t3) => requestAnimationFrame(t3)), e3.style.visibility = "";
        const { x: i2, y: o2, sx: a2, sy: s2, speed: l2 } = getDimensions(t2.target, e3), p2 = animate(e3, [{ transform: `translate(${i2}px, ${o2}px) scale(${a2}, ${s2})`, opacity: 0 }, {}], { duration: 225 * l2, easing: "cubic-bezier(0.0, 0, 0.2, 1)" });
        null == (n3 = getChildren(e3)) || n3.forEach((t3) => {
          animate(t3, [{ opacity: 0 }, { opacity: 0, offset: 0.33 }, {}], { duration: 450 * l2, easing: md });
        }), p2.finished.then(() => r3());
      }, onAfterEnter(t3) {
        t3.style.removeProperty("pointer-events");
      }, onBeforeLeave(t3) {
        t3.style.pointerEvents = "none";
      }, async onLeave(e3, r3) {
        var n3;
        await new Promise((t3) => requestAnimationFrame(t3));
        const { x: i2, y: o2, sx: a2, sy: s2, speed: l2 } = getDimensions(t2.target, e3);
        animate(e3, [{}, { transform: `translate(${i2}px, ${o2}px) scale(${a2}, ${s2})`, opacity: 0 }], { duration: 125 * l2, easing: "cubic-bezier(0.4, 0, 1, 1)" }).finished.then(() => r3()), null == (n3 = getChildren(e3)) || n3.forEach((t3) => {
          animate(t3, [{}, { opacity: 0, offset: 0.2 }, { opacity: 0 }], { duration: 250 * l2, easing: md });
        });
      }, onAfterLeave(t3) {
        t3.style.removeProperty("pointer-events");
      } };
      return () => t2.target ? Zr.createVNode(Zr.Transition, Zr.mergeProps({ name: "dialog-transition" }, n2, { css: false }), r2) : Zr.createVNode(Zr.Transition, { name: "dialog-transition" }, r2);
    } });
    function getChildren(t2) {
      var e2;
      const r2 = null == (e2 = t2.querySelector(":scope > .v-card, :scope > .v-sheet, :scope > .v-list")) ? void 0 : e2.children;
      return r2 && [...r2];
    }
    function getDimensions(t2, e2) {
      const r2 = getTargetBox(t2), n2 = nullifyTransforms(e2), [i2, o2] = getComputedStyle(e2).transformOrigin.split(" ").map((t3) => parseFloat(t3)), [a2, s2] = getComputedStyle(e2).getPropertyValue("--v-overlay-anchor-origin").split(" ");
      let l2 = r2.left + r2.width / 2;
      "left" === a2 || "left" === s2 ? l2 -= r2.width / 2 : "right" !== a2 && "right" !== s2 || (l2 += r2.width / 2);
      let p2 = r2.top + r2.height / 2;
      "top" === a2 || "top" === s2 ? p2 -= r2.height / 2 : "bottom" !== a2 && "bottom" !== s2 || (p2 += r2.height / 2);
      const c2 = r2.width / n2.width, d2 = r2.height / n2.height, m2 = Math.max(1, c2, d2), u2 = c2 / m2 || 0, h2 = d2 / m2 || 0, g2 = n2.width * n2.height / (window.innerWidth * window.innerHeight), x2 = g2 > 0.12 ? Math.min(1.5, 10 * (g2 - 0.12) + 1) : 1;
      return { x: l2 - (i2 + n2.left), y: p2 - (o2 + n2.top), sx: u2, sy: h2, speed: x2 };
    }
    createCssTransition("fab-transition", "center center", "out-in"), createCssTransition("dialog-bottom-transition"), createCssTransition("dialog-top-transition"), createCssTransition("fade-transition"), createCssTransition("scale-transition"), createCssTransition("scroll-x-transition"), createCssTransition("scroll-x-reverse-transition"), createCssTransition("scroll-y-transition"), createCssTransition("scroll-y-reverse-transition"), createCssTransition("slide-x-transition"), createCssTransition("slide-x-reverse-transition");
    const om = createCssTransition("slide-y-transition");
    createCssTransition("slide-y-reverse-transition");
    const am = createJavascriptTransition("expand-transition", ExpandTransitionGenerator()), sm = createJavascriptTransition("expand-x-transition", ExpandTransitionGenerator("", true)), lm = Symbol.for("vuetify:list");
    function createList() {
      const t2 = Zr.inject(lm, { hasPrepend: Zr.shallowRef(false), updateHasPrepend: () => null }), e2 = { hasPrepend: Zr.shallowRef(false), updateHasPrepend: (t3) => {
        t3 && (e2.hasPrepend.value = t3);
      } };
      return Zr.provide(lm, e2), t2;
    }
    function useList() {
      return Zr.inject(lm, null);
    }
    const pm = { open: (t2) => {
      let { id: e2, value: r2, opened: n2, parents: i2 } = t2;
      if (r2) {
        const t3 = /* @__PURE__ */ new Set();
        t3.add(e2);
        let r3 = i2.get(e2);
        for (; null != r3; )
          t3.add(r3), r3 = i2.get(r3);
        return t3;
      }
      return n2.delete(e2), n2;
    }, select: () => null }, cm = { open: (t2) => {
      let { id: e2, value: r2, opened: n2, parents: i2 } = t2;
      if (r2) {
        let t3 = i2.get(e2);
        for (n2.add(e2); null != t3 && t3 !== e2; )
          n2.add(t3), t3 = i2.get(t3);
        return n2;
      }
      return n2.delete(e2), n2;
    }, select: () => null }, dm = { open: cm.open, select: (t2) => {
      let { id: e2, value: r2, opened: n2, parents: i2 } = t2;
      if (!r2)
        return n2;
      const o2 = [];
      let a2 = i2.get(e2);
      for (; null != a2; )
        o2.push(a2), a2 = i2.get(a2);
      return new Set(o2);
    } }, independentSelectStrategy = (t2) => {
      const e2 = { select: (e3) => {
        let { id: r2, value: n2, selected: i2 } = e3;
        if (r2 = Zr.toRaw(r2), t2 && !n2) {
          const t3 = Array.from(i2.entries()).reduce((t4, e4) => {
            let [r3, n3] = e4;
            return "on" === n3 ? [...t4, r3] : t4;
          }, []);
          if (1 === t3.length && t3[0] === r2)
            return i2;
        }
        return i2.set(r2, n2 ? "on" : "off"), i2;
      }, in: (t3, r2, n2) => {
        let i2 = /* @__PURE__ */ new Map();
        for (const o2 of t3 || [])
          i2 = e2.select({ id: o2, value: true, selected: new Map(i2), children: r2, parents: n2 });
        return i2;
      }, out: (t3) => {
        const e3 = [];
        for (const [r2, n2] of t3.entries())
          "on" === n2 && e3.push(r2);
        return e3;
      } };
      return e2;
    }, independentSingleSelectStrategy = (t2) => {
      const e2 = independentSelectStrategy(t2);
      return { select: (t3) => {
        let { selected: r2, id: n2, ...i2 } = t3;
        n2 = Zr.toRaw(n2);
        const o2 = r2.has(n2) ? /* @__PURE__ */ new Map([[n2, r2.get(n2)]]) : /* @__PURE__ */ new Map();
        return e2.select({ ...i2, id: n2, selected: o2 });
      }, in: (t3, r2, n2) => {
        let i2 = /* @__PURE__ */ new Map();
        return (null == t3 ? void 0 : t3.length) && (i2 = e2.in(t3.slice(0, 1), r2, n2)), i2;
      }, out: (t3, r2, n2) => e2.out(t3, r2, n2) };
    }, mm = Symbol.for("vuetify:nested"), um = { id: Zr.shallowRef(), root: { register: () => null, unregister: () => null, parents: Zr.ref(/* @__PURE__ */ new Map()), children: Zr.ref(/* @__PURE__ */ new Map()), open: () => null, openOnSelect: () => null, select: () => null, opened: Zr.ref(/* @__PURE__ */ new Set()), selected: Zr.ref(/* @__PURE__ */ new Map()), selectedValues: Zr.ref([]) } }, hm = propsFactory({ selectStrategy: [String, Function], openStrategy: [String, Object], opened: Array, selected: Array, mandatory: Boolean }, "nested"), useNested = (t2) => {
      const e2 = Zr.ref(/* @__PURE__ */ new Map()), r2 = Zr.ref(/* @__PURE__ */ new Map()), n2 = useProxiedModel(t2, "opened", t2.opened, (t3) => new Set(t3), (t3) => [...t3.values()]), i2 = Zr.computed(() => {
        if ("object" == typeof t2.selectStrategy)
          return t2.selectStrategy;
        switch (t2.selectStrategy) {
          case "single-leaf":
            return ((t3) => {
              const e3 = independentSingleSelectStrategy(t3);
              return { select: (t4) => {
                let { id: r3, selected: n3, children: i3, ...o3 } = t4;
                return r3 = Zr.toRaw(r3), i3.has(r3) ? n3 : e3.select({ id: r3, selected: n3, children: i3, ...o3 });
              }, in: e3.in, out: e3.out };
            })(t2.mandatory);
          case "leaf":
            return ((t3) => {
              const e3 = independentSelectStrategy(t3);
              return { select: (t4) => {
                let { id: r3, selected: n3, children: i3, ...o3 } = t4;
                return r3 = Zr.toRaw(r3), i3.has(r3) ? n3 : e3.select({ id: r3, selected: n3, children: i3, ...o3 });
              }, in: e3.in, out: e3.out };
            })(t2.mandatory);
          case "independent":
            return independentSelectStrategy(t2.mandatory);
          case "single-independent":
            return independentSingleSelectStrategy(t2.mandatory);
          default:
            return ((t3) => {
              const e3 = { select: (e4) => {
                let { id: r3, value: n3, selected: i3, children: o3, parents: a3 } = e4;
                r3 = Zr.toRaw(r3);
                const s3 = new Map(i3), l3 = [r3];
                for (; l3.length; ) {
                  const t4 = l3.shift();
                  i3.set(t4, n3 ? "on" : "off"), o3.has(t4) && l3.push(...o3.get(t4));
                }
                let p2 = a3.get(r3);
                for (; p2; ) {
                  const t4 = o3.get(p2), e5 = t4.every((t5) => "on" === i3.get(t5)), r4 = t4.every((t5) => !i3.has(t5) || "off" === i3.get(t5));
                  i3.set(p2, e5 ? "on" : r4 ? "off" : "indeterminate"), p2 = a3.get(p2);
                }
                return t3 && !n3 && 0 === Array.from(i3.entries()).reduce((t4, e5) => {
                  let [r4, n4] = e5;
                  return "on" === n4 ? [...t4, r4] : t4;
                }, []).length ? s3 : i3;
              }, in: (t4, r3, n3) => {
                let i3 = /* @__PURE__ */ new Map();
                for (const o3 of t4 || [])
                  i3 = e3.select({ id: o3, value: true, selected: new Map(i3), children: r3, parents: n3 });
                return i3;
              }, out: (t4, e4) => {
                const r3 = [];
                for (const [n3, i3] of t4.entries())
                  "on" !== i3 || e4.has(n3) || r3.push(n3);
                return r3;
              } };
              return e3;
            })(t2.mandatory);
        }
      }), o2 = Zr.computed(() => {
        if ("object" == typeof t2.openStrategy)
          return t2.openStrategy;
        switch (t2.openStrategy) {
          case "list":
            return dm;
          case "single":
            return pm;
          default:
            return cm;
        }
      }), a2 = useProxiedModel(t2, "selected", t2.selected, (t3) => i2.value.in(t3, e2.value, r2.value), (t3) => i2.value.out(t3, e2.value, r2.value));
      function getPath(t3) {
        const e3 = [];
        let n3 = t3;
        for (; null != n3; )
          e3.unshift(n3), n3 = r2.value.get(n3);
        return e3;
      }
      const s2 = getCurrentInstance("nested"), l2 = { id: Zr.shallowRef(), root: { opened: n2, selected: a2, selectedValues: Zr.computed(() => {
        const t3 = [];
        for (const [e3, r3] of a2.value.entries())
          "on" === r3 && t3.push(e3);
        return t3;
      }), register: (t3, n3, i3) => {
        n3 && t3 !== n3 && r2.value.set(t3, n3), i3 && e2.value.set(t3, []), null != n3 && e2.value.set(n3, [...e2.value.get(n3) || [], t3]);
      }, unregister: (t3) => {
        var i3;
        e2.value.delete(t3);
        const o3 = r2.value.get(t3);
        if (o3) {
          const r3 = null != (i3 = e2.value.get(o3)) ? i3 : [];
          e2.value.set(o3, r3.filter((e3) => e3 !== t3));
        }
        r2.value.delete(t3), n2.value.delete(t3);
      }, open: (t3, i3, a3) => {
        s2.emit("click:open", { id: t3, value: i3, path: getPath(t3), event: a3 });
        const l3 = o2.value.open({ id: t3, value: i3, opened: new Set(n2.value), children: e2.value, parents: r2.value, event: a3 });
        l3 && (n2.value = l3);
      }, openOnSelect: (t3, i3, s3) => {
        const l3 = o2.value.select({ id: t3, value: i3, selected: new Map(a2.value), opened: new Set(n2.value), children: e2.value, parents: r2.value, event: s3 });
        l3 && (n2.value = l3);
      }, select: (t3, n3, o3) => {
        s2.emit("click:select", { id: t3, value: n3, path: getPath(t3), event: o3 });
        const p2 = i2.value.select({ id: t3, value: n3, selected: new Map(a2.value), children: e2.value, parents: r2.value, event: o3 });
        p2 && (a2.value = p2), l2.root.openOnSelect(t3, n3, o3);
      }, children: e2, parents: r2 } };
      return Zr.provide(mm, l2), l2.root;
    }, useNestedItem = (t2, e2) => {
      const r2 = Zr.inject(mm, um), n2 = Symbol(getUid()), i2 = Zr.computed(() => void 0 !== t2.value ? t2.value : n2), o2 = { ...r2, id: i2, open: (t3, e3) => r2.root.open(i2.value, t3, e3), openOnSelect: (t3, e3) => r2.root.openOnSelect(i2.value, t3, e3), isOpen: Zr.computed(() => r2.root.opened.value.has(i2.value)), parent: Zr.computed(() => r2.root.parents.value.get(i2.value)), select: (t3, e3) => r2.root.select(i2.value, t3, e3), isSelected: Zr.computed(() => "on" === r2.root.selected.value.get(Zr.toRaw(i2.value))), isIndeterminate: Zr.computed(() => "indeterminate" === r2.root.selected.value.get(i2.value)), isLeaf: Zr.computed(() => !r2.root.children.value.get(i2.value)), isGroupActivator: r2.isGroupActivator };
      return !r2.isGroupActivator && r2.root.register(i2.value, r2.id.value, e2), e2 && Zr.provide(mm, o2), o2;
    };
    function useSsrBoot() {
      const t2 = Zr.shallowRef(false);
      return { ssrBootStyles: Zr.computed(() => t2.value ? void 0 : { transition: "none !important" }), isBooted: Zr.readonly(t2) };
    }
    const fm = propsFactory({ transition: { type: [Boolean, String, Object], default: "fade-transition", validator: (t2) => true !== t2 } }, "transition"), MaybeTransition = (t2, e2) => {
      let { slots: r2 } = e2;
      const { transition: n2, disabled: i2, ...o2 } = t2, { component: a2 = Zr.Transition, ...s2 } = "object" == typeof n2 ? n2 : {};
      return Zr.h(a2, Zr.mergeProps("string" == typeof n2 ? { name: i2 ? "" : n2 } : s2, o2, { disabled: i2 }), r2);
    }, gm = defineComponent({ name: "VListGroupActivator", setup(t2, e2) {
      let { slots: r2 } = e2;
      return (() => {
        const t3 = Zr.inject(mm, um);
        Zr.provide(mm, { ...t3, isGroupActivator: true });
      })(), () => {
        var t3;
        return null == (t3 = r2.default) ? void 0 : t3.call(r2);
      };
    } }), xm = propsFactory({ activeColor: String, baseColor: String, color: String, collapseIcon: { type: gc, default: "$collapse" }, expandIcon: { type: gc, default: "$expand" }, prependIcon: gc, appendIcon: gc, fluid: Boolean, subgroup: Boolean, title: String, value: null, ...mc(), ...Sd() }, "VListGroup"), vm = genericComponent()({ name: "VListGroup", props: xm(), setup(t2, e2) {
      let { slots: r2 } = e2;
      const { isOpen: n2, open: i2, id: o2 } = useNestedItem(Zr.toRef(t2, "value"), true), a2 = Zr.computed(() => `v-list-group--id-${String(o2.value)}`), s2 = useList(), { isBooted: l2 } = useSsrBoot();
      function onClick(t3) {
        i2(!n2.value, t3);
      }
      const p2 = Zr.computed(() => ({ onClick, class: "v-list-group__header", id: a2.value })), c2 = Zr.computed(() => n2.value ? t2.collapseIcon : t2.expandIcon), d2 = Zr.computed(() => ({ VListItem: { active: n2.value, activeColor: t2.activeColor, baseColor: t2.baseColor, color: t2.color, prependIcon: t2.prependIcon || t2.subgroup && c2.value, appendIcon: t2.appendIcon || !t2.subgroup && c2.value, title: t2.title, value: t2.value } }));
      return useRender(() => Zr.createVNode(t2.tag, { class: ["v-list-group", { "v-list-group--prepend": null == s2 ? void 0 : s2.hasPrepend.value, "v-list-group--fluid": t2.fluid, "v-list-group--subgroup": t2.subgroup, "v-list-group--open": n2.value }, t2.class], style: t2.style }, { default: () => [r2.activator && Zr.createVNode(Od, { defaults: d2.value }, { default: () => [Zr.createVNode(gm, null, { default: () => [r2.activator({ props: p2.value, isOpen: n2.value })] })] }), Zr.createVNode(MaybeTransition, { transition: { component: am }, disabled: !l2.value }, { default: () => {
        var t3;
        return [Zr.withDirectives(Zr.createVNode("div", { class: "v-list-group__items", role: "group", "aria-labelledby": a2.value }, [null == (t3 = r2.default) ? void 0 : t3.call(r2)]), [[Zr.vShow, n2.value]])];
      } })] })), {};
    } }), ym = createSimpleFunctional("v-list-item-subtitle"), bm = createSimpleFunctional("v-list-item-title");
    const wm = propsFactory({ aspectRatio: [String, Number], contentClass: String, inline: Boolean, ...mc(), ...$d() }, "VResponsive"), km = genericComponent()({ name: "VResponsive", props: wm(), setup(t2, e2) {
      let { slots: r2 } = e2;
      const { aspectStyles: n2 } = function(t3) {
        return { aspectStyles: Zr.computed(() => {
          const e3 = Number(t3.aspectRatio);
          return e3 ? { paddingBottom: String(1 / e3 * 100) + "%" } : void 0;
        }) };
      }(t2), { dimensionStyles: i2 } = useDimension(t2);
      return useRender(() => {
        var e3;
        return Zr.createVNode("div", { class: ["v-responsive", { "v-responsive--inline": t2.inline }, t2.class], style: [i2.value, t2.style] }, [Zr.createVNode("div", { class: "v-responsive__sizer", style: n2.value }, null), null == (e3 = r2.additional) ? void 0 : e3.call(r2), r2.default && Zr.createVNode("div", { class: ["v-responsive__content", t2.contentClass] }, [r2.default()])]);
      }), {};
    } });
    function unmounted(t2, e2) {
      var r2;
      const n2 = null == (r2 = t2._observe) ? void 0 : r2[e2.instance.$.uid];
      n2 && (n2.observer.unobserve(t2), delete t2._observe[e2.instance.$.uid]);
    }
    const Sm = { mounted: function(t2, e2) {
    }, unmounted }, Cm = propsFactory({ alt: String, cover: Boolean, draggable: { type: [Boolean, String], default: void 0 }, eager: Boolean, gradient: String, lazySrc: String, options: { type: Object, default: () => ({ root: void 0, rootMargin: void 0, threshold: void 0 }) }, sizes: String, src: { type: [String, Object], default: "" }, crossorigin: String, referrerpolicy: String, srcset: String, position: String, ...wm(), ...mc(), ...fm() }, "VImg"), Em = genericComponent()({ name: "VImg", directives: { intersect: Sm }, props: Cm(), emits: { loadstart: (t2) => true, load: (t2) => true, error: (t2) => true }, setup(t2, e2) {
      let { emit: r2, slots: n2 } = e2;
      const i2 = getCurrentInstance("VImg"), o2 = Zr.shallowRef(""), a2 = Zr.ref(), s2 = Zr.shallowRef(t2.eager ? "loading" : "idle"), l2 = Zr.shallowRef(), p2 = Zr.shallowRef(), c2 = Zr.computed(() => t2.src && "object" == typeof t2.src ? { src: t2.src.src, srcset: t2.srcset || t2.src.srcset, lazySrc: t2.lazySrc || t2.src.lazySrc, aspect: Number(t2.aspectRatio || t2.src.aspect || 0) } : { src: t2.src, srcset: t2.srcset, lazySrc: t2.lazySrc, aspect: Number(t2.aspectRatio || 0) }), d2 = Zr.computed(() => c2.value.aspect || l2.value / p2.value || 0);
      function init(e3) {
        if (!t2.eager || !e3) {
          if (s2.value = "loading", c2.value.lazySrc) {
            const t3 = new Image();
            t3.src = c2.value.lazySrc, pollForSize(t3, null);
          }
          c2.value.src && Zr.nextTick(() => {
            var t3;
            r2("loadstart", (null == (t3 = a2.value) ? void 0 : t3.currentSrc) || c2.value.src), setTimeout(() => {
              var t4;
              if (!i2.isUnmounted)
                if (null == (t4 = a2.value) ? void 0 : t4.complete) {
                  if (a2.value.naturalWidth || onError(), "error" === s2.value)
                    return;
                  d2.value || pollForSize(a2.value, null), "loading" === s2.value && onLoad();
                } else
                  d2.value || pollForSize(a2.value), getSrc();
            });
          });
        }
      }
      function onLoad() {
        var t3;
        i2.isUnmounted || (getSrc(), pollForSize(a2.value), s2.value = "loaded", r2("load", (null == (t3 = a2.value) ? void 0 : t3.currentSrc) || c2.value.src));
      }
      function onError() {
        var t3;
        i2.isUnmounted || (s2.value = "error", r2("error", (null == (t3 = a2.value) ? void 0 : t3.currentSrc) || c2.value.src));
      }
      function getSrc() {
        const t3 = a2.value;
        t3 && (o2.value = t3.currentSrc || t3.src);
      }
      Zr.watch(() => t2.src, () => {
        init("idle" !== s2.value);
      }), Zr.watch(d2, (t3, e3) => {
        !t3 && e3 && a2.value && pollForSize(a2.value);
      });
      let m2 = -1;
      function pollForSize(t3) {
        let e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 100;
        const poll = () => {
          if (clearTimeout(m2), i2.isUnmounted)
            return;
          const { naturalHeight: r3, naturalWidth: n3 } = t3;
          r3 || n3 ? (l2.value = n3, p2.value = r3) : t3.complete || "loading" !== s2.value || null == e3 ? (t3.currentSrc.endsWith(".svg") || t3.currentSrc.startsWith("data:image/svg+xml")) && (l2.value = 1, p2.value = 1) : m2 = window.setTimeout(poll, e3);
        };
        poll();
      }
      const u2 = Zr.computed(() => ({ "v-img__img--cover": t2.cover, "v-img__img--contain": !t2.cover })), __image = () => {
        var e3;
        if (!c2.value.src || "idle" === s2.value)
          return null;
        const r3 = Zr.createVNode("img", { class: ["v-img__img", u2.value], style: { objectPosition: t2.position }, src: c2.value.src, srcset: c2.value.srcset, alt: t2.alt, crossorigin: t2.crossorigin, referrerpolicy: t2.referrerpolicy, draggable: t2.draggable, sizes: t2.sizes, ref: a2, onLoad, onError }, null), i3 = null == (e3 = n2.sources) ? void 0 : e3.call(n2);
        return Zr.createVNode(MaybeTransition, { transition: t2.transition, appear: true }, { default: () => [Zr.withDirectives(i3 ? Zr.createVNode("picture", { class: "v-img__picture" }, [i3, r3]) : r3, [[Zr.vShow, "loaded" === s2.value]])] });
      }, __preloadImage = () => Zr.createVNode(MaybeTransition, { transition: t2.transition }, { default: () => [c2.value.lazySrc && "loaded" !== s2.value && Zr.createVNode("img", { class: ["v-img__img", "v-img__img--preload", u2.value], style: { objectPosition: t2.position }, src: c2.value.lazySrc, alt: t2.alt, crossorigin: t2.crossorigin, referrerpolicy: t2.referrerpolicy, draggable: t2.draggable }, null)] }), __placeholder = () => n2.placeholder ? Zr.createVNode(MaybeTransition, { transition: t2.transition, appear: true }, { default: () => [("loading" === s2.value || "error" === s2.value && !n2.error) && Zr.createVNode("div", { class: "v-img__placeholder" }, [n2.placeholder()])] }) : null, __error = () => n2.error ? Zr.createVNode(MaybeTransition, { transition: t2.transition, appear: true }, { default: () => ["error" === s2.value && Zr.createVNode("div", { class: "v-img__error" }, [n2.error()])] }) : null, __gradient = () => t2.gradient ? Zr.createVNode("div", { class: "v-img__gradient", style: { backgroundImage: `linear-gradient(${t2.gradient})` } }, null) : null, h2 = Zr.shallowRef(false);
      {
        const t3 = Zr.watch(d2, (e3) => {
          e3 && (requestAnimationFrame(() => {
            requestAnimationFrame(() => {
              h2.value = true;
            });
          }), t3());
        });
      }
      return useRender(() => {
        const e3 = km.filterProps(t2);
        return Zr.withDirectives(Zr.createVNode(km, Zr.mergeProps({ class: ["v-img", { "v-img--booting": !h2.value }, t2.class], style: [{ width: convertToUnit("auto" === t2.width ? l2.value : t2.width) }, t2.style] }, e3, { aspectRatio: d2.value, "aria-label": t2.alt, role: t2.alt ? "img" : void 0 }), { additional: () => Zr.createVNode(Zr.Fragment, null, [Zr.createVNode(__image, null, null), Zr.createVNode(__preloadImage, null, null), Zr.createVNode(__gradient, null, null), Zr.createVNode(__placeholder, null, null), Zr.createVNode(__error, null, null)]), default: n2.default }), [[Zr.resolveDirective("intersect"), { handler: init, options: t2.options }, null, { once: true }]]);
      }), { currentSrc: o2, image: a2, state: s2, naturalWidth: l2, naturalHeight: p2 };
    } }), _m = propsFactory({ start: Boolean, end: Boolean, icon: gc, image: String, text: String, ...mc(), ...bd(), ...kd(), ...Md(), ...Sd(), ...$c(), ...Ed({ variant: "flat" }) }, "VAvatar"), Pm = genericComponent()({ name: "VAvatar", props: _m(), setup(t2, e2) {
      let { slots: r2 } = e2;
      const { themeClasses: n2 } = provideTheme(t2), { colorClasses: i2, colorStyles: o2, variantClasses: a2 } = useVariant(t2), { densityClasses: s2 } = useDensity(t2), { roundedClasses: l2 } = useRounded(t2), { sizeClasses: p2, sizeStyles: c2 } = useSize(t2);
      return useRender(() => Zr.createVNode(t2.tag, { class: ["v-avatar", { "v-avatar--start": t2.start, "v-avatar--end": t2.end }, n2.value, i2.value, s2.value, l2.value, p2.value, a2.value, t2.class], style: [o2.value, c2.value, t2.style] }, { default: () => {
        var e3, n3;
        return [t2.image ? Zr.createVNode(Em, { key: "image", src: t2.image, alt: "", cover: true }, null) : t2.icon ? Zr.createVNode(Dd, { key: "icon", icon: t2.icon }, null) : null != (e3 = null == (n3 = r2.default) ? void 0 : n3.call(r2)) ? e3 : t2.text, genOverlays(false, "v-avatar")];
      } })), {};
    } }), Tm = propsFactory({ active: { type: Boolean, default: void 0 }, activeClass: String, activeColor: String, appendAvatar: String, appendIcon: gc, baseColor: String, disabled: Boolean, lines: String, link: { type: Boolean, default: void 0 }, nav: Boolean, prependAvatar: String, prependIcon: gc, ripple: { type: [Boolean, Object], default: true }, slim: Boolean, subtitle: [String, Number], title: [String, Number], value: null, onClick: EventProp(), onClickOnce: EventProp(), ...vd(), ...mc(), ...bd(), ...$d(), ...wd(), ...kd(), ...Gd(), ...Sd(), ...$c(), ...Ed({ variant: "text" }) }, "VListItem"), Am = genericComponent()({ name: "VListItem", directives: { Ripple: Zd }, props: Tm(), emits: { click: (t2) => true }, setup(t2, e2) {
      let { attrs: r2, slots: n2, emit: i2 } = e2;
      const o2 = useLink(t2, r2), a2 = Zr.computed(() => void 0 === t2.value ? o2.href.value : t2.value), { select: s2, isSelected: l2, isIndeterminate: p2, isGroupActivator: c2, root: d2, parent: m2, openOnSelect: u2 } = useNestedItem(a2, false), h2 = useList(), g2 = Zr.computed(() => {
        var e3;
        return false !== t2.active && (t2.active || (null == (e3 = o2.isActive) ? void 0 : e3.value) || l2.value);
      }), x2 = Zr.computed(() => false !== t2.link && o2.isLink.value), v2 = Zr.computed(() => !t2.disabled && false !== t2.link && (t2.link || o2.isClickable.value || null != t2.value && !!h2)), y2 = Zr.computed(() => t2.rounded || t2.nav), b2 = Zr.computed(() => {
        var e3;
        return null != (e3 = t2.color) ? e3 : t2.activeColor;
      }), w2 = Zr.computed(() => {
        var e3;
        return { color: g2.value && null != (e3 = b2.value) ? e3 : t2.baseColor, variant: t2.variant };
      });
      Zr.watch(() => {
        var t3;
        return null == (t3 = o2.isActive) ? void 0 : t3.value;
      }, (t3) => {
        t3 && null != m2.value && d2.open(m2.value, true), t3 && u2(t3);
      }, { immediate: true });
      const { themeClasses: k2 } = provideTheme(t2), { borderClasses: S2 } = useBorder(t2), { colorClasses: C2, colorStyles: _2, variantClasses: P2 } = useVariant(w2), { densityClasses: T2 } = useDensity(t2), { dimensionStyles: A2 } = useDimension(t2), { elevationClasses: I2 } = useElevation(t2), { roundedClasses: N2 } = useRounded(y2), R2 = Zr.computed(() => t2.lines ? `v-list-item--${t2.lines}-line` : void 0), O2 = Zr.computed(() => ({ isActive: g2.value, select: s2, isSelected: l2.value, isIndeterminate: p2.value }));
      function onClick(e3) {
        var r3;
        i2("click", e3), !c2 && v2.value && (null == (r3 = o2.navigate) || r3.call(o2, e3), null != t2.value && s2(!l2.value, e3));
      }
      function onKeyDown(t3) {
        "Enter" !== t3.key && " " !== t3.key || (t3.preventDefault(), onClick(t3));
      }
      return useRender(() => {
        const e3 = x2.value ? "a" : t2.tag, r3 = n2.title || null != t2.title, i3 = n2.subtitle || null != t2.subtitle, a3 = !(!t2.appendAvatar && !t2.appendIcon), s3 = !(!a3 && !n2.append), l3 = !(!t2.prependAvatar && !t2.prependIcon), p3 = !(!l3 && !n2.prepend);
        return null == h2 || h2.updateHasPrepend(p3), t2.activeColor && deprecate("active-color", ["color", "base-color"]), Zr.withDirectives(Zr.createVNode(e3, { class: ["v-list-item", { "v-list-item--active": g2.value, "v-list-item--disabled": t2.disabled, "v-list-item--link": v2.value, "v-list-item--nav": t2.nav, "v-list-item--prepend": !p3 && (null == h2 ? void 0 : h2.hasPrepend.value), "v-list-item--slim": t2.slim, [`${t2.activeClass}`]: t2.activeClass && g2.value }, k2.value, S2.value, C2.value, T2.value, I2.value, R2.value, N2.value, P2.value, t2.class], style: [_2.value, A2.value, t2.style], href: o2.href.value, tabindex: v2.value ? h2 ? -2 : 0 : void 0, onClick, onKeydown: v2.value && !x2.value && onKeyDown }, { default: () => {
          var e4;
          return [genOverlays(v2.value || g2.value, "v-list-item"), p3 && Zr.createVNode("div", { key: "prepend", class: "v-list-item__prepend" }, [n2.prepend ? Zr.createVNode(Od, { key: "prepend-defaults", disabled: !l3, defaults: { VAvatar: { density: t2.density, image: t2.prependAvatar }, VIcon: { density: t2.density, icon: t2.prependIcon }, VListItemAction: { start: true } } }, { default: () => {
            var t3;
            return [null == (t3 = n2.prepend) ? void 0 : t3.call(n2, O2.value)];
          } }) : Zr.createVNode(Zr.Fragment, null, [t2.prependAvatar && Zr.createVNode(Pm, { key: "prepend-avatar", density: t2.density, image: t2.prependAvatar }, null), t2.prependIcon && Zr.createVNode(Dd, { key: "prepend-icon", density: t2.density, icon: t2.prependIcon }, null)]), Zr.createVNode("div", { class: "v-list-item__spacer" }, null)]), Zr.createVNode("div", { class: "v-list-item__content", "data-no-activator": "" }, [r3 && Zr.createVNode(bm, { key: "title" }, { default: () => {
            var e5, r4;
            return [null != (e5 = null == (r4 = n2.title) ? void 0 : r4.call(n2, { title: t2.title })) ? e5 : t2.title];
          } }), i3 && Zr.createVNode(ym, { key: "subtitle" }, { default: () => {
            var e5, r4;
            return [null != (e5 = null == (r4 = n2.subtitle) ? void 0 : r4.call(n2, { subtitle: t2.subtitle })) ? e5 : t2.subtitle];
          } }), null == (e4 = n2.default) ? void 0 : e4.call(n2, O2.value)]), s3 && Zr.createVNode("div", { key: "append", class: "v-list-item__append" }, [n2.append ? Zr.createVNode(Od, { key: "append-defaults", disabled: !a3, defaults: { VAvatar: { density: t2.density, image: t2.appendAvatar }, VIcon: { density: t2.density, icon: t2.appendIcon }, VListItemAction: { end: true } } }, { default: () => {
            var t3;
            return [null == (t3 = n2.append) ? void 0 : t3.call(n2, O2.value)];
          } }) : Zr.createVNode(Zr.Fragment, null, [t2.appendIcon && Zr.createVNode(Dd, { key: "append-icon", density: t2.density, icon: t2.appendIcon }, null), t2.appendAvatar && Zr.createVNode(Pm, { key: "append-avatar", density: t2.density, image: t2.appendAvatar }, null)]), Zr.createVNode("div", { class: "v-list-item__spacer" }, null)])];
        } }), [[Zr.resolveDirective("ripple"), v2.value && t2.ripple]]);
      }), {};
    } }), Im = propsFactory({ color: String, inset: Boolean, sticky: Boolean, title: String, ...mc(), ...Sd() }, "VListSubheader"), Nm = genericComponent()({ name: "VListSubheader", props: Im(), setup(t2, e2) {
      let { slots: r2 } = e2;
      const { textColorClasses: n2, textColorStyles: i2 } = useTextColor(Zr.toRef(t2, "color"));
      return useRender(() => {
        const e3 = !(!r2.default && !t2.title);
        return Zr.createVNode(t2.tag, { class: ["v-list-subheader", { "v-list-subheader--inset": t2.inset, "v-list-subheader--sticky": t2.sticky }, n2.value, t2.class], style: [{ textColorStyles: i2 }, t2.style] }, { default: () => {
          var n3, i3;
          return [e3 && Zr.createVNode("div", { class: "v-list-subheader__text" }, [null != (n3 = null == (i3 = r2.default) ? void 0 : i3.call(r2)) ? n3 : t2.title])];
        } });
      }), {};
    } }), Rm = propsFactory({ color: String, inset: Boolean, length: [Number, String], thickness: [Number, String], vertical: Boolean, ...mc(), ...$c() }, "VDivider"), Om = genericComponent()({ name: "VDivider", props: Rm(), setup(t2, e2) {
      let { attrs: r2 } = e2;
      const { themeClasses: n2 } = provideTheme(t2), { textColorClasses: i2, textColorStyles: o2 } = useTextColor(Zr.toRef(t2, "color")), a2 = Zr.computed(() => {
        const e3 = {};
        return t2.length && (e3[t2.vertical ? "maxHeight" : "maxWidth"] = convertToUnit(t2.length)), t2.thickness && (e3[t2.vertical ? "borderRightWidth" : "borderTopWidth"] = convertToUnit(t2.thickness)), e3;
      });
      return useRender(() => Zr.createVNode("hr", { class: [{ "v-divider": true, "v-divider--inset": t2.inset, "v-divider--vertical": t2.vertical }, n2.value, i2.value, t2.class], style: [a2.value, o2.value, t2.style], "aria-orientation": r2.role && "separator" !== r2.role ? void 0 : t2.vertical ? "vertical" : "horizontal", role: `${r2.role || "separator"}` }, null)), {};
    } }), Lm = propsFactory({ items: Array, returnObject: Boolean }, "VListChildren"), Mm = genericComponent()({ name: "VListChildren", props: Lm(), setup(t2, e2) {
      let { slots: r2 } = e2;
      return createList(), () => {
        var e3, n2, i2;
        return null != (e3 = null == (n2 = r2.default) ? void 0 : n2.call(r2)) ? e3 : null == (i2 = t2.items) ? void 0 : i2.map((e4) => {
          var n3, i3, o2, a2;
          let { children: s2, props: l2, type: p2, raw: c2 } = e4;
          if ("divider" === p2)
            return null != (n3 = null == (o2 = r2.divider) ? void 0 : o2.call(r2, { props: l2 })) ? n3 : Zr.createVNode(Om, l2, null);
          if ("subheader" === p2)
            return null != (i3 = null == (a2 = r2.subheader) ? void 0 : a2.call(r2, { props: l2 })) ? i3 : Zr.createVNode(Nm, l2, null);
          const d2 = { subtitle: r2.subtitle ? (t3) => {
            var e5;
            return null == (e5 = r2.subtitle) ? void 0 : e5.call(r2, { ...t3, item: c2 });
          } : void 0, prepend: r2.prepend ? (t3) => {
            var e5;
            return null == (e5 = r2.prepend) ? void 0 : e5.call(r2, { ...t3, item: c2 });
          } : void 0, append: r2.append ? (t3) => {
            var e5;
            return null == (e5 = r2.append) ? void 0 : e5.call(r2, { ...t3, item: c2 });
          } : void 0, title: r2.title ? (t3) => {
            var e5;
            return null == (e5 = r2.title) ? void 0 : e5.call(r2, { ...t3, item: c2 });
          } : void 0 }, m2 = vm.filterProps(l2);
          return s2 ? Zr.createVNode(vm, Zr.mergeProps({ value: null == l2 ? void 0 : l2.value }, m2), { activator: (e5) => {
            let { props: n4 } = e5;
            const i4 = { ...l2, ...n4, value: t2.returnObject ? c2 : l2.value };
            return r2.header ? r2.header({ props: i4 }) : Zr.createVNode(Am, i4, d2);
          }, default: () => Zr.createVNode(Mm, { items: s2 }, r2) }) : r2.item ? r2.item({ props: l2 }) : Zr.createVNode(Am, Zr.mergeProps(l2, { value: t2.returnObject ? c2 : l2.value }), d2);
        });
      };
    } }), Bm = propsFactory({ items: { type: Array, default: () => [] }, itemTitle: { type: [String, Array, Function], default: "title" }, itemValue: { type: [String, Array, Function], default: "value" }, itemChildren: { type: [Boolean, String, Array, Function], default: "children" }, itemProps: { type: [Boolean, String, Array, Function], default: "props" }, returnObject: Boolean, valueComparator: { type: Function, default: deepEqual } }, "list-items");
    function transformItem(t2, e2) {
      const r2 = getPropertyFromItem(e2, t2.itemType, "item"), n2 = function(t3) {
        return "string" == typeof t3 || "number" == typeof t3 || "boolean" == typeof t3;
      }(e2) ? e2 : getPropertyFromItem(e2, t2.itemTitle), i2 = getPropertyFromItem(e2, t2.itemValue, void 0), o2 = getPropertyFromItem(e2, t2.itemChildren), a2 = { title: n2, value: i2, ...true === t2.itemProps ? omit(e2, ["children"]) : getPropertyFromItem(e2, t2.itemProps) };
      return { type: r2, title: a2.title, value: a2.value, props: a2, children: "item" === r2 && o2 ? transformItems(t2, o2) : void 0, raw: e2 };
    }
    function transformItems(t2, e2) {
      const r2 = [];
      for (const n2 of e2)
        r2.push(transformItem(t2, n2));
      return r2;
    }
    const Dm = propsFactory({ baseColor: String, activeColor: String, activeClass: String, bgColor: String, disabled: Boolean, lines: { type: [Boolean, String], default: "one" }, slim: Boolean, nav: Boolean, ...hm({ selectStrategy: "single-leaf", openStrategy: "list" }), ...vd(), ...mc(), ...bd(), ...$d(), ...wd(), itemType: { type: String, default: "type" }, ...Bm(), ...kd(), ...Sd(), ...$c(), ...Ed({ variant: "text" }) }, "VList"), jm = genericComponent()({ name: "VList", props: Dm(), emits: { "update:selected": (t2) => true, "update:opened": (t2) => true, "click:open": (t2) => true, "click:select": (t2) => true }, setup(t2, e2) {
      let { slots: r2 } = e2;
      const { items: n2 } = function(t3) {
        return { items: Zr.computed(() => transformItems(t3, t3.items)) };
      }(t2), { themeClasses: i2 } = provideTheme(t2), { backgroundColorClasses: o2, backgroundColorStyles: a2 } = useBackgroundColor(Zr.toRef(t2, "bgColor")), { borderClasses: s2 } = useBorder(t2), { densityClasses: l2 } = useDensity(t2), { dimensionStyles: p2 } = useDimension(t2), { elevationClasses: c2 } = useElevation(t2), { roundedClasses: d2 } = useRounded(t2), { open: m2, select: u2 } = useNested(t2), h2 = Zr.computed(() => t2.lines ? `v-list--${t2.lines}-line` : void 0), g2 = Zr.toRef(t2, "activeColor"), x2 = Zr.toRef(t2, "baseColor"), v2 = Zr.toRef(t2, "color");
      createList(), provideDefaults({ VListGroup: { activeColor: g2, baseColor: x2, color: v2 }, VListItem: { activeClass: Zr.toRef(t2, "activeClass"), activeColor: g2, baseColor: x2, color: v2, density: Zr.toRef(t2, "density"), disabled: Zr.toRef(t2, "disabled"), lines: Zr.toRef(t2, "lines"), nav: Zr.toRef(t2, "nav"), slim: Zr.toRef(t2, "slim"), variant: Zr.toRef(t2, "variant") } });
      const y2 = Zr.shallowRef(false), b2 = Zr.ref();
      function onFocusin(t3) {
        y2.value = true;
      }
      function onFocusout(t3) {
        y2.value = false;
      }
      function onFocus(t3) {
        var e3;
        y2.value || t3.relatedTarget && (null == (e3 = b2.value) ? void 0 : e3.contains(t3.relatedTarget)) || focus();
      }
      function onKeydown(t3) {
        if (b2.value) {
          if ("ArrowDown" === t3.key)
            focus("next");
          else if ("ArrowUp" === t3.key)
            focus("prev");
          else if ("Home" === t3.key)
            focus("first");
          else {
            if ("End" !== t3.key)
              return;
            focus("last");
          }
          t3.preventDefault();
        }
      }
      function focus(t3) {
        if (b2.value)
          return focusChild(b2.value, t3);
      }
      return useRender(() => Zr.createVNode(t2.tag, { ref: b2, class: ["v-list", { "v-list--disabled": t2.disabled, "v-list--nav": t2.nav }, i2.value, o2.value, s2.value, l2.value, c2.value, h2.value, d2.value, t2.class], style: [a2.value, p2.value, t2.style], tabindex: t2.disabled || y2.value ? -1 : 0, role: "listbox", "aria-activedescendant": void 0, onFocusin, onFocusout, onFocus, onKeydown }, { default: () => [Zr.createVNode(Mm, { items: n2.value, returnObject: t2.returnObject }, r2)] })), { open: m2, select: u2, focus };
    } });
    function elementToViewport(t2, e2) {
      return { x: t2.x + e2.x, y: t2.y + e2.y };
    }
    function anchorToPoint(t2, e2) {
      if ("top" === t2.side || "bottom" === t2.side) {
        const { side: r2, align: n2 } = t2;
        return elementToViewport({ x: "left" === n2 ? 0 : "center" === n2 ? e2.width / 2 : "right" === n2 ? e2.width : n2, y: "top" === r2 ? 0 : "bottom" === r2 ? e2.height : r2 }, e2);
      }
      if ("left" === t2.side || "right" === t2.side) {
        const { side: r2, align: n2 } = t2;
        return elementToViewport({ x: "left" === r2 ? 0 : "right" === r2 ? e2.width : r2, y: "top" === n2 ? 0 : "center" === n2 ? e2.height / 2 : "bottom" === n2 ? e2.height : n2 }, e2);
      }
      return elementToViewport({ x: e2.width / 2, y: e2.height / 2 }, e2);
    }
    const Fm = { static: function() {
    }, connected: function(t2, e2, r2) {
      (Array.isArray(t2.target.value) || function(t3) {
        for (; t3; ) {
          if ("fixed" === window.getComputedStyle(t3).position)
            return true;
          t3 = t3.offsetParent;
        }
        return false;
      }(t2.target.value)) && Object.assign(r2.value, { position: "fixed", top: 0, [t2.isRtl.value ? "right" : "left"]: 0 });
      const { preferredAnchor: n2, preferredOrigin: i2 } = destructComputed(() => {
        const r3 = parseAnchor(e2.location, t2.isRtl.value), n3 = "overlap" === e2.origin ? r3 : "auto" === e2.origin ? flipSide(r3) : parseAnchor(e2.origin, t2.isRtl.value);
        return r3.side === n3.side && r3.align === flipAlign(n3).align ? { preferredAnchor: flipCorner(r3), preferredOrigin: flipCorner(n3) } : { preferredAnchor: r3, preferredOrigin: n3 };
      }), [o2, a2, s2, l2] = ["minWidth", "minHeight", "maxWidth", "maxHeight"].map((t3) => Zr.computed(() => {
        const r3 = parseFloat(e2[t3]);
        return isNaN(r3) ? 1 / 0 : r3;
      })), p2 = Zr.computed(() => {
        if (Array.isArray(e2.offset))
          return e2.offset;
        if ("string" == typeof e2.offset) {
          const t3 = e2.offset.split(" ").map(parseFloat);
          return t3.length < 2 && t3.push(0), t3;
        }
        return "number" == typeof e2.offset ? [e2.offset, 0] : [0, 0];
      });
      let c2 = false;
      const d2 = new ResizeObserver(() => {
        c2 && updateLocation();
      });
      function updateLocation() {
        if (c2 = false, requestAnimationFrame(() => {
          requestAnimationFrame(() => c2 = true);
        }), !t2.target.value || !t2.contentEl.value)
          return;
        const e3 = getTargetBox(t2.target.value), d3 = function(t3, e4) {
          e4 ? t3.style.removeProperty("left") : t3.style.removeProperty("right");
          const r3 = nullifyTransforms(t3);
          e4 ? r3.x += parseFloat(t3.style.right || 0) : r3.x -= parseFloat(t3.style.left || 0);
          return r3.y -= parseFloat(t3.style.top || 0), r3;
        }(t2.contentEl.value, t2.isRtl.value), m2 = getScrollParents(t2.contentEl.value);
        m2.length || (m2.push(document.documentElement), t2.contentEl.value.style.top && t2.contentEl.value.style.left || (d3.x -= parseFloat(document.documentElement.style.getPropertyValue("--v-body-scroll-x") || 0), d3.y -= parseFloat(document.documentElement.style.getPropertyValue("--v-body-scroll-y") || 0)));
        const u2 = m2.reduce((t3, e4) => {
          const r3 = e4.getBoundingClientRect(), n3 = new Box({ x: e4 === document.documentElement ? 0 : r3.x, y: e4 === document.documentElement ? 0 : r3.y, width: e4.clientWidth, height: e4.clientHeight });
          return t3 ? new Box({ x: Math.max(t3.left, n3.left), y: Math.max(t3.top, n3.top), width: Math.min(t3.right, n3.right) - Math.max(t3.left, n3.left), height: Math.min(t3.bottom, n3.bottom) - Math.max(t3.top, n3.top) }) : n3;
        }, void 0);
        u2.x += 12, u2.y += 12, u2.width -= 24, u2.height -= 24;
        let h2 = { anchor: n2.value, origin: i2.value };
        function checkOverflow(t3) {
          const r3 = new Box(d3), n3 = anchorToPoint(t3.anchor, e3), i3 = anchorToPoint(t3.origin, r3);
          let { x: o3, y: a3 } = (m3 = i3, { x: (c3 = n3).x - m3.x, y: c3.y - m3.y });
          var c3, m3;
          switch (t3.anchor.side) {
            case "top":
              a3 -= p2.value[0];
              break;
            case "bottom":
              a3 += p2.value[0];
              break;
            case "left":
              o3 -= p2.value[0];
              break;
            case "right":
              o3 += p2.value[0];
          }
          switch (t3.anchor.align) {
            case "top":
              a3 -= p2.value[1];
              break;
            case "bottom":
              a3 += p2.value[1];
              break;
            case "left":
              o3 -= p2.value[1];
              break;
            case "right":
              o3 += p2.value[1];
          }
          r3.x += o3, r3.y += a3, r3.width = Math.min(r3.width, s2.value), r3.height = Math.min(r3.height, l2.value);
          return { overflows: getOverflow(r3, u2), x: o3, y: a3 };
        }
        let g2 = 0, x2 = 0;
        const v2 = { x: 0, y: 0 }, y2 = { x: false, y: false };
        let b2 = -1;
        for (; ; ) {
          if (b2++ > 10) {
            consoleError("Infinite loop detected in connectedLocationStrategy");
            break;
          }
          const { x: t3, y: e4, overflows: r3 } = checkOverflow(h2);
          g2 += t3, x2 += e4, d3.x += t3, d3.y += e4;
          {
            const t4 = getAxis(h2.anchor), e5 = r3.x.before || r3.x.after, n3 = r3.y.before || r3.y.after;
            let i3 = false;
            if (["x", "y"].forEach((o3) => {
              if ("x" === o3 && e5 && !y2.x || "y" === o3 && n3 && !y2.y) {
                const e6 = { anchor: { ...h2.anchor }, origin: { ...h2.origin } }, n4 = "x" === o3 ? "y" === t4 ? flipAlign : flipSide : "y" === t4 ? flipSide : flipAlign;
                e6.anchor = n4(e6.anchor), e6.origin = n4(e6.origin);
                const { overflows: a3 } = checkOverflow(e6);
                (a3[o3].before <= r3[o3].before && a3[o3].after <= r3[o3].after || a3[o3].before + a3[o3].after < (r3[o3].before + r3[o3].after) / 2) && (h2 = e6, i3 = y2[o3] = true);
              }
            }), i3)
              continue;
          }
          r3.x.before && (g2 += r3.x.before, d3.x += r3.x.before), r3.x.after && (g2 -= r3.x.after, d3.x -= r3.x.after), r3.y.before && (x2 += r3.y.before, d3.y += r3.y.before), r3.y.after && (x2 -= r3.y.after, d3.y -= r3.y.after);
          {
            const t4 = getOverflow(d3, u2);
            v2.x = u2.width - t4.x.before - t4.x.after, v2.y = u2.height - t4.y.before - t4.y.after, g2 += t4.x.before, d3.x += t4.x.before, x2 += t4.y.before, d3.y += t4.y.before;
          }
          break;
        }
        const w2 = getAxis(h2.anchor);
        return Object.assign(r2.value, { "--v-overlay-anchor-origin": `${h2.anchor.side} ${h2.anchor.align}`, transformOrigin: `${h2.origin.side} ${h2.origin.align}`, top: convertToUnit(pixelRound(x2)), left: t2.isRtl.value ? void 0 : convertToUnit(pixelRound(g2)), right: t2.isRtl.value ? convertToUnit(pixelRound(-g2)) : void 0, minWidth: convertToUnit("y" === w2 ? Math.min(o2.value, e3.width) : o2.value), maxWidth: convertToUnit(pixelCeil(clamp(v2.x, o2.value === 1 / 0 ? 0 : o2.value, s2.value))), maxHeight: convertToUnit(pixelCeil(clamp(v2.y, a2.value === 1 / 0 ? 0 : a2.value, l2.value))) }), { available: v2, contentBox: d3 };
      }
      return Zr.watch([t2.target, t2.contentEl], (t3, e3) => {
        let [r3, n3] = t3, [i3, o3] = e3;
        i3 && !Array.isArray(i3) && d2.unobserve(i3), r3 && !Array.isArray(r3) && d2.observe(r3), o3 && d2.unobserve(o3), n3 && d2.observe(n3);
      }, { immediate: true }), Zr.onScopeDispose(() => {
        d2.disconnect();
      }), Zr.watch(() => [n2.value, i2.value, e2.offset, e2.minWidth, e2.minHeight, e2.maxWidth, e2.maxHeight], () => updateLocation()), Zr.nextTick(() => {
        const t3 = updateLocation();
        if (!t3)
          return;
        const { available: e3, contentBox: r3 } = t3;
        r3.height > e3.y && requestAnimationFrame(() => {
          updateLocation(), requestAnimationFrame(() => {
            updateLocation();
          });
        });
      }), { updateLocation };
    } }, $m = propsFactory({ locationStrategy: { type: [String, Function], default: "static", validator: (t2) => "function" == typeof t2 || t2 in Fm }, location: { type: String, default: "bottom" }, origin: { type: String, default: "auto" }, offset: [Number, String, Array] }, "VOverlay-location-strategies");
    function pixelRound(t2) {
      return Math.round(t2 * devicePixelRatio) / devicePixelRatio;
    }
    function pixelCeil(t2) {
      return Math.ceil(t2 * devicePixelRatio) / devicePixelRatio;
    }
    let Vm = true;
    const zm = [];
    let Um = -1;
    function run() {
      cancelAnimationFrame(Um), Um = requestAnimationFrame(() => {
        const t2 = zm.shift();
        t2 && t2(), zm.length ? run() : Vm = true;
      });
    }
    const Hm = { none: null, close: function(t2) {
      var e2;
      bindScroll(null != (e2 = t2.targetEl.value) ? e2 : t2.contentEl.value, function(e3) {
        t2.isActive.value = false;
      });
    }, block: function(t2, e2) {
      var r2;
      const n2 = null == (r2 = t2.root.value) ? void 0 : r2.offsetParent, i2 = [.../* @__PURE__ */ new Set([...getScrollParents(t2.targetEl.value, e2.contained ? n2 : void 0), ...getScrollParents(t2.contentEl.value, e2.contained ? n2 : void 0)])].filter((t3) => !t3.classList.contains("v-overlay-scroll-blocked")), o2 = window.innerWidth - document.documentElement.offsetWidth, a2 = (s2 = n2 || document.documentElement, hasScrollbar(s2) && s2);
      var s2;
      a2 && t2.root.value.classList.add("v-overlay--scroll-blocked");
      i2.forEach((t3, e3) => {
        t3.style.setProperty("--v-body-scroll-x", convertToUnit(-t3.scrollLeft)), t3.style.setProperty("--v-body-scroll-y", convertToUnit(-t3.scrollTop)), t3 !== document.documentElement && t3.style.setProperty("--v-scrollbar-offset", convertToUnit(o2)), t3.classList.add("v-overlay-scroll-blocked");
      }), Zr.onScopeDispose(() => {
        i2.forEach((t3, e3) => {
          const r3 = parseFloat(t3.style.getPropertyValue("--v-body-scroll-x")), n3 = parseFloat(t3.style.getPropertyValue("--v-body-scroll-y"));
          t3.style.removeProperty("--v-body-scroll-x"), t3.style.removeProperty("--v-body-scroll-y"), t3.style.removeProperty("--v-scrollbar-offset"), t3.classList.remove("v-overlay-scroll-blocked"), t3.scrollLeft = -r3, t3.scrollTop = -n3;
        }), a2 && t2.root.value.classList.remove("v-overlay--scroll-blocked");
      });
    }, reposition: function(t2, e2, r2) {
      let n2 = false, i2 = -1, o2 = -1;
      function update(e3) {
        var r3;
        r3 = () => {
          var r4, i3;
          const o3 = performance.now();
          null == (i3 = (r4 = t2.updateLocation).value) || i3.call(r4, e3);
          const a2 = performance.now() - o3;
          n2 = a2 / (1e3 / 60) > 2;
        }, !Vm || zm.length ? (zm.push(r3), run()) : (Vm = false, r3(), run());
      }
      o2 = ("undefined" == typeof requestIdleCallback ? (t3) => t3() : requestIdleCallback)(() => {
        r2.run(() => {
          var e3;
          bindScroll(null != (e3 = t2.targetEl.value) ? e3 : t2.contentEl.value, (t3) => {
            n2 ? (cancelAnimationFrame(i2), i2 = requestAnimationFrame(() => {
              i2 = requestAnimationFrame(() => {
                update(t3);
              });
            })) : update(t3);
          });
        });
      }), Zr.onScopeDispose(() => {
        "undefined" != typeof cancelIdleCallback && cancelIdleCallback(o2), cancelAnimationFrame(i2);
      });
    } }, qm = propsFactory({ scrollStrategy: { type: [String, Function], default: "block", validator: (t2) => "function" == typeof t2 || t2 in Hm } }, "VOverlay-scroll-strategies");
    function bindScroll(t2, e2) {
      const r2 = [document, ...getScrollParents(t2)];
      r2.forEach((t3) => {
        t3.addEventListener("scroll", e2, { passive: true });
      }), Zr.onScopeDispose(() => {
        r2.forEach((t3) => {
          t3.removeEventListener("scroll", e2);
        });
      });
    }
    const Wm = Symbol.for("vuetify:v-menu"), Km = propsFactory({ closeDelay: [Number, String], openDelay: [Number, String] }, "delay");
    const Gm = propsFactory({ target: [String, Object], activator: [String, Object], activatorProps: { type: Object, default: () => ({}) }, openOnClick: { type: Boolean, default: void 0 }, openOnHover: Boolean, openOnFocus: { type: Boolean, default: void 0 }, closeOnContentClick: Boolean, ...Km() }, "VOverlay-activator");
    function useActivator(t2, e2) {
      let { isActive: r2, isTop: n2 } = e2;
      const i2 = getCurrentInstance("useActivator"), o2 = Zr.ref();
      let a2 = false, s2 = false, l2 = true;
      const p2 = Zr.computed(() => t2.openOnFocus || null == t2.openOnFocus && t2.openOnHover), c2 = Zr.computed(() => t2.openOnClick || null == t2.openOnClick && !t2.openOnHover && !p2.value), { runOpenDelay: d2, runCloseDelay: m2 } = function(t3, e3) {
        const runDelayFactory = (t4) => () => Promise.resolve(true);
        return { runCloseDelay: runDelayFactory(), runOpenDelay: runDelayFactory() };
      }(), u2 = Zr.ref(), availableEvents_onClick = (t3) => {
        t3.stopPropagation(), o2.value = t3.currentTarget || t3.target, r2.value || (u2.value = [t3.clientX, t3.clientY]), r2.value = !r2.value;
      }, availableEvents_onMouseenter = (t3) => {
        var e3;
        (null == (e3 = t3.sourceCapabilities) ? void 0 : e3.firesTouchEvents) || (a2 = true, o2.value = t3.currentTarget || t3.target, d2());
      }, availableEvents_onMouseleave = (t3) => {
        a2 = false, m2();
      }, availableEvents_onFocus = (t3) => {
        t3.target, s2 = true, t3.stopPropagation(), o2.value = t3.currentTarget || t3.target, d2();
      }, availableEvents_onBlur = (t3) => {
        s2 = false, t3.stopPropagation(), m2();
      }, h2 = Zr.computed(() => {
        const e3 = {};
        return c2.value && (e3.onClick = availableEvents_onClick), t2.openOnHover && (e3.onMouseenter = availableEvents_onMouseenter, e3.onMouseleave = availableEvents_onMouseleave), p2.value && (e3.onFocus = availableEvents_onFocus, e3.onBlur = availableEvents_onBlur), e3;
      }), g2 = Zr.computed(() => {
        const e3 = {};
        if (t2.openOnHover && (e3.onMouseenter = () => {
          a2 = true, d2();
        }, e3.onMouseleave = () => {
          a2 = false, m2();
        }), p2.value && (e3.onFocusin = () => {
          s2 = true, d2();
        }, e3.onFocusout = () => {
          s2 = false, m2();
        }), t2.closeOnContentClick) {
          const t3 = Zr.inject(Wm, null);
          e3.onClick = () => {
            r2.value = false, null == t3 || t3.closeParents();
          };
        }
        return e3;
      }), x2 = Zr.computed(() => {
        const e3 = {};
        return t2.openOnHover && (e3.onMouseenter = () => {
          l2 && (a2 = true, l2 = false, d2());
        }, e3.onMouseleave = () => {
          a2 = false, m2();
        }), e3;
      });
      Zr.watch(n2, (e3) => {
        !e3 || (!t2.openOnHover || a2 || p2.value && s2) && (!p2.value || s2 || t2.openOnHover && a2) || (r2.value = false);
      }), Zr.watch(r2, (t3) => {
        t3 || setTimeout(() => {
          u2.value = void 0;
        });
      }, { flush: "post" });
      const v2 = Zr.ref();
      Zr.watchEffect(() => {
        v2.value && Zr.nextTick(() => {
          o2.value = refElement(v2.value);
        });
      });
      const y2 = Zr.ref(), b2 = Zr.computed(() => "cursor" === t2.target && u2.value ? u2.value : y2.value ? refElement(y2.value) : getTarget(t2.target, i2) || o2.value), w2 = Zr.computed(() => Array.isArray(b2.value) ? void 0 : b2.value);
      let k2;
      return Zr.watch(() => !!t2.activator, (t3) => {
        k2 && k2.stop();
      }, { flush: "post", immediate: true }), Zr.onScopeDispose(() => {
        null == k2 || k2.stop();
      }), { activatorEl: o2, activatorRef: v2, target: b2, targetEl: w2, targetRef: y2, activatorEvents: h2, contentEvents: g2, scrimEvents: x2 };
    }
    function getTarget(t2, e2) {
      var r2, n2;
      if (!t2)
        return;
      let i2;
      if ("parent" === t2) {
        let t3 = null == (n2 = null == (r2 = null == e2 ? void 0 : e2.proxy) ? void 0 : r2.$el) ? void 0 : n2.parentNode;
        for (; null == t3 ? void 0 : t3.hasAttribute("data-no-activator"); )
          t3 = t3.parentNode;
        i2 = t3;
      } else
        i2 = "string" == typeof t2 ? document.querySelector(t2) : "$el" in t2 ? t2.$el : t2;
      return i2;
    }
    const Jm = propsFactory({ eager: Boolean }, "lazy");
    function useScopeId() {
      const t2 = getCurrentInstance("useScopeId").vnode.scopeId;
      return { scopeId: t2 ? { [t2]: "" } : void 0 };
    }
    const Ym = Symbol.for("vuetify:stack"), Xm = Zr.reactive([]);
    function defaultConditional() {
      return true;
    }
    function checkEvent(t2, e2, r2) {
      if (!t2 || false === checkIsActive(t2, r2))
        return false;
      const n2 = attachedRoot(e2);
      if ("undefined" != typeof ShadowRoot && n2 instanceof ShadowRoot && n2.host === t2.target)
        return false;
      const i2 = ("object" == typeof r2.value && r2.value.include || (() => []))();
      return i2.push(e2), !i2.some((e3) => null == e3 ? void 0 : e3.contains(t2.target));
    }
    function checkIsActive(t2, e2) {
      return ("object" == typeof e2.value && e2.value.closeConditional || defaultConditional)(t2);
    }
    function handleShadow(t2, e2) {
      const r2 = attachedRoot(t2);
      e2(document), "undefined" != typeof ShadowRoot && r2 instanceof ShadowRoot && e2(r2);
    }
    const Qm = { mounted(t2, e2) {
      const onClick = (r2) => function(t3, e3, r3) {
        const n2 = "function" == typeof r3.value ? r3.value : r3.value.handler;
        e3._clickOutside.lastMousedownWasOutside && checkEvent(t3, e3, r3) && setTimeout(() => {
          checkIsActive(t3, r3) && n2 && n2(t3);
        }, 0);
      }(r2, t2, e2), onMousedown = (r2) => {
        t2._clickOutside.lastMousedownWasOutside = checkEvent(r2, t2, e2);
      };
      handleShadow(t2, (t3) => {
        t3.addEventListener("click", onClick, true), t3.addEventListener("mousedown", onMousedown, true);
      }), t2._clickOutside || (t2._clickOutside = { lastMousedownWasOutside: false }), t2._clickOutside[e2.instance.$.uid] = { onClick, onMousedown };
    }, unmounted(t2, e2) {
      t2._clickOutside && (handleShadow(t2, (r2) => {
        var n2;
        if (!r2 || !(null == (n2 = t2._clickOutside) ? void 0 : n2[e2.instance.$.uid]))
          return;
        const { onClick: i2, onMousedown: o2 } = t2._clickOutside[e2.instance.$.uid];
        r2.removeEventListener("click", i2, true), r2.removeEventListener("mousedown", o2, true);
      }), delete t2._clickOutside[e2.instance.$.uid]);
    } };
    function Scrim(t2) {
      const { modelValue: e2, color: r2, ...n2 } = t2;
      return Zr.createVNode(Zr.Transition, { name: "fade-transition", appear: true }, { default: () => [t2.modelValue && Zr.createVNode("div", Zr.mergeProps({ class: ["v-overlay__scrim", t2.color.backgroundColorClasses.value], style: t2.color.backgroundColorStyles.value }, n2), null)] });
    }
    const Zm = propsFactory({ absolute: Boolean, attach: [Boolean, String, Object], closeOnBack: { type: Boolean, default: true }, contained: Boolean, contentClass: null, contentProps: null, disabled: Boolean, noClickAnimation: Boolean, modelValue: Boolean, persistent: Boolean, scrim: { type: [Boolean, String], default: true }, zIndex: { type: [Number, String], default: 2e3 }, ...Gm(), ...mc(), ...$d(), ...Jm(), ...$m(), ...qm(), ...$c(), ...fm() }, "VOverlay"), tu = genericComponent()({ name: "VOverlay", directives: { ClickOutside: Qm }, inheritAttrs: false, props: { _disableGlobalStack: Boolean, ...Zm() }, emits: { "click:outside": (t2) => true, "update:modelValue": (t2) => true, afterLeave: () => true }, setup(t2, e2) {
      let { slots: r2, attrs: n2, emit: i2 } = e2;
      const o2 = useProxiedModel(t2, "modelValue"), a2 = Zr.computed({ get: () => o2.value, set: (e3) => {
        e3 && t2.disabled || (o2.value = e3);
      } }), { teleportTarget: s2 } = function(t3) {
        return { teleportTarget: Zr.computed(() => {
          t3.value;
        }) };
      }(Zr.computed(() => t2.attach || t2.contained)), { themeClasses: l2 } = provideTheme(t2), { rtlClasses: p2, isRtl: c2 } = useRtl(), { hasContent: d2, onAfterLeave: m2 } = function(t3, e3) {
        const r3 = Zr.shallowRef(false), n3 = Zr.computed(() => r3.value || t3.eager || e3.value);
        return Zr.watch(e3, () => r3.value = true), { isBooted: r3, hasContent: n3, onAfterLeave: function() {
          t3.eager || (r3.value = false);
        } };
      }(t2, a2), u2 = useBackgroundColor(Zr.computed(() => "string" == typeof t2.scrim ? t2.scrim : null)), { globalTop: h2, localTop: g2, stackStyles: x2 } = function(t3, e3, r3) {
        const n3 = getCurrentInstance("useStack"), i3 = !r3, o3 = Zr.inject(Ym, void 0), a3 = Zr.reactive({ activeChildren: /* @__PURE__ */ new Set() });
        Zr.provide(Ym, a3);
        const s3 = Zr.shallowRef(+e3.value);
        useToggleScope(t3, () => {
          var t4;
          const r4 = null == (t4 = Xm.at(-1)) ? void 0 : t4[1];
          s3.value = r4 ? r4 + 10 : +e3.value, i3 && Xm.push([n3.uid, s3.value]), null == o3 || o3.activeChildren.add(n3.uid), Zr.onScopeDispose(() => {
            if (i3) {
              const t5 = Zr.toRaw(Xm).findIndex((t6) => t6[0] === n3.uid);
              Xm.splice(t5, 1);
            }
            null == o3 || o3.activeChildren.delete(n3.uid);
          });
        });
        const l3 = Zr.shallowRef(true);
        i3 && Zr.watchEffect(() => {
          var t4;
          const e4 = (null == (t4 = Xm.at(-1)) ? void 0 : t4[0]) === n3.uid;
          setTimeout(() => l3.value = e4);
        });
        const p3 = Zr.computed(() => !a3.activeChildren.size);
        return { globalTop: Zr.readonly(l3), localTop: p3, stackStyles: Zr.computed(() => ({ zIndex: s3.value })) };
      }(a2, Zr.toRef(t2, "zIndex"), t2._disableGlobalStack), { activatorEl: v2, activatorRef: y2, target: b2, targetEl: w2, targetRef: k2, activatorEvents: S2, contentEvents: C2, scrimEvents: _2 } = useActivator(t2, { isActive: a2, isTop: g2 }), { dimensionStyles: P2 } = useDimension(t2), T2 = Zr.shallowRef(false), { scopeId: A2 } = useScopeId();
      Zr.watch(() => t2.disabled, (t3) => {
        t3 && (a2.value = false);
      });
      const I2 = Zr.ref(), N2 = Zr.ref(), { contentStyles: R2, updateLocation: O2 } = { contentStyles: Zr.ref({}), updateLocation: Zr.ref() };
      function onClickOutside(e3) {
        i2("click:outside", e3), t2.persistent ? animateClick() : a2.value = false;
      }
      function closeConditional() {
        return a2.value && h2.value;
      }
      useRouter(), useToggleScope(() => t2.closeOnBack, () => {
      });
      const L2 = Zr.ref();
      function animateClick() {
        t2.noClickAnimation || N2.value && animate(N2.value, [{ transformOrigin: "center" }, { transform: "scale(1.03)" }, { transformOrigin: "center" }], { duration: 150, easing: md });
      }
      return Zr.watch(() => a2.value && (t2.absolute || t2.contained) && null == s2.value, (t3) => {
        if (t3) {
          const t4 = function(t5) {
            let e3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            for (; t5; ) {
              if (e3 ? isPotentiallyScrollable(t5) : hasScrollbar(t5))
                return t5;
              t5 = t5.parentElement;
            }
            return document.scrollingElement;
          }(I2.value);
          t4 && t4 !== document.scrollingElement && (L2.value = t4.scrollTop);
        }
      }), useRender(() => {
        var e3;
        return Zr.createVNode(Zr.Fragment, null, [null == (e3 = r2.activator) ? void 0 : e3.call(r2, { isActive: a2.value, props: Zr.mergeProps({ ref: y2, targetRef: k2 }, S2.value, t2.activatorProps) }), T2.value && d2.value && Zr.createVNode(Zr.Teleport, { disabled: !s2.value, to: s2.value }, { default: () => [Zr.createVNode("div", Zr.mergeProps({ class: ["v-overlay", { "v-overlay--absolute": t2.absolute || t2.contained, "v-overlay--active": a2.value, "v-overlay--contained": t2.contained }, l2.value, p2.value, t2.class], style: [x2.value, { top: convertToUnit(L2.value) }, t2.style], ref: I2 }, A2, n2), [Zr.createVNode(Scrim, Zr.mergeProps({ color: u2, modelValue: a2.value && !!t2.scrim }, _2.value), null), Zr.createVNode(MaybeTransition, { appear: true, persisted: true, transition: t2.transition, target: b2.value, onAfterLeave: () => {
          m2(), i2("afterLeave");
        } }, { default: () => {
          var e4;
          return [Zr.withDirectives(Zr.createVNode("div", Zr.mergeProps({ ref: N2, class: ["v-overlay__content", t2.contentClass], style: [P2.value, R2.value] }, C2.value, t2.contentProps), [null == (e4 = r2.default) ? void 0 : e4.call(r2, { isActive: a2 })]), [[Zr.vShow, a2.value], [Zr.resolveDirective("click-outside"), { handler: onClickOutside, closeConditional, include: () => [v2.value] }]])];
        } })])] })]);
      }), { activatorEl: v2, target: b2, animateClick, contentEl: N2, globalTop: h2, localTop: g2, updateLocation: O2 };
    } }), eu = Symbol("Forwarded refs");
    function getDescriptor(t2, e2) {
      let r2 = t2;
      for (; r2; ) {
        const t3 = Reflect.getOwnPropertyDescriptor(r2, e2);
        if (t3)
          return t3;
        r2 = Object.getPrototypeOf(r2);
      }
    }
    function forwardRefs(t2) {
      for (var e2 = arguments.length, r2 = new Array(e2 > 1 ? e2 - 1 : 0), n2 = 1; n2 < e2; n2++)
        r2[n2 - 1] = arguments[n2];
      return t2[eu] = r2, new Proxy(t2, { get(t3, e3) {
        if (Reflect.has(t3, e3))
          return Reflect.get(t3, e3);
        if ("symbol" != typeof e3 && !e3.startsWith("$") && !e3.startsWith("__")) {
          for (const t4 of r2)
            if (t4.value && Reflect.has(t4.value, e3)) {
              const r3 = Reflect.get(t4.value, e3);
              return "function" == typeof r3 ? r3.bind(t4.value) : r3;
            }
        }
      }, has(t3, e3) {
        if (Reflect.has(t3, e3))
          return true;
        if ("symbol" == typeof e3 || e3.startsWith("$") || e3.startsWith("__"))
          return false;
        for (const t4 of r2)
          if (t4.value && Reflect.has(t4.value, e3))
            return true;
        return false;
      }, set(t3, e3, n3) {
        if (Reflect.has(t3, e3))
          return Reflect.set(t3, e3, n3);
        if ("symbol" == typeof e3 || e3.startsWith("$") || e3.startsWith("__"))
          return false;
        for (const t4 of r2)
          if (t4.value && Reflect.has(t4.value, e3))
            return Reflect.set(t4.value, e3, n3);
        return false;
      }, getOwnPropertyDescriptor(t3, e3) {
        var n3, i2;
        const o2 = Reflect.getOwnPropertyDescriptor(t3, e3);
        if (o2)
          return o2;
        if ("symbol" != typeof e3 && !e3.startsWith("$") && !e3.startsWith("__")) {
          for (const t4 of r2) {
            if (!t4.value)
              continue;
            const r3 = null != (n3 = getDescriptor(t4.value, e3)) ? n3 : "_" in t4.value ? getDescriptor(null == (i2 = t4.value._) ? void 0 : i2.setupState, e3) : void 0;
            if (r3)
              return r3;
          }
          for (const t4 of r2) {
            const r3 = t4.value && t4.value[eu];
            if (!r3)
              continue;
            const n4 = r3.slice();
            for (; n4.length; ) {
              const t5 = n4.shift(), r4 = getDescriptor(t5.value, e3);
              if (r4)
                return r4;
              const i3 = t5.value && t5.value[eu];
              i3 && n4.push(...i3);
            }
          }
        }
      } });
    }
    const ru = propsFactory({ id: String, ...omit(Zm({ closeDelay: 250, closeOnContentClick: true, locationStrategy: "connected", openDelay: 300, scrim: false, scrollStrategy: "reposition", transition: { component: im } }), ["absolute"]) }, "VMenu"), nu = genericComponent()({ name: "VMenu", props: ru(), emits: { "update:modelValue": (t2) => true }, setup(t2, e2) {
      let { slots: r2 } = e2;
      const n2 = useProxiedModel(t2, "modelValue"), { scopeId: i2 } = useScopeId(), o2 = getUid(), a2 = Zr.computed(() => t2.id || `v-menu-${o2}`), s2 = Zr.ref(), l2 = Zr.inject(Wm, null), p2 = Zr.shallowRef(0);
      async function onFocusIn(t3) {
        var e3, r3, i3;
        const o3 = t3.relatedTarget, a3 = t3.target;
        if (await Zr.nextTick(), n2.value && o3 !== a3 && (null == (e3 = s2.value) ? void 0 : e3.contentEl) && (null == (r3 = s2.value) ? void 0 : r3.globalTop) && ![document, s2.value.contentEl].includes(a3) && !s2.value.contentEl.contains(a3)) {
          null == (i3 = focusableChildren(s2.value.contentEl)[0]) || i3.focus();
        }
      }
      function onClickOutside() {
        null == l2 || l2.closeParents();
      }
      function onKeydown(e3) {
        var r3, i3, o3;
        if (!t2.disabled && "Tab" === e3.key) {
          getNextElement(focusableChildren(null == (r3 = s2.value) ? void 0 : r3.contentEl, false), e3.shiftKey ? "prev" : "next", (t3) => t3.tabIndex >= 0) || (n2.value = false, null == (o3 = null == (i3 = s2.value) ? void 0 : i3.activatorEl) || o3.focus());
        }
      }
      function onActivatorKeydown(e3) {
        var r3;
        if (t2.disabled)
          return;
        const i3 = null == (r3 = s2.value) ? void 0 : r3.contentEl;
        i3 && n2.value ? "ArrowDown" === e3.key ? (e3.preventDefault(), focusChild(i3, "next")) : "ArrowUp" === e3.key && (e3.preventDefault(), focusChild(i3, "prev")) : ["ArrowDown", "ArrowUp"].includes(e3.key) && (n2.value = true, e3.preventDefault(), setTimeout(() => setTimeout(() => onActivatorKeydown(e3))));
      }
      Zr.provide(Wm, { register() {
        ++p2.value;
      }, unregister() {
        --p2.value;
      }, closeParents() {
        setTimeout(() => {
          p2.value || (n2.value = false, null == l2 || l2.closeParents());
        }, 40);
      } }), Zr.watch(n2, (t3) => {
        t3 ? (null == l2 || l2.register(), document.addEventListener("focusin", onFocusIn, { once: true })) : (null == l2 || l2.unregister(), document.removeEventListener("focusin", onFocusIn));
      });
      const c2 = Zr.computed(() => Zr.mergeProps({ "aria-haspopup": "menu", "aria-expanded": String(n2.value), "aria-owns": a2.value, onKeydown: onActivatorKeydown }, t2.activatorProps));
      return useRender(() => {
        const e3 = tu.filterProps(t2);
        return Zr.createVNode(tu, Zr.mergeProps({ ref: s2, class: ["v-menu", t2.class], style: t2.style }, e3, { modelValue: n2.value, "onUpdate:modelValue": (t3) => n2.value = t3, absolute: true, activatorProps: c2.value, "onClick:outside": onClickOutside, onKeydown }, i2), { activator: r2.activator, default: function() {
          for (var t3 = arguments.length, e4 = new Array(t3), n3 = 0; n3 < t3; n3++)
            e4[n3] = arguments[n3];
          return Zr.createVNode(Od, { root: "VMenu" }, { default: () => {
            var t4;
            return [null == (t4 = r2.default) ? void 0 : t4.call(r2, ...e4)];
          } });
        } });
      }), forwardRefs({ id: a2, "\u03A8openChildren": p2 }, s2);
    } }), iu = propsFactory({ color: String, ...vd(), ...mc(), ...$d(), ...wd(), ...zd(), ...Kd(), ...kd(), ...Sd(), ...$c() }, "VSheet"), ou = genericComponent()({ name: "VSheet", props: iu(), setup(t2, e2) {
      let { slots: r2 } = e2;
      const { themeClasses: n2 } = provideTheme(t2), { backgroundColorClasses: i2, backgroundColorStyles: o2 } = useBackgroundColor(Zr.toRef(t2, "color")), { borderClasses: a2 } = useBorder(t2), { dimensionStyles: s2 } = useDimension(t2), { elevationClasses: l2 } = useElevation(t2), { locationStyles: p2 } = useLocation(t2), { positionClasses: c2 } = usePosition(t2), { roundedClasses: d2 } = useRounded(t2);
      return useRender(() => Zr.createVNode(t2.tag, { class: ["v-sheet", n2.value, i2.value, a2.value, l2.value, c2.value, d2.value, t2.class], style: [o2.value, s2.value, p2.value, t2.style] }, r2)), {};
    } }), au = Zr.defineComponent({ __name: "NodeBase", __ssrInlineRender: true, props: { title: { default: "NO TITLE" }, color: { default: "red" }, x: { default: 0 }, y: { default: 0 }, page_scale: { default: 1 }, dirty: { type: Boolean }, working: { type: Boolean, default: false } }, emits: ["update:x", "update:y", "update:dirty", "delete"], setup(t2, { emit: e2 }) {
      let r2 = t2, n2 = e2, i2 = 0, o2 = 0, a2 = Zr.ref(false);
      Zr.watch(() => r2.dirty, () => {
        console.log(a2.value, !r2.dirty), a2.value && !r2.dirty && setTimeout(() => n2("update:dirty", true), 100);
      });
      let s2 = Zr.ref(false);
      function open_menu(t3) {
        t3.preventDefault(), s2.value = true;
      }
      let l2 = Zr.ref(false);
      function start_hold(t3) {
        i2 = r2.x - t3.pageX / r2.page_scale, o2 = r2.y - t3.pageY / r2.page_scale, l2.value = true, document.addEventListener("mousemove", mousemove), document.addEventListener("mouseup", end_hold);
      }
      function end_hold(t3) {
        l2.value = false, document.removeEventListener("mousemove", mousemove), document.removeEventListener("mouseup", end_hold);
      }
      function mousemove(t3) {
        l2.value && (t3.preventDefault(), n2("update:x", t3.pageX / r2.page_scale + i2), n2("update:y", t3.pageY / r2.page_scale + o2));
      }
      let p2 = Zr.computed(() => r2.working ? "green" : a2.value ? "yellow" : "red");
      return (t3, e3, r3, n3) => {
        const i3 = { style: { "--a288afe6": t3.x, "--a288afe4": t3.y, "--22666edb": Zr.unref(p2) } };
        e3(`<div${Gs.ssrRenderAttrs(Zr.mergeProps({ id: "border", class: { animated_border: t3.working || Zr.unref(a2), static_border: t3.dirty && !t3.working && !Zr.unref(a2) } }, n3, i3))} data-v-babecec4>`), e3(Gs.ssrRenderComponent(ou, { id: "node", elevation: 24, color: Zr.unref(l2) ? "yellow-darken-4" : t3.color, rounded: "", width: "max-content", onContextmenu: open_menu }, { default: Zr.withCtx((e4, r4, n4, i4) => {
          if (!r4)
            return [Zr.createVNode("h1", { id: "", onMousedown: start_hold }, Zr.toDisplayString(t3.title), 33), Zr.renderSlot(t3.$slots, "default", {}, void 0, true)];
          r4(`<h1 id="" data-v-babecec4${i4}>${Gs.ssrInterpolate(t3.title)}</h1>`), Gs.ssrRenderSlot(t3.$slots, "default", {}, null, r4, n4, i4);
        }), _: 3 }, r3)), e3(Gs.ssrRenderComponent(nu, { activator: "parent", modelValue: Zr.unref(s2), "onUpdate:modelValue": (t4) => Zr.isRef(s2) ? s2.value = t4 : s2 = t4, "open-on-click": false }, { default: Zr.withCtx((e4, r4, n4, i4) => {
          if (!r4)
            return [Zr.createVNode(jm, null, { default: Zr.withCtx(() => [Zr.renderSlot(t3.$slots, "context", {}, void 0, true), Zr.createVNode(Am, null, { default: Zr.withCtx(() => [Zr.createVNode(em, { variant: "plain", disabled: t3.dirty || Zr.unref(a2), onClick: (e5) => t3.$emit("update:dirty", true) }, { default: Zr.withCtx(() => [Zr.createTextVNode("Invalidate Cache")]), _: 1 }, 8, ["disabled", "onClick"])]), _: 1 }), Zr.createVNode(Am, null, { default: Zr.withCtx(() => [Zr.createVNode(em, { variant: "plain", onClick: (e5) => {
              Zr.isRef(a2) ? a2.value = !Zr.unref(a2) : a2 = !Zr.unref(a2), t3.$emit("update:dirty", true);
            } }, { default: Zr.withCtx(() => [Zr.createTextVNode(Zr.toDisplayString(Zr.unref(a2) ? "Enable Cache" : "Disable Cache"), 1)]), _: 1 }, 8, ["onClick"])]), _: 1 }), Zr.createVNode(Am, null, { default: Zr.withCtx(() => [Zr.createVNode(em, { variant: "plain", color: "red", onClick: (e5) => t3.$emit("delete") }, { default: Zr.withCtx(() => [Zr.createTextVNode("Delete Node")]), _: 1 }, 8, ["onClick"])]), _: 1 })]), _: 3 })];
          r4(Gs.ssrRenderComponent(jm, null, { default: Zr.withCtx((e5, r5, n5, i5) => {
            if (!r5)
              return [Zr.renderSlot(t3.$slots, "context", {}, void 0, true), Zr.createVNode(Am, null, { default: Zr.withCtx(() => [Zr.createVNode(em, { variant: "plain", disabled: t3.dirty || Zr.unref(a2), onClick: (e6) => t3.$emit("update:dirty", true) }, { default: Zr.withCtx(() => [Zr.createTextVNode("Invalidate Cache")]), _: 1 }, 8, ["disabled", "onClick"])]), _: 1 }), Zr.createVNode(Am, null, { default: Zr.withCtx(() => [Zr.createVNode(em, { variant: "plain", onClick: (e6) => {
                Zr.isRef(a2) ? a2.value = !Zr.unref(a2) : a2 = !Zr.unref(a2), t3.$emit("update:dirty", true);
              } }, { default: Zr.withCtx(() => [Zr.createTextVNode(Zr.toDisplayString(Zr.unref(a2) ? "Enable Cache" : "Disable Cache"), 1)]), _: 1 }, 8, ["onClick"])]), _: 1 }), Zr.createVNode(Am, null, { default: Zr.withCtx(() => [Zr.createVNode(em, { variant: "plain", color: "red", onClick: (e6) => t3.$emit("delete") }, { default: Zr.withCtx(() => [Zr.createTextVNode("Delete Node")]), _: 1 }, 8, ["onClick"])]), _: 1 })];
            Gs.ssrRenderSlot(t3.$slots, "context", {}, null, r5, n5, i5), r5(Gs.ssrRenderComponent(Am, null, { default: Zr.withCtx((e6, r6, n6, i6) => {
              if (!r6)
                return [Zr.createVNode(em, { variant: "plain", disabled: t3.dirty || Zr.unref(a2), onClick: (e7) => t3.$emit("update:dirty", true) }, { default: Zr.withCtx(() => [Zr.createTextVNode("Invalidate Cache")]), _: 1 }, 8, ["disabled", "onClick"])];
              r6(Gs.ssrRenderComponent(em, { variant: "plain", disabled: t3.dirty || Zr.unref(a2), onClick: (e7) => t3.$emit("update:dirty", true) }, { default: Zr.withCtx((t4, e7, r7, n7) => {
                if (!e7)
                  return [Zr.createTextVNode("Invalidate Cache")];
                e7("Invalidate Cache");
              }), _: 1 }, n6, i6));
            }), _: 1 }, n5, i5)), r5(Gs.ssrRenderComponent(Am, null, { default: Zr.withCtx((e6, r6, n6, i6) => {
              if (!r6)
                return [Zr.createVNode(em, { variant: "plain", onClick: (e7) => {
                  Zr.isRef(a2) ? a2.value = !Zr.unref(a2) : a2 = !Zr.unref(a2), t3.$emit("update:dirty", true);
                } }, { default: Zr.withCtx(() => [Zr.createTextVNode(Zr.toDisplayString(Zr.unref(a2) ? "Enable Cache" : "Disable Cache"), 1)]), _: 1 }, 8, ["onClick"])];
              r6(Gs.ssrRenderComponent(em, { variant: "plain", onClick: (e7) => {
                Zr.isRef(a2) ? a2.value = !Zr.unref(a2) : a2 = !Zr.unref(a2), t3.$emit("update:dirty", true);
              } }, { default: Zr.withCtx((t4, e7, r7, n7) => {
                if (!e7)
                  return [Zr.createTextVNode(Zr.toDisplayString(Zr.unref(a2) ? "Enable Cache" : "Disable Cache"), 1)];
                e7(`${Gs.ssrInterpolate(Zr.unref(a2) ? "Enable Cache" : "Disable Cache")}`);
              }), _: 1 }, n6, i6));
            }), _: 1 }, n5, i5)), r5(Gs.ssrRenderComponent(Am, null, { default: Zr.withCtx((e6, r6, n6, i6) => {
              if (!r6)
                return [Zr.createVNode(em, { variant: "plain", color: "red", onClick: (e7) => t3.$emit("delete") }, { default: Zr.withCtx(() => [Zr.createTextVNode("Delete Node")]), _: 1 }, 8, ["onClick"])];
              r6(Gs.ssrRenderComponent(em, { variant: "plain", color: "red", onClick: (e7) => t3.$emit("delete") }, { default: Zr.withCtx((t4, e7, r7, n7) => {
                if (!e7)
                  return [Zr.createTextVNode("Delete Node")];
                e7("Delete Node");
              }), _: 1 }, n6, i6));
            }), _: 1 }, n5, i5));
          }), _: 3 }, n4, i4));
        }), _: 3 }, r3)), e3("</div>");
      };
    } }), su = au.setup;
    au.setup = (t2, e2) => {
      const r2 = Zr.useSSRContext();
      return (r2.modules || (r2.modules = /* @__PURE__ */ new Set())).add("components/NodeBase.vue"), su ? su(t2, e2) : void 0;
    };
    const lu = _export_sfc(au, [["__scopeId", "data-v-babecec4"]]), pu = Zr.defineComponent({ __name: "Socket", __ssrInlineRender: true, props: { kind: {} }, setup(t2) {
      let e2 = t2, r2 = Zr.computed(() => kind_to_color(e2.kind));
      return (t3, e3, n2, i2) => {
        const o2 = { style: { "--ea906046": Zr.unref(r2) } };
        e3(`<div${Gs.ssrRenderAttrs(Zr.mergeProps({ id: "socket" }, i2, o2))} data-v-91c58806></div>`);
      };
    } }), cu = pu.setup;
    pu.setup = (t2, e2) => {
      const r2 = Zr.useSSRContext();
      return (r2.modules || (r2.modules = /* @__PURE__ */ new Set())).add("components/Socket.vue"), cu ? cu(t2, e2) : void 0;
    };
    const du = _export_sfc(pu, [["__scopeId", "data-v-91c58806"]]), mu = Symbol(), uu = Zr.defineComponent({ __name: "SocketOutput", __ssrInlineRender: true, props: { kind: {}, name: {}, calc: { type: Function }, value: {}, dirty: { type: Boolean } }, setup(t2) {
      let e2 = t2, r2 = null;
      async function get_value() {
        return (e2.dirty || null !== r2) && (null === r2 && (r2 = e2.calc()), console.log(r2), await r2, r2 = null), e2.value;
      }
      const n2 = Zr.inject(mu), i2 = Zr.ref(null);
      let o2 = [], a2 = [], s2 = [];
      function update(t3, e3) {
        o2.push(t3.make_dirty), a2.push(t3.reset), s2.push(e3);
      }
      function reset() {
      }
      function clicked() {
        n2({ element: i2.value, kind: e2.kind, io: "output", update_value: update, data: { get_value, reset } });
      }
      return Zr.watch(() => e2.dirty, () => {
        console.log("DIRTY CHANGED", e2.dirty), null !== o2 && e2.dirty && o2.forEach((t3) => t3());
      }), Zr.onUnmounted(function() {
        console.log("CLEARING OUT CONNECTED!"), console.log(a2), a2.forEach((t3) => t3()), s2.forEach((t3) => t3()), a2 = [], s2 = [];
      }), (t3, e3, r3, n3) => {
        const i3 = du;
        e3("<!--[-->"), void 0 !== t3.name ? e3(`<div style="${Gs.ssrRenderStyle({ transform: "translateY(15px)" })}">${Gs.ssrInterpolate(t3.name)}</div>`) : e3("<!---->"), e3(`<div style="${Gs.ssrRenderStyle({ "margin-left": "calc(100% + 5px)" })}">`), e3(Gs.ssrRenderComponent(i3, { kind: t3.kind, onClick: clicked }, null, r3)), e3("</div><!--]-->");
      };
    } }), hu = uu.setup;
    uu.setup = (t2, e2) => {
      const r2 = Zr.useSSRContext();
      return (r2.modules || (r2.modules = /* @__PURE__ */ new Set())).add("components/SocketOutput.vue"), hu ? hu(t2, e2) : void 0;
    };
    const fu = propsFactory({ active: Boolean, max: [Number, String], value: { type: [Number, String], default: 0 }, ...mc(), ...fm({ transition: { component: om } }) }, "VCounter"), gu = genericComponent()({ name: "VCounter", functional: true, props: fu(), setup(t2, e2) {
      let { slots: r2 } = e2;
      const n2 = Zr.computed(() => t2.max ? `${t2.value} / ${t2.max}` : String(t2.value));
      return useRender(() => Zr.createVNode(MaybeTransition, { transition: t2.transition }, { default: () => [Zr.withDirectives(Zr.createVNode("div", { class: ["v-counter", t2.class], style: t2.style }, [r2.default ? r2.default({ counter: n2.value, max: t2.max, value: t2.value }) : n2.value]), [[Zr.vShow, t2.active]])] })), {};
    } }), xu = propsFactory({ text: String, clickable: Boolean, ...mc(), ...$c() }, "VLabel"), vu = genericComponent()({ name: "VLabel", props: xu(), setup(t2, e2) {
      let { slots: r2 } = e2;
      return useRender(() => {
        var e3;
        return Zr.createVNode("label", { class: ["v-label", { "v-label--clickable": t2.clickable }, t2.class], style: t2.style }, [t2.text, null == (e3 = r2.default) ? void 0 : e3.call(r2)]);
      }), {};
    } }), yu = propsFactory({ floating: Boolean, ...mc() }, "VFieldLabel"), bu = genericComponent()({ name: "VFieldLabel", props: yu(), setup(t2, e2) {
      let { slots: r2 } = e2;
      return useRender(() => Zr.createVNode(vu, { class: ["v-field-label", { "v-field-label--floating": t2.floating }, t2.class], style: t2.style, "aria-hidden": t2.floating || void 0 }, r2)), {};
    } });
    function useInputIcon(t2) {
      const { t: e2 } = useLocale();
      return { InputIcon: function(r2) {
        var n2;
        let { name: i2 } = r2;
        const o2 = { prepend: "prependAction", prependInner: "prependAction", append: "appendAction", appendInner: "appendAction", clear: "clear" }[i2], a2 = t2[`onClick:${i2}`], s2 = a2 && o2 ? e2(`$vuetify.input.${o2}`, null != (n2 = t2.label) ? n2 : "") : void 0;
        return Zr.createVNode(Dd, { icon: t2[`${i2}Icon`], "aria-label": s2, onClick: a2 }, null);
      } };
    }
    const wu = propsFactory({ focused: Boolean, "onUpdate:focused": EventProp() }, "focus");
    function useFocus(t2) {
      let e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : getCurrentInstanceName();
      const r2 = useProxiedModel(t2, "focused");
      return { focusClasses: Zr.computed(() => ({ [`${e2}--focused`]: r2.value })), isFocused: r2, focus: function() {
        r2.value = true;
      }, blur: function() {
        r2.value = false;
      } };
    }
    const ku = ["underlined", "outlined", "filled", "solo", "solo-inverted", "solo-filled", "plain"], Su = propsFactory({ appendInnerIcon: gc, bgColor: String, clearable: Boolean, clearIcon: { type: gc, default: "$clear" }, active: Boolean, centerAffix: { type: Boolean, default: void 0 }, color: String, baseColor: String, dirty: Boolean, disabled: { type: Boolean, default: null }, error: Boolean, flat: Boolean, label: String, persistentClear: Boolean, prependInnerIcon: gc, reverse: Boolean, singleLine: Boolean, variant: { type: String, default: "filled", validator: (t2) => ku.includes(t2) }, "onClick:clear": EventProp(), "onClick:appendInner": EventProp(), "onClick:prependInner": EventProp(), ...mc(), ...qd(), ...kd(), ...$c() }, "VField"), Cu = genericComponent()({ name: "VField", inheritAttrs: false, props: { id: String, ...wu(), ...Su() }, emits: { "update:focused": (t2) => true, "update:modelValue": (t2) => true }, setup(t2, e2) {
      let { attrs: r2, emit: n2, slots: i2 } = e2;
      const { themeClasses: o2 } = provideTheme(t2), { loaderClasses: a2 } = useLoader(t2), { focusClasses: s2, isFocused: l2, focus: p2, blur: c2 } = useFocus(t2), { InputIcon: d2 } = useInputIcon(t2), { roundedClasses: m2 } = useRounded(t2), { rtlClasses: u2 } = useRtl(), h2 = Zr.computed(() => t2.dirty || t2.active), g2 = Zr.computed(() => !(t2.singleLine || !t2.label && !i2.label)), x2 = getUid(), v2 = Zr.computed(() => t2.id || `input-${x2}`), y2 = Zr.computed(() => `${v2.value}-messages`), b2 = Zr.ref(), w2 = Zr.ref(), k2 = Zr.ref(), S2 = Zr.computed(() => ["plain", "underlined"].includes(t2.variant)), { backgroundColorClasses: C2, backgroundColorStyles: _2 } = useBackgroundColor(Zr.toRef(t2, "bgColor")), { textColorClasses: P2, textColorStyles: T2 } = useTextColor(Zr.computed(() => t2.error || t2.disabled ? void 0 : h2.value && l2.value ? t2.color : t2.baseColor));
      Zr.watch(h2, (t3) => {
        if (g2.value) {
          const e3 = b2.value.$el, r3 = w2.value.$el;
          requestAnimationFrame(() => {
            const n3 = nullifyTransforms(e3), i3 = r3.getBoundingClientRect(), o3 = i3.x - n3.x, a3 = i3.y - n3.y - (n3.height / 2 - i3.height / 2), s3 = i3.width / 0.75, l3 = Math.abs(s3 - n3.width) > 1 ? { maxWidth: convertToUnit(s3) } : void 0, p3 = getComputedStyle(e3), c3 = getComputedStyle(r3), d3 = 1e3 * parseFloat(p3.transitionDuration) || 150, m3 = parseFloat(c3.getPropertyValue("--v-field-label-scale")), u3 = c3.getPropertyValue("color");
            e3.style.visibility = "visible", r3.style.visibility = "hidden", animate(e3, { transform: `translate(${o3}px, ${a3}px) scale(${m3})`, color: u3, ...l3 }, { duration: d3, easing: md, direction: t3 ? "normal" : "reverse" }).finished.then(() => {
              e3.style.removeProperty("visibility"), r3.style.removeProperty("visibility");
            });
          });
        }
      }, { flush: "post" });
      const A2 = Zr.computed(() => ({ isActive: h2, isFocused: l2, controlRef: k2, blur: c2, focus: p2 }));
      function onClick(t3) {
        t3.target !== document.activeElement && t3.preventDefault();
      }
      return useRender(() => {
        var e3, n3, l3, x3;
        const k3 = "outlined" === t2.variant, I2 = i2["prepend-inner"] || t2.prependInnerIcon, N2 = !(!t2.clearable && !i2.clear), R2 = !!(i2["append-inner"] || t2.appendInnerIcon || N2), label = () => i2.label ? i2.label({ ...A2.value, label: t2.label, props: { for: v2.value } }) : t2.label;
        return Zr.createVNode("div", Zr.mergeProps({ class: ["v-field", { "v-field--active": h2.value, "v-field--appended": R2, "v-field--center-affix": null != (e3 = t2.centerAffix) ? e3 : !S2.value, "v-field--disabled": t2.disabled, "v-field--dirty": t2.dirty, "v-field--error": t2.error, "v-field--flat": t2.flat, "v-field--has-background": !!t2.bgColor, "v-field--persistent-clear": t2.persistentClear, "v-field--prepended": I2, "v-field--reverse": t2.reverse, "v-field--single-line": t2.singleLine, "v-field--no-label": !label(), [`v-field--variant-${t2.variant}`]: true }, o2.value, C2.value, s2.value, a2.value, m2.value, u2.value, t2.class], style: [_2.value, t2.style], onClick }, r2), [Zr.createVNode("div", { class: "v-field__overlay" }, null), Zr.createVNode(LoaderSlot, { name: "v-field", active: !!t2.loading, color: t2.error ? "error" : "string" == typeof t2.loading ? t2.loading : t2.color }, { default: i2.loader }), I2 && Zr.createVNode("div", { key: "prepend", class: "v-field__prepend-inner" }, [t2.prependInnerIcon && Zr.createVNode(d2, { key: "prepend-icon", name: "prependInner" }, null), null == (n3 = i2["prepend-inner"]) ? void 0 : n3.call(i2, A2.value)]), Zr.createVNode("div", { class: "v-field__field", "data-no-activator": "" }, [["filled", "solo", "solo-inverted", "solo-filled"].includes(t2.variant) && g2.value && Zr.createVNode(bu, { key: "floating-label", ref: w2, class: [P2.value], floating: true, for: v2.value, style: T2.value }, { default: () => [label()] }), Zr.createVNode(bu, { ref: b2, for: v2.value }, { default: () => [label()] }), null == (l3 = i2.default) ? void 0 : l3.call(i2, { ...A2.value, props: { id: v2.value, class: "v-field__input", "aria-describedby": y2.value }, focus: p2, blur: c2 })]), N2 && Zr.createVNode(sm, { key: "clear" }, { default: () => [Zr.withDirectives(Zr.createVNode("div", { class: "v-field__clearable", onMousedown: (t3) => {
          t3.preventDefault(), t3.stopPropagation();
        } }, [i2.clear ? i2.clear() : Zr.createVNode(d2, { name: "clear" }, null)]), [[Zr.vShow, t2.dirty]])] }), R2 && Zr.createVNode("div", { key: "append", class: "v-field__append-inner" }, [null == (x3 = i2["append-inner"]) ? void 0 : x3.call(i2, A2.value), t2.appendInnerIcon && Zr.createVNode(d2, { key: "append-icon", name: "appendInner" }, null)]), Zr.createVNode("div", { class: ["v-field__outline", P2.value], style: T2.value }, [k3 && Zr.createVNode(Zr.Fragment, null, [Zr.createVNode("div", { class: "v-field__outline__start" }, null), g2.value && Zr.createVNode("div", { class: "v-field__outline__notch" }, [Zr.createVNode(bu, { ref: w2, floating: true, for: v2.value }, { default: () => [label()] })]), Zr.createVNode("div", { class: "v-field__outline__end" }, null)]), S2.value && g2.value && Zr.createVNode(bu, { ref: w2, floating: true, for: v2.value }, { default: () => [label()] })])]);
      }), { controlRef: k2 };
    } });
    function filterFieldProps(t2) {
      return pick(t2, Object.keys(Cu.props).filter((t3) => !isOn(t3) && "class" !== t3 && "style" !== t3));
    }
    const Eu = propsFactory({ active: Boolean, color: String, messages: { type: [Array, String], default: () => [] }, ...mc(), ...fm({ transition: { component: om, leaveAbsolute: true, group: true } }) }, "VMessages"), _u = genericComponent()({ name: "VMessages", props: Eu(), setup(t2, e2) {
      let { slots: r2 } = e2;
      const n2 = Zr.computed(() => wrapInArray(t2.messages)), { textColorClasses: i2, textColorStyles: o2 } = useTextColor(Zr.computed(() => t2.color));
      return useRender(() => Zr.createVNode(MaybeTransition, { transition: t2.transition, tag: "div", class: ["v-messages", i2.value, t2.class], style: [o2.value, t2.style], role: "alert", "aria-live": "polite" }, { default: () => [t2.active && n2.value.map((t3, e3) => Zr.createVNode("div", { class: "v-messages__message", key: `${e3}-${n2.value}` }, [r2.message ? r2.message({ message: t3 }) : t3]))] })), {};
    } }), Pu = Symbol.for("vuetify:form");
    const Tu = propsFactory({ disabled: { type: Boolean, default: null }, error: Boolean, errorMessages: { type: [Array, String], default: () => [] }, maxErrors: { type: [Number, String], default: 1 }, name: String, label: String, readonly: { type: Boolean, default: null }, rules: { type: Array, default: () => [] }, modelValue: null, validateOn: String, validationValue: null, ...wu() }, "validation");
    function useValidation(t2) {
      let e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : getCurrentInstanceName(), r2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : getUid();
      const n2 = useProxiedModel(t2, "modelValue"), i2 = Zr.computed(() => void 0 === t2.validationValue ? n2.value : t2.validationValue), o2 = Zr.inject(Pu, null), a2 = Zr.ref([]), s2 = Zr.shallowRef(true), l2 = Zr.computed(() => !(!wrapInArray("" === n2.value ? null : n2.value).length && !wrapInArray("" === i2.value ? null : i2.value).length)), p2 = Zr.computed(() => {
        var e3;
        return !!(null != (e3 = t2.disabled) ? e3 : null == o2 ? void 0 : o2.isDisabled.value);
      }), c2 = Zr.computed(() => {
        var e3;
        return !!(null != (e3 = t2.readonly) ? e3 : null == o2 ? void 0 : o2.isReadonly.value);
      }), d2 = Zr.computed(() => {
        var e3;
        return (null == (e3 = t2.errorMessages) ? void 0 : e3.length) ? wrapInArray(t2.errorMessages).concat(a2.value).slice(0, Math.max(0, +t2.maxErrors)) : a2.value;
      }), m2 = Zr.computed(() => {
        var e3, r3;
        let n3 = (null != (e3 = t2.validateOn) ? e3 : null == o2 ? void 0 : o2.validateOn.value) || "input";
        "lazy" === n3 && (n3 = "input lazy");
        const i3 = new Set(null != (r3 = null == n3 ? void 0 : n3.split(" ")) ? r3 : []);
        return { blur: i3.has("blur") || i3.has("input"), input: i3.has("input"), submit: i3.has("submit"), lazy: i3.has("lazy") };
      }), u2 = Zr.computed(() => {
        var e3;
        return !t2.error && !(null == (e3 = t2.errorMessages) ? void 0 : e3.length) && (!t2.rules.length || (s2.value ? !a2.value.length && !m2.value.lazy || null : !a2.value.length));
      }), h2 = Zr.shallowRef(false), g2 = Zr.computed(() => ({ [`${e2}--error`]: false === u2.value, [`${e2}--dirty`]: l2.value, [`${e2}--disabled`]: p2.value, [`${e2}--readonly`]: c2.value })), x2 = Zr.computed(() => {
        var e3;
        return null != (e3 = t2.name) ? e3 : Zr.unref(r2);
      });
      function resetValidation() {
        s2.value = true, m2.value.lazy ? a2.value = [] : validate(true);
      }
      async function validate() {
        var e3;
        let r3 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
        const n3 = [];
        h2.value = true;
        for (const r4 of t2.rules) {
          if (n3.length >= +(null != (e3 = t2.maxErrors) ? e3 : 1))
            break;
          const o3 = "function" == typeof r4 ? r4 : () => r4, a3 = await o3(i2.value);
          true !== a3 && (false === a3 || "string" == typeof a3 ? n3.push(a3 || "") : console.warn(`${a3} is not a valid value. Rule functions must return boolean true or a string.`));
        }
        return a2.value = n3, h2.value = false, s2.value = r3, a2.value;
      }
      return useToggleScope(() => m2.value.input, () => {
        Zr.watch(i2, () => {
          if (null != i2.value)
            validate();
          else if (t2.focused) {
            const e3 = Zr.watch(() => t2.focused, (t3) => {
              t3 || validate(), e3();
            });
          }
        });
      }), useToggleScope(() => m2.value.blur, () => {
        Zr.watch(() => t2.focused, (t3) => {
          t3 || validate();
        });
      }), Zr.watch(u2, () => {
        null == o2 || o2.update(x2.value, u2.value, d2.value);
      }), { errorMessages: d2, isDirty: l2, isDisabled: p2, isReadonly: c2, isPristine: s2, isValid: u2, isValidating: h2, reset: function() {
        n2.value = null, Zr.nextTick(resetValidation);
      }, resetValidation, validate, validationClasses: g2 };
    }
    const Au = propsFactory({ id: String, appendIcon: gc, centerAffix: { type: Boolean, default: true }, prependIcon: gc, hideDetails: [Boolean, String], hideSpinButtons: Boolean, hint: String, persistentHint: Boolean, messages: { type: [Array, String], default: () => [] }, direction: { type: String, default: "horizontal", validator: (t2) => ["horizontal", "vertical"].includes(t2) }, "onClick:prepend": EventProp(), "onClick:append": EventProp(), ...mc(), ...bd(), ...Tu() }, "VInput"), Iu = genericComponent()({ name: "VInput", props: { ...Au() }, emits: { "update:modelValue": (t2) => true }, setup(t2, e2) {
      let { attrs: r2, slots: n2, emit: i2 } = e2;
      const { densityClasses: o2 } = useDensity(t2), { rtlClasses: a2 } = useRtl(), { InputIcon: s2 } = useInputIcon(t2), l2 = getUid(), p2 = Zr.computed(() => t2.id || `input-${l2}`), c2 = Zr.computed(() => `${p2.value}-messages`), { errorMessages: d2, isDirty: m2, isDisabled: u2, isReadonly: h2, isPristine: g2, isValid: x2, isValidating: v2, reset: y2, resetValidation: b2, validate: w2, validationClasses: k2 } = useValidation(t2, "v-input", p2), S2 = Zr.computed(() => ({ id: p2, messagesId: c2, isDirty: m2, isDisabled: u2, isReadonly: h2, isPristine: g2, isValid: x2, isValidating: v2, reset: y2, resetValidation: b2, validate: w2 })), C2 = Zr.computed(() => {
        var e3;
        return (null == (e3 = t2.errorMessages) ? void 0 : e3.length) || !g2.value && d2.value.length ? d2.value : t2.hint && (t2.persistentHint || t2.focused) ? t2.hint : t2.messages;
      });
      return useRender(() => {
        var e3, r3, i3, l3;
        const p3 = !(!n2.prepend && !t2.prependIcon), d3 = !(!n2.append && !t2.appendIcon), m3 = C2.value.length > 0, u3 = !t2.hideDetails || "auto" === t2.hideDetails && (m3 || !!n2.details);
        return Zr.createVNode("div", { class: ["v-input", `v-input--${t2.direction}`, { "v-input--center-affix": t2.centerAffix, "v-input--hide-spin-buttons": t2.hideSpinButtons }, o2.value, a2.value, k2.value, t2.class], style: t2.style }, [p3 && Zr.createVNode("div", { key: "prepend", class: "v-input__prepend" }, [null == (e3 = n2.prepend) ? void 0 : e3.call(n2, S2.value), t2.prependIcon && Zr.createVNode(s2, { key: "prepend-icon", name: "prepend" }, null)]), n2.default && Zr.createVNode("div", { class: "v-input__control" }, [null == (r3 = n2.default) ? void 0 : r3.call(n2, S2.value)]), d3 && Zr.createVNode("div", { key: "append", class: "v-input__append" }, [t2.appendIcon && Zr.createVNode(s2, { key: "append-icon", name: "append" }, null), null == (i3 = n2.append) ? void 0 : i3.call(n2, S2.value)]), u3 && Zr.createVNode("div", { class: "v-input__details" }, [Zr.createVNode(_u, { id: c2.value, active: m3, messages: C2.value }, { message: n2.message }), null == (l3 = n2.details) ? void 0 : l3.call(n2, S2.value)])]);
      }), { reset: y2, resetValidation: b2, validate: w2, isValid: x2, errorMessages: d2 };
    } }), Nu = ["color", "file", "time", "date", "datetime-local", "week", "month"], Ru = propsFactory({ autofocus: Boolean, counter: [Boolean, Number, String], counterValue: [Number, Function], prefix: String, placeholder: String, persistentPlaceholder: Boolean, persistentCounter: Boolean, suffix: String, role: String, type: { type: String, default: "text" }, modelModifiers: Object, ...Au(), ...Su() }, "VTextField"), Ou = genericComponent()({ name: "VTextField", directives: { Intersect: Sm }, inheritAttrs: false, props: Ru(), emits: { "click:control": (t2) => true, "mousedown:control": (t2) => true, "update:focused": (t2) => true, "update:modelValue": (t2) => true }, setup(t2, e2) {
      let { attrs: r2, emit: n2, slots: i2 } = e2;
      const o2 = useProxiedModel(t2, "modelValue"), { isFocused: a2, focus: s2, blur: l2 } = useFocus(t2), p2 = Zr.computed(() => {
        var e3;
        return "function" == typeof t2.counterValue ? t2.counterValue(o2.value) : "number" == typeof t2.counterValue ? t2.counterValue : (null != (e3 = o2.value) ? e3 : "").toString().length;
      }), c2 = Zr.computed(() => r2.maxlength ? r2.maxlength : !t2.counter || "number" != typeof t2.counter && "string" != typeof t2.counter ? void 0 : t2.counter), d2 = Zr.computed(() => ["plain", "underlined"].includes(t2.variant));
      function onIntersect(e3, r3) {
        var n3, i3;
        t2.autofocus && e3 && (null == (i3 = null == (n3 = r3[0].target) ? void 0 : n3.focus) || i3.call(n3));
      }
      const m2 = Zr.ref(), u2 = Zr.ref(), h2 = Zr.ref(), g2 = Zr.computed(() => Nu.includes(t2.type) || t2.persistentPlaceholder || a2.value || t2.active);
      function onFocus() {
        var t3;
        h2.value !== document.activeElement && (null == (t3 = h2.value) || t3.focus()), a2.value || s2();
      }
      function onControlMousedown(t3) {
        n2("mousedown:control", t3), t3.target !== h2.value && (onFocus(), t3.preventDefault());
      }
      function onControlClick(t3) {
        onFocus(), n2("click:control", t3);
      }
      function onClear(e3) {
        e3.stopPropagation(), onFocus(), Zr.nextTick(() => {
          o2.value = null, callEvent(t2["onClick:clear"], e3);
        });
      }
      function onInput(e3) {
        var r3;
        const n3 = e3.target;
        if (o2.value = n3.value, (null == (r3 = t2.modelModifiers) ? void 0 : r3.trim) && ["text", "search", "password", "tel", "url"].includes(t2.type)) {
          const t3 = [n3.selectionStart, n3.selectionEnd];
          Zr.nextTick(() => {
            n3.selectionStart = t3[0], n3.selectionEnd = t3[1];
          });
        }
      }
      return useRender(() => {
        const e3 = !!(i2.counter || false !== t2.counter && null != t2.counter), n3 = !(!e3 && !i2.details), [s3, x2] = filterInputAttrs(r2), { modelValue: v2, ...y2 } = Iu.filterProps(t2), b2 = filterFieldProps(t2);
        return Zr.createVNode(Iu, Zr.mergeProps({ ref: m2, modelValue: o2.value, "onUpdate:modelValue": (t3) => o2.value = t3, class: ["v-text-field", { "v-text-field--prefixed": t2.prefix, "v-text-field--suffixed": t2.suffix, "v-input--plain-underlined": d2.value }, t2.class], style: t2.style }, s3, y2, { centerAffix: !d2.value, focused: a2.value }), { ...i2, default: (e4) => {
          let { id: r3, isDisabled: n4, isDirty: s4, isReadonly: p3, isValid: c3 } = e4;
          return Zr.createVNode(Cu, Zr.mergeProps({ ref: u2, onMousedown: onControlMousedown, onClick: onControlClick, "onClick:clear": onClear, "onClick:prependInner": t2["onClick:prependInner"], "onClick:appendInner": t2["onClick:appendInner"], role: t2.role }, b2, { id: r3.value, active: g2.value || s4.value, dirty: s4.value || t2.dirty, disabled: n4.value, focused: a2.value, error: false === c3.value }), { ...i2, default: (e5) => {
            let { props: { class: r4, ...a3 } } = e5;
            const s5 = Zr.withDirectives(Zr.createVNode("input", Zr.mergeProps({ ref: h2, value: o2.value, onInput, autofocus: t2.autofocus, readonly: p3.value, disabled: n4.value, name: t2.name, placeholder: t2.placeholder, size: 1, type: t2.type, onFocus, onBlur: l2 }, a3, x2), null), [[Zr.resolveDirective("intersect"), { handler: onIntersect }, null, { once: true }]]);
            return Zr.createVNode(Zr.Fragment, null, [t2.prefix && Zr.createVNode("span", { class: "v-text-field__prefix" }, [Zr.createVNode("span", { class: "v-text-field__prefix__text" }, [t2.prefix])]), i2.default ? Zr.createVNode("div", { class: r4, "data-no-activator": "" }, [i2.default(), s5]) : Zr.cloneVNode(s5, { class: r4 }), t2.suffix && Zr.createVNode("span", { class: "v-text-field__suffix" }, [Zr.createVNode("span", { class: "v-text-field__suffix__text" }, [t2.suffix])])]);
          } });
        }, details: n3 ? (r3) => {
          var n4;
          return Zr.createVNode(Zr.Fragment, null, [null == (n4 = i2.details) ? void 0 : n4.call(i2, r3), e3 && Zr.createVNode(Zr.Fragment, null, [Zr.createVNode("span", null, null), Zr.createVNode(gu, { active: t2.persistentCounter || a2.value, value: p2.value, max: c2.value }, i2.counter)])]);
        } : void 0 });
      }), forwardRefs({}, m2, u2, h2);
    } }), Lu = Zr.defineComponent({ __name: "LiteralNumber", __ssrInlineRender: true, setup(t2) {
      let e2 = Zr.ref(0), r2 = Zr.ref(true);
      return (t3, n2, i2, o2) => {
        const a2 = lu, s2 = uu;
        n2(Gs.ssrRenderComponent(a2, Zr.mergeProps({ title: "Number", color: Zr.unref(ud), dirty: Zr.unref(r2), "onUpdate:dirty": (t4) => Zr.isRef(r2) ? r2.value = t4 : r2 = t4 }, t3.$attrs, o2), { default: Zr.withCtx((t4, n3, i3, o3) => {
          if (!n3)
            return [Zr.createVNode(s2, { kind: "number", name: "", calc: async () => {
              Zr.isRef(r2) ? r2.value = false : r2 = false;
            }, value: Zr.unref(e2).toString(), dirty: Zr.unref(r2), "onUpdate:dirty": (t5) => Zr.isRef(r2) ? r2.value = t5 : r2 = t5 }, null, 8, ["calc", "value", "dirty", "onUpdate:dirty"]), Zr.createVNode(Ou, { variant: "outlined", type: "number", modelValue: Zr.unref(e2), "onUpdate:modelValue": [(t5) => Zr.isRef(e2) ? e2.value = t5 : e2 = t5, (t5) => Zr.isRef(r2) ? r2.value = true : r2 = true] }, null, 8, ["modelValue", "onUpdate:modelValue"])];
          n3(Gs.ssrRenderComponent(s2, { kind: "number", name: "", calc: async () => {
            Zr.isRef(r2) ? r2.value = false : r2 = false;
          }, value: Zr.unref(e2).toString(), dirty: Zr.unref(r2), "onUpdate:dirty": (t5) => Zr.isRef(r2) ? r2.value = t5 : r2 = t5 }, null, i3, o3)), n3(Gs.ssrRenderComponent(Ou, { variant: "outlined", type: "number", modelValue: Zr.unref(e2), "onUpdate:modelValue": [(t5) => Zr.isRef(e2) ? e2.value = t5 : e2 = t5, (t5) => Zr.isRef(r2) ? r2.value = true : r2 = true] }, null, i3, o3));
        }), _: 1 }, i2));
      };
    } }), Mu = Lu.setup;
    Lu.setup = (t2, e2) => {
      const r2 = Zr.useSSRContext();
      return (r2.modules || (r2.modules = /* @__PURE__ */ new Set())).add("components/node/LiteralNumber.vue"), Mu ? Mu(t2, e2) : void 0;
    };
    const Bu = propsFactory({ autoGrow: Boolean, autofocus: Boolean, counter: [Boolean, Number, String], counterValue: Function, prefix: String, placeholder: String, persistentPlaceholder: Boolean, persistentCounter: Boolean, noResize: Boolean, rows: { type: [Number, String], default: 5, validator: (t2) => !isNaN(parseFloat(t2)) }, maxRows: { type: [Number, String], validator: (t2) => !isNaN(parseFloat(t2)) }, suffix: String, modelModifiers: Object, ...Au(), ...Su() }, "VTextarea"), Du = genericComponent()({ name: "VTextarea", directives: { Intersect: Sm }, inheritAttrs: false, props: Bu(), emits: { "click:control": (t2) => true, "mousedown:control": (t2) => true, "update:focused": (t2) => true, "update:modelValue": (t2) => true }, setup(t2, e2) {
      let { attrs: r2, emit: n2, slots: i2 } = e2;
      const o2 = useProxiedModel(t2, "modelValue"), { isFocused: a2, focus: s2, blur: l2 } = useFocus(t2), p2 = Zr.computed(() => "function" == typeof t2.counterValue ? t2.counterValue(o2.value) : (o2.value || "").toString().length), c2 = Zr.computed(() => r2.maxlength ? r2.maxlength : !t2.counter || "number" != typeof t2.counter && "string" != typeof t2.counter ? void 0 : t2.counter);
      function onIntersect(e3, r3) {
        var n3, i3;
        t2.autofocus && e3 && (null == (i3 = null == (n3 = r3[0].target) ? void 0 : n3.focus) || i3.call(n3));
      }
      const d2 = Zr.ref(), m2 = Zr.ref(), u2 = Zr.shallowRef(""), h2 = Zr.ref(), g2 = Zr.computed(() => t2.persistentPlaceholder || a2.value || t2.active);
      function onFocus() {
        var t3;
        h2.value !== document.activeElement && (null == (t3 = h2.value) || t3.focus()), a2.value || s2();
      }
      function onControlClick(t3) {
        onFocus(), n2("click:control", t3);
      }
      function onControlMousedown(t3) {
        n2("mousedown:control", t3);
      }
      function onClear(e3) {
        e3.stopPropagation(), onFocus(), Zr.nextTick(() => {
          o2.value = "", callEvent(t2["onClick:clear"], e3);
        });
      }
      function onInput(e3) {
        var r3;
        const n3 = e3.target;
        if (o2.value = n3.value, null == (r3 = t2.modelModifiers) ? void 0 : r3.trim) {
          const t3 = [n3.selectionStart, n3.selectionEnd];
          Zr.nextTick(() => {
            n3.selectionStart = t3[0], n3.selectionEnd = t3[1];
          });
        }
      }
      const x2 = Zr.ref(), v2 = Zr.ref(+t2.rows), y2 = Zr.computed(() => ["plain", "underlined"].includes(t2.variant));
      function calculateInputHeight() {
        t2.autoGrow && Zr.nextTick(() => {
          if (!x2.value || !m2.value)
            return;
          const e3 = getComputedStyle(x2.value), r3 = getComputedStyle(m2.value.$el), n3 = parseFloat(e3.getPropertyValue("--v-field-padding-top")) + parseFloat(e3.getPropertyValue("--v-input-padding-top")) + parseFloat(e3.getPropertyValue("--v-field-padding-bottom")), i3 = x2.value.scrollHeight, o3 = parseFloat(e3.lineHeight), a3 = clamp(null != i3 ? i3 : 0, Math.max(parseFloat(t2.rows) * o3 + n3, parseFloat(r3.getPropertyValue("--v-input-control-height"))), parseFloat(t2.maxRows) * o3 + n3 || 1 / 0);
          v2.value = Math.floor((a3 - n3) / o3), u2.value = convertToUnit(a3);
        });
      }
      let b2;
      return Zr.watchEffect(() => {
        t2.autoGrow || (v2.value = +t2.rows);
      }), Zr.watch(o2, calculateInputHeight), Zr.watch(() => t2.rows, calculateInputHeight), Zr.watch(() => t2.maxRows, calculateInputHeight), Zr.watch(() => t2.density, calculateInputHeight), Zr.watch(x2, (t3) => {
        t3 ? (b2 = new ResizeObserver(calculateInputHeight), b2.observe(x2.value)) : null == b2 || b2.disconnect();
      }), useRender(() => {
        const e3 = !!(i2.counter || t2.counter || t2.counterValue), n3 = !(!e3 && !i2.details), [s3, b3] = filterInputAttrs(r2), { modelValue: w2, ...k2 } = Iu.filterProps(t2), S2 = filterFieldProps(t2);
        return Zr.createVNode(Iu, Zr.mergeProps({ ref: d2, modelValue: o2.value, "onUpdate:modelValue": (t3) => o2.value = t3, class: ["v-textarea v-text-field", { "v-textarea--prefixed": t2.prefix, "v-textarea--suffixed": t2.suffix, "v-text-field--prefixed": t2.prefix, "v-text-field--suffixed": t2.suffix, "v-textarea--auto-grow": t2.autoGrow, "v-textarea--no-resize": t2.noResize || t2.autoGrow, "v-input--plain-underlined": y2.value }, t2.class], style: t2.style }, s3, k2, { centerAffix: 1 === v2.value && !y2.value, focused: a2.value }), { ...i2, default: (e4) => {
          let { id: r3, isDisabled: n4, isDirty: s4, isReadonly: p3, isValid: c3 } = e4;
          return Zr.createVNode(Cu, Zr.mergeProps({ ref: m2, style: { "--v-textarea-control-height": u2.value }, onClick: onControlClick, onMousedown: onControlMousedown, "onClick:clear": onClear, "onClick:prependInner": t2["onClick:prependInner"], "onClick:appendInner": t2["onClick:appendInner"] }, S2, { id: r3.value, active: g2.value || s4.value, centerAffix: 1 === v2.value && !y2.value, dirty: s4.value || t2.dirty, disabled: n4.value, focused: a2.value, error: false === c3.value }), { ...i2, default: (e5) => {
            let { props: { class: r4, ...i3 } } = e5;
            return Zr.createVNode(Zr.Fragment, null, [t2.prefix && Zr.createVNode("span", { class: "v-text-field__prefix" }, [t2.prefix]), Zr.withDirectives(Zr.createVNode("textarea", Zr.mergeProps({ ref: h2, class: r4, value: o2.value, onInput, autofocus: t2.autofocus, readonly: p3.value, disabled: n4.value, placeholder: t2.placeholder, rows: t2.rows, name: t2.name, onFocus, onBlur: l2 }, i3, b3), null), [[Zr.resolveDirective("intersect"), { handler: onIntersect }, null, { once: true }]]), t2.autoGrow && Zr.withDirectives(Zr.createVNode("textarea", { class: [r4, "v-textarea__sizer"], id: `${i3.id}-sizer`, "onUpdate:modelValue": (t3) => o2.value = t3, ref: x2, readonly: true, "aria-hidden": "true" }, null), [[Zr.vModelText, o2.value]]), t2.suffix && Zr.createVNode("span", { class: "v-text-field__suffix" }, [t2.suffix])]);
          } });
        }, details: n3 ? (r3) => {
          var n4;
          return Zr.createVNode(Zr.Fragment, null, [null == (n4 = i2.details) ? void 0 : n4.call(i2, r3), e3 && Zr.createVNode(Zr.Fragment, null, [Zr.createVNode("span", null, null), Zr.createVNode(gu, { active: t2.persistentCounter || a2.value, value: p2.value, max: c2.value }, i2.counter)])]);
        } : void 0 });
      }), forwardRefs({}, d2, m2, h2);
    } }), ju = Zr.defineComponent({ __name: "LiteralString", __ssrInlineRender: true, setup(t2) {
      let e2 = Zr.ref(""), r2 = Zr.ref(true);
      return (t3, n2, i2, o2) => {
        const a2 = lu, s2 = uu;
        n2(Gs.ssrRenderComponent(a2, Zr.mergeProps({ title: "Text", color: Zr.unref(hd), dirty: Zr.unref(r2), "onUpdate:dirty": (t4) => Zr.isRef(r2) ? r2.value = t4 : r2 = t4 }, t3.$attrs, o2), { default: Zr.withCtx((t4, n3, i3, o3) => {
          if (!n3)
            return [Zr.createVNode(s2, { kind: "string", name: "", calc: async () => {
              Zr.isRef(r2) ? r2.value = false : r2 = false;
            }, value: Zr.unref(e2), dirty: Zr.unref(r2), "onUpdate:dirty": (t5) => Zr.isRef(r2) ? r2.value = t5 : r2 = t5 }, null, 8, ["calc", "value", "dirty", "onUpdate:dirty"]), Zr.createVNode("div", { style: { width: "500px" } }), Zr.createVNode(Du, { modelValue: Zr.unref(e2), "onUpdate:modelValue": [(t5) => Zr.isRef(e2) ? e2.value = t5 : e2 = t5, (t5) => Zr.isRef(r2) ? r2.value = true : r2 = true], variant: "outlined", "auto-grow": "" }, null, 8, ["modelValue", "onUpdate:modelValue"])];
          n3(Gs.ssrRenderComponent(s2, { kind: "string", name: "", calc: async () => {
            Zr.isRef(r2) ? r2.value = false : r2 = false;
          }, value: Zr.unref(e2), dirty: Zr.unref(r2), "onUpdate:dirty": (t5) => Zr.isRef(r2) ? r2.value = t5 : r2 = t5 }, null, i3, o3)), n3(`<div style="${Gs.ssrRenderStyle({ width: "500px" })}"${o3}></div>`), n3(Gs.ssrRenderComponent(Du, { modelValue: Zr.unref(e2), "onUpdate:modelValue": [(t5) => Zr.isRef(e2) ? e2.value = t5 : e2 = t5, (t5) => Zr.isRef(r2) ? r2.value = true : r2 = true], variant: "outlined", "auto-grow": "" }, null, i3, o3));
        }), _: 1 }, i2));
      };
    } }), Fu = ju.setup;
    ju.setup = (t2, e2) => {
      const r2 = Zr.useSSRContext();
      return (r2.modules || (r2.modules = /* @__PURE__ */ new Set())).add("components/node/LiteralString.vue"), Fu ? Fu(t2, e2) : void 0;
    };
    const $u = genericComponent()({ name: "VCardActions", props: mc(), setup(t2, e2) {
      let { slots: r2 } = e2;
      return provideDefaults({ VBtn: { slim: true, variant: "text" } }), useRender(() => {
        var e3;
        return Zr.createVNode("div", { class: ["v-card-actions", t2.class], style: t2.style }, [null == (e3 = r2.default) ? void 0 : e3.call(r2)]);
      }), {};
    } }), Vu = createSimpleFunctional("v-card-subtitle"), zu = createSimpleFunctional("v-card-title"), Uu = propsFactory({ appendAvatar: String, appendIcon: gc, prependAvatar: String, prependIcon: gc, subtitle: [String, Number], title: [String, Number], ...mc(), ...bd() }, "VCardItem"), Hu = genericComponent()({ name: "VCardItem", props: Uu(), setup(t2, e2) {
      let { slots: r2 } = e2;
      return useRender(() => {
        var e3;
        const n2 = !(!t2.prependAvatar && !t2.prependIcon), i2 = !(!n2 && !r2.prepend), o2 = !(!t2.appendAvatar && !t2.appendIcon), a2 = !(!o2 && !r2.append), s2 = !(null == t2.title && !r2.title), l2 = !(null == t2.subtitle && !r2.subtitle);
        return Zr.createVNode("div", { class: ["v-card-item", t2.class], style: t2.style }, [i2 && Zr.createVNode("div", { key: "prepend", class: "v-card-item__prepend" }, [r2.prepend ? Zr.createVNode(Od, { key: "prepend-defaults", disabled: !n2, defaults: { VAvatar: { density: t2.density, icon: t2.prependIcon, image: t2.prependAvatar } } }, r2.prepend) : n2 && Zr.createVNode(Pm, { key: "prepend-avatar", density: t2.density, icon: t2.prependIcon, image: t2.prependAvatar }, null)]), Zr.createVNode("div", { class: "v-card-item__content" }, [s2 && Zr.createVNode(zu, { key: "title" }, { default: () => {
          var e4, n3;
          return [null != (e4 = null == (n3 = r2.title) ? void 0 : n3.call(r2)) ? e4 : t2.title];
        } }), l2 && Zr.createVNode(Vu, { key: "subtitle" }, { default: () => {
          var e4, n3;
          return [null != (e4 = null == (n3 = r2.subtitle) ? void 0 : n3.call(r2)) ? e4 : t2.subtitle];
        } }), null == (e3 = r2.default) ? void 0 : e3.call(r2)]), a2 && Zr.createVNode("div", { key: "append", class: "v-card-item__append" }, [r2.append ? Zr.createVNode(Od, { key: "append-defaults", disabled: !o2, defaults: { VAvatar: { density: t2.density, icon: t2.appendIcon, image: t2.appendAvatar } } }, r2.append) : o2 && Zr.createVNode(Pm, { key: "append-avatar", density: t2.density, icon: t2.appendIcon, image: t2.appendAvatar }, null)])]);
      }), {};
    } }), qu = createSimpleFunctional("v-card-text"), Wu = propsFactory({ appendAvatar: String, appendIcon: gc, disabled: Boolean, flat: Boolean, hover: Boolean, image: String, link: { type: Boolean, default: void 0 }, prependAvatar: String, prependIcon: gc, ripple: { type: [Boolean, Object], default: true }, subtitle: [String, Number], text: [String, Number], title: [String, Number], ...vd(), ...mc(), ...bd(), ...$d(), ...wd(), ...qd(), ...zd(), ...Kd(), ...kd(), ...Gd(), ...Sd(), ...$c(), ...Ed({ variant: "elevated" }) }, "VCard"), Ku = genericComponent()({ name: "VCard", directives: { Ripple: Zd }, props: Wu(), setup(t2, e2) {
      let { attrs: r2, slots: n2 } = e2;
      const { themeClasses: i2 } = provideTheme(t2), { borderClasses: o2 } = useBorder(t2), { colorClasses: a2, colorStyles: s2, variantClasses: l2 } = useVariant(t2), { densityClasses: p2 } = useDensity(t2), { dimensionStyles: c2 } = useDimension(t2), { elevationClasses: d2 } = useElevation(t2), { loaderClasses: m2 } = useLoader(t2), { locationStyles: u2 } = useLocation(t2), { positionClasses: h2 } = usePosition(t2), { roundedClasses: g2 } = useRounded(t2), x2 = useLink(t2, r2), v2 = Zr.computed(() => false !== t2.link && x2.isLink.value), y2 = Zr.computed(() => !t2.disabled && false !== t2.link && (t2.link || x2.isClickable.value));
      return useRender(() => {
        const e3 = v2.value ? "a" : t2.tag, r3 = !(!n2.title && null == t2.title), b2 = !(!n2.subtitle && null == t2.subtitle), w2 = r3 || b2, k2 = !!(n2.append || t2.appendAvatar || t2.appendIcon), S2 = !!(n2.prepend || t2.prependAvatar || t2.prependIcon), C2 = !(!n2.image && !t2.image), _2 = w2 || S2 || k2, P2 = !(!n2.text && null == t2.text);
        return Zr.withDirectives(Zr.createVNode(e3, { class: ["v-card", { "v-card--disabled": t2.disabled, "v-card--flat": t2.flat, "v-card--hover": t2.hover && !(t2.disabled || t2.flat), "v-card--link": y2.value }, i2.value, o2.value, a2.value, p2.value, d2.value, m2.value, h2.value, g2.value, l2.value, t2.class], style: [s2.value, c2.value, u2.value, t2.style], href: x2.href.value, onClick: y2.value && x2.navigate, tabindex: t2.disabled ? -1 : void 0 }, { default: () => {
          var e4;
          return [C2 && Zr.createVNode("div", { key: "image", class: "v-card__image" }, [n2.image ? Zr.createVNode(Od, { key: "image-defaults", disabled: !t2.image, defaults: { VImg: { cover: true, src: t2.image } } }, n2.image) : Zr.createVNode(Em, { key: "image-img", cover: true, src: t2.image }, null)]), Zr.createVNode(LoaderSlot, { name: "v-card", active: !!t2.loading, color: "boolean" == typeof t2.loading ? void 0 : t2.loading }, { default: n2.loader }), _2 && Zr.createVNode(Hu, { key: "item", prependAvatar: t2.prependAvatar, prependIcon: t2.prependIcon, title: t2.title, subtitle: t2.subtitle, appendAvatar: t2.appendAvatar, appendIcon: t2.appendIcon }, { default: n2.item, prepend: n2.prepend, title: n2.title, subtitle: n2.subtitle, append: n2.append }), P2 && Zr.createVNode(qu, { key: "text" }, { default: () => {
            var e5, r4;
            return [null != (e5 = null == (r4 = n2.text) ? void 0 : r4.call(n2)) ? e5 : t2.text];
          } }), null == (e4 = n2.default) ? void 0 : e4.call(n2), n2.actions && Zr.createVNode($u, null, { default: n2.actions }), genOverlays(y2.value, "v-card")];
        } }), [[Zr.resolveDirective("ripple"), y2.value && t2.ripple]]);
      }), {};
    } }), Gu = propsFactory({ scrollable: Boolean, ...mc(), ...Sd({ tag: "main" }) }, "VMain"), Ju = genericComponent()({ name: "VMain", props: Gu(), setup(t2, e2) {
      let { slots: r2 } = e2;
      const { mainStyles: n2 } = useLayout(), { ssrBootStyles: i2 } = useSsrBoot();
      return useRender(() => Zr.createVNode(t2.tag, { class: ["v-main", { "v-main--scrollable": t2.scrollable }, t2.class], style: [n2.value, i2.value, t2.style] }, { default: () => {
        var e3, n3;
        return [t2.scrollable ? Zr.createVNode("div", { class: "v-main__scroller" }, [null == (e3 = r2.default) ? void 0 : e3.call(r2)]) : null == (n3 = r2.default) ? void 0 : n3.call(r2)];
      } })), {};
    } });
    function oops() {
      throw new Error();
    }
    const Yu = ["start", "end", "left", "right", "top", "bottom"], Xu = propsFactory({ color: String, disableResizeWatcher: Boolean, disableRouteWatcher: Boolean, expandOnHover: Boolean, floating: Boolean, modelValue: { type: Boolean, default: null }, permanent: Boolean, rail: { type: Boolean, default: null }, railWidth: { type: [Number, String], default: 56 }, scrim: { type: [Boolean, String], default: true }, image: String, temporary: Boolean, touchless: Boolean, width: { type: [Number, String], default: 256 }, location: { type: String, default: "start", validator: (t2) => Yu.includes(t2) }, sticky: Boolean, ...vd(), ...mc(), ...jc(), ...wd(), ...Hc(), ...kd(), ...Sd({ tag: "nav" }), ...$c() }, "VNavigationDrawer"), Qu = genericComponent()({ name: "VNavigationDrawer", props: Xu(), emits: { "update:modelValue": (t2) => true, "update:rail": (t2) => true }, setup(t2, e2) {
      let { attrs: r2, emit: n2, slots: i2 } = e2;
      const { isRtl: o2 } = useRtl(), { themeClasses: a2 } = provideTheme(t2), { borderClasses: s2 } = useBorder(t2), { backgroundColorClasses: l2, backgroundColorStyles: p2 } = useBackgroundColor(Zr.toRef(t2, "color")), { elevationClasses: c2 } = useElevation(t2), { displayClasses: d2, mobile: m2 } = useDisplay(t2), { roundedClasses: u2 } = useRounded(t2), h2 = useRouter(), g2 = useProxiedModel(t2, "modelValue", null, (t3) => !!t3), { ssrBootStyles: x2 } = useSsrBoot(), { scopeId: v2 } = useScopeId(), y2 = Zr.ref(), b2 = Zr.shallowRef(false), w2 = Zr.computed(() => t2.rail && t2.expandOnHover && b2.value ? Number(t2.width) : Number(t2.rail ? t2.railWidth : t2.width)), k2 = Zr.computed(() => toPhysical(t2.location, o2.value)), S2 = Zr.computed(() => !t2.permanent && (m2.value || t2.temporary)), C2 = Zr.computed(() => t2.sticky && !S2.value && "bottom" !== k2.value);
      useToggleScope(() => t2.expandOnHover && null != t2.rail, () => {
        Zr.watch(b2, (t3) => n2("update:rail", !t3));
      }), useToggleScope(() => !t2.disableResizeWatcher, () => {
        Zr.watch(S2, (e3) => !t2.permanent && Zr.nextTick(() => g2.value = !e3));
      }), useToggleScope(() => !t2.disableRouteWatcher && !!h2, () => {
        Zr.watch(h2.currentRoute, () => S2.value && (g2.value = false));
      }), Zr.watch(() => t2.permanent, (t3) => {
        t3 && (g2.value = true);
      });
      const { isDragging: _2, dragProgress: P2, dragStyles: T2 } = function(t3) {
        let { isActive: e3, isTemporary: r3, width: n3, touchless: i3, position: o3 } = t3;
        Zr.computed(() => ["left", "right"].includes(o3.value));
        const a3 = Zr.shallowRef(false), s3 = Zr.shallowRef(0);
        Zr.shallowRef(0);
        const l3 = Zr.computed(() => a3.value ? { transform: "left" === o3.value ? `translateX(calc(-100% + ${s3.value * n3.value}px))` : "right" === o3.value ? `translateX(calc(100% - ${s3.value * n3.value}px))` : "top" === o3.value ? `translateY(calc(-100% + ${s3.value * n3.value}px))` : "bottom" === o3.value ? `translateY(calc(100% - ${s3.value * n3.value}px))` : oops(), transition: "none" } : void 0);
        return { isDragging: a3, dragProgress: s3, dragStyles: l3 };
      }({ isActive: g2, isTemporary: S2, width: w2, touchless: Zr.toRef(t2, "touchless"), position: k2 }), A2 = Zr.computed(() => {
        const e3 = S2.value ? 0 : t2.rail && t2.expandOnHover ? Number(t2.railWidth) : w2.value;
        return _2.value ? e3 * P2.value : e3;
      }), { layoutItemStyles: I2, layoutItemScrimStyles: N2 } = useLayoutItem({ id: t2.name, order: Zr.computed(() => parseInt(t2.order, 10)), position: k2, layoutSize: A2, elementSize: w2, active: Zr.computed(() => g2.value || _2.value), disableTransitions: Zr.computed(() => _2.value), absolute: Zr.computed(() => t2.absolute || C2.value && "string" != typeof R2.value) }), { isStuck: R2, stickyStyles: O2 } = function(t3) {
        let { rootEl: e3, isSticky: r3, layoutItemStyles: n3 } = t3;
        const i3 = Zr.shallowRef(false), o3 = Zr.shallowRef(0), a3 = Zr.computed(() => {
          const t4 = "boolean" == typeof i3.value ? "top" : i3.value;
          return [r3.value ? { top: "auto", bottom: "auto", height: void 0 } : void 0, i3.value ? { [t4]: convertToUnit(o3.value) } : { top: n3.value.top }];
        });
        return { isStuck: i3, stickyStyles: a3 };
      }({ rootEl: y2, isSticky: C2, layoutItemStyles: I2 }), L2 = useBackgroundColor(Zr.computed(() => "string" == typeof t2.scrim ? t2.scrim : null)), M2 = Zr.computed(() => ({ ..._2.value ? { opacity: 0.2 * P2.value, transition: "none" } : void 0, ...N2.value }));
      function onMouseenter() {
        b2.value = true;
      }
      function onMouseleave() {
        b2.value = false;
      }
      return provideDefaults({ VList: { bgColor: "transparent" } }), useRender(() => {
        const e3 = i2.image || t2.image;
        return Zr.createVNode(Zr.Fragment, null, [Zr.createVNode(t2.tag, Zr.mergeProps({ ref: y2, onMouseenter, onMouseleave, class: ["v-navigation-drawer", `v-navigation-drawer--${k2.value}`, { "v-navigation-drawer--expand-on-hover": t2.expandOnHover, "v-navigation-drawer--floating": t2.floating, "v-navigation-drawer--is-hovering": b2.value, "v-navigation-drawer--rail": t2.rail, "v-navigation-drawer--temporary": S2.value, "v-navigation-drawer--active": g2.value, "v-navigation-drawer--sticky": C2.value }, a2.value, l2.value, s2.value, d2.value, c2.value, u2.value, t2.class], style: [p2.value, I2.value, T2.value, x2.value, O2.value, t2.style] }, v2, r2), { default: () => {
          var r3, n3, o3, a3;
          return [e3 && Zr.createVNode("div", { key: "image", class: "v-navigation-drawer__img" }, [i2.image ? null == (r3 = i2.image) ? void 0 : r3.call(i2, { image: t2.image }) : Zr.createVNode("img", { src: t2.image, alt: "" }, null)]), i2.prepend && Zr.createVNode("div", { class: "v-navigation-drawer__prepend" }, [null == (n3 = i2.prepend) ? void 0 : n3.call(i2)]), Zr.createVNode("div", { class: "v-navigation-drawer__content" }, [null == (o3 = i2.default) ? void 0 : o3.call(i2)]), i2.append && Zr.createVNode("div", { class: "v-navigation-drawer__append" }, [null == (a3 = i2.append) ? void 0 : a3.call(i2)])];
        } }), Zr.createVNode(Zr.Transition, { name: "fade-transition" }, { default: () => [S2.value && (_2.value || g2.value) && !!t2.scrim && Zr.createVNode("div", Zr.mergeProps({ class: ["v-navigation-drawer__scrim", L2.backgroundColorClasses.value], style: [M2.value, L2.backgroundColorStyles.value], onClick: () => g2.value = false }, v2), null)] })]);
      }), { isStuck: R2 };
    } }), Zu = propsFactory({ id: String, text: String, ...omit(Zm({ closeOnBack: false, location: "end", locationStrategy: "connected", eager: true, minWidth: 0, offset: 10, openOnClick: false, openOnHover: true, origin: "auto", scrim: false, scrollStrategy: "reposition", transition: false }), ["absolute", "persistent"]) }, "VTooltip"), th = genericComponent()({ name: "VTooltip", props: Zu(), emits: { "update:modelValue": (t2) => true }, setup(t2, e2) {
      let { slots: r2 } = e2;
      const n2 = useProxiedModel(t2, "modelValue"), { scopeId: i2 } = useScopeId(), o2 = getUid(), a2 = Zr.computed(() => t2.id || `v-tooltip-${o2}`), s2 = Zr.ref(), l2 = Zr.computed(() => t2.location.split(" ").length > 1 ? t2.location : t2.location + " center"), p2 = Zr.computed(() => "auto" === t2.origin || "overlap" === t2.origin || t2.origin.split(" ").length > 1 || t2.location.split(" ").length > 1 ? t2.origin : t2.origin + " center"), c2 = Zr.computed(() => t2.transition ? t2.transition : n2.value ? "scale-transition" : "fade-transition"), d2 = Zr.computed(() => Zr.mergeProps({ "aria-describedby": a2.value }, t2.activatorProps));
      return useRender(() => {
        const e3 = tu.filterProps(t2);
        return Zr.createVNode(tu, Zr.mergeProps({ ref: s2, class: ["v-tooltip", t2.class], style: t2.style, id: a2.value }, e3, { modelValue: n2.value, "onUpdate:modelValue": (t3) => n2.value = t3, transition: c2.value, absolute: true, location: l2.value, origin: p2.value, persistent: true, role: "tooltip", activatorProps: d2.value, _disableGlobalStack: true }, i2), { activator: r2.activator, default: function() {
          for (var e4, n3, i3 = arguments.length, o3 = new Array(i3), a3 = 0; a3 < i3; a3++)
            o3[a3] = arguments[a3];
          return null != (e4 = null == (n3 = r2.default) ? void 0 : n3.call(r2, ...o3)) ? e4 : t2.text;
        } });
      }), forwardRefs({}, s2);
    } }), eh = Zr.defineComponent({ __name: "NodeEditor", __ssrInlineRender: true, setup(t2) {
      let e2 = Zr.ref([]), r2 = Zr.ref([]), n2 = [{ type: Zr.markRaw(Lu), color: ud, name: "Number", tip: "Constant number" }, { type: Zr.markRaw(ju), color: hd, name: "Text", tip: "Constant text" }];
      function dragstart(t3, e3) {
        var r3;
        null == (r3 = t3.dataTransfer) || r3.setData("text/plain", e3.toString());
      }
      function drop(t3) {
        var e3;
        t3.preventDefault();
        let i3 = Number.parseInt(null == (e3 = t3.dataTransfer) ? void 0 : e3.getData("text/plain")), l3 = (t3.offsetX - o2.value) / s2.value, p3 = (t3.offsetY - a2.value) / s2.value;
        !function(t4, e4, n3) {
          let i4 = Math.max(...r2.value.map((t5) => t5.id));
          Number.isFinite(i4) || (i4 = 0), r2.value.push({ type: t4, x: e4, y: n3, id: i4 + 1 });
        }(n2[i3].type, l3, p3);
      }
      let i2 = Zr.ref(null);
      Zr.provide(mu, function(t3) {
        if (null === i2.value)
          i2.value = t3;
        else {
          if (i2.value.io === t3.io || i2.value.kind !== t3.kind)
            return console.log(i2, t3), void (i2.value = null);
          console.log(i2, t3);
          let r3 = Math.random();
          e2.value.push({ from: i2.value.element, to: t3.element, id: r3 });
          let n3, o3, kill_connection = () => {
            return t4 = r3, void (e2.value = e2.value.filter((e3) => e3.id !== t4));
            var t4;
          };
          "output" === t3.io && "input" == i2.value.io ? (o3 = t3, n3 = i2.value) : "input" == t3.io && "output" == i2.value.io && (o3 = i2.value, n3 = t3), n3.update_value(o3.data, kill_connection), o3.update_value(n3.data, kill_connection), i2.value = null;
        }
      });
      let o2 = Zr.ref(0), a2 = Zr.ref(0), s2 = Zr.ref(1);
      function handle_pan(t3) {
        p2.value = t3.pageX, c2.value = t3.pageY, 0 != (4 & t3.buttons) && (o2.value += t3.movementX, a2.value += t3.movementY);
      }
      let l2 = Zr.ref(null);
      function handle_zoom(t3) {
        t3.preventDefault();
        let e3 = s2.value - t3.deltaY / 1e3;
        e3 = Math.max(Math.min(e3, 2), 0.1);
        let r3 = l2.value.getBoundingClientRect(), n3 = t3.pageX - r3.left, i3 = t3.pageY - r3.top, p3 = e3 / s2.value, c3 = n3 * p3 - n3, d3 = i3 * p3 - i3;
        o2.value -= c3, a2.value -= d3, s2.value = e3;
      }
      let p2 = Zr.ref(0), c2 = Zr.ref(0), d2 = Zr.ref(null);
      return (t3, m2, u2, h2) => {
        const g2 = xd, x2 = { style: { "--18c627d4": Zr.unref(p2), "--18c627d5": Zr.unref(c2), "--03e5234c": Zr.unref(o2), "--03e5234d": Zr.unref(a2), "--04102340": Zr.unref(s2) } };
        m2("<!--[-->"), m2(Gs.ssrRenderComponent(Qu, Zr.mergeProps({ permanent: "" }, x2), { default: Zr.withCtx((t4, e3, r3, i3) => {
          if (!e3)
            return [(Zr.openBlock(true), Zr.createBlock(Zr.Fragment, null, Zr.renderList(Zr.unref(n2), (t5, e4) => (Zr.openBlock(), Zr.createBlock(Zr.Fragment, null, [true === t5.divider ? (Zr.openBlock(), Zr.createBlock(Om, { key: 0, thickness: "4px" })) : Zr.createCommentVNode("", true), Zr.createVNode(th, { text: t5.tip }, { activator: Zr.withCtx(({ props: r4 }) => [Zr.createVNode(Ku, Zr.mergeProps(r4, { class: "pa-2 ma-3", color: t5.color, draggable: "true", onDragstart: (t6) => dragstart(t6, e4) }), { default: Zr.withCtx(() => [Zr.createTextVNode(Zr.toDisplayString(t5.name), 1)]), _: 2 }, 1040, ["color", "onDragstart"])]), _: 2 }, 1032, ["text"])], 64))), 256))];
          e3("<!--[-->"), Gs.ssrRenderList(Zr.unref(n2), (t5, n3) => {
            e3("<!--[-->"), true === t5.divider ? e3(Gs.ssrRenderComponent(Om, { thickness: "4px" }, null, r3, i3)) : e3("<!---->"), e3(Gs.ssrRenderComponent(th, { text: t5.tip }, { activator: Zr.withCtx(({ props: e4 }, r4, i4, o3) => {
              if (!r4)
                return [Zr.createVNode(Ku, Zr.mergeProps(e4, { class: "pa-2 ma-3", color: t5.color, draggable: "true", onDragstart: (t6) => dragstart(t6, n3) }), { default: Zr.withCtx(() => [Zr.createTextVNode(Zr.toDisplayString(t5.name), 1)]), _: 2 }, 1040, ["color", "onDragstart"])];
              r4(Gs.ssrRenderComponent(Ku, Zr.mergeProps(e4, { class: "pa-2 ma-3", color: t5.color, draggable: "true", onDragstart: (t6) => dragstart(t6, n3) }), { default: Zr.withCtx((e5, r5, n4, i5) => {
                if (!r5)
                  return [Zr.createTextVNode(Zr.toDisplayString(t5.name), 1)];
                r5(`${Gs.ssrInterpolate(t5.name)}`);
              }), _: 2 }, i4, o3));
            }), _: 2 }, r3, i3)), e3("<!--]-->");
          }), e3("<!--]-->");
        }), _: 1 }, u2)), m2(Gs.ssrRenderComponent(Ju, x2, { default: Zr.withCtx((t4, n3, o3, a3) => {
          if (!n3)
            return [Zr.createVNode("div", { id: "container", onDragover: (t5) => t5.preventDefault(), onDrop: drop, onMousemove: handle_pan, onWheel: handle_zoom }, [Zr.createVNode("div", { id: "node_container", ref_key: "node_container", ref: l2 }, [(Zr.openBlock(true), Zr.createBlock(Zr.Fragment, null, Zr.renderList(Zr.unref(r2), (t5, e3) => (Zr.openBlock(), Zr.createBlock(Zr.resolveDynamicComponent(t5.type), { key: t5.id, x: t5.x, "onUpdate:x": (e4) => t5.x = e4, y: t5.y, "onUpdate:y": (e4) => t5.y = e4, page_scale: Zr.unref(s2), onDelete: (t6) => Zr.unref(r2).splice(e3, 1) }, null, 40, ["x", "onUpdate:x", "y", "onUpdate:y", "page_scale", "onDelete"]))), 128))], 512), (Zr.openBlock(true), Zr.createBlock(Zr.Fragment, null, Zr.renderList(Zr.unref(e2), (t5) => (Zr.openBlock(), Zr.createBlock(g2, { from: t5.from, to: t5.to, page_scale: Zr.unref(s2), kind: t5.kind }, null, 8, ["from", "to", "page_scale", "kind"]))), 256)), null !== Zr.unref(i2) && null !== Zr.unref(d2) ? (Zr.openBlock(), Zr.createBlock(g2, { key: 0, from: Zr.unref(i2).element, kind: Zr.unref(i2).kind, to: Zr.unref(d2), page_scale: Zr.unref(s2) }, null, 8, ["from", "kind", "to", "page_scale"])) : Zr.createCommentVNode("", true)], 40, ["onDragover"])];
          n3(`<div id="container" data-v-4d3919b8${a3}><div id="node_container" data-v-4d3919b8${a3}><!--[-->`), Gs.ssrRenderList(Zr.unref(r2), (t5, e3) => {
            Gs.ssrRenderVNode(n3, Zr.createVNode(Zr.resolveDynamicComponent(t5.type), { key: t5.id, x: t5.x, "onUpdate:x": (e4) => t5.x = e4, y: t5.y, "onUpdate:y": (e4) => t5.y = e4, page_scale: Zr.unref(s2), onDelete: (t6) => Zr.unref(r2).splice(e3, 1) }, null), o3, a3);
          }), n3("<!--]--></div><!--[-->"), Gs.ssrRenderList(Zr.unref(e2), (t5) => {
            n3(Gs.ssrRenderComponent(g2, { from: t5.from, to: t5.to, page_scale: Zr.unref(s2), kind: t5.kind }, null, o3, a3));
          }), n3("<!--]-->"), null !== Zr.unref(i2) && null !== Zr.unref(d2) ? n3(Gs.ssrRenderComponent(g2, { from: Zr.unref(i2).element, kind: Zr.unref(i2).kind, to: Zr.unref(d2), page_scale: Zr.unref(s2) }, null, o3, a3)) : n3("<!---->"), n3("</div>");
        }), _: 1 }, u2)), m2(`<div${Gs.ssrRenderAttrs(Zr.mergeProps({ id: "mouse_tracker", ref_key: "mouse_tracker", ref: d2 }, x2))} data-v-4d3919b8></div><!--]-->`);
      };
    } }), rh = eh.setup;
    eh.setup = (t2, e2) => {
      const r2 = Zr.useSSRContext();
      return (r2.modules || (r2.modules = /* @__PURE__ */ new Set())).add("components/NodeEditor.vue"), rh ? rh(t2, e2) : void 0;
    };
    const nh = _export_sfc(eh, [["__scopeId", "data-v-4d3919b8"]]), ih = {};
    const oh = ih.setup;
    ih.setup = (t2, e2) => {
      const r2 = Zr.useSSRContext();
      return (r2.modules || (r2.modules = /* @__PURE__ */ new Set())).add("pages/index.vue"), oh ? oh(t2, e2) : void 0;
    };
    const ah = _export_sfc(ih, [["ssrRender", function(t2, e2, r2, n2) {
      const i2 = nh;
      e2(Gs.ssrRenderComponent(i2, n2, null, r2));
    }]]), sh = Object.freeze(Object.defineProperty({ __proto__: null, default: ah }, Symbol.toStringTag, { value: "Module" }));
    function useHead(t2, e2 = {}) {
      const r2 = e2.head || injectHead();
      if (r2)
        return r2.ssr ? r2.push(t2, e2) : function(t3, e3, r3 = {}) {
          const n2 = Zr.ref(false), i2 = Zr.ref({});
          Zr.watchEffect(() => {
            i2.value = n2.value ? {} : resolveUnrefHeadInput(e3);
          });
          const o2 = t3.push(i2.value, r3);
          return Zr.watch(i2, (t4) => {
            o2.patch(t4);
          }), Zr.getCurrentInstance(), o2;
        }(r2, t2, e2);
    }
    function defineNuxtLink(t2) {
      const e2 = t2.componentName || "NuxtLink", resolveTrailingSlashBehavior = (e3, r2) => {
        if (!e3 || "append" !== t2.trailingSlash && "remove" !== t2.trailingSlash)
          return e3;
        const n2 = "append" === t2.trailingSlash ? withTrailingSlash : withoutTrailingSlash;
        if ("string" == typeof e3)
          return n2(e3, true);
        const i2 = "path" in e3 ? e3.path : r2(e3).path;
        return { ...e3, name: void 0, path: n2(i2, true) };
      };
      return Zr.defineComponent({ name: e2, props: { to: { type: [String, Object], default: void 0, required: false }, href: { type: [String, Object], default: void 0, required: false }, target: { type: String, default: void 0, required: false }, rel: { type: String, default: void 0, required: false }, noRel: { type: Boolean, default: void 0, required: false }, prefetch: { type: Boolean, default: void 0, required: false }, noPrefetch: { type: Boolean, default: void 0, required: false }, activeClass: { type: String, default: void 0, required: false }, exactActiveClass: { type: String, default: void 0, required: false }, prefetchedClass: { type: String, default: void 0, required: false }, replace: { type: Boolean, default: void 0, required: false }, ariaCurrentValue: { type: String, default: void 0, required: false }, external: { type: Boolean, default: void 0, required: false }, custom: { type: Boolean, default: void 0, required: false } }, setup(e3, { slots: r2 }) {
        const n2 = useRouter$1(), i2 = useRuntimeConfig(), o2 = Zr.computed(() => {
          const t3 = e3.to || e3.href || "";
          return resolveTrailingSlashBehavior(t3, n2.resolve);
        }), a2 = Zr.computed(() => "string" == typeof o2.value && hasProtocol(o2.value, { acceptRelative: true })), s2 = Zr.computed(() => !!e3.external || (!(!e3.target || "_self" === e3.target) || "object" != typeof o2.value && ("" === o2.value || a2.value))), l2 = Zr.ref(false);
        return () => {
          var p2, c2, d2;
          if (!s2.value) {
            const n3 = { ref: void 0, to: o2.value, activeClass: e3.activeClass || t2.activeClass, exactActiveClass: e3.exactActiveClass || t2.exactActiveClass, replace: e3.replace, ariaCurrentValue: e3.ariaCurrentValue, custom: e3.custom };
            return e3.custom || (l2.value && (n3.class = e3.prefetchedClass || t2.prefetchedClass), n3.rel = e3.rel), Zr.h(Zr.resolveComponent("RouterLink"), n3, r2.default);
          }
          const m2 = "object" == typeof o2.value ? null != (p2 = null == (c2 = n2.resolve(o2.value)) ? void 0 : c2.href) ? p2 : null : !o2.value || e3.external || a2.value ? o2.value || null : resolveTrailingSlashBehavior(joinURL(i2.app.baseURL, o2.value), n2.resolve), u2 = e3.target || null, h2 = e3.noRel ? null : ((...t3) => t3.find((t4) => void 0 !== t4))(e3.rel, t2.externalRelAttribute, m2 ? "noopener noreferrer" : "") || null, navigate = () => navigateTo(m2, { replace: e3.replace });
          return e3.custom ? r2.default ? r2.default({ href: m2, navigate, get route() {
            if (!m2)
              return;
            const t3 = parseURL$1(m2);
            return { path: t3.pathname, fullPath: t3.pathname, get query() {
              return parseQuery$1(t3.search);
            }, hash: t3.hash, params: {}, name: void 0, matched: [], redirectedFrom: void 0, meta: {}, href: m2 };
          }, rel: h2, target: u2, isExternal: s2.value, isActive: false, isExactActive: false }) : null : Zr.h("a", { ref: void 0, href: m2, rel: h2, target: u2 }, null == (d2 = r2.default) ? void 0 : d2.call(r2));
        };
      } });
    }
    const lh = defineNuxtLink(Ap), ph = { __name: "error-404", __ssrInlineRender: true, props: { appName: { type: String, default: "Nuxt" }, version: { type: String, default: "" }, statusCode: { type: Number, default: 404 }, statusMessage: { type: String, default: "Not Found" }, description: { type: String, default: "Sorry, the page you are looking for could not be found." }, backHome: { type: String, default: "Go back home" } }, setup(t2) {
      const e2 = t2;
      return useHead({ title: `${e2.statusCode} - ${e2.statusMessage} | ${e2.appName}`, script: [], style: [{ children: '*,:before,:after{-webkit-box-sizing:border-box;box-sizing:border-box;border-width:0;border-style:solid;border-color:#e0e0e0}*{--tw-ring-inset:var(--tw-empty, );--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(14, 165, 233, .5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000}:root{-moz-tab-size:4;-o-tab-size:4;tab-size:4}a{color:inherit;text-decoration:inherit}body{margin:0;font-family:inherit;line-height:inherit}html{-webkit-text-size-adjust:100%;font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,"Apple Color Emoji","Segoe UI Emoji",Segoe UI Symbol,"Noto Color Emoji";line-height:1.5}h1,p{margin:0}h1{font-size:inherit;font-weight:inherit}' }] }), (e3, r2, n2, i2) => {
        const o2 = lh;
        r2(`<div${Gs.ssrRenderAttrs(Zr.mergeProps({ class: "font-sans antialiased bg-white dark:bg-black text-black dark:text-white grid min-h-screen place-content-center overflow-hidden" }, i2))} data-v-ccd3db62><div class="fixed left-0 right-0 spotlight z-10" data-v-ccd3db62></div><div class="max-w-520px text-center z-20" data-v-ccd3db62><h1 class="text-8xl sm:text-10xl font-medium mb-8" data-v-ccd3db62>${Gs.ssrInterpolate(t2.statusCode)}</h1><p class="text-xl px-8 sm:px-0 sm:text-4xl font-light mb-16 leading-tight" data-v-ccd3db62>${Gs.ssrInterpolate(t2.description)}</p><div class="w-full flex items-center justify-center" data-v-ccd3db62>`), r2(Gs.ssrRenderComponent(o2, { to: "/", class: "gradient-border text-md sm:text-xl py-2 px-4 sm:py-3 sm:px-6 cursor-pointer" }, { default: Zr.withCtx((e4, r3, n3, i3) => {
          if (!r3)
            return [Zr.createTextVNode(Zr.toDisplayString(t2.backHome), 1)];
          r3(`${Gs.ssrInterpolate(t2.backHome)}`);
        }), _: 1 }, n2)), r2("</div></div></div>");
      };
    } }, ch = ph.setup;
    ph.setup = (t2, e2) => {
      const r2 = Zr.useSSRContext();
      return (r2.modules || (r2.modules = /* @__PURE__ */ new Set())).add("node_modules/@nuxt/ui-templates/dist/templates/error-404.vue"), ch ? ch(t2, e2) : void 0;
    };
    const dh = _export_sfc(ph, [["__scopeId", "data-v-ccd3db62"]]), mh = Object.freeze(Object.defineProperty({ __proto__: null, default: dh }, Symbol.toStringTag, { value: "Module" })), uh = { __name: "error-500", __ssrInlineRender: true, props: { appName: { type: String, default: "Nuxt" }, version: { type: String, default: "" }, statusCode: { type: Number, default: 500 }, statusMessage: { type: String, default: "Server error" }, description: { type: String, default: "This page is temporarily unavailable." } }, setup(t2) {
      const e2 = t2;
      return useHead({ title: `${e2.statusCode} - ${e2.statusMessage} | ${e2.appName}`, script: [], style: [{ children: '*,:before,:after{-webkit-box-sizing:border-box;box-sizing:border-box;border-width:0;border-style:solid;border-color:#e0e0e0}*{--tw-ring-inset:var(--tw-empty, );--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(14, 165, 233, .5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000}:root{-moz-tab-size:4;-o-tab-size:4;tab-size:4}body{margin:0;font-family:inherit;line-height:inherit}html{-webkit-text-size-adjust:100%;font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,"Apple Color Emoji","Segoe UI Emoji",Segoe UI Symbol,"Noto Color Emoji";line-height:1.5}h1,p{margin:0}h1{font-size:inherit;font-weight:inherit}' }] }), (e3, r2, n2, i2) => {
        r2(`<div${Gs.ssrRenderAttrs(Zr.mergeProps({ class: "font-sans antialiased bg-white dark:bg-black text-black dark:text-white grid min-h-screen place-content-center overflow-hidden" }, i2))} data-v-df79c84d><div class="fixed -bottom-1/2 left-0 right-0 h-1/2 spotlight" data-v-df79c84d></div><div class="max-w-520px text-center" data-v-df79c84d><h1 class="text-8xl sm:text-10xl font-medium mb-8" data-v-df79c84d>${Gs.ssrInterpolate(t2.statusCode)}</h1><p class="text-xl px-8 sm:px-0 sm:text-4xl font-light mb-16 leading-tight" data-v-df79c84d>${Gs.ssrInterpolate(t2.description)}</p></div></div>`);
      };
    } }, hh = uh.setup;
    uh.setup = (t2, e2) => {
      const r2 = Zr.useSSRContext();
      return (r2.modules || (r2.modules = /* @__PURE__ */ new Set())).add("node_modules/@nuxt/ui-templates/dist/templates/error-500.vue"), hh ? hh(t2, e2) : void 0;
    };
    const fh = _export_sfc(uh, [["__scopeId", "data-v-df79c84d"]]), gh = Object.freeze(Object.defineProperty({ __proto__: null, default: fh }, Symbol.toStringTag, { value: "Module" })), xh = Object.freeze({ __proto__: null, default: {} }), vh = Zr.defineComponent({ props: { context: { type: Object, required: true } }, setup(t2) {
      const e2 = xh[t2.context.name];
      if (!e2)
        throw createError({ statusCode: 404, statusMessage: `Island component not found: ${t2.context.name}` });
      return Zr.onErrorCaptured((t3) => {
        console.log(t3);
      }), () => Zr.createVNode(e2 || "span", { ...t2.context.props, "nuxt-ssr-component-uid": "" });
    } }), yh = Object.freeze(Object.defineProperty({ __proto__: null, default: vh }, Symbol.toStringTag, { value: "Module" })), bh = ["@keyframes v-shake{59%{margin-left:0}60%,80%{margin-left:2px}70%,90%{margin-left:-2px}}.bg-black{background-color:#000!important;color:#fff!important}.bg-white{background-color:#fff!important;color:#000!important}.bg-transparent{background-color:transparent!important;color:currentColor!important}.bg-red{background-color:#f44336!important;color:#fff!important}.bg-red-lighten-5{background-color:#ffebee!important;color:#000!important}.bg-red-lighten-4{background-color:#ffcdd2!important;color:#000!important}.bg-red-lighten-3{background-color:#ef9a9a!important;color:#000!important}.bg-red-lighten-2{background-color:#e57373!important;color:#fff!important}.bg-red-lighten-1{background-color:#ef5350!important;color:#fff!important}.bg-red-darken-1{background-color:#e53935!important;color:#fff!important}.bg-red-darken-2{background-color:#d32f2f!important;color:#fff!important}.bg-red-darken-3{background-color:#c62828!important;color:#fff!important}.bg-red-darken-4{background-color:#b71c1c!important;color:#fff!important}.bg-red-accent-1{background-color:#ff8a80!important;color:#000!important}.bg-red-accent-2{background-color:#ff5252!important;color:#fff!important}.bg-red-accent-3{background-color:#ff1744!important;color:#fff!important}.bg-red-accent-4{background-color:#d50000!important;color:#fff!important}.bg-pink{background-color:#e91e63!important;color:#fff!important}.bg-pink-lighten-5{background-color:#fce4ec!important;color:#000!important}.bg-pink-lighten-4{background-color:#f8bbd0!important;color:#000!important}.bg-pink-lighten-3{background-color:#f48fb1!important;color:#000!important}.bg-pink-lighten-2{background-color:#f06292!important;color:#fff!important}.bg-pink-lighten-1{background-color:#ec407a!important;color:#fff!important}.bg-pink-darken-1{background-color:#d81b60!important;color:#fff!important}.bg-pink-darken-2{background-color:#c2185b!important;color:#fff!important}.bg-pink-darken-3{background-color:#ad1457!important;color:#fff!important}.bg-pink-darken-4{background-color:#880e4f!important;color:#fff!important}.bg-pink-accent-1{background-color:#ff80ab!important;color:#fff!important}.bg-pink-accent-2{background-color:#ff4081!important;color:#fff!important}.bg-pink-accent-3{background-color:#f50057!important;color:#fff!important}.bg-pink-accent-4{background-color:#c51162!important;color:#fff!important}.bg-purple{background-color:#9c27b0!important;color:#fff!important}.bg-purple-lighten-5{background-color:#f3e5f5!important;color:#000!important}.bg-purple-lighten-4{background-color:#e1bee7!important;color:#000!important}.bg-purple-lighten-3{background-color:#ce93d8!important;color:#fff!important}.bg-purple-lighten-2{background-color:#ba68c8!important;color:#fff!important}.bg-purple-lighten-1{background-color:#ab47bc!important;color:#fff!important}.bg-purple-darken-1{background-color:#8e24aa!important;color:#fff!important}.bg-purple-darken-2{background-color:#7b1fa2!important;color:#fff!important}.bg-purple-darken-3{background-color:#6a1b9a!important;color:#fff!important}.bg-purple-darken-4{background-color:#4a148c!important;color:#fff!important}.bg-purple-accent-1{background-color:#ea80fc!important;color:#fff!important}.bg-purple-accent-2{background-color:#e040fb!important;color:#fff!important}.bg-purple-accent-3{background-color:#d500f9!important;color:#fff!important}.bg-purple-accent-4{background-color:#a0f!important;color:#fff!important}.bg-deep-purple{background-color:#673ab7!important;color:#fff!important}.bg-deep-purple-lighten-5{background-color:#ede7f6!important;color:#000!important}.bg-deep-purple-lighten-4{background-color:#d1c4e9!important;color:#000!important}.bg-deep-purple-lighten-3{background-color:#b39ddb!important;color:#fff!important}.bg-deep-purple-lighten-2{background-color:#9575cd!important;color:#fff!important}.bg-deep-purple-lighten-1{background-color:#7e57c2!important;color:#fff!important}.bg-deep-purple-darken-1{background-color:#5e35b1!important;color:#fff!important}.bg-deep-purple-darken-2{background-color:#512da8!important;color:#fff!important}.bg-deep-purple-darken-3{background-color:#4527a0!important;color:#fff!important}.bg-deep-purple-darken-4{background-color:#311b92!important;color:#fff!important}.bg-deep-purple-accent-1{background-color:#b388ff!important;color:#fff!important}.bg-deep-purple-accent-2{background-color:#7c4dff!important;color:#fff!important}.bg-deep-purple-accent-3{background-color:#651fff!important;color:#fff!important}.bg-deep-purple-accent-4{background-color:#6200ea!important;color:#fff!important}.bg-indigo{background-color:#3f51b5!important;color:#fff!important}.bg-indigo-lighten-5{background-color:#e8eaf6!important;color:#000!important}.bg-indigo-lighten-4{background-color:#c5cae9!important;color:#000!important}.bg-indigo-lighten-3{background-color:#9fa8da!important;color:#fff!important}.bg-indigo-lighten-2{background-color:#7986cb!important;color:#fff!important}.bg-indigo-lighten-1{background-color:#5c6bc0!important;color:#fff!important}.bg-indigo-darken-1{background-color:#3949ab!important;color:#fff!important}.bg-indigo-darken-2{background-color:#303f9f!important;color:#fff!important}.bg-indigo-darken-3{background-color:#283593!important;color:#fff!important}.bg-indigo-darken-4{background-color:#1a237e!important;color:#fff!important}.bg-indigo-accent-1{background-color:#8c9eff!important;color:#fff!important}.bg-indigo-accent-2{background-color:#536dfe!important;color:#fff!important}.bg-indigo-accent-3{background-color:#3d5afe!important;color:#fff!important}.bg-indigo-accent-4{background-color:#304ffe!important;color:#fff!important}.bg-blue{background-color:#2196f3!important;color:#fff!important}.bg-blue-lighten-5{background-color:#e3f2fd!important;color:#000!important}.bg-blue-lighten-4{background-color:#bbdefb!important;color:#000!important}.bg-blue-lighten-3{background-color:#90caf9!important;color:#000!important}.bg-blue-lighten-2{background-color:#64b5f6!important;color:#000!important}.bg-blue-lighten-1{background-color:#42a5f5!important;color:#fff!important}.bg-blue-darken-1{background-color:#1e88e5!important;color:#fff!important}.bg-blue-darken-2{background-color:#1976d2!important;color:#fff!important}.bg-blue-darken-3{background-color:#1565c0!important;color:#fff!important}.bg-blue-darken-4{background-color:#0d47a1!important;color:#fff!important}.bg-blue-accent-1{background-color:#82b1ff!important;color:#000!important}.bg-blue-accent-2{background-color:#448aff!important;color:#fff!important}.bg-blue-accent-3{background-color:#2979ff!important;color:#fff!important}.bg-blue-accent-4{background-color:#2962ff!important;color:#fff!important}.bg-light-blue{background-color:#03a9f4!important;color:#fff!important}.bg-light-blue-lighten-5{background-color:#e1f5fe!important;color:#000!important}.bg-light-blue-lighten-4{background-color:#b3e5fc!important;color:#000!important}.bg-light-blue-lighten-3{background-color:#81d4fa!important;color:#000!important}.bg-light-blue-lighten-2{background-color:#4fc3f7!important;color:#000!important}.bg-light-blue-lighten-1{background-color:#29b6f6!important;color:#000!important}.bg-light-blue-darken-1{background-color:#039be5!important;color:#fff!important}.bg-light-blue-darken-2{background-color:#0288d1!important;color:#fff!important}.bg-light-blue-darken-3{background-color:#0277bd!important;color:#fff!important}.bg-light-blue-darken-4{background-color:#01579b!important;color:#fff!important}.bg-light-blue-accent-1{background-color:#80d8ff!important;color:#000!important}.bg-light-blue-accent-2{background-color:#40c4ff!important;color:#000!important}.bg-light-blue-accent-3{background-color:#00b0ff!important;color:#fff!important}.bg-light-blue-accent-4{background-color:#0091ea!important;color:#fff!important}.bg-cyan{background-color:#00bcd4!important;color:#000!important}.bg-cyan-lighten-5{background-color:#e0f7fa!important;color:#000!important}.bg-cyan-lighten-4{background-color:#b2ebf2!important;color:#000!important}.bg-cyan-lighten-3{background-color:#80deea!important;color:#000!important}.bg-cyan-lighten-2{background-color:#4dd0e1!important;color:#000!important}.bg-cyan-lighten-1{background-color:#26c6da!important;color:#000!important}.bg-cyan-darken-1{background-color:#00acc1!important;color:#fff!important}.bg-cyan-darken-2{background-color:#0097a7!important;color:#fff!important}.bg-cyan-darken-3{background-color:#00838f!important;color:#fff!important}.bg-cyan-darken-4{background-color:#006064!important;color:#fff!important}.bg-cyan-accent-1{background-color:#84ffff!important;color:#000!important}.bg-cyan-accent-2{background-color:#18ffff!important;color:#000!important}.bg-cyan-accent-3{background-color:#00e5ff!important;color:#000!important}.bg-cyan-accent-4{background-color:#00b8d4!important;color:#fff!important}.bg-teal{background-color:#009688!important;color:#fff!important}.bg-teal-lighten-5{background-color:#e0f2f1!important;color:#000!important}.bg-teal-lighten-4{background-color:#b2dfdb!important;color:#000!important}.bg-teal-lighten-3{background-color:#80cbc4!important;color:#000!important}.bg-teal-lighten-2{background-color:#4db6ac!important;color:#fff!important}.bg-teal-lighten-1{background-color:#26a69a!important;color:#fff!important}.bg-teal-darken-1{background-color:#00897b!important;color:#fff!important}.bg-teal-darken-2{background-color:#00796b!important;color:#fff!important}.bg-teal-darken-3{background-color:#00695c!important;color:#fff!important}.bg-teal-darken-4{background-color:#004d40!important;color:#fff!important}.bg-teal-accent-1{background-color:#a7ffeb!important;color:#000!important}.bg-teal-accent-2{background-color:#64ffda!important;color:#000!important}.bg-teal-accent-3{background-color:#1de9b6!important;color:#000!important}.bg-teal-accent-4{background-color:#00bfa5!important;color:#fff!important}.bg-green{background-color:#4caf50!important;color:#fff!important}.bg-green-lighten-5{background-color:#e8f5e9!important;color:#000!important}.bg-green-lighten-4{background-color:#c8e6c9!important;color:#000!important}.bg-green-lighten-3{background-color:#a5d6a7!important;color:#000!important}.bg-green-lighten-2{background-color:#81c784!important;color:#000!important}.bg-green-lighten-1{background-color:#66bb6a!important;color:#fff!important}.bg-green-darken-1{background-color:#43a047!important;color:#fff!important}.bg-green-darken-2{background-color:#388e3c!important;color:#fff!important}.bg-green-darken-3{background-color:#2e7d32!important;color:#fff!important}.bg-green-darken-4{background-color:#1b5e20!important;color:#fff!important}.bg-green-accent-1{background-color:#b9f6ca!important;color:#000!important}.bg-green-accent-2{background-color:#69f0ae!important;color:#000!important}.bg-green-accent-3{background-color:#00e676!important;color:#000!important}.bg-green-accent-4{background-color:#00c853!important;color:#000!important}.bg-light-green{background-color:#8bc34a!important;color:#000!important}.bg-light-green-lighten-5{background-color:#f1f8e9!important;color:#000!important}.bg-light-green-lighten-4{background-color:#dcedc8!important;color:#000!important}.bg-light-green-lighten-3{background-color:#c5e1a5!important;color:#000!important}.bg-light-green-lighten-2{background-color:#aed581!important;color:#000!important}.bg-light-green-lighten-1{background-color:#9ccc65!important;color:#000!important}.bg-light-green-darken-1{background-color:#7cb342!important;color:#fff!important}.bg-light-green-darken-2{background-color:#689f38!important;color:#fff!important}.bg-light-green-darken-3{background-color:#558b2f!important;color:#fff!important}.bg-light-green-darken-4{background-color:#33691e!important;color:#fff!important}.bg-light-green-accent-1{background-color:#ccff90!important;color:#000!important}.bg-light-green-accent-2{background-color:#b2ff59!important;color:#000!important}.bg-light-green-accent-3{background-color:#76ff03!important;color:#000!important}.bg-light-green-accent-4{background-color:#64dd17!important;color:#000!important}.bg-lime{background-color:#cddc39!important;color:#000!important}.bg-lime-lighten-5{background-color:#f9fbe7!important;color:#000!important}.bg-lime-lighten-4{background-color:#f0f4c3!important;color:#000!important}.bg-lime-lighten-3{background-color:#e6ee9c!important;color:#000!important}.bg-lime-lighten-2{background-color:#dce775!important;color:#000!important}.bg-lime-lighten-1{background-color:#d4e157!important;color:#000!important}.bg-lime-darken-1{background-color:#c0ca33!important;color:#000!important}.bg-lime-darken-2{background-color:#afb42b!important;color:#000!important}.bg-lime-darken-3{background-color:#9e9d24!important;color:#fff!important}.bg-lime-darken-4{background-color:#827717!important;color:#fff!important}.bg-lime-accent-1{background-color:#f4ff81!important;color:#000!important}.bg-lime-accent-2{background-color:#eeff41!important;color:#000!important}.bg-lime-accent-3{background-color:#c6ff00!important;color:#000!important}.bg-lime-accent-4{background-color:#aeea00!important;color:#000!important}.bg-yellow{background-color:#ffeb3b!important;color:#000!important}.bg-yellow-lighten-5{background-color:#fffde7!important;color:#000!important}.bg-yellow-lighten-4{background-color:#fff9c4!important;color:#000!important}.bg-yellow-lighten-3{background-color:#fff59d!important;color:#000!important}.bg-yellow-lighten-2{background-color:#fff176!important;color:#000!important}.bg-yellow-lighten-1{background-color:#ffee58!important;color:#000!important}.bg-yellow-darken-1{background-color:#fdd835!important;color:#000!important}.bg-yellow-darken-2{background-color:#fbc02d!important;color:#000!important}.bg-yellow-darken-3{background-color:#f9a825!important;color:#000!important}.bg-yellow-darken-4{background-color:#f57f17!important;color:#fff!important}.bg-yellow-accent-1{background-color:#ffff8d!important;color:#000!important}.bg-yellow-accent-2{background-color:#ff0!important;color:#000!important}.bg-yellow-accent-3{background-color:#ffea00!important;color:#000!important}.bg-yellow-accent-4{background-color:#ffd600!important;color:#000!important}.bg-amber{background-color:#ffc107!important;color:#000!important}.bg-amber-lighten-5{background-color:#fff8e1!important;color:#000!important}.bg-amber-lighten-4{background-color:#ffecb3!important;color:#000!important}.bg-amber-lighten-3{background-color:#ffe082!important;color:#000!important}.bg-amber-lighten-2{background-color:#ffd54f!important;color:#000!important}.bg-amber-lighten-1{background-color:#ffca28!important;color:#000!important}.bg-amber-darken-1{background-color:#ffb300!important;color:#000!important}.bg-amber-darken-2{background-color:#ffa000!important;color:#000!important}.bg-amber-darken-3{background-color:#ff8f00!important;color:#000!important}.bg-amber-darken-4{background-color:#ff6f00!important;color:#fff!important}.bg-amber-accent-1{background-color:#ffe57f!important;color:#000!important}.bg-amber-accent-2{background-color:#ffd740!important;color:#000!important}.bg-amber-accent-3{background-color:#ffc400!important;color:#000!important}.bg-amber-accent-4{background-color:#ffab00!important;color:#000!important}.bg-orange{background-color:#ff9800!important;color:#000!important}.bg-orange-lighten-5{background-color:#fff3e0!important;color:#000!important}.bg-orange-lighten-4{background-color:#ffe0b2!important;color:#000!important}.bg-orange-lighten-3{background-color:#ffcc80!important;color:#000!important}.bg-orange-lighten-2{background-color:#ffb74d!important;color:#000!important}.bg-orange-lighten-1{background-color:#ffa726!important;color:#000!important}.bg-orange-darken-1{background-color:#fb8c00!important;color:#fff!important}.bg-orange-darken-2{background-color:#f57c00!important;color:#fff!important}.bg-orange-darken-3{background-color:#ef6c00!important;color:#fff!important}.bg-orange-darken-4{background-color:#e65100!important;color:#fff!important}.bg-orange-accent-1{background-color:#ffd180!important;color:#000!important}.bg-orange-accent-2{background-color:#ffab40!important;color:#000!important}.bg-orange-accent-3{background-color:#ff9100!important;color:#000!important}.bg-orange-accent-4{background-color:#ff6d00!important;color:#fff!important}.bg-deep-orange{background-color:#ff5722!important;color:#fff!important}.bg-deep-orange-lighten-5{background-color:#fbe9e7!important;color:#000!important}.bg-deep-orange-lighten-4{background-color:#ffccbc!important;color:#000!important}.bg-deep-orange-lighten-3{background-color:#ffab91!important;color:#000!important}.bg-deep-orange-lighten-2{background-color:#ff8a65!important;color:#000!important}.bg-deep-orange-lighten-1{background-color:#ff7043!important;color:#fff!important}.bg-deep-orange-darken-1{background-color:#f4511e!important;color:#fff!important}.bg-deep-orange-darken-2{background-color:#e64a19!important;color:#fff!important}.bg-deep-orange-darken-3{background-color:#d84315!important;color:#fff!important}.bg-deep-orange-darken-4{background-color:#bf360c!important;color:#fff!important}.bg-deep-orange-accent-1{background-color:#ff9e80!important;color:#000!important}.bg-deep-orange-accent-2{background-color:#ff6e40!important;color:#fff!important}.bg-deep-orange-accent-3{background-color:#ff3d00!important;color:#fff!important}.bg-deep-orange-accent-4{background-color:#dd2c00!important;color:#fff!important}.bg-brown{background-color:#795548!important;color:#fff!important}.bg-brown-lighten-5{background-color:#efebe9!important;color:#000!important}.bg-brown-lighten-4{background-color:#d7ccc8!important;color:#000!important}.bg-brown-lighten-3{background-color:#bcaaa4!important;color:#000!important}.bg-brown-lighten-2{background-color:#a1887f!important;color:#fff!important}.bg-brown-lighten-1{background-color:#8d6e63!important;color:#fff!important}.bg-brown-darken-1{background-color:#6d4c41!important;color:#fff!important}.bg-brown-darken-2{background-color:#5d4037!important;color:#fff!important}.bg-brown-darken-3{background-color:#4e342e!important;color:#fff!important}.bg-brown-darken-4{background-color:#3e2723!important;color:#fff!important}.bg-blue-grey{background-color:#607d8b!important;color:#fff!important}.bg-blue-grey-lighten-5{background-color:#eceff1!important;color:#000!important}.bg-blue-grey-lighten-4{background-color:#cfd8dc!important;color:#000!important}.bg-blue-grey-lighten-3{background-color:#b0bec5!important;color:#000!important}.bg-blue-grey-lighten-2{background-color:#90a4ae!important;color:#fff!important}.bg-blue-grey-lighten-1{background-color:#78909c!important;color:#fff!important}.bg-blue-grey-darken-1{background-color:#546e7a!important;color:#fff!important}.bg-blue-grey-darken-2{background-color:#455a64!important;color:#fff!important}.bg-blue-grey-darken-3{background-color:#37474f!important;color:#fff!important}.bg-blue-grey-darken-4{background-color:#263238!important;color:#fff!important}.bg-grey{background-color:#9e9e9e!important;color:#fff!important}.bg-grey-lighten-5{background-color:#fafafa!important;color:#000!important}.bg-grey-lighten-4{background-color:#f5f5f5!important;color:#000!important}.bg-grey-lighten-3{background-color:#eee!important;color:#000!important}.bg-grey-lighten-2{background-color:#e0e0e0!important;color:#000!important}.bg-grey-lighten-1{background-color:#bdbdbd!important;color:#000!important}.bg-grey-darken-1{background-color:#757575!important;color:#fff!important}.bg-grey-darken-2{background-color:#616161!important;color:#fff!important}.bg-grey-darken-3{background-color:#424242!important;color:#fff!important}.bg-grey-darken-4{background-color:#212121!important;color:#fff!important}.bg-shades-black{background-color:#000!important;color:#fff!important}.bg-shades-white{background-color:#fff!important;color:#000!important}.bg-shades-transparent{background-color:transparent!important;color:currentColor!important}.text-black{color:#000!important}.text-white{color:#fff!important}.text-transparent{color:transparent!important}.text-red{color:#f44336!important}.text-red-lighten-5{color:#ffebee!important}.text-red-lighten-4{color:#ffcdd2!important}.text-red-lighten-3{color:#ef9a9a!important}.text-red-lighten-2{color:#e57373!important}.text-red-lighten-1{color:#ef5350!important}.text-red-darken-1{color:#e53935!important}.text-red-darken-2{color:#d32f2f!important}.text-red-darken-3{color:#c62828!important}.text-red-darken-4{color:#b71c1c!important}.text-red-accent-1{color:#ff8a80!important}.text-red-accent-2{color:#ff5252!important}.text-red-accent-3{color:#ff1744!important}.text-red-accent-4{color:#d50000!important}.text-pink{color:#e91e63!important}.text-pink-lighten-5{color:#fce4ec!important}.text-pink-lighten-4{color:#f8bbd0!important}.text-pink-lighten-3{color:#f48fb1!important}.text-pink-lighten-2{color:#f06292!important}.text-pink-lighten-1{color:#ec407a!important}.text-pink-darken-1{color:#d81b60!important}.text-pink-darken-2{color:#c2185b!important}.text-pink-darken-3{color:#ad1457!important}.text-pink-darken-4{color:#880e4f!important}.text-pink-accent-1{color:#ff80ab!important}.text-pink-accent-2{color:#ff4081!important}.text-pink-accent-3{color:#f50057!important}.text-pink-accent-4{color:#c51162!important}.text-purple{color:#9c27b0!important}.text-purple-lighten-5{color:#f3e5f5!important}.text-purple-lighten-4{color:#e1bee7!important}.text-purple-lighten-3{color:#ce93d8!important}.text-purple-lighten-2{color:#ba68c8!important}.text-purple-lighten-1{color:#ab47bc!important}.text-purple-darken-1{color:#8e24aa!important}.text-purple-darken-2{color:#7b1fa2!important}.text-purple-darken-3{color:#6a1b9a!important}.text-purple-darken-4{color:#4a148c!important}.text-purple-accent-1{color:#ea80fc!important}.text-purple-accent-2{color:#e040fb!important}.text-purple-accent-3{color:#d500f9!important}.text-purple-accent-4{color:#a0f!important}.text-deep-purple{color:#673ab7!important}.text-deep-purple-lighten-5{color:#ede7f6!important}.text-deep-purple-lighten-4{color:#d1c4e9!important}.text-deep-purple-lighten-3{color:#b39ddb!important}.text-deep-purple-lighten-2{color:#9575cd!important}.text-deep-purple-lighten-1{color:#7e57c2!important}.text-deep-purple-darken-1{color:#5e35b1!important}.text-deep-purple-darken-2{color:#512da8!important}.text-deep-purple-darken-3{color:#4527a0!important}.text-deep-purple-darken-4{color:#311b92!important}.text-deep-purple-accent-1{color:#b388ff!important}.text-deep-purple-accent-2{color:#7c4dff!important}.text-deep-purple-accent-3{color:#651fff!important}.text-deep-purple-accent-4{color:#6200ea!important}.text-indigo{color:#3f51b5!important}.text-indigo-lighten-5{color:#e8eaf6!important}.text-indigo-lighten-4{color:#c5cae9!important}.text-indigo-lighten-3{color:#9fa8da!important}.text-indigo-lighten-2{color:#7986cb!important}.text-indigo-lighten-1{color:#5c6bc0!important}.text-indigo-darken-1{color:#3949ab!important}.text-indigo-darken-2{color:#303f9f!important}.text-indigo-darken-3{color:#283593!important}.text-indigo-darken-4{color:#1a237e!important}.text-indigo-accent-1{color:#8c9eff!important}.text-indigo-accent-2{color:#536dfe!important}.text-indigo-accent-3{color:#3d5afe!important}.text-indigo-accent-4{color:#304ffe!important}.text-blue{color:#2196f3!important}.text-blue-lighten-5{color:#e3f2fd!important}.text-blue-lighten-4{color:#bbdefb!important}.text-blue-lighten-3{color:#90caf9!important}.text-blue-lighten-2{color:#64b5f6!important}.text-blue-lighten-1{color:#42a5f5!important}.text-blue-darken-1{color:#1e88e5!important}.text-blue-darken-2{color:#1976d2!important}.text-blue-darken-3{color:#1565c0!important}.text-blue-darken-4{color:#0d47a1!important}.text-blue-accent-1{color:#82b1ff!important}.text-blue-accent-2{color:#448aff!important}.text-blue-accent-3{color:#2979ff!important}.text-blue-accent-4{color:#2962ff!important}.text-light-blue{color:#03a9f4!important}.text-light-blue-lighten-5{color:#e1f5fe!important}.text-light-blue-lighten-4{color:#b3e5fc!important}.text-light-blue-lighten-3{color:#81d4fa!important}.text-light-blue-lighten-2{color:#4fc3f7!important}.text-light-blue-lighten-1{color:#29b6f6!important}.text-light-blue-darken-1{color:#039be5!important}.text-light-blue-darken-2{color:#0288d1!important}.text-light-blue-darken-3{color:#0277bd!important}.text-light-blue-darken-4{color:#01579b!important}.text-light-blue-accent-1{color:#80d8ff!important}.text-light-blue-accent-2{color:#40c4ff!important}.text-light-blue-accent-3{color:#00b0ff!important}.text-light-blue-accent-4{color:#0091ea!important}.text-cyan{color:#00bcd4!important}.text-cyan-lighten-5{color:#e0f7fa!important}.text-cyan-lighten-4{color:#b2ebf2!important}.text-cyan-lighten-3{color:#80deea!important}.text-cyan-lighten-2{color:#4dd0e1!important}.text-cyan-lighten-1{color:#26c6da!important}.text-cyan-darken-1{color:#00acc1!important}.text-cyan-darken-2{color:#0097a7!important}.text-cyan-darken-3{color:#00838f!important}.text-cyan-darken-4{color:#006064!important}.text-cyan-accent-1{color:#84ffff!important}.text-cyan-accent-2{color:#18ffff!important}.text-cyan-accent-3{color:#00e5ff!important}.text-cyan-accent-4{color:#00b8d4!important}.text-teal{color:#009688!important}.text-teal-lighten-5{color:#e0f2f1!important}.text-teal-lighten-4{color:#b2dfdb!important}.text-teal-lighten-3{color:#80cbc4!important}.text-teal-lighten-2{color:#4db6ac!important}.text-teal-lighten-1{color:#26a69a!important}.text-teal-darken-1{color:#00897b!important}.text-teal-darken-2{color:#00796b!important}.text-teal-darken-3{color:#00695c!important}.text-teal-darken-4{color:#004d40!important}.text-teal-accent-1{color:#a7ffeb!important}.text-teal-accent-2{color:#64ffda!important}.text-teal-accent-3{color:#1de9b6!important}.text-teal-accent-4{color:#00bfa5!important}.text-green{color:#4caf50!important}.text-green-lighten-5{color:#e8f5e9!important}.text-green-lighten-4{color:#c8e6c9!important}.text-green-lighten-3{color:#a5d6a7!important}.text-green-lighten-2{color:#81c784!important}.text-green-lighten-1{color:#66bb6a!important}.text-green-darken-1{color:#43a047!important}.text-green-darken-2{color:#388e3c!important}.text-green-darken-3{color:#2e7d32!important}.text-green-darken-4{color:#1b5e20!important}.text-green-accent-1{color:#b9f6ca!important}.text-green-accent-2{color:#69f0ae!important}.text-green-accent-3{color:#00e676!important}.text-green-accent-4{color:#00c853!important}.text-light-green{color:#8bc34a!important}.text-light-green-lighten-5{color:#f1f8e9!important}.text-light-green-lighten-4{color:#dcedc8!important}.text-light-green-lighten-3{color:#c5e1a5!important}.text-light-green-lighten-2{color:#aed581!important}.text-light-green-lighten-1{color:#9ccc65!important}.text-light-green-darken-1{color:#7cb342!important}.text-light-green-darken-2{color:#689f38!important}.text-light-green-darken-3{color:#558b2f!important}.text-light-green-darken-4{color:#33691e!important}.text-light-green-accent-1{color:#ccff90!important}.text-light-green-accent-2{color:#b2ff59!important}.text-light-green-accent-3{color:#76ff03!important}.text-light-green-accent-4{color:#64dd17!important}.text-lime{color:#cddc39!important}.text-lime-lighten-5{color:#f9fbe7!important}.text-lime-lighten-4{color:#f0f4c3!important}.text-lime-lighten-3{color:#e6ee9c!important}.text-lime-lighten-2{color:#dce775!important}.text-lime-lighten-1{color:#d4e157!important}.text-lime-darken-1{color:#c0ca33!important}.text-lime-darken-2{color:#afb42b!important}.text-lime-darken-3{color:#9e9d24!important}.text-lime-darken-4{color:#827717!important}.text-lime-accent-1{color:#f4ff81!important}.text-lime-accent-2{color:#eeff41!important}.text-lime-accent-3{color:#c6ff00!important}.text-lime-accent-4{color:#aeea00!important}.text-yellow{color:#ffeb3b!important}.text-yellow-lighten-5{color:#fffde7!important}.text-yellow-lighten-4{color:#fff9c4!important}.text-yellow-lighten-3{color:#fff59d!important}.text-yellow-lighten-2{color:#fff176!important}.text-yellow-lighten-1{color:#ffee58!important}.text-yellow-darken-1{color:#fdd835!important}.text-yellow-darken-2{color:#fbc02d!important}.text-yellow-darken-3{color:#f9a825!important}.text-yellow-darken-4{color:#f57f17!important}.text-yellow-accent-1{color:#ffff8d!important}.text-yellow-accent-2{color:#ff0!important}.text-yellow-accent-3{color:#ffea00!important}.text-yellow-accent-4{color:#ffd600!important}.text-amber{color:#ffc107!important}.text-amber-lighten-5{color:#fff8e1!important}.text-amber-lighten-4{color:#ffecb3!important}.text-amber-lighten-3{color:#ffe082!important}.text-amber-lighten-2{color:#ffd54f!important}.text-amber-lighten-1{color:#ffca28!important}.text-amber-darken-1{color:#ffb300!important}.text-amber-darken-2{color:#ffa000!important}.text-amber-darken-3{color:#ff8f00!important}.text-amber-darken-4{color:#ff6f00!important}.text-amber-accent-1{color:#ffe57f!important}.text-amber-accent-2{color:#ffd740!important}.text-amber-accent-3{color:#ffc400!important}.text-amber-accent-4{color:#ffab00!important}.text-orange{color:#ff9800!important}.text-orange-lighten-5{color:#fff3e0!important}.text-orange-lighten-4{color:#ffe0b2!important}.text-orange-lighten-3{color:#ffcc80!important}.text-orange-lighten-2{color:#ffb74d!important}.text-orange-lighten-1{color:#ffa726!important}.text-orange-darken-1{color:#fb8c00!important}.text-orange-darken-2{color:#f57c00!important}.text-orange-darken-3{color:#ef6c00!important}.text-orange-darken-4{color:#e65100!important}.text-orange-accent-1{color:#ffd180!important}.text-orange-accent-2{color:#ffab40!important}.text-orange-accent-3{color:#ff9100!important}.text-orange-accent-4{color:#ff6d00!important}.text-deep-orange{color:#ff5722!important}.text-deep-orange-lighten-5{color:#fbe9e7!important}.text-deep-orange-lighten-4{color:#ffccbc!important}.text-deep-orange-lighten-3{color:#ffab91!important}.text-deep-orange-lighten-2{color:#ff8a65!important}.text-deep-orange-lighten-1{color:#ff7043!important}.text-deep-orange-darken-1{color:#f4511e!important}.text-deep-orange-darken-2{color:#e64a19!important}.text-deep-orange-darken-3{color:#d84315!important}.text-deep-orange-darken-4{color:#bf360c!important}.text-deep-orange-accent-1{color:#ff9e80!important}.text-deep-orange-accent-2{color:#ff6e40!important}.text-deep-orange-accent-3{color:#ff3d00!important}.text-deep-orange-accent-4{color:#dd2c00!important}.text-brown{color:#795548!important}.text-brown-lighten-5{color:#efebe9!important}.text-brown-lighten-4{color:#d7ccc8!important}.text-brown-lighten-3{color:#bcaaa4!important}.text-brown-lighten-2{color:#a1887f!important}.text-brown-lighten-1{color:#8d6e63!important}.text-brown-darken-1{color:#6d4c41!important}.text-brown-darken-2{color:#5d4037!important}.text-brown-darken-3{color:#4e342e!important}.text-brown-darken-4{color:#3e2723!important}.text-blue-grey{color:#607d8b!important}.text-blue-grey-lighten-5{color:#eceff1!important}.text-blue-grey-lighten-4{color:#cfd8dc!important}.text-blue-grey-lighten-3{color:#b0bec5!important}.text-blue-grey-lighten-2{color:#90a4ae!important}.text-blue-grey-lighten-1{color:#78909c!important}.text-blue-grey-darken-1{color:#546e7a!important}.text-blue-grey-darken-2{color:#455a64!important}.text-blue-grey-darken-3{color:#37474f!important}.text-blue-grey-darken-4{color:#263238!important}.text-grey{color:#9e9e9e!important}.text-grey-lighten-5{color:#fafafa!important}.text-grey-lighten-4{color:#f5f5f5!important}.text-grey-lighten-3{color:#eee!important}.text-grey-lighten-2{color:#e0e0e0!important}.text-grey-lighten-1{color:#bdbdbd!important}.text-grey-darken-1{color:#757575!important}.text-grey-darken-2{color:#616161!important}.text-grey-darken-3{color:#424242!important}.text-grey-darken-4{color:#212121!important}.text-shades-black{color:#000!important}.text-shades-white{color:#fff!important}.text-shades-transparent{color:transparent!important}\n\n/*!\n * ress.css \u2022 v2.0.4\n * MIT License\n * github.com/filipelinhares/ress\n */html{box-sizing:border-box;overflow-y:scroll;-webkit-text-size-adjust:100%;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-break:normal}*,:after,:before{background-repeat:no-repeat;box-sizing:inherit}:after,:before{text-decoration:inherit;vertical-align:inherit}*{margin:0;padding:0}hr{height:0;overflow:visible}details,main{display:block}summary{display:list-item}small{font-size:80%}[hidden]{display:none}abbr[title]{border-bottom:none;text-decoration:underline;-webkit-text-decoration:underline dotted;text-decoration:underline dotted}a{background-color:transparent}a:active,a:hover{outline-width:0}code,kbd,pre,samp{font-family:monospace,monospace}pre{font-size:1em}b,strong{font-weight:bolder}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}input{border-radius:0}[disabled]{cursor:default}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}textarea{overflow:auto;resize:vertical}button,input,optgroup,select,textarea{font:inherit}optgroup{font-weight:700}button{overflow:visible}button,select{text-transform:none}[role=button],[type=button],[type=reset],[type=submit],button{color:inherit;cursor:pointer}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button:-moz-focusring{outline:1px dotted ButtonText}[type=reset],[type=submit],button,html [type=button]{-webkit-appearance:button}button,input,select,textarea{background-color:transparent;border-style:none}select{-moz-appearance:none;-webkit-appearance:none}select::-ms-expand{display:none}select::-ms-value{color:currentColor}legend{border:0;color:inherit;display:table;max-width:100%;white-space:normal}::-webkit-file-upload-button{-webkit-appearance:button;color:inherit;font:inherit}::-ms-clear,::-ms-reveal{display:none}img{border-style:none}progress{vertical-align:baseline}@media screen{[hidden~=screen]{display:inherit}[hidden~=screen]:not(:active):not(:focus):not(:target){position:absolute!important;clip:rect(0 0 0 0)!important}}[aria-busy=true]{cursor:progress}[aria-controls]{cursor:pointer}[aria-disabled=true]{cursor:default}.dialog-bottom-transition-enter-active,.dialog-top-transition-enter-active,.dialog-transition-enter-active{transition-duration:225ms!important;transition-timing-function:cubic-bezier(0,0,.2,1)!important}.dialog-bottom-transition-leave-active,.dialog-top-transition-leave-active,.dialog-transition-leave-active{transition-duration:125ms!important;transition-timing-function:cubic-bezier(.4,0,1,1)!important}.dialog-bottom-transition-enter-active,.dialog-bottom-transition-leave-active,.dialog-top-transition-enter-active,.dialog-top-transition-leave-active,.dialog-transition-enter-active,.dialog-transition-leave-active{pointer-events:none;transition-property:transform,opacity!important}.dialog-transition-enter-from,.dialog-transition-leave-to{opacity:0;transform:scale(.9)}.dialog-transition-enter-to,.dialog-transition-leave-from{opacity:1}.dialog-bottom-transition-enter-from,.dialog-bottom-transition-leave-to{transform:translateY(calc(50vh + 50%))}.dialog-top-transition-enter-from,.dialog-top-transition-leave-to{transform:translateY(calc(-50vh - 50%))}.picker-reverse-transition-enter-active,.picker-reverse-transition-leave-active,.picker-transition-enter-active,.picker-transition-leave-active{transition-duration:.3s!important;transition-timing-function:cubic-bezier(.4,0,.2,1)!important}.picker-reverse-transition-move,.picker-transition-move{transition-duration:.5s!important;transition-property:transform!important;transition-timing-function:cubic-bezier(.4,0,.2,1)!important}.picker-reverse-transition-enter-from,.picker-reverse-transition-leave-to,.picker-transition-enter-from,.picker-transition-leave-to{opacity:0}.picker-reverse-transition-leave-active,.picker-reverse-transition-leave-from,.picker-reverse-transition-leave-to,.picker-transition-leave-active,.picker-transition-leave-from,.picker-transition-leave-to{position:absolute!important}.picker-reverse-transition-enter-active,.picker-reverse-transition-leave-active,.picker-transition-enter-active,.picker-transition-leave-active{transition-property:transform,opacity!important}.picker-transition-enter-active,.picker-transition-leave-active{transition-duration:.3s!important;transition-timing-function:cubic-bezier(.4,0,.2,1)!important}.picker-transition-move{transition-duration:.5s!important;transition-property:transform!important;transition-timing-function:cubic-bezier(.4,0,.2,1)!important}.picker-transition-enter-from{transform:translateY(100%)}.picker-transition-leave-to{transform:translateY(-100%)}.picker-reverse-transition-enter-active,.picker-reverse-transition-leave-active{transition-duration:.3s!important;transition-timing-function:cubic-bezier(.4,0,.2,1)!important}.picker-reverse-transition-move{transition-duration:.5s!important;transition-property:transform!important;transition-timing-function:cubic-bezier(.4,0,.2,1)!important}.picker-reverse-transition-enter-from{transform:translateY(-100%)}.picker-reverse-transition-leave-to{transform:translateY(100%)}.expand-transition-enter-active,.expand-transition-leave-active{transition-duration:.3s!important;transition-timing-function:cubic-bezier(.4,0,.2,1)!important}.expand-transition-move{transition-duration:.5s!important;transition-property:transform!important;transition-timing-function:cubic-bezier(.4,0,.2,1)!important}.expand-transition-enter-active,.expand-transition-leave-active{transition-property:height!important}.expand-x-transition-enter-active,.expand-x-transition-leave-active{transition-duration:.3s!important;transition-timing-function:cubic-bezier(.4,0,.2,1)!important}.expand-x-transition-move{transition-duration:.5s!important;transition-property:transform!important;transition-timing-function:cubic-bezier(.4,0,.2,1)!important}.expand-x-transition-enter-active,.expand-x-transition-leave-active{transition-property:width!important}.scale-transition-enter-active,.scale-transition-leave-active{transition-duration:.3s!important;transition-timing-function:cubic-bezier(.4,0,.2,1)!important}.scale-transition-move{transition-duration:.5s!important;transition-property:transform!important;transition-timing-function:cubic-bezier(.4,0,.2,1)!important}.scale-transition-leave-to{opacity:0}.scale-transition-leave-active{transition-duration:.1s!important}.scale-transition-enter-from{opacity:0;transform:scale(0)}.scale-transition-enter-active,.scale-transition-leave-active{transition-property:transform,opacity!important}.scale-rotate-transition-enter-active,.scale-rotate-transition-leave-active{transition-duration:.3s!important;transition-timing-function:cubic-bezier(.4,0,.2,1)!important}.scale-rotate-transition-move{transition-duration:.5s!important;transition-property:transform!important;transition-timing-function:cubic-bezier(.4,0,.2,1)!important}.scale-rotate-transition-leave-to{opacity:0}.scale-rotate-transition-leave-active{transition-duration:.1s!important}.scale-rotate-transition-enter-from{opacity:0;transform:scale(0) rotate(-45deg)}.scale-rotate-transition-enter-active,.scale-rotate-transition-leave-active{transition-property:transform,opacity!important}.scale-rotate-reverse-transition-enter-active,.scale-rotate-reverse-transition-leave-active{transition-duration:.3s!important;transition-timing-function:cubic-bezier(.4,0,.2,1)!important}.scale-rotate-reverse-transition-move{transition-duration:.5s!important;transition-property:transform!important;transition-timing-function:cubic-bezier(.4,0,.2,1)!important}.scale-rotate-reverse-transition-leave-to{opacity:0}.scale-rotate-reverse-transition-leave-active{transition-duration:.1s!important}.scale-rotate-reverse-transition-enter-from{opacity:0;transform:scale(0) rotate(45deg)}.scale-rotate-reverse-transition-enter-active,.scale-rotate-reverse-transition-leave-active{transition-property:transform,opacity!important}.message-transition-enter-active,.message-transition-leave-active{transition-duration:.3s!important;transition-timing-function:cubic-bezier(.4,0,.2,1)!important}.message-transition-move{transition-duration:.5s!important;transition-property:transform!important;transition-timing-function:cubic-bezier(.4,0,.2,1)!important}.message-transition-enter-from,.message-transition-leave-to{opacity:0;transform:translateY(-15px)}.message-transition-leave-active,.message-transition-leave-from{position:absolute}.message-transition-enter-active,.message-transition-leave-active{transition-property:transform,opacity!important}.slide-y-transition-enter-active,.slide-y-transition-leave-active{transition-duration:.3s!important;transition-timing-function:cubic-bezier(.4,0,.2,1)!important}.slide-y-transition-move{transition-duration:.5s!important;transition-property:transform!important;transition-timing-function:cubic-bezier(.4,0,.2,1)!important}.slide-y-transition-enter-from,.slide-y-transition-leave-to{opacity:0;transform:translateY(-15px)}.slide-y-transition-enter-active,.slide-y-transition-leave-active{transition-property:transform,opacity!important}.slide-y-reverse-transition-enter-active,.slide-y-reverse-transition-leave-active{transition-duration:.3s!important;transition-timing-function:cubic-bezier(.4,0,.2,1)!important}.slide-y-reverse-transition-move{transition-duration:.5s!important;transition-property:transform!important;transition-timing-function:cubic-bezier(.4,0,.2,1)!important}.slide-y-reverse-transition-enter-from,.slide-y-reverse-transition-leave-to{opacity:0;transform:translateY(15px)}.slide-y-reverse-transition-enter-active,.slide-y-reverse-transition-leave-active{transition-property:transform,opacity!important}.scroll-y-transition-enter-active,.scroll-y-transition-leave-active{transition-duration:.3s!important;transition-timing-function:cubic-bezier(.4,0,.2,1)!important}.scroll-y-transition-move{transition-duration:.5s!important;transition-property:transform!important;transition-timing-function:cubic-bezier(.4,0,.2,1)!important}.scroll-y-transition-enter-from,.scroll-y-transition-leave-to{opacity:0}.scroll-y-transition-enter-from{transform:translateY(-15px)}.scroll-y-transition-leave-to{transform:translateY(15px)}.scroll-y-transition-enter-active,.scroll-y-transition-leave-active{transition-property:transform,opacity!important}.scroll-y-reverse-transition-enter-active,.scroll-y-reverse-transition-leave-active{transition-duration:.3s!important;transition-timing-function:cubic-bezier(.4,0,.2,1)!important}.scroll-y-reverse-transition-move{transition-duration:.5s!important;transition-property:transform!important;transition-timing-function:cubic-bezier(.4,0,.2,1)!important}.scroll-y-reverse-transition-enter-from,.scroll-y-reverse-transition-leave-to{opacity:0}.scroll-y-reverse-transition-enter-from{transform:translateY(15px)}.scroll-y-reverse-transition-leave-to{transform:translateY(-15px)}.scroll-y-reverse-transition-enter-active,.scroll-y-reverse-transition-leave-active{transition-property:transform,opacity!important}.scroll-x-transition-enter-active,.scroll-x-transition-leave-active{transition-duration:.3s!important;transition-timing-function:cubic-bezier(.4,0,.2,1)!important}.scroll-x-transition-move{transition-duration:.5s!important;transition-property:transform!important;transition-timing-function:cubic-bezier(.4,0,.2,1)!important}.scroll-x-transition-enter-from,.scroll-x-transition-leave-to{opacity:0}.scroll-x-transition-enter-from{transform:translateX(-15px)}.scroll-x-transition-leave-to{transform:translateX(15px)}.scroll-x-transition-enter-active,.scroll-x-transition-leave-active{transition-property:transform,opacity!important}.scroll-x-reverse-transition-enter-active,.scroll-x-reverse-transition-leave-active{transition-duration:.3s!important;transition-timing-function:cubic-bezier(.4,0,.2,1)!important}.scroll-x-reverse-transition-move{transition-duration:.5s!important;transition-property:transform!important;transition-timing-function:cubic-bezier(.4,0,.2,1)!important}.scroll-x-reverse-transition-enter-from,.scroll-x-reverse-transition-leave-to{opacity:0}.scroll-x-reverse-transition-enter-from{transform:translateX(15px)}.scroll-x-reverse-transition-leave-to{transform:translateX(-15px)}.scroll-x-reverse-transition-enter-active,.scroll-x-reverse-transition-leave-active{transition-property:transform,opacity!important}.slide-x-transition-enter-active,.slide-x-transition-leave-active{transition-duration:.3s!important;transition-timing-function:cubic-bezier(.4,0,.2,1)!important}.slide-x-transition-move{transition-duration:.5s!important;transition-property:transform!important;transition-timing-function:cubic-bezier(.4,0,.2,1)!important}.slide-x-transition-enter-from,.slide-x-transition-leave-to{opacity:0;transform:translateX(-15px)}.slide-x-transition-enter-active,.slide-x-transition-leave-active{transition-property:transform,opacity!important}.slide-x-reverse-transition-enter-active,.slide-x-reverse-transition-leave-active{transition-duration:.3s!important;transition-timing-function:cubic-bezier(.4,0,.2,1)!important}.slide-x-reverse-transition-move{transition-duration:.5s!important;transition-property:transform!important;transition-timing-function:cubic-bezier(.4,0,.2,1)!important}.slide-x-reverse-transition-enter-from,.slide-x-reverse-transition-leave-to{opacity:0;transform:translateX(15px)}.slide-x-reverse-transition-enter-active,.slide-x-reverse-transition-leave-active{transition-property:transform,opacity!important}.fade-transition-enter-active,.fade-transition-leave-active{transition-duration:.3s!important;transition-timing-function:cubic-bezier(.4,0,.2,1)!important}.fade-transition-move{transition-duration:.5s!important;transition-property:transform!important;transition-timing-function:cubic-bezier(.4,0,.2,1)!important}.fade-transition-enter-from,.fade-transition-leave-to{opacity:0!important}.fade-transition-enter-active,.fade-transition-leave-active{transition-property:opacity!important}.fab-transition-enter-active,.fab-transition-leave-active{transition-duration:.3s!important;transition-timing-function:cubic-bezier(.4,0,.2,1)!important}.fab-transition-move{transition-duration:.5s!important;transition-property:transform!important;transition-timing-function:cubic-bezier(.4,0,.2,1)!important}.fab-transition-enter-from,.fab-transition-leave-to{transform:scale(0) rotate(-45deg)}.fab-transition-enter-active,.fab-transition-leave-active{transition-property:transform!important}.v-locale--is-rtl{direction:rtl}.v-locale--is-ltr{direction:ltr}.blockquote{font-size:18px;font-weight:300;padding:16px 0 16px 24px}html{font-family:Roboto,sans-serif;font-size:1rem;line-height:1.5;overflow-x:hidden;text-rendering:optimizeLegibility;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;-webkit-tap-highlight-color:rgba(0,0,0,0)}html.overflow-y-hidden{overflow-y:hidden!important}:root{--v-theme-overlay-multiplier:1;--v-scrollbar-offset:0px}@supports (-webkit-touch-callout:none){body{cursor:pointer}}@media only print{.hidden-print-only{display:none!important}}@media only screen{.hidden-screen-only{display:none!important}}@media (max-width:599.98px){.hidden-xs{display:none!important}}@media (min-width:600px) and (max-width:959.98px){.hidden-sm{display:none!important}}@media (min-width:960px) and (max-width:1279.98px){.hidden-md{display:none!important}}@media (min-width:1280px) and (max-width:1919.98px){.hidden-lg{display:none!important}}@media (min-width:1920px) and (max-width:2559.98px){.hidden-xl{display:none!important}}@media (min-width:2560px){.hidden-xxl{display:none!important}}@media (min-width:600px){.hidden-sm-and-up{display:none!important}}@media (min-width:960px){.hidden-md-and-up{display:none!important}}@media (min-width:1280px){.hidden-lg-and-up{display:none!important}}@media (min-width:1920px){.hidden-xl-and-up{display:none!important}}@media (max-width:959.98px){.hidden-sm-and-down{display:none!important}}@media (max-width:1279.98px){.hidden-md-and-down{display:none!important}}@media (max-width:1919.98px){.hidden-lg-and-down{display:none!important}}@media (max-width:2559.98px){.hidden-xl-and-down{display:none!important}}.elevation-24{box-shadow:0 11px 15px -7px var(--v-shadow-key-umbra-opacity,rgba(0,0,0,.2)),0 24px 38px 3px var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.14)),0 9px 46px 8px var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.12))!important}.elevation-23{box-shadow:0 11px 14px -7px var(--v-shadow-key-umbra-opacity,rgba(0,0,0,.2)),0 23px 36px 3px var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.14)),0 9px 44px 8px var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.12))!important}.elevation-22{box-shadow:0 10px 14px -6px var(--v-shadow-key-umbra-opacity,rgba(0,0,0,.2)),0 22px 35px 3px var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.14)),0 8px 42px 7px var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.12))!important}.elevation-21{box-shadow:0 10px 13px -6px var(--v-shadow-key-umbra-opacity,rgba(0,0,0,.2)),0 21px 33px 3px var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.14)),0 8px 40px 7px var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.12))!important}.elevation-20{box-shadow:0 10px 13px -6px var(--v-shadow-key-umbra-opacity,rgba(0,0,0,.2)),0 20px 31px 3px var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.14)),0 8px 38px 7px var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.12))!important}.elevation-19{box-shadow:0 9px 12px -6px var(--v-shadow-key-umbra-opacity,rgba(0,0,0,.2)),0 19px 29px 2px var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.14)),0 7px 36px 6px var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.12))!important}.elevation-18{box-shadow:0 9px 11px -5px var(--v-shadow-key-umbra-opacity,rgba(0,0,0,.2)),0 18px 28px 2px var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.14)),0 7px 34px 6px var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.12))!important}.elevation-17{box-shadow:0 8px 11px -5px var(--v-shadow-key-umbra-opacity,rgba(0,0,0,.2)),0 17px 26px 2px var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.14)),0 6px 32px 5px var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.12))!important}.elevation-16{box-shadow:0 8px 10px -5px var(--v-shadow-key-umbra-opacity,rgba(0,0,0,.2)),0 16px 24px 2px var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.14)),0 6px 30px 5px var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.12))!important}.elevation-15{box-shadow:0 8px 9px -5px var(--v-shadow-key-umbra-opacity,rgba(0,0,0,.2)),0 15px 22px 2px var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.14)),0 6px 28px 5px var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.12))!important}.elevation-14{box-shadow:0 7px 9px -4px var(--v-shadow-key-umbra-opacity,rgba(0,0,0,.2)),0 14px 21px 2px var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.14)),0 5px 26px 4px var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.12))!important}.elevation-13{box-shadow:0 7px 8px -4px var(--v-shadow-key-umbra-opacity,rgba(0,0,0,.2)),0 13px 19px 2px var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.14)),0 5px 24px 4px var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.12))!important}.elevation-12{box-shadow:0 7px 8px -4px var(--v-shadow-key-umbra-opacity,rgba(0,0,0,.2)),0 12px 17px 2px var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.14)),0 5px 22px 4px var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.12))!important}.elevation-11{box-shadow:0 6px 7px -4px var(--v-shadow-key-umbra-opacity,rgba(0,0,0,.2)),0 11px 15px 1px var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.14)),0 4px 20px 3px var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.12))!important}.elevation-10{box-shadow:0 6px 6px -3px var(--v-shadow-key-umbra-opacity,rgba(0,0,0,.2)),0 10px 14px 1px var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.14)),0 4px 18px 3px var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.12))!important}.elevation-9{box-shadow:0 5px 6px -3px var(--v-shadow-key-umbra-opacity,rgba(0,0,0,.2)),0 9px 12px 1px var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.14)),0 3px 16px 2px var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.12))!important}.elevation-8{box-shadow:0 5px 5px -3px var(--v-shadow-key-umbra-opacity,rgba(0,0,0,.2)),0 8px 10px 1px var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.14)),0 3px 14px 2px var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.12))!important}.elevation-7{box-shadow:0 4px 5px -2px var(--v-shadow-key-umbra-opacity,rgba(0,0,0,.2)),0 7px 10px 1px var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.14)),0 2px 16px 1px var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.12))!important}.elevation-6{box-shadow:0 3px 5px -1px var(--v-shadow-key-umbra-opacity,rgba(0,0,0,.2)),0 6px 10px 0 var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.14)),0 1px 18px 0 var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.12))!important}.elevation-5{box-shadow:0 3px 5px -1px var(--v-shadow-key-umbra-opacity,rgba(0,0,0,.2)),0 5px 8px 0 var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.14)),0 1px 14px 0 var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.12))!important}.elevation-4{box-shadow:0 2px 4px -1px var(--v-shadow-key-umbra-opacity,rgba(0,0,0,.2)),0 4px 5px 0 var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.14)),0 1px 10px 0 var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.12))!important}.elevation-3{box-shadow:0 3px 3px -2px var(--v-shadow-key-umbra-opacity,rgba(0,0,0,.2)),0 3px 4px 0 var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.14)),0 1px 8px 0 var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.12))!important}.elevation-2{box-shadow:0 3px 1px -2px var(--v-shadow-key-umbra-opacity,rgba(0,0,0,.2)),0 2px 2px 0 var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.14)),0 1px 5px 0 var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.12))!important}.elevation-1{box-shadow:0 2px 1px -1px var(--v-shadow-key-umbra-opacity,rgba(0,0,0,.2)),0 1px 1px 0 var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.14)),0 1px 3px 0 var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.12))!important}.elevation-0{box-shadow:0 0 0 0 var(--v-shadow-key-umbra-opacity,rgba(0,0,0,.2)),0 0 0 0 var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.14)),0 0 0 0 var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.12))!important}.d-sr-only,.d-sr-only-focusable:not(:focus){border:0!important;clip:rect(0,0,0,0)!important;height:1px!important;margin:-1px!important;overflow:hidden!important;padding:0!important;position:absolute!important;white-space:nowrap!important;width:1px!important}.overflow-auto{overflow:auto!important}.overflow-hidden{overflow:hidden!important}.overflow-visible{overflow:visible!important}.overflow-x-auto{overflow-x:auto!important}.overflow-x-hidden{overflow-x:hidden!important}.overflow-y-auto{overflow-y:auto!important}.overflow-y-hidden{overflow-y:hidden!important}.d-none{display:none!important}.d-inline{display:inline!important}.d-inline-block{display:inline-block!important}.d-block{display:block!important}.d-table{display:table!important}.d-table-row{display:table-row!important}.d-table-cell{display:table-cell!important}.d-flex{display:flex!important}.d-inline-flex{display:inline-flex!important}.float-none{float:none!important}.float-left{float:left!important}.float-right{float:right!important}.v-locale--is-rtl .float-end{float:left!important}.v-locale--is-ltr .float-end,.v-locale--is-rtl .float-start{float:right!important}.v-locale--is-ltr .float-start{float:left!important}.flex-1-1,.flex-fill{flex:1 1 auto!important}.flex-1-0{flex:1 0 auto!important}.flex-0-1{flex:0 1 auto!important}.flex-0-0{flex:0 0 auto!important}.flex-1-1-100{flex:1 1 100%!important}.flex-1-0-100{flex:1 0 100%!important}.flex-0-1-100{flex:0 1 100%!important}.flex-0-0-100{flex:0 0 100%!important}.flex-row{flex-direction:row!important}.flex-column{flex-direction:column!important}.flex-row-reverse{flex-direction:row-reverse!important}.flex-column-reverse{flex-direction:column-reverse!important}.flex-grow-0{flex-grow:0!important}.flex-grow-1{flex-grow:1!important}.flex-shrink-0{flex-shrink:0!important}.flex-shrink-1{flex-shrink:1!important}.flex-wrap{flex-wrap:wrap!important}.flex-nowrap{flex-wrap:nowrap!important}.flex-wrap-reverse{flex-wrap:wrap-reverse!important}.justify-start{justify-content:flex-start!important}.justify-end{justify-content:flex-end!important}.justify-center{justify-content:center!important}.justify-space-between{justify-content:space-between!important}.justify-space-around{justify-content:space-around!important}.justify-space-evenly{justify-content:space-evenly!important}.align-start{align-items:flex-start!important}.align-end{align-items:flex-end!important}.align-center{align-items:center!important}.align-baseline{align-items:baseline!important}.align-stretch{align-items:stretch!important}.align-content-start{align-content:flex-start!important}.align-content-end{align-content:flex-end!important}.align-content-center{align-content:center!important}.align-content-space-between{align-content:space-between!important}.align-content-space-around{align-content:space-around!important}.align-content-space-evenly{align-content:space-evenly!important}.align-content-stretch{align-content:stretch!important}.align-self-auto{align-self:auto!important}.align-self-start{align-self:flex-start!important}.align-self-end{align-self:flex-end!important}.align-self-center{align-self:center!important}.align-self-baseline{align-self:baseline!important}.align-self-stretch{align-self:stretch!important}.order-first{order:-1!important}.order-0{order:0!important}.order-1{order:1!important}.order-2{order:2!important}.order-3{order:3!important}.order-4{order:4!important}.order-5{order:5!important}.order-6{order:6!important}.order-7{order:7!important}.order-8{order:8!important}.order-9{order:9!important}.order-10{order:10!important}.order-11{order:11!important}.order-12{order:12!important}.order-last{order:13!important}.ga-0{gap:0!important}.ga-1{gap:4px!important}.ga-2{gap:8px!important}.ga-3{gap:12px!important}.ga-4{gap:16px!important}.ga-5{gap:20px!important}.ga-6{gap:24px!important}.ga-7{gap:28px!important}.ga-8{gap:32px!important}.ga-9{gap:36px!important}.ga-10{gap:40px!important}.ga-11{gap:44px!important}.ga-12{gap:48px!important}.ga-13{gap:52px!important}.ga-14{gap:56px!important}.ga-15{gap:60px!important}.ga-16{gap:64px!important}.ga-auto{gap:auto!important}.gr-0{row-gap:0!important}.gr-1{row-gap:4px!important}.gr-2{row-gap:8px!important}.gr-3{row-gap:12px!important}.gr-4{row-gap:16px!important}.gr-5{row-gap:20px!important}.gr-6{row-gap:24px!important}.gr-7{row-gap:28px!important}.gr-8{row-gap:32px!important}.gr-9{row-gap:36px!important}.gr-10{row-gap:40px!important}.gr-11{row-gap:44px!important}.gr-12{row-gap:48px!important}.gr-13{row-gap:52px!important}.gr-14{row-gap:56px!important}.gr-15{row-gap:60px!important}.gr-16{row-gap:64px!important}.gr-auto{row-gap:auto!important}.gc-0{-moz-column-gap:0!important;column-gap:0!important}.gc-1{-moz-column-gap:4px!important;column-gap:4px!important}.gc-2{-moz-column-gap:8px!important;column-gap:8px!important}.gc-3{-moz-column-gap:12px!important;column-gap:12px!important}.gc-4{-moz-column-gap:16px!important;column-gap:16px!important}.gc-5{-moz-column-gap:20px!important;column-gap:20px!important}.gc-6{-moz-column-gap:24px!important;column-gap:24px!important}.gc-7{-moz-column-gap:28px!important;column-gap:28px!important}.gc-8{-moz-column-gap:32px!important;column-gap:32px!important}.gc-9{-moz-column-gap:36px!important;column-gap:36px!important}.gc-10{-moz-column-gap:40px!important;column-gap:40px!important}.gc-11{-moz-column-gap:44px!important;column-gap:44px!important}.gc-12{-moz-column-gap:48px!important;column-gap:48px!important}.gc-13{-moz-column-gap:52px!important;column-gap:52px!important}.gc-14{-moz-column-gap:56px!important;column-gap:56px!important}.gc-15{-moz-column-gap:60px!important;column-gap:60px!important}.gc-16{-moz-column-gap:64px!important;column-gap:64px!important}.gc-auto{-moz-column-gap:auto!important;column-gap:auto!important}.ma-0{margin:0!important}.ma-1{margin:4px!important}.ma-2{margin:8px!important}.ma-3{margin:12px!important}.ma-4{margin:16px!important}.ma-5{margin:20px!important}.ma-6{margin:24px!important}.ma-7{margin:28px!important}.ma-8{margin:32px!important}.ma-9{margin:36px!important}.ma-10{margin:40px!important}.ma-11{margin:44px!important}.ma-12{margin:48px!important}.ma-13{margin:52px!important}.ma-14{margin:56px!important}.ma-15{margin:60px!important}.ma-16{margin:64px!important}.ma-auto{margin:auto!important}.mx-0{margin-left:0!important;margin-right:0!important}.mx-1{margin-left:4px!important;margin-right:4px!important}.mx-2{margin-left:8px!important;margin-right:8px!important}.mx-3{margin-left:12px!important;margin-right:12px!important}.mx-4{margin-left:16px!important;margin-right:16px!important}.mx-5{margin-left:20px!important;margin-right:20px!important}.mx-6{margin-left:24px!important;margin-right:24px!important}.mx-7{margin-left:28px!important;margin-right:28px!important}.mx-8{margin-left:32px!important;margin-right:32px!important}.mx-9{margin-left:36px!important;margin-right:36px!important}.mx-10{margin-left:40px!important;margin-right:40px!important}.mx-11{margin-left:44px!important;margin-right:44px!important}.mx-12{margin-left:48px!important;margin-right:48px!important}.mx-13{margin-left:52px!important;margin-right:52px!important}.mx-14{margin-left:56px!important;margin-right:56px!important}.mx-15{margin-left:60px!important;margin-right:60px!important}.mx-16{margin-left:64px!important;margin-right:64px!important}.mx-auto{margin-left:auto!important;margin-right:auto!important}.my-0{margin-bottom:0!important;margin-top:0!important}.my-1{margin-bottom:4px!important;margin-top:4px!important}.my-2{margin-bottom:8px!important;margin-top:8px!important}.my-3{margin-bottom:12px!important;margin-top:12px!important}.my-4{margin-bottom:16px!important;margin-top:16px!important}.my-5{margin-bottom:20px!important;margin-top:20px!important}.my-6{margin-bottom:24px!important;margin-top:24px!important}.my-7{margin-bottom:28px!important;margin-top:28px!important}.my-8{margin-bottom:32px!important;margin-top:32px!important}.my-9{margin-bottom:36px!important;margin-top:36px!important}.my-10{margin-bottom:40px!important;margin-top:40px!important}.my-11{margin-bottom:44px!important;margin-top:44px!important}.my-12{margin-bottom:48px!important;margin-top:48px!important}.my-13{margin-bottom:52px!important;margin-top:52px!important}.my-14{margin-bottom:56px!important;margin-top:56px!important}.my-15{margin-bottom:60px!important;margin-top:60px!important}.my-16{margin-bottom:64px!important;margin-top:64px!important}.my-auto{margin-bottom:auto!important;margin-top:auto!important}.mt-0{margin-top:0!important}.mt-1{margin-top:4px!important}.mt-2{margin-top:8px!important}.mt-3{margin-top:12px!important}.mt-4{margin-top:16px!important}.mt-5{margin-top:20px!important}.mt-6{margin-top:24px!important}.mt-7{margin-top:28px!important}.mt-8{margin-top:32px!important}.mt-9{margin-top:36px!important}.mt-10{margin-top:40px!important}.mt-11{margin-top:44px!important}.mt-12{margin-top:48px!important}.mt-13{margin-top:52px!important}.mt-14{margin-top:56px!important}.mt-15{margin-top:60px!important}.mt-16{margin-top:64px!important}.mt-auto{margin-top:auto!important}.mr-0{margin-right:0!important}.mr-1{margin-right:4px!important}.mr-2{margin-right:8px!important}.mr-3{margin-right:12px!important}.mr-4{margin-right:16px!important}.mr-5{margin-right:20px!important}.mr-6{margin-right:24px!important}.mr-7{margin-right:28px!important}.mr-8{margin-right:32px!important}.mr-9{margin-right:36px!important}.mr-10{margin-right:40px!important}.mr-11{margin-right:44px!important}.mr-12{margin-right:48px!important}.mr-13{margin-right:52px!important}.mr-14{margin-right:56px!important}.mr-15{margin-right:60px!important}.mr-16{margin-right:64px!important}.mr-auto{margin-right:auto!important}.mb-0{margin-bottom:0!important}.mb-1{margin-bottom:4px!important}.mb-2{margin-bottom:8px!important}.mb-3{margin-bottom:12px!important}.mb-4{margin-bottom:16px!important}.mb-5{margin-bottom:20px!important}.mb-6{margin-bottom:24px!important}.mb-7{margin-bottom:28px!important}.mb-8{margin-bottom:32px!important}.mb-9{margin-bottom:36px!important}.mb-10{margin-bottom:40px!important}.mb-11{margin-bottom:44px!important}.mb-12{margin-bottom:48px!important}.mb-13{margin-bottom:52px!important}.mb-14{margin-bottom:56px!important}.mb-15{margin-bottom:60px!important}.mb-16{margin-bottom:64px!important}.mb-auto{margin-bottom:auto!important}.ml-0{margin-left:0!important}.ml-1{margin-left:4px!important}.ml-2{margin-left:8px!important}.ml-3{margin-left:12px!important}.ml-4{margin-left:16px!important}.ml-5{margin-left:20px!important}.ml-6{margin-left:24px!important}.ml-7{margin-left:28px!important}.ml-8{margin-left:32px!important}.ml-9{margin-left:36px!important}.ml-10{margin-left:40px!important}.ml-11{margin-left:44px!important}.ml-12{margin-left:48px!important}.ml-13{margin-left:52px!important}.ml-14{margin-left:56px!important}.ml-15{margin-left:60px!important}.ml-16{margin-left:64px!important}.ml-auto{margin-left:auto!important}.ms-0{margin-inline-start:0!important}.ms-1{margin-inline-start:4px!important}.ms-2{margin-inline-start:8px!important}.ms-3{margin-inline-start:12px!important}.ms-4{margin-inline-start:16px!important}.ms-5{margin-inline-start:20px!important}.ms-6{margin-inline-start:24px!important}.ms-7{margin-inline-start:28px!important}.ms-8{margin-inline-start:32px!important}.ms-9{margin-inline-start:36px!important}.ms-10{margin-inline-start:40px!important}.ms-11{margin-inline-start:44px!important}.ms-12{margin-inline-start:48px!important}.ms-13{margin-inline-start:52px!important}.ms-14{margin-inline-start:56px!important}.ms-15{margin-inline-start:60px!important}.ms-16{margin-inline-start:64px!important}.ms-auto{margin-inline-start:auto!important}.me-0{margin-inline-end:0!important}.me-1{margin-inline-end:4px!important}.me-2{margin-inline-end:8px!important}.me-3{margin-inline-end:12px!important}.me-4{margin-inline-end:16px!important}.me-5{margin-inline-end:20px!important}.me-6{margin-inline-end:24px!important}.me-7{margin-inline-end:28px!important}.me-8{margin-inline-end:32px!important}.me-9{margin-inline-end:36px!important}.me-10{margin-inline-end:40px!important}.me-11{margin-inline-end:44px!important}.me-12{margin-inline-end:48px!important}.me-13{margin-inline-end:52px!important}.me-14{margin-inline-end:56px!important}.me-15{margin-inline-end:60px!important}.me-16{margin-inline-end:64px!important}.me-auto{margin-inline-end:auto!important}.ma-n1{margin:-4px!important}.ma-n2{margin:-8px!important}.ma-n3{margin:-12px!important}.ma-n4{margin:-16px!important}.ma-n5{margin:-20px!important}.ma-n6{margin:-24px!important}.ma-n7{margin:-28px!important}.ma-n8{margin:-32px!important}.ma-n9{margin:-36px!important}.ma-n10{margin:-40px!important}.ma-n11{margin:-44px!important}.ma-n12{margin:-48px!important}.ma-n13{margin:-52px!important}.ma-n14{margin:-56px!important}.ma-n15{margin:-60px!important}.ma-n16{margin:-64px!important}.mx-n1{margin-left:-4px!important;margin-right:-4px!important}.mx-n2{margin-left:-8px!important;margin-right:-8px!important}.mx-n3{margin-left:-12px!important;margin-right:-12px!important}.mx-n4{margin-left:-16px!important;margin-right:-16px!important}.mx-n5{margin-left:-20px!important;margin-right:-20px!important}.mx-n6{margin-left:-24px!important;margin-right:-24px!important}.mx-n7{margin-left:-28px!important;margin-right:-28px!important}.mx-n8{margin-left:-32px!important;margin-right:-32px!important}.mx-n9{margin-left:-36px!important;margin-right:-36px!important}.mx-n10{margin-left:-40px!important;margin-right:-40px!important}.mx-n11{margin-left:-44px!important;margin-right:-44px!important}.mx-n12{margin-left:-48px!important;margin-right:-48px!important}.mx-n13{margin-left:-52px!important;margin-right:-52px!important}.mx-n14{margin-left:-56px!important;margin-right:-56px!important}.mx-n15{margin-left:-60px!important;margin-right:-60px!important}.mx-n16{margin-left:-64px!important;margin-right:-64px!important}.my-n1{margin-bottom:-4px!important;margin-top:-4px!important}.my-n2{margin-bottom:-8px!important;margin-top:-8px!important}.my-n3{margin-bottom:-12px!important;margin-top:-12px!important}.my-n4{margin-bottom:-16px!important;margin-top:-16px!important}.my-n5{margin-bottom:-20px!important;margin-top:-20px!important}.my-n6{margin-bottom:-24px!important;margin-top:-24px!important}.my-n7{margin-bottom:-28px!important;margin-top:-28px!important}.my-n8{margin-bottom:-32px!important;margin-top:-32px!important}.my-n9{margin-bottom:-36px!important;margin-top:-36px!important}.my-n10{margin-bottom:-40px!important;margin-top:-40px!important}.my-n11{margin-bottom:-44px!important;margin-top:-44px!important}.my-n12{margin-bottom:-48px!important;margin-top:-48px!important}.my-n13{margin-bottom:-52px!important;margin-top:-52px!important}.my-n14{margin-bottom:-56px!important;margin-top:-56px!important}.my-n15{margin-bottom:-60px!important;margin-top:-60px!important}.my-n16{margin-bottom:-64px!important;margin-top:-64px!important}.mt-n1{margin-top:-4px!important}.mt-n2{margin-top:-8px!important}.mt-n3{margin-top:-12px!important}.mt-n4{margin-top:-16px!important}.mt-n5{margin-top:-20px!important}.mt-n6{margin-top:-24px!important}.mt-n7{margin-top:-28px!important}.mt-n8{margin-top:-32px!important}.mt-n9{margin-top:-36px!important}.mt-n10{margin-top:-40px!important}.mt-n11{margin-top:-44px!important}.mt-n12{margin-top:-48px!important}.mt-n13{margin-top:-52px!important}.mt-n14{margin-top:-56px!important}.mt-n15{margin-top:-60px!important}.mt-n16{margin-top:-64px!important}.mr-n1{margin-right:-4px!important}.mr-n2{margin-right:-8px!important}.mr-n3{margin-right:-12px!important}.mr-n4{margin-right:-16px!important}.mr-n5{margin-right:-20px!important}.mr-n6{margin-right:-24px!important}.mr-n7{margin-right:-28px!important}.mr-n8{margin-right:-32px!important}.mr-n9{margin-right:-36px!important}.mr-n10{margin-right:-40px!important}.mr-n11{margin-right:-44px!important}.mr-n12{margin-right:-48px!important}.mr-n13{margin-right:-52px!important}.mr-n14{margin-right:-56px!important}.mr-n15{margin-right:-60px!important}.mr-n16{margin-right:-64px!important}.mb-n1{margin-bottom:-4px!important}.mb-n2{margin-bottom:-8px!important}.mb-n3{margin-bottom:-12px!important}.mb-n4{margin-bottom:-16px!important}.mb-n5{margin-bottom:-20px!important}.mb-n6{margin-bottom:-24px!important}.mb-n7{margin-bottom:-28px!important}.mb-n8{margin-bottom:-32px!important}.mb-n9{margin-bottom:-36px!important}.mb-n10{margin-bottom:-40px!important}.mb-n11{margin-bottom:-44px!important}.mb-n12{margin-bottom:-48px!important}.mb-n13{margin-bottom:-52px!important}.mb-n14{margin-bottom:-56px!important}.mb-n15{margin-bottom:-60px!important}.mb-n16{margin-bottom:-64px!important}.ml-n1{margin-left:-4px!important}.ml-n2{margin-left:-8px!important}.ml-n3{margin-left:-12px!important}.ml-n4{margin-left:-16px!important}.ml-n5{margin-left:-20px!important}.ml-n6{margin-left:-24px!important}.ml-n7{margin-left:-28px!important}.ml-n8{margin-left:-32px!important}.ml-n9{margin-left:-36px!important}.ml-n10{margin-left:-40px!important}.ml-n11{margin-left:-44px!important}.ml-n12{margin-left:-48px!important}.ml-n13{margin-left:-52px!important}.ml-n14{margin-left:-56px!important}.ml-n15{margin-left:-60px!important}.ml-n16{margin-left:-64px!important}.ms-n1{margin-inline-start:-4px!important}.ms-n2{margin-inline-start:-8px!important}.ms-n3{margin-inline-start:-12px!important}.ms-n4{margin-inline-start:-16px!important}.ms-n5{margin-inline-start:-20px!important}.ms-n6{margin-inline-start:-24px!important}.ms-n7{margin-inline-start:-28px!important}.ms-n8{margin-inline-start:-32px!important}.ms-n9{margin-inline-start:-36px!important}.ms-n10{margin-inline-start:-40px!important}.ms-n11{margin-inline-start:-44px!important}.ms-n12{margin-inline-start:-48px!important}.ms-n13{margin-inline-start:-52px!important}.ms-n14{margin-inline-start:-56px!important}.ms-n15{margin-inline-start:-60px!important}.ms-n16{margin-inline-start:-64px!important}.me-n1{margin-inline-end:-4px!important}.me-n2{margin-inline-end:-8px!important}.me-n3{margin-inline-end:-12px!important}.me-n4{margin-inline-end:-16px!important}.me-n5{margin-inline-end:-20px!important}.me-n6{margin-inline-end:-24px!important}.me-n7{margin-inline-end:-28px!important}.me-n8{margin-inline-end:-32px!important}.me-n9{margin-inline-end:-36px!important}.me-n10{margin-inline-end:-40px!important}.me-n11{margin-inline-end:-44px!important}.me-n12{margin-inline-end:-48px!important}.me-n13{margin-inline-end:-52px!important}.me-n14{margin-inline-end:-56px!important}.me-n15{margin-inline-end:-60px!important}.me-n16{margin-inline-end:-64px!important}.pa-0{padding:0!important}.pa-1{padding:4px!important}.pa-2{padding:8px!important}.pa-3{padding:12px!important}.pa-4{padding:16px!important}.pa-5{padding:20px!important}.pa-6{padding:24px!important}.pa-7{padding:28px!important}.pa-8{padding:32px!important}.pa-9{padding:36px!important}.pa-10{padding:40px!important}.pa-11{padding:44px!important}.pa-12{padding:48px!important}.pa-13{padding:52px!important}.pa-14{padding:56px!important}.pa-15{padding:60px!important}.pa-16{padding:64px!important}.px-0{padding-left:0!important;padding-right:0!important}.px-1{padding-left:4px!important;padding-right:4px!important}.px-2{padding-left:8px!important;padding-right:8px!important}.px-3{padding-left:12px!important;padding-right:12px!important}.px-4{padding-left:16px!important;padding-right:16px!important}.px-5{padding-left:20px!important;padding-right:20px!important}.px-6{padding-left:24px!important;padding-right:24px!important}.px-7{padding-left:28px!important;padding-right:28px!important}.px-8{padding-left:32px!important;padding-right:32px!important}.px-9{padding-left:36px!important;padding-right:36px!important}.px-10{padding-left:40px!important;padding-right:40px!important}.px-11{padding-left:44px!important;padding-right:44px!important}.px-12{padding-left:48px!important;padding-right:48px!important}.px-13{padding-left:52px!important;padding-right:52px!important}.px-14{padding-left:56px!important;padding-right:56px!important}.px-15{padding-left:60px!important;padding-right:60px!important}.px-16{padding-left:64px!important;padding-right:64px!important}.py-0{padding-bottom:0!important;padding-top:0!important}.py-1{padding-bottom:4px!important;padding-top:4px!important}.py-2{padding-bottom:8px!important;padding-top:8px!important}.py-3{padding-bottom:12px!important;padding-top:12px!important}.py-4{padding-bottom:16px!important;padding-top:16px!important}.py-5{padding-bottom:20px!important;padding-top:20px!important}.py-6{padding-bottom:24px!important;padding-top:24px!important}.py-7{padding-bottom:28px!important;padding-top:28px!important}.py-8{padding-bottom:32px!important;padding-top:32px!important}.py-9{padding-bottom:36px!important;padding-top:36px!important}.py-10{padding-bottom:40px!important;padding-top:40px!important}.py-11{padding-bottom:44px!important;padding-top:44px!important}.py-12{padding-bottom:48px!important;padding-top:48px!important}.py-13{padding-bottom:52px!important;padding-top:52px!important}.py-14{padding-bottom:56px!important;padding-top:56px!important}.py-15{padding-bottom:60px!important;padding-top:60px!important}.py-16{padding-bottom:64px!important;padding-top:64px!important}.pt-0{padding-top:0!important}.pt-1{padding-top:4px!important}.pt-2{padding-top:8px!important}.pt-3{padding-top:12px!important}.pt-4{padding-top:16px!important}.pt-5{padding-top:20px!important}.pt-6{padding-top:24px!important}.pt-7{padding-top:28px!important}.pt-8{padding-top:32px!important}.pt-9{padding-top:36px!important}.pt-10{padding-top:40px!important}.pt-11{padding-top:44px!important}.pt-12{padding-top:48px!important}.pt-13{padding-top:52px!important}.pt-14{padding-top:56px!important}.pt-15{padding-top:60px!important}.pt-16{padding-top:64px!important}.pr-0{padding-right:0!important}.pr-1{padding-right:4px!important}.pr-2{padding-right:8px!important}.pr-3{padding-right:12px!important}.pr-4{padding-right:16px!important}.pr-5{padding-right:20px!important}.pr-6{padding-right:24px!important}.pr-7{padding-right:28px!important}.pr-8{padding-right:32px!important}.pr-9{padding-right:36px!important}.pr-10{padding-right:40px!important}.pr-11{padding-right:44px!important}.pr-12{padding-right:48px!important}.pr-13{padding-right:52px!important}.pr-14{padding-right:56px!important}.pr-15{padding-right:60px!important}.pr-16{padding-right:64px!important}.pb-0{padding-bottom:0!important}.pb-1{padding-bottom:4px!important}.pb-2{padding-bottom:8px!important}.pb-3{padding-bottom:12px!important}.pb-4{padding-bottom:16px!important}.pb-5{padding-bottom:20px!important}.pb-6{padding-bottom:24px!important}.pb-7{padding-bottom:28px!important}.pb-8{padding-bottom:32px!important}.pb-9{padding-bottom:36px!important}.pb-10{padding-bottom:40px!important}.pb-11{padding-bottom:44px!important}.pb-12{padding-bottom:48px!important}.pb-13{padding-bottom:52px!important}.pb-14{padding-bottom:56px!important}.pb-15{padding-bottom:60px!important}.pb-16{padding-bottom:64px!important}.pl-0{padding-left:0!important}.pl-1{padding-left:4px!important}.pl-2{padding-left:8px!important}.pl-3{padding-left:12px!important}.pl-4{padding-left:16px!important}.pl-5{padding-left:20px!important}.pl-6{padding-left:24px!important}.pl-7{padding-left:28px!important}.pl-8{padding-left:32px!important}.pl-9{padding-left:36px!important}.pl-10{padding-left:40px!important}.pl-11{padding-left:44px!important}.pl-12{padding-left:48px!important}.pl-13{padding-left:52px!important}.pl-14{padding-left:56px!important}.pl-15{padding-left:60px!important}.pl-16{padding-left:64px!important}.ps-0{padding-inline-start:0!important}.ps-1{padding-inline-start:4px!important}.ps-2{padding-inline-start:8px!important}.ps-3{padding-inline-start:12px!important}.ps-4{padding-inline-start:16px!important}.ps-5{padding-inline-start:20px!important}.ps-6{padding-inline-start:24px!important}.ps-7{padding-inline-start:28px!important}.ps-8{padding-inline-start:32px!important}.ps-9{padding-inline-start:36px!important}.ps-10{padding-inline-start:40px!important}.ps-11{padding-inline-start:44px!important}.ps-12{padding-inline-start:48px!important}.ps-13{padding-inline-start:52px!important}.ps-14{padding-inline-start:56px!important}.ps-15{padding-inline-start:60px!important}.ps-16{padding-inline-start:64px!important}.pe-0{padding-inline-end:0!important}.pe-1{padding-inline-end:4px!important}.pe-2{padding-inline-end:8px!important}.pe-3{padding-inline-end:12px!important}.pe-4{padding-inline-end:16px!important}.pe-5{padding-inline-end:20px!important}.pe-6{padding-inline-end:24px!important}.pe-7{padding-inline-end:28px!important}.pe-8{padding-inline-end:32px!important}.pe-9{padding-inline-end:36px!important}.pe-10{padding-inline-end:40px!important}.pe-11{padding-inline-end:44px!important}.pe-12{padding-inline-end:48px!important}.pe-13{padding-inline-end:52px!important}.pe-14{padding-inline-end:56px!important}.pe-15{padding-inline-end:60px!important}.pe-16{padding-inline-end:64px!important}.rounded-0{border-radius:0!important}.rounded-sm{border-radius:2px!important}.rounded{border-radius:4px!important}.rounded-lg{border-radius:8px!important}.rounded-xl{border-radius:24px!important}.rounded-pill{border-radius:9999px!important}.rounded-circle{border-radius:50%!important}.rounded-shaped{border-radius:24px 0!important}.rounded-t-0{border-top-left-radius:0!important;border-top-right-radius:0!important}.rounded-t-sm{border-top-left-radius:2px!important;border-top-right-radius:2px!important}.rounded-t{border-top-left-radius:4px!important;border-top-right-radius:4px!important}.rounded-t-lg{border-top-left-radius:8px!important;border-top-right-radius:8px!important}.rounded-t-xl{border-top-left-radius:24px!important;border-top-right-radius:24px!important}.rounded-t-pill{border-top-left-radius:9999px!important;border-top-right-radius:9999px!important}.rounded-t-circle{border-top-left-radius:50%!important;border-top-right-radius:50%!important}.rounded-t-shaped{border-top-left-radius:24px!important;border-top-right-radius:0!important}.v-locale--is-ltr .rounded-e-0{border-bottom-right-radius:0!important;border-top-right-radius:0!important}.v-locale--is-rtl .rounded-e-0{border-bottom-left-radius:0!important;border-top-left-radius:0!important}.v-locale--is-ltr .rounded-e-sm{border-bottom-right-radius:2px!important;border-top-right-radius:2px!important}.v-locale--is-rtl .rounded-e-sm{border-bottom-left-radius:2px!important;border-top-left-radius:2px!important}.v-locale--is-ltr .rounded-e{border-bottom-right-radius:4px!important;border-top-right-radius:4px!important}.v-locale--is-rtl .rounded-e{border-bottom-left-radius:4px!important;border-top-left-radius:4px!important}.v-locale--is-ltr .rounded-e-lg{border-bottom-right-radius:8px!important;border-top-right-radius:8px!important}.v-locale--is-rtl .rounded-e-lg{border-bottom-left-radius:8px!important;border-top-left-radius:8px!important}.v-locale--is-ltr .rounded-e-xl{border-bottom-right-radius:24px!important;border-top-right-radius:24px!important}.v-locale--is-rtl .rounded-e-xl{border-bottom-left-radius:24px!important;border-top-left-radius:24px!important}.v-locale--is-ltr .rounded-e-pill{border-bottom-right-radius:9999px!important;border-top-right-radius:9999px!important}.v-locale--is-rtl .rounded-e-pill{border-bottom-left-radius:9999px!important;border-top-left-radius:9999px!important}.v-locale--is-ltr .rounded-e-circle{border-bottom-right-radius:50%!important;border-top-right-radius:50%!important}.v-locale--is-rtl .rounded-e-circle{border-bottom-left-radius:50%!important;border-top-left-radius:50%!important}.v-locale--is-ltr .rounded-e-shaped{border-bottom-right-radius:0!important;border-top-right-radius:24px!important}.v-locale--is-rtl .rounded-e-shaped{border-bottom-left-radius:0!important;border-top-left-radius:24px!important}.rounded-b-0{border-bottom-left-radius:0!important;border-bottom-right-radius:0!important}.rounded-b-sm{border-bottom-left-radius:2px!important;border-bottom-right-radius:2px!important}.rounded-b{border-bottom-left-radius:4px!important;border-bottom-right-radius:4px!important}.rounded-b-lg{border-bottom-left-radius:8px!important;border-bottom-right-radius:8px!important}.rounded-b-xl{border-bottom-left-radius:24px!important;border-bottom-right-radius:24px!important}.rounded-b-pill{border-bottom-left-radius:9999px!important;border-bottom-right-radius:9999px!important}.rounded-b-circle{border-bottom-left-radius:50%!important;border-bottom-right-radius:50%!important}.rounded-b-shaped{border-bottom-left-radius:24px!important;border-bottom-right-radius:0!important}.v-locale--is-ltr .rounded-s-0{border-bottom-left-radius:0!important;border-top-left-radius:0!important}.v-locale--is-rtl .rounded-s-0{border-bottom-right-radius:0!important;border-top-right-radius:0!important}.v-locale--is-ltr .rounded-s-sm{border-bottom-left-radius:2px!important;border-top-left-radius:2px!important}.v-locale--is-rtl .rounded-s-sm{border-bottom-right-radius:2px!important;border-top-right-radius:2px!important}.v-locale--is-ltr .rounded-s{border-bottom-left-radius:4px!important;border-top-left-radius:4px!important}.v-locale--is-rtl .rounded-s{border-bottom-right-radius:4px!important;border-top-right-radius:4px!important}.v-locale--is-ltr .rounded-s-lg{border-bottom-left-radius:8px!important;border-top-left-radius:8px!important}.v-locale--is-rtl .rounded-s-lg{border-bottom-right-radius:8px!important;border-top-right-radius:8px!important}.v-locale--is-ltr .rounded-s-xl{border-bottom-left-radius:24px!important;border-top-left-radius:24px!important}.v-locale--is-rtl .rounded-s-xl{border-bottom-right-radius:24px!important;border-top-right-radius:24px!important}.v-locale--is-ltr .rounded-s-pill{border-bottom-left-radius:9999px!important;border-top-left-radius:9999px!important}.v-locale--is-rtl .rounded-s-pill{border-bottom-right-radius:9999px!important;border-top-right-radius:9999px!important}.v-locale--is-ltr .rounded-s-circle{border-bottom-left-radius:50%!important;border-top-left-radius:50%!important}.v-locale--is-rtl .rounded-s-circle{border-bottom-right-radius:50%!important;border-top-right-radius:50%!important}.v-locale--is-ltr .rounded-s-shaped{border-bottom-left-radius:0!important;border-top-left-radius:24px!important}.v-locale--is-rtl .rounded-s-shaped{border-bottom-right-radius:0!important;border-top-right-radius:24px!important}.v-locale--is-ltr .rounded-ts-0{border-top-left-radius:0!important}.v-locale--is-rtl .rounded-ts-0{border-top-right-radius:0!important}.v-locale--is-ltr .rounded-ts-sm{border-top-left-radius:2px!important}.v-locale--is-rtl .rounded-ts-sm{border-top-right-radius:2px!important}.v-locale--is-ltr .rounded-ts{border-top-left-radius:4px!important}.v-locale--is-rtl .rounded-ts{border-top-right-radius:4px!important}.v-locale--is-ltr .rounded-ts-lg{border-top-left-radius:8px!important}.v-locale--is-rtl .rounded-ts-lg{border-top-right-radius:8px!important}.v-locale--is-ltr .rounded-ts-xl{border-top-left-radius:24px!important}.v-locale--is-rtl .rounded-ts-xl{border-top-right-radius:24px!important}.v-locale--is-ltr .rounded-ts-pill{border-top-left-radius:9999px!important}.v-locale--is-rtl .rounded-ts-pill{border-top-right-radius:9999px!important}.v-locale--is-ltr .rounded-ts-circle{border-top-left-radius:50%!important}.v-locale--is-rtl .rounded-ts-circle{border-top-right-radius:50%!important}.v-locale--is-ltr .rounded-ts-shaped{border-top-left-radius:24px 0!important}.v-locale--is-rtl .rounded-ts-shaped{border-top-right-radius:24px 0!important}.v-locale--is-ltr .rounded-te-0{border-top-right-radius:0!important}.v-locale--is-rtl .rounded-te-0{border-top-left-radius:0!important}.v-locale--is-ltr .rounded-te-sm{border-top-right-radius:2px!important}.v-locale--is-rtl .rounded-te-sm{border-top-left-radius:2px!important}.v-locale--is-ltr .rounded-te{border-top-right-radius:4px!important}.v-locale--is-rtl .rounded-te{border-top-left-radius:4px!important}.v-locale--is-ltr .rounded-te-lg{border-top-right-radius:8px!important}.v-locale--is-rtl .rounded-te-lg{border-top-left-radius:8px!important}.v-locale--is-ltr .rounded-te-xl{border-top-right-radius:24px!important}.v-locale--is-rtl .rounded-te-xl{border-top-left-radius:24px!important}.v-locale--is-ltr .rounded-te-pill{border-top-right-radius:9999px!important}.v-locale--is-rtl .rounded-te-pill{border-top-left-radius:9999px!important}.v-locale--is-ltr .rounded-te-circle{border-top-right-radius:50%!important}.v-locale--is-rtl .rounded-te-circle{border-top-left-radius:50%!important}.v-locale--is-ltr .rounded-te-shaped{border-top-right-radius:24px 0!important}.v-locale--is-rtl .rounded-te-shaped{border-top-left-radius:24px 0!important}.v-locale--is-ltr .rounded-be-0{border-bottom-right-radius:0!important}.v-locale--is-rtl .rounded-be-0{border-bottom-left-radius:0!important}.v-locale--is-ltr .rounded-be-sm{border-bottom-right-radius:2px!important}.v-locale--is-rtl .rounded-be-sm{border-bottom-left-radius:2px!important}.v-locale--is-ltr .rounded-be{border-bottom-right-radius:4px!important}.v-locale--is-rtl .rounded-be{border-bottom-left-radius:4px!important}.v-locale--is-ltr .rounded-be-lg{border-bottom-right-radius:8px!important}.v-locale--is-rtl .rounded-be-lg{border-bottom-left-radius:8px!important}.v-locale--is-ltr .rounded-be-xl{border-bottom-right-radius:24px!important}.v-locale--is-rtl .rounded-be-xl{border-bottom-left-radius:24px!important}.v-locale--is-ltr .rounded-be-pill{border-bottom-right-radius:9999px!important}.v-locale--is-rtl .rounded-be-pill{border-bottom-left-radius:9999px!important}.v-locale--is-ltr .rounded-be-circle{border-bottom-right-radius:50%!important}.v-locale--is-rtl .rounded-be-circle{border-bottom-left-radius:50%!important}.v-locale--is-ltr .rounded-be-shaped{border-bottom-right-radius:24px 0!important}.v-locale--is-rtl .rounded-be-shaped{border-bottom-left-radius:24px 0!important}.v-locale--is-ltr .rounded-bs-0{border-bottom-left-radius:0!important}.v-locale--is-rtl .rounded-bs-0{border-bottom-right-radius:0!important}.v-locale--is-ltr .rounded-bs-sm{border-bottom-left-radius:2px!important}.v-locale--is-rtl .rounded-bs-sm{border-bottom-right-radius:2px!important}.v-locale--is-ltr .rounded-bs{border-bottom-left-radius:4px!important}.v-locale--is-rtl .rounded-bs{border-bottom-right-radius:4px!important}.v-locale--is-ltr .rounded-bs-lg{border-bottom-left-radius:8px!important}.v-locale--is-rtl .rounded-bs-lg{border-bottom-right-radius:8px!important}.v-locale--is-ltr .rounded-bs-xl{border-bottom-left-radius:24px!important}.v-locale--is-rtl .rounded-bs-xl{border-bottom-right-radius:24px!important}.v-locale--is-ltr .rounded-bs-pill{border-bottom-left-radius:9999px!important}.v-locale--is-rtl .rounded-bs-pill{border-bottom-right-radius:9999px!important}.v-locale--is-ltr .rounded-bs-circle{border-bottom-left-radius:50%!important}.v-locale--is-rtl .rounded-bs-circle{border-bottom-right-radius:50%!important}.v-locale--is-ltr .rounded-bs-shaped{border-bottom-left-radius:24px 0!important}.v-locale--is-rtl .rounded-bs-shaped{border-bottom-right-radius:24px 0!important}.border-0{border-color:rgba(var(--v-border-color),var(--v-border-opacity))!important;border-style:solid!important;border-width:0!important}.border{border-color:rgba(var(--v-border-color),var(--v-border-opacity))!important;border-style:solid!important;border-width:thin!important}.border-sm{border-color:rgba(var(--v-border-color),var(--v-border-opacity))!important;border-style:solid!important;border-width:1px!important}.border-md{border-color:rgba(var(--v-border-color),var(--v-border-opacity))!important;border-style:solid!important;border-width:2px!important}.border-lg{border-color:rgba(var(--v-border-color),var(--v-border-opacity))!important;border-style:solid!important;border-width:4px!important}.border-xl{border-color:rgba(var(--v-border-color),var(--v-border-opacity))!important;border-style:solid!important;border-width:8px!important}.border-opacity-0{--v-border-opacity:0!important}.border-opacity{--v-border-opacity:0.12!important}.border-opacity-25{--v-border-opacity:0.25!important}.border-opacity-50{--v-border-opacity:0.5!important}.border-opacity-75{--v-border-opacity:0.75!important}.border-opacity-100{--v-border-opacity:1!important}.border-t-0{border-block-start-color:rgba(var(--v-border-color),var(--v-border-opacity))!important;border-block-start-style:solid!important;border-block-start-width:0!important}.border-t{border-block-start-color:rgba(var(--v-border-color),var(--v-border-opacity))!important;border-block-start-style:solid!important;border-block-start-width:thin!important}.border-t-sm{border-block-start-color:rgba(var(--v-border-color),var(--v-border-opacity))!important;border-block-start-style:solid!important;border-block-start-width:1px!important}.border-t-md{border-block-start-color:rgba(var(--v-border-color),var(--v-border-opacity))!important;border-block-start-style:solid!important;border-block-start-width:2px!important}.border-t-lg{border-block-start-color:rgba(var(--v-border-color),var(--v-border-opacity))!important;border-block-start-style:solid!important;border-block-start-width:4px!important}.border-t-xl{border-block-start-color:rgba(var(--v-border-color),var(--v-border-opacity))!important;border-block-start-style:solid!important;border-block-start-width:8px!important}.border-e-0{border-inline-end-color:rgba(var(--v-border-color),var(--v-border-opacity))!important;border-inline-end-style:solid!important;border-inline-end-width:0!important}.border-e{border-inline-end-color:rgba(var(--v-border-color),var(--v-border-opacity))!important;border-inline-end-style:solid!important;border-inline-end-width:thin!important}.border-e-sm{border-inline-end-color:rgba(var(--v-border-color),var(--v-border-opacity))!important;border-inline-end-style:solid!important;border-inline-end-width:1px!important}.border-e-md{border-inline-end-color:rgba(var(--v-border-color),var(--v-border-opacity))!important;border-inline-end-style:solid!important;border-inline-end-width:2px!important}.border-e-lg{border-inline-end-color:rgba(var(--v-border-color),var(--v-border-opacity))!important;border-inline-end-style:solid!important;border-inline-end-width:4px!important}.border-e-xl{border-inline-end-color:rgba(var(--v-border-color),var(--v-border-opacity))!important;border-inline-end-style:solid!important;border-inline-end-width:8px!important}.border-b-0{border-block-end-color:rgba(var(--v-border-color),var(--v-border-opacity))!important;border-block-end-style:solid!important;border-block-end-width:0!important}.border-b{border-block-end-color:rgba(var(--v-border-color),var(--v-border-opacity))!important;border-block-end-style:solid!important;border-block-end-width:thin!important}.border-b-sm{border-block-end-color:rgba(var(--v-border-color),var(--v-border-opacity))!important;border-block-end-style:solid!important;border-block-end-width:1px!important}.border-b-md{border-block-end-color:rgba(var(--v-border-color),var(--v-border-opacity))!important;border-block-end-style:solid!important;border-block-end-width:2px!important}.border-b-lg{border-block-end-color:rgba(var(--v-border-color),var(--v-border-opacity))!important;border-block-end-style:solid!important;border-block-end-width:4px!important}.border-b-xl{border-block-end-color:rgba(var(--v-border-color),var(--v-border-opacity))!important;border-block-end-style:solid!important;border-block-end-width:8px!important}.border-s-0{border-inline-start-color:rgba(var(--v-border-color),var(--v-border-opacity))!important;border-inline-start-style:solid!important;border-inline-start-width:0!important}.border-s{border-inline-start-color:rgba(var(--v-border-color),var(--v-border-opacity))!important;border-inline-start-style:solid!important;border-inline-start-width:thin!important}.border-s-sm{border-inline-start-color:rgba(var(--v-border-color),var(--v-border-opacity))!important;border-inline-start-style:solid!important;border-inline-start-width:1px!important}.border-s-md{border-inline-start-color:rgba(var(--v-border-color),var(--v-border-opacity))!important;border-inline-start-style:solid!important;border-inline-start-width:2px!important}.border-s-lg{border-inline-start-color:rgba(var(--v-border-color),var(--v-border-opacity))!important;border-inline-start-style:solid!important;border-inline-start-width:4px!important}.border-s-xl{border-inline-start-color:rgba(var(--v-border-color),var(--v-border-opacity))!important;border-inline-start-style:solid!important;border-inline-start-width:8px!important}.border-solid{border-style:solid!important}.border-dashed{border-style:dashed!important}.border-dotted{border-style:dotted!important}.border-double{border-style:double!important}.border-none{border-style:none!important}.text-left{text-align:left!important}.text-right{text-align:right!important}.text-center{text-align:center!important}.text-justify{text-align:justify!important}.text-start{text-align:start!important}.text-end{text-align:end!important}.text-decoration-line-through{text-decoration:line-through!important}.text-decoration-none{text-decoration:none!important}.text-decoration-overline{text-decoration:overline!important}.text-decoration-underline{text-decoration:underline!important}.text-wrap{white-space:normal!important}.text-no-wrap{white-space:nowrap!important}.text-pre{white-space:pre!important}.text-pre-line{white-space:pre-line!important}.text-pre-wrap{white-space:pre-wrap!important}.text-break{overflow-wrap:break-word!important;word-break:break-word!important}.text-high-emphasis{color:rgba(var(--v-theme-on-background),var(--v-high-emphasis-opacity))!important}.text-medium-emphasis{color:rgba(var(--v-theme-on-background),var(--v-medium-emphasis-opacity))!important}.text-disabled{color:rgba(var(--v-theme-on-background),var(--v-disabled-opacity))!important}.text-truncate{overflow:hidden!important;text-overflow:ellipsis!important;white-space:nowrap!important}.text-h1{font-size:6rem!important;letter-spacing:-.015625em!important;line-height:6rem}.text-h1,.text-h2{font-family:Roboto,sans-serif!important;font-weight:300;text-transform:none!important}.text-h2{font-size:3.75rem!important;letter-spacing:-.0083333333em!important;line-height:3.75rem}.text-h3{font-size:3rem!important;letter-spacing:normal!important;line-height:3.125rem}.text-h3,.text-h4{font-family:Roboto,sans-serif!important;font-weight:400;text-transform:none!important}.text-h4{font-size:2.125rem!important;letter-spacing:.0073529412em!important;line-height:2.5rem}.text-h5{font-size:1.5rem!important;font-weight:400;letter-spacing:normal!important}.text-h5,.text-h6{font-family:Roboto,sans-serif!important;line-height:2rem;text-transform:none!important}.text-h6{font-size:1.25rem!important;font-weight:500;letter-spacing:.0125em!important}.text-subtitle-1{font-size:1rem!important;font-weight:400;letter-spacing:.009375em!important;line-height:1.75rem}.text-subtitle-1,.text-subtitle-2{font-family:Roboto,sans-serif!important;text-transform:none!important}.text-subtitle-2{font-size:.875rem!important;font-weight:500;letter-spacing:.0071428571em!important;line-height:1.375rem}.text-body-1{font-size:1rem!important;letter-spacing:.03125em!important;line-height:1.5rem}.text-body-1,.text-body-2{font-family:Roboto,sans-serif!important;font-weight:400;text-transform:none!important}.text-body-2{letter-spacing:.0178571429em!important;line-height:1.25rem}.text-body-2,.text-button{font-size:.875rem!important}.text-button{font-family:Roboto,sans-serif!important;font-weight:500;letter-spacing:.0892857143em!important;line-height:2.25rem;text-transform:uppercase!important}.text-caption{font-weight:400;letter-spacing:.0333333333em!important;line-height:1.25rem;text-transform:none!important}.text-caption,.text-overline{font-family:Roboto,sans-serif!important;font-size:.75rem!important}.text-overline{font-weight:500;letter-spacing:.1666666667em!important;line-height:2rem;text-transform:uppercase!important}.text-none{text-transform:none!important}.text-capitalize{text-transform:capitalize!important}.text-lowercase{text-transform:lowercase!important}.text-uppercase{text-transform:uppercase!important}.font-weight-thin{font-weight:100!important}.font-weight-light{font-weight:300!important}.font-weight-regular{font-weight:400!important}.font-weight-medium{font-weight:500!important}.font-weight-bold{font-weight:700!important}.font-weight-black{font-weight:900!important}.font-italic{font-style:italic!important}.text-mono{font-family:monospace!important}.position-static{position:static!important}.position-relative{position:relative!important}.position-fixed{position:fixed!important}.position-absolute{position:absolute!important}.position-sticky{position:sticky!important}.fill-height{height:100%!important}.h-auto{height:auto!important}.h-screen{height:100vh!important}.h-0{height:0!important}.h-25{height:25%!important}.h-50{height:50%!important}.h-75{height:75%!important}.h-100{height:100%!important}.h-screen{height:100dvh!important}.w-auto{width:auto!important}.w-0{width:0!important}.w-25{width:25%!important}.w-33{width:33%!important}.w-50{width:50%!important}.w-66{width:66%!important}.w-75{width:75%!important}.w-100{width:100%!important}@media (min-width:600px){.d-sm-none{display:none!important}.d-sm-inline{display:inline!important}.d-sm-inline-block{display:inline-block!important}.d-sm-block{display:block!important}.d-sm-table{display:table!important}.d-sm-table-row{display:table-row!important}.d-sm-table-cell{display:table-cell!important}.d-sm-flex{display:flex!important}.d-sm-inline-flex{display:inline-flex!important}.float-sm-none{float:none!important}.float-sm-left{float:left!important}.float-sm-right{float:right!important}.v-locale--is-rtl .float-sm-end{float:left!important}.v-locale--is-ltr .float-sm-end,.v-locale--is-rtl .float-sm-start{float:right!important}.v-locale--is-ltr .float-sm-start{float:left!important}.flex-sm-1-1,.flex-sm-fill{flex:1 1 auto!important}.flex-sm-1-0{flex:1 0 auto!important}.flex-sm-0-1{flex:0 1 auto!important}.flex-sm-0-0{flex:0 0 auto!important}.flex-sm-1-1-100{flex:1 1 100%!important}.flex-sm-1-0-100{flex:1 0 100%!important}.flex-sm-0-1-100{flex:0 1 100%!important}.flex-sm-0-0-100{flex:0 0 100%!important}.flex-sm-row{flex-direction:row!important}.flex-sm-column{flex-direction:column!important}.flex-sm-row-reverse{flex-direction:row-reverse!important}.flex-sm-column-reverse{flex-direction:column-reverse!important}.flex-sm-grow-0{flex-grow:0!important}.flex-sm-grow-1{flex-grow:1!important}.flex-sm-shrink-0{flex-shrink:0!important}.flex-sm-shrink-1{flex-shrink:1!important}.flex-sm-wrap{flex-wrap:wrap!important}.flex-sm-nowrap{flex-wrap:nowrap!important}.flex-sm-wrap-reverse{flex-wrap:wrap-reverse!important}.justify-sm-start{justify-content:flex-start!important}.justify-sm-end{justify-content:flex-end!important}.justify-sm-center{justify-content:center!important}.justify-sm-space-between{justify-content:space-between!important}.justify-sm-space-around{justify-content:space-around!important}.justify-sm-space-evenly{justify-content:space-evenly!important}.align-sm-start{align-items:flex-start!important}.align-sm-end{align-items:flex-end!important}.align-sm-center{align-items:center!important}.align-sm-baseline{align-items:baseline!important}.align-sm-stretch{align-items:stretch!important}.align-content-sm-start{align-content:flex-start!important}.align-content-sm-end{align-content:flex-end!important}.align-content-sm-center{align-content:center!important}.align-content-sm-space-between{align-content:space-between!important}.align-content-sm-space-around{align-content:space-around!important}.align-content-sm-space-evenly{align-content:space-evenly!important}.align-content-sm-stretch{align-content:stretch!important}.align-self-sm-auto{align-self:auto!important}.align-self-sm-start{align-self:flex-start!important}.align-self-sm-end{align-self:flex-end!important}.align-self-sm-center{align-self:center!important}.align-self-sm-baseline{align-self:baseline!important}.align-self-sm-stretch{align-self:stretch!important}.order-sm-first{order:-1!important}.order-sm-0{order:0!important}.order-sm-1{order:1!important}.order-sm-2{order:2!important}.order-sm-3{order:3!important}.order-sm-4{order:4!important}.order-sm-5{order:5!important}.order-sm-6{order:6!important}.order-sm-7{order:7!important}.order-sm-8{order:8!important}.order-sm-9{order:9!important}.order-sm-10{order:10!important}.order-sm-11{order:11!important}.order-sm-12{order:12!important}.order-sm-last{order:13!important}.ga-sm-0{gap:0!important}.ga-sm-1{gap:4px!important}.ga-sm-2{gap:8px!important}.ga-sm-3{gap:12px!important}.ga-sm-4{gap:16px!important}.ga-sm-5{gap:20px!important}.ga-sm-6{gap:24px!important}.ga-sm-7{gap:28px!important}.ga-sm-8{gap:32px!important}.ga-sm-9{gap:36px!important}.ga-sm-10{gap:40px!important}.ga-sm-11{gap:44px!important}.ga-sm-12{gap:48px!important}.ga-sm-13{gap:52px!important}.ga-sm-14{gap:56px!important}.ga-sm-15{gap:60px!important}.ga-sm-16{gap:64px!important}.ga-sm-auto{gap:auto!important}.gr-sm-0{row-gap:0!important}.gr-sm-1{row-gap:4px!important}.gr-sm-2{row-gap:8px!important}.gr-sm-3{row-gap:12px!important}.gr-sm-4{row-gap:16px!important}.gr-sm-5{row-gap:20px!important}.gr-sm-6{row-gap:24px!important}.gr-sm-7{row-gap:28px!important}.gr-sm-8{row-gap:32px!important}.gr-sm-9{row-gap:36px!important}.gr-sm-10{row-gap:40px!important}.gr-sm-11{row-gap:44px!important}.gr-sm-12{row-gap:48px!important}.gr-sm-13{row-gap:52px!important}.gr-sm-14{row-gap:56px!important}.gr-sm-15{row-gap:60px!important}.gr-sm-16{row-gap:64px!important}.gr-sm-auto{row-gap:auto!important}.gc-sm-0{-moz-column-gap:0!important;column-gap:0!important}.gc-sm-1{-moz-column-gap:4px!important;column-gap:4px!important}.gc-sm-2{-moz-column-gap:8px!important;column-gap:8px!important}.gc-sm-3{-moz-column-gap:12px!important;column-gap:12px!important}.gc-sm-4{-moz-column-gap:16px!important;column-gap:16px!important}.gc-sm-5{-moz-column-gap:20px!important;column-gap:20px!important}.gc-sm-6{-moz-column-gap:24px!important;column-gap:24px!important}.gc-sm-7{-moz-column-gap:28px!important;column-gap:28px!important}.gc-sm-8{-moz-column-gap:32px!important;column-gap:32px!important}.gc-sm-9{-moz-column-gap:36px!important;column-gap:36px!important}.gc-sm-10{-moz-column-gap:40px!important;column-gap:40px!important}.gc-sm-11{-moz-column-gap:44px!important;column-gap:44px!important}.gc-sm-12{-moz-column-gap:48px!important;column-gap:48px!important}.gc-sm-13{-moz-column-gap:52px!important;column-gap:52px!important}.gc-sm-14{-moz-column-gap:56px!important;column-gap:56px!important}.gc-sm-15{-moz-column-gap:60px!important;column-gap:60px!important}.gc-sm-16{-moz-column-gap:64px!important;column-gap:64px!important}.gc-sm-auto{-moz-column-gap:auto!important;column-gap:auto!important}.ma-sm-0{margin:0!important}.ma-sm-1{margin:4px!important}.ma-sm-2{margin:8px!important}.ma-sm-3{margin:12px!important}.ma-sm-4{margin:16px!important}.ma-sm-5{margin:20px!important}.ma-sm-6{margin:24px!important}.ma-sm-7{margin:28px!important}.ma-sm-8{margin:32px!important}.ma-sm-9{margin:36px!important}.ma-sm-10{margin:40px!important}.ma-sm-11{margin:44px!important}.ma-sm-12{margin:48px!important}.ma-sm-13{margin:52px!important}.ma-sm-14{margin:56px!important}.ma-sm-15{margin:60px!important}.ma-sm-16{margin:64px!important}.ma-sm-auto{margin:auto!important}.mx-sm-0{margin-left:0!important;margin-right:0!important}.mx-sm-1{margin-left:4px!important;margin-right:4px!important}.mx-sm-2{margin-left:8px!important;margin-right:8px!important}.mx-sm-3{margin-left:12px!important;margin-right:12px!important}.mx-sm-4{margin-left:16px!important;margin-right:16px!important}.mx-sm-5{margin-left:20px!important;margin-right:20px!important}.mx-sm-6{margin-left:24px!important;margin-right:24px!important}.mx-sm-7{margin-left:28px!important;margin-right:28px!important}.mx-sm-8{margin-left:32px!important;margin-right:32px!important}.mx-sm-9{margin-left:36px!important;margin-right:36px!important}.mx-sm-10{margin-left:40px!important;margin-right:40px!important}.mx-sm-11{margin-left:44px!important;margin-right:44px!important}.mx-sm-12{margin-left:48px!important;margin-right:48px!important}.mx-sm-13{margin-left:52px!important;margin-right:52px!important}.mx-sm-14{margin-left:56px!important;margin-right:56px!important}.mx-sm-15{margin-left:60px!important;margin-right:60px!important}.mx-sm-16{margin-left:64px!important;margin-right:64px!important}.mx-sm-auto{margin-left:auto!important;margin-right:auto!important}.my-sm-0{margin-bottom:0!important;margin-top:0!important}.my-sm-1{margin-bottom:4px!important;margin-top:4px!important}.my-sm-2{margin-bottom:8px!important;margin-top:8px!important}.my-sm-3{margin-bottom:12px!important;margin-top:12px!important}.my-sm-4{margin-bottom:16px!important;margin-top:16px!important}.my-sm-5{margin-bottom:20px!important;margin-top:20px!important}.my-sm-6{margin-bottom:24px!important;margin-top:24px!important}.my-sm-7{margin-bottom:28px!important;margin-top:28px!important}.my-sm-8{margin-bottom:32px!important;margin-top:32px!important}.my-sm-9{margin-bottom:36px!important;margin-top:36px!important}.my-sm-10{margin-bottom:40px!important;margin-top:40px!important}.my-sm-11{margin-bottom:44px!important;margin-top:44px!important}.my-sm-12{margin-bottom:48px!important;margin-top:48px!important}.my-sm-13{margin-bottom:52px!important;margin-top:52px!important}.my-sm-14{margin-bottom:56px!important;margin-top:56px!important}.my-sm-15{margin-bottom:60px!important;margin-top:60px!important}.my-sm-16{margin-bottom:64px!important;margin-top:64px!important}.my-sm-auto{margin-bottom:auto!important;margin-top:auto!important}.mt-sm-0{margin-top:0!important}.mt-sm-1{margin-top:4px!important}.mt-sm-2{margin-top:8px!important}.mt-sm-3{margin-top:12px!important}.mt-sm-4{margin-top:16px!important}.mt-sm-5{margin-top:20px!important}.mt-sm-6{margin-top:24px!important}.mt-sm-7{margin-top:28px!important}.mt-sm-8{margin-top:32px!important}.mt-sm-9{margin-top:36px!important}.mt-sm-10{margin-top:40px!important}.mt-sm-11{margin-top:44px!important}.mt-sm-12{margin-top:48px!important}.mt-sm-13{margin-top:52px!important}.mt-sm-14{margin-top:56px!important}.mt-sm-15{margin-top:60px!important}.mt-sm-16{margin-top:64px!important}.mt-sm-auto{margin-top:auto!important}.mr-sm-0{margin-right:0!important}.mr-sm-1{margin-right:4px!important}.mr-sm-2{margin-right:8px!important}.mr-sm-3{margin-right:12px!important}.mr-sm-4{margin-right:16px!important}.mr-sm-5{margin-right:20px!important}.mr-sm-6{margin-right:24px!important}.mr-sm-7{margin-right:28px!important}.mr-sm-8{margin-right:32px!important}.mr-sm-9{margin-right:36px!important}.mr-sm-10{margin-right:40px!important}.mr-sm-11{margin-right:44px!important}.mr-sm-12{margin-right:48px!important}.mr-sm-13{margin-right:52px!important}.mr-sm-14{margin-right:56px!important}.mr-sm-15{margin-right:60px!important}.mr-sm-16{margin-right:64px!important}.mr-sm-auto{margin-right:auto!important}.mb-sm-0{margin-bottom:0!important}.mb-sm-1{margin-bottom:4px!important}.mb-sm-2{margin-bottom:8px!important}.mb-sm-3{margin-bottom:12px!important}.mb-sm-4{margin-bottom:16px!important}.mb-sm-5{margin-bottom:20px!important}.mb-sm-6{margin-bottom:24px!important}.mb-sm-7{margin-bottom:28px!important}.mb-sm-8{margin-bottom:32px!important}.mb-sm-9{margin-bottom:36px!important}.mb-sm-10{margin-bottom:40px!important}.mb-sm-11{margin-bottom:44px!important}.mb-sm-12{margin-bottom:48px!important}.mb-sm-13{margin-bottom:52px!important}.mb-sm-14{margin-bottom:56px!important}.mb-sm-15{margin-bottom:60px!important}.mb-sm-16{margin-bottom:64px!important}.mb-sm-auto{margin-bottom:auto!important}.ml-sm-0{margin-left:0!important}.ml-sm-1{margin-left:4px!important}.ml-sm-2{margin-left:8px!important}.ml-sm-3{margin-left:12px!important}.ml-sm-4{margin-left:16px!important}.ml-sm-5{margin-left:20px!important}.ml-sm-6{margin-left:24px!important}.ml-sm-7{margin-left:28px!important}.ml-sm-8{margin-left:32px!important}.ml-sm-9{margin-left:36px!important}.ml-sm-10{margin-left:40px!important}.ml-sm-11{margin-left:44px!important}.ml-sm-12{margin-left:48px!important}.ml-sm-13{margin-left:52px!important}.ml-sm-14{margin-left:56px!important}.ml-sm-15{margin-left:60px!important}.ml-sm-16{margin-left:64px!important}.ml-sm-auto{margin-left:auto!important}.ms-sm-0{margin-inline-start:0!important}.ms-sm-1{margin-inline-start:4px!important}.ms-sm-2{margin-inline-start:8px!important}.ms-sm-3{margin-inline-start:12px!important}.ms-sm-4{margin-inline-start:16px!important}.ms-sm-5{margin-inline-start:20px!important}.ms-sm-6{margin-inline-start:24px!important}.ms-sm-7{margin-inline-start:28px!important}.ms-sm-8{margin-inline-start:32px!important}.ms-sm-9{margin-inline-start:36px!important}.ms-sm-10{margin-inline-start:40px!important}.ms-sm-11{margin-inline-start:44px!important}.ms-sm-12{margin-inline-start:48px!important}.ms-sm-13{margin-inline-start:52px!important}.ms-sm-14{margin-inline-start:56px!important}.ms-sm-15{margin-inline-start:60px!important}.ms-sm-16{margin-inline-start:64px!important}.ms-sm-auto{margin-inline-start:auto!important}.me-sm-0{margin-inline-end:0!important}.me-sm-1{margin-inline-end:4px!important}.me-sm-2{margin-inline-end:8px!important}.me-sm-3{margin-inline-end:12px!important}.me-sm-4{margin-inline-end:16px!important}.me-sm-5{margin-inline-end:20px!important}.me-sm-6{margin-inline-end:24px!important}.me-sm-7{margin-inline-end:28px!important}.me-sm-8{margin-inline-end:32px!important}.me-sm-9{margin-inline-end:36px!important}.me-sm-10{margin-inline-end:40px!important}.me-sm-11{margin-inline-end:44px!important}.me-sm-12{margin-inline-end:48px!important}.me-sm-13{margin-inline-end:52px!important}.me-sm-14{margin-inline-end:56px!important}.me-sm-15{margin-inline-end:60px!important}.me-sm-16{margin-inline-end:64px!important}.me-sm-auto{margin-inline-end:auto!important}.ma-sm-n1{margin:-4px!important}.ma-sm-n2{margin:-8px!important}.ma-sm-n3{margin:-12px!important}.ma-sm-n4{margin:-16px!important}.ma-sm-n5{margin:-20px!important}.ma-sm-n6{margin:-24px!important}.ma-sm-n7{margin:-28px!important}.ma-sm-n8{margin:-32px!important}.ma-sm-n9{margin:-36px!important}.ma-sm-n10{margin:-40px!important}.ma-sm-n11{margin:-44px!important}.ma-sm-n12{margin:-48px!important}.ma-sm-n13{margin:-52px!important}.ma-sm-n14{margin:-56px!important}.ma-sm-n15{margin:-60px!important}.ma-sm-n16{margin:-64px!important}.mx-sm-n1{margin-left:-4px!important;margin-right:-4px!important}.mx-sm-n2{margin-left:-8px!important;margin-right:-8px!important}.mx-sm-n3{margin-left:-12px!important;margin-right:-12px!important}.mx-sm-n4{margin-left:-16px!important;margin-right:-16px!important}.mx-sm-n5{margin-left:-20px!important;margin-right:-20px!important}.mx-sm-n6{margin-left:-24px!important;margin-right:-24px!important}.mx-sm-n7{margin-left:-28px!important;margin-right:-28px!important}.mx-sm-n8{margin-left:-32px!important;margin-right:-32px!important}.mx-sm-n9{margin-left:-36px!important;margin-right:-36px!important}.mx-sm-n10{margin-left:-40px!important;margin-right:-40px!important}.mx-sm-n11{margin-left:-44px!important;margin-right:-44px!important}.mx-sm-n12{margin-left:-48px!important;margin-right:-48px!important}.mx-sm-n13{margin-left:-52px!important;margin-right:-52px!important}.mx-sm-n14{margin-left:-56px!important;margin-right:-56px!important}.mx-sm-n15{margin-left:-60px!important;margin-right:-60px!important}.mx-sm-n16{margin-left:-64px!important;margin-right:-64px!important}.my-sm-n1{margin-bottom:-4px!important;margin-top:-4px!important}.my-sm-n2{margin-bottom:-8px!important;margin-top:-8px!important}.my-sm-n3{margin-bottom:-12px!important;margin-top:-12px!important}.my-sm-n4{margin-bottom:-16px!important;margin-top:-16px!important}.my-sm-n5{margin-bottom:-20px!important;margin-top:-20px!important}.my-sm-n6{margin-bottom:-24px!important;margin-top:-24px!important}.my-sm-n7{margin-bottom:-28px!important;margin-top:-28px!important}.my-sm-n8{margin-bottom:-32px!important;margin-top:-32px!important}.my-sm-n9{margin-bottom:-36px!important;margin-top:-36px!important}.my-sm-n10{margin-bottom:-40px!important;margin-top:-40px!important}.my-sm-n11{margin-bottom:-44px!important;margin-top:-44px!important}.my-sm-n12{margin-bottom:-48px!important;margin-top:-48px!important}.my-sm-n13{margin-bottom:-52px!important;margin-top:-52px!important}.my-sm-n14{margin-bottom:-56px!important;margin-top:-56px!important}.my-sm-n15{margin-bottom:-60px!important;margin-top:-60px!important}.my-sm-n16{margin-bottom:-64px!important;margin-top:-64px!important}.mt-sm-n1{margin-top:-4px!important}.mt-sm-n2{margin-top:-8px!important}.mt-sm-n3{margin-top:-12px!important}.mt-sm-n4{margin-top:-16px!important}.mt-sm-n5{margin-top:-20px!important}.mt-sm-n6{margin-top:-24px!important}.mt-sm-n7{margin-top:-28px!important}.mt-sm-n8{margin-top:-32px!important}.mt-sm-n9{margin-top:-36px!important}.mt-sm-n10{margin-top:-40px!important}.mt-sm-n11{margin-top:-44px!important}.mt-sm-n12{margin-top:-48px!important}.mt-sm-n13{margin-top:-52px!important}.mt-sm-n14{margin-top:-56px!important}.mt-sm-n15{margin-top:-60px!important}.mt-sm-n16{margin-top:-64px!important}.mr-sm-n1{margin-right:-4px!important}.mr-sm-n2{margin-right:-8px!important}.mr-sm-n3{margin-right:-12px!important}.mr-sm-n4{margin-right:-16px!important}.mr-sm-n5{margin-right:-20px!important}.mr-sm-n6{margin-right:-24px!important}.mr-sm-n7{margin-right:-28px!important}.mr-sm-n8{margin-right:-32px!important}.mr-sm-n9{margin-right:-36px!important}.mr-sm-n10{margin-right:-40px!important}.mr-sm-n11{margin-right:-44px!important}.mr-sm-n12{margin-right:-48px!important}.mr-sm-n13{margin-right:-52px!important}.mr-sm-n14{margin-right:-56px!important}.mr-sm-n15{margin-right:-60px!important}.mr-sm-n16{margin-right:-64px!important}.mb-sm-n1{margin-bottom:-4px!important}.mb-sm-n2{margin-bottom:-8px!important}.mb-sm-n3{margin-bottom:-12px!important}.mb-sm-n4{margin-bottom:-16px!important}.mb-sm-n5{margin-bottom:-20px!important}.mb-sm-n6{margin-bottom:-24px!important}.mb-sm-n7{margin-bottom:-28px!important}.mb-sm-n8{margin-bottom:-32px!important}.mb-sm-n9{margin-bottom:-36px!important}.mb-sm-n10{margin-bottom:-40px!important}.mb-sm-n11{margin-bottom:-44px!important}.mb-sm-n12{margin-bottom:-48px!important}.mb-sm-n13{margin-bottom:-52px!important}.mb-sm-n14{margin-bottom:-56px!important}.mb-sm-n15{margin-bottom:-60px!important}.mb-sm-n16{margin-bottom:-64px!important}.ml-sm-n1{margin-left:-4px!important}.ml-sm-n2{margin-left:-8px!important}.ml-sm-n3{margin-left:-12px!important}.ml-sm-n4{margin-left:-16px!important}.ml-sm-n5{margin-left:-20px!important}.ml-sm-n6{margin-left:-24px!important}.ml-sm-n7{margin-left:-28px!important}.ml-sm-n8{margin-left:-32px!important}.ml-sm-n9{margin-left:-36px!important}.ml-sm-n10{margin-left:-40px!important}.ml-sm-n11{margin-left:-44px!important}.ml-sm-n12{margin-left:-48px!important}.ml-sm-n13{margin-left:-52px!important}.ml-sm-n14{margin-left:-56px!important}.ml-sm-n15{margin-left:-60px!important}.ml-sm-n16{margin-left:-64px!important}.ms-sm-n1{margin-inline-start:-4px!important}.ms-sm-n2{margin-inline-start:-8px!important}.ms-sm-n3{margin-inline-start:-12px!important}.ms-sm-n4{margin-inline-start:-16px!important}.ms-sm-n5{margin-inline-start:-20px!important}.ms-sm-n6{margin-inline-start:-24px!important}.ms-sm-n7{margin-inline-start:-28px!important}.ms-sm-n8{margin-inline-start:-32px!important}.ms-sm-n9{margin-inline-start:-36px!important}.ms-sm-n10{margin-inline-start:-40px!important}.ms-sm-n11{margin-inline-start:-44px!important}.ms-sm-n12{margin-inline-start:-48px!important}.ms-sm-n13{margin-inline-start:-52px!important}.ms-sm-n14{margin-inline-start:-56px!important}.ms-sm-n15{margin-inline-start:-60px!important}.ms-sm-n16{margin-inline-start:-64px!important}.me-sm-n1{margin-inline-end:-4px!important}.me-sm-n2{margin-inline-end:-8px!important}.me-sm-n3{margin-inline-end:-12px!important}.me-sm-n4{margin-inline-end:-16px!important}.me-sm-n5{margin-inline-end:-20px!important}.me-sm-n6{margin-inline-end:-24px!important}.me-sm-n7{margin-inline-end:-28px!important}.me-sm-n8{margin-inline-end:-32px!important}.me-sm-n9{margin-inline-end:-36px!important}.me-sm-n10{margin-inline-end:-40px!important}.me-sm-n11{margin-inline-end:-44px!important}.me-sm-n12{margin-inline-end:-48px!important}.me-sm-n13{margin-inline-end:-52px!important}.me-sm-n14{margin-inline-end:-56px!important}.me-sm-n15{margin-inline-end:-60px!important}.me-sm-n16{margin-inline-end:-64px!important}.pa-sm-0{padding:0!important}.pa-sm-1{padding:4px!important}.pa-sm-2{padding:8px!important}.pa-sm-3{padding:12px!important}.pa-sm-4{padding:16px!important}.pa-sm-5{padding:20px!important}.pa-sm-6{padding:24px!important}.pa-sm-7{padding:28px!important}.pa-sm-8{padding:32px!important}.pa-sm-9{padding:36px!important}.pa-sm-10{padding:40px!important}.pa-sm-11{padding:44px!important}.pa-sm-12{padding:48px!important}.pa-sm-13{padding:52px!important}.pa-sm-14{padding:56px!important}.pa-sm-15{padding:60px!important}.pa-sm-16{padding:64px!important}.px-sm-0{padding-left:0!important;padding-right:0!important}.px-sm-1{padding-left:4px!important;padding-right:4px!important}.px-sm-2{padding-left:8px!important;padding-right:8px!important}.px-sm-3{padding-left:12px!important;padding-right:12px!important}.px-sm-4{padding-left:16px!important;padding-right:16px!important}.px-sm-5{padding-left:20px!important;padding-right:20px!important}.px-sm-6{padding-left:24px!important;padding-right:24px!important}.px-sm-7{padding-left:28px!important;padding-right:28px!important}.px-sm-8{padding-left:32px!important;padding-right:32px!important}.px-sm-9{padding-left:36px!important;padding-right:36px!important}.px-sm-10{padding-left:40px!important;padding-right:40px!important}.px-sm-11{padding-left:44px!important;padding-right:44px!important}.px-sm-12{padding-left:48px!important;padding-right:48px!important}.px-sm-13{padding-left:52px!important;padding-right:52px!important}.px-sm-14{padding-left:56px!important;padding-right:56px!important}.px-sm-15{padding-left:60px!important;padding-right:60px!important}.px-sm-16{padding-left:64px!important;padding-right:64px!important}.py-sm-0{padding-bottom:0!important;padding-top:0!important}.py-sm-1{padding-bottom:4px!important;padding-top:4px!important}.py-sm-2{padding-bottom:8px!important;padding-top:8px!important}.py-sm-3{padding-bottom:12px!important;padding-top:12px!important}.py-sm-4{padding-bottom:16px!important;padding-top:16px!important}.py-sm-5{padding-bottom:20px!important;padding-top:20px!important}.py-sm-6{padding-bottom:24px!important;padding-top:24px!important}.py-sm-7{padding-bottom:28px!important;padding-top:28px!important}.py-sm-8{padding-bottom:32px!important;padding-top:32px!important}.py-sm-9{padding-bottom:36px!important;padding-top:36px!important}.py-sm-10{padding-bottom:40px!important;padding-top:40px!important}.py-sm-11{padding-bottom:44px!important;padding-top:44px!important}.py-sm-12{padding-bottom:48px!important;padding-top:48px!important}.py-sm-13{padding-bottom:52px!important;padding-top:52px!important}.py-sm-14{padding-bottom:56px!important;padding-top:56px!important}.py-sm-15{padding-bottom:60px!important;padding-top:60px!important}.py-sm-16{padding-bottom:64px!important;padding-top:64px!important}.pt-sm-0{padding-top:0!important}.pt-sm-1{padding-top:4px!important}.pt-sm-2{padding-top:8px!important}.pt-sm-3{padding-top:12px!important}.pt-sm-4{padding-top:16px!important}.pt-sm-5{padding-top:20px!important}.pt-sm-6{padding-top:24px!important}.pt-sm-7{padding-top:28px!important}.pt-sm-8{padding-top:32px!important}.pt-sm-9{padding-top:36px!important}.pt-sm-10{padding-top:40px!important}.pt-sm-11{padding-top:44px!important}.pt-sm-12{padding-top:48px!important}.pt-sm-13{padding-top:52px!important}.pt-sm-14{padding-top:56px!important}.pt-sm-15{padding-top:60px!important}.pt-sm-16{padding-top:64px!important}.pr-sm-0{padding-right:0!important}.pr-sm-1{padding-right:4px!important}.pr-sm-2{padding-right:8px!important}.pr-sm-3{padding-right:12px!important}.pr-sm-4{padding-right:16px!important}.pr-sm-5{padding-right:20px!important}.pr-sm-6{padding-right:24px!important}.pr-sm-7{padding-right:28px!important}.pr-sm-8{padding-right:32px!important}.pr-sm-9{padding-right:36px!important}.pr-sm-10{padding-right:40px!important}.pr-sm-11{padding-right:44px!important}.pr-sm-12{padding-right:48px!important}.pr-sm-13{padding-right:52px!important}.pr-sm-14{padding-right:56px!important}.pr-sm-15{padding-right:60px!important}.pr-sm-16{padding-right:64px!important}.pb-sm-0{padding-bottom:0!important}.pb-sm-1{padding-bottom:4px!important}.pb-sm-2{padding-bottom:8px!important}.pb-sm-3{padding-bottom:12px!important}.pb-sm-4{padding-bottom:16px!important}.pb-sm-5{padding-bottom:20px!important}.pb-sm-6{padding-bottom:24px!important}.pb-sm-7{padding-bottom:28px!important}.pb-sm-8{padding-bottom:32px!important}.pb-sm-9{padding-bottom:36px!important}.pb-sm-10{padding-bottom:40px!important}.pb-sm-11{padding-bottom:44px!important}.pb-sm-12{padding-bottom:48px!important}.pb-sm-13{padding-bottom:52px!important}.pb-sm-14{padding-bottom:56px!important}.pb-sm-15{padding-bottom:60px!important}.pb-sm-16{padding-bottom:64px!important}.pl-sm-0{padding-left:0!important}.pl-sm-1{padding-left:4px!important}.pl-sm-2{padding-left:8px!important}.pl-sm-3{padding-left:12px!important}.pl-sm-4{padding-left:16px!important}.pl-sm-5{padding-left:20px!important}.pl-sm-6{padding-left:24px!important}.pl-sm-7{padding-left:28px!important}.pl-sm-8{padding-left:32px!important}.pl-sm-9{padding-left:36px!important}.pl-sm-10{padding-left:40px!important}.pl-sm-11{padding-left:44px!important}.pl-sm-12{padding-left:48px!important}.pl-sm-13{padding-left:52px!important}.pl-sm-14{padding-left:56px!important}.pl-sm-15{padding-left:60px!important}.pl-sm-16{padding-left:64px!important}.ps-sm-0{padding-inline-start:0!important}.ps-sm-1{padding-inline-start:4px!important}.ps-sm-2{padding-inline-start:8px!important}.ps-sm-3{padding-inline-start:12px!important}.ps-sm-4{padding-inline-start:16px!important}.ps-sm-5{padding-inline-start:20px!important}.ps-sm-6{padding-inline-start:24px!important}.ps-sm-7{padding-inline-start:28px!important}.ps-sm-8{padding-inline-start:32px!important}.ps-sm-9{padding-inline-start:36px!important}.ps-sm-10{padding-inline-start:40px!important}.ps-sm-11{padding-inline-start:44px!important}.ps-sm-12{padding-inline-start:48px!important}.ps-sm-13{padding-inline-start:52px!important}.ps-sm-14{padding-inline-start:56px!important}.ps-sm-15{padding-inline-start:60px!important}.ps-sm-16{padding-inline-start:64px!important}.pe-sm-0{padding-inline-end:0!important}.pe-sm-1{padding-inline-end:4px!important}.pe-sm-2{padding-inline-end:8px!important}.pe-sm-3{padding-inline-end:12px!important}.pe-sm-4{padding-inline-end:16px!important}.pe-sm-5{padding-inline-end:20px!important}.pe-sm-6{padding-inline-end:24px!important}.pe-sm-7{padding-inline-end:28px!important}.pe-sm-8{padding-inline-end:32px!important}.pe-sm-9{padding-inline-end:36px!important}.pe-sm-10{padding-inline-end:40px!important}.pe-sm-11{padding-inline-end:44px!important}.pe-sm-12{padding-inline-end:48px!important}.pe-sm-13{padding-inline-end:52px!important}.pe-sm-14{padding-inline-end:56px!important}.pe-sm-15{padding-inline-end:60px!important}.pe-sm-16{padding-inline-end:64px!important}.text-sm-left{text-align:left!important}.text-sm-right{text-align:right!important}.text-sm-center{text-align:center!important}.text-sm-justify{text-align:justify!important}.text-sm-start{text-align:start!important}.text-sm-end{text-align:end!important}.text-sm-h1{font-size:6rem!important;letter-spacing:-.015625em!important;line-height:6rem}.text-sm-h1,.text-sm-h2{font-family:Roboto,sans-serif!important;font-weight:300;text-transform:none!important}.text-sm-h2{font-size:3.75rem!important;letter-spacing:-.0083333333em!important;line-height:3.75rem}.text-sm-h3{font-size:3rem!important;letter-spacing:normal!important;line-height:3.125rem}.text-sm-h3,.text-sm-h4{font-family:Roboto,sans-serif!important;font-weight:400;text-transform:none!important}.text-sm-h4{font-size:2.125rem!important;letter-spacing:.0073529412em!important;line-height:2.5rem}.text-sm-h5{font-size:1.5rem!important;font-weight:400;letter-spacing:normal!important}.text-sm-h5,.text-sm-h6{font-family:Roboto,sans-serif!important;line-height:2rem;text-transform:none!important}.text-sm-h6{font-size:1.25rem!important;font-weight:500;letter-spacing:.0125em!important}.text-sm-subtitle-1{font-size:1rem!important;font-weight:400;letter-spacing:.009375em!important;line-height:1.75rem}.text-sm-subtitle-1,.text-sm-subtitle-2{font-family:Roboto,sans-serif!important;text-transform:none!important}.text-sm-subtitle-2{font-size:.875rem!important;font-weight:500;letter-spacing:.0071428571em!important;line-height:1.375rem}.text-sm-body-1{font-size:1rem!important;letter-spacing:.03125em!important;line-height:1.5rem}.text-sm-body-1,.text-sm-body-2{font-family:Roboto,sans-serif!important;font-weight:400;text-transform:none!important}.text-sm-body-2{font-size:.875rem!important;letter-spacing:.0178571429em!important;line-height:1.25rem}.text-sm-button{font-family:Roboto,sans-serif!important;font-size:.875rem!important;font-weight:500;letter-spacing:.0892857143em!important;line-height:2.25rem;text-transform:uppercase!important}.text-sm-caption{font-weight:400;letter-spacing:.0333333333em!important;line-height:1.25rem;text-transform:none!important}.text-sm-caption,.text-sm-overline{font-family:Roboto,sans-serif!important;font-size:.75rem!important}.text-sm-overline{font-weight:500;letter-spacing:.1666666667em!important;line-height:2rem;text-transform:uppercase!important}}@media (min-width:960px){.d-md-none{display:none!important}.d-md-inline{display:inline!important}.d-md-inline-block{display:inline-block!important}.d-md-block{display:block!important}.d-md-table{display:table!important}.d-md-table-row{display:table-row!important}.d-md-table-cell{display:table-cell!important}.d-md-flex{display:flex!important}.d-md-inline-flex{display:inline-flex!important}.float-md-none{float:none!important}.float-md-left{float:left!important}.float-md-right{float:right!important}.v-locale--is-rtl .float-md-end{float:left!important}.v-locale--is-ltr .float-md-end,.v-locale--is-rtl .float-md-start{float:right!important}.v-locale--is-ltr .float-md-start{float:left!important}.flex-md-1-1,.flex-md-fill{flex:1 1 auto!important}.flex-md-1-0{flex:1 0 auto!important}.flex-md-0-1{flex:0 1 auto!important}.flex-md-0-0{flex:0 0 auto!important}.flex-md-1-1-100{flex:1 1 100%!important}.flex-md-1-0-100{flex:1 0 100%!important}.flex-md-0-1-100{flex:0 1 100%!important}.flex-md-0-0-100{flex:0 0 100%!important}.flex-md-row{flex-direction:row!important}.flex-md-column{flex-direction:column!important}.flex-md-row-reverse{flex-direction:row-reverse!important}.flex-md-column-reverse{flex-direction:column-reverse!important}.flex-md-grow-0{flex-grow:0!important}.flex-md-grow-1{flex-grow:1!important}.flex-md-shrink-0{flex-shrink:0!important}.flex-md-shrink-1{flex-shrink:1!important}.flex-md-wrap{flex-wrap:wrap!important}.flex-md-nowrap{flex-wrap:nowrap!important}.flex-md-wrap-reverse{flex-wrap:wrap-reverse!important}.justify-md-start{justify-content:flex-start!important}.justify-md-end{justify-content:flex-end!important}.justify-md-center{justify-content:center!important}.justify-md-space-between{justify-content:space-between!important}.justify-md-space-around{justify-content:space-around!important}.justify-md-space-evenly{justify-content:space-evenly!important}.align-md-start{align-items:flex-start!important}.align-md-end{align-items:flex-end!important}.align-md-center{align-items:center!important}.align-md-baseline{align-items:baseline!important}.align-md-stretch{align-items:stretch!important}.align-content-md-start{align-content:flex-start!important}.align-content-md-end{align-content:flex-end!important}.align-content-md-center{align-content:center!important}.align-content-md-space-between{align-content:space-between!important}.align-content-md-space-around{align-content:space-around!important}.align-content-md-space-evenly{align-content:space-evenly!important}.align-content-md-stretch{align-content:stretch!important}.align-self-md-auto{align-self:auto!important}.align-self-md-start{align-self:flex-start!important}.align-self-md-end{align-self:flex-end!important}.align-self-md-center{align-self:center!important}.align-self-md-baseline{align-self:baseline!important}.align-self-md-stretch{align-self:stretch!important}.order-md-first{order:-1!important}.order-md-0{order:0!important}.order-md-1{order:1!important}.order-md-2{order:2!important}.order-md-3{order:3!important}.order-md-4{order:4!important}.order-md-5{order:5!important}.order-md-6{order:6!important}.order-md-7{order:7!important}.order-md-8{order:8!important}.order-md-9{order:9!important}.order-md-10{order:10!important}.order-md-11{order:11!important}.order-md-12{order:12!important}.order-md-last{order:13!important}.ga-md-0{gap:0!important}.ga-md-1{gap:4px!important}.ga-md-2{gap:8px!important}.ga-md-3{gap:12px!important}.ga-md-4{gap:16px!important}.ga-md-5{gap:20px!important}.ga-md-6{gap:24px!important}.ga-md-7{gap:28px!important}.ga-md-8{gap:32px!important}.ga-md-9{gap:36px!important}.ga-md-10{gap:40px!important}.ga-md-11{gap:44px!important}.ga-md-12{gap:48px!important}.ga-md-13{gap:52px!important}.ga-md-14{gap:56px!important}.ga-md-15{gap:60px!important}.ga-md-16{gap:64px!important}.ga-md-auto{gap:auto!important}.gr-md-0{row-gap:0!important}.gr-md-1{row-gap:4px!important}.gr-md-2{row-gap:8px!important}.gr-md-3{row-gap:12px!important}.gr-md-4{row-gap:16px!important}.gr-md-5{row-gap:20px!important}.gr-md-6{row-gap:24px!important}.gr-md-7{row-gap:28px!important}.gr-md-8{row-gap:32px!important}.gr-md-9{row-gap:36px!important}.gr-md-10{row-gap:40px!important}.gr-md-11{row-gap:44px!important}.gr-md-12{row-gap:48px!important}.gr-md-13{row-gap:52px!important}.gr-md-14{row-gap:56px!important}.gr-md-15{row-gap:60px!important}.gr-md-16{row-gap:64px!important}.gr-md-auto{row-gap:auto!important}.gc-md-0{-moz-column-gap:0!important;column-gap:0!important}.gc-md-1{-moz-column-gap:4px!important;column-gap:4px!important}.gc-md-2{-moz-column-gap:8px!important;column-gap:8px!important}.gc-md-3{-moz-column-gap:12px!important;column-gap:12px!important}.gc-md-4{-moz-column-gap:16px!important;column-gap:16px!important}.gc-md-5{-moz-column-gap:20px!important;column-gap:20px!important}.gc-md-6{-moz-column-gap:24px!important;column-gap:24px!important}.gc-md-7{-moz-column-gap:28px!important;column-gap:28px!important}.gc-md-8{-moz-column-gap:32px!important;column-gap:32px!important}.gc-md-9{-moz-column-gap:36px!important;column-gap:36px!important}.gc-md-10{-moz-column-gap:40px!important;column-gap:40px!important}.gc-md-11{-moz-column-gap:44px!important;column-gap:44px!important}.gc-md-12{-moz-column-gap:48px!important;column-gap:48px!important}.gc-md-13{-moz-column-gap:52px!important;column-gap:52px!important}.gc-md-14{-moz-column-gap:56px!important;column-gap:56px!important}.gc-md-15{-moz-column-gap:60px!important;column-gap:60px!important}.gc-md-16{-moz-column-gap:64px!important;column-gap:64px!important}.gc-md-auto{-moz-column-gap:auto!important;column-gap:auto!important}.ma-md-0{margin:0!important}.ma-md-1{margin:4px!important}.ma-md-2{margin:8px!important}.ma-md-3{margin:12px!important}.ma-md-4{margin:16px!important}.ma-md-5{margin:20px!important}.ma-md-6{margin:24px!important}.ma-md-7{margin:28px!important}.ma-md-8{margin:32px!important}.ma-md-9{margin:36px!important}.ma-md-10{margin:40px!important}.ma-md-11{margin:44px!important}.ma-md-12{margin:48px!important}.ma-md-13{margin:52px!important}.ma-md-14{margin:56px!important}.ma-md-15{margin:60px!important}.ma-md-16{margin:64px!important}.ma-md-auto{margin:auto!important}.mx-md-0{margin-left:0!important;margin-right:0!important}.mx-md-1{margin-left:4px!important;margin-right:4px!important}.mx-md-2{margin-left:8px!important;margin-right:8px!important}.mx-md-3{margin-left:12px!important;margin-right:12px!important}.mx-md-4{margin-left:16px!important;margin-right:16px!important}.mx-md-5{margin-left:20px!important;margin-right:20px!important}.mx-md-6{margin-left:24px!important;margin-right:24px!important}.mx-md-7{margin-left:28px!important;margin-right:28px!important}.mx-md-8{margin-left:32px!important;margin-right:32px!important}.mx-md-9{margin-left:36px!important;margin-right:36px!important}.mx-md-10{margin-left:40px!important;margin-right:40px!important}.mx-md-11{margin-left:44px!important;margin-right:44px!important}.mx-md-12{margin-left:48px!important;margin-right:48px!important}.mx-md-13{margin-left:52px!important;margin-right:52px!important}.mx-md-14{margin-left:56px!important;margin-right:56px!important}.mx-md-15{margin-left:60px!important;margin-right:60px!important}.mx-md-16{margin-left:64px!important;margin-right:64px!important}.mx-md-auto{margin-left:auto!important;margin-right:auto!important}.my-md-0{margin-bottom:0!important;margin-top:0!important}.my-md-1{margin-bottom:4px!important;margin-top:4px!important}.my-md-2{margin-bottom:8px!important;margin-top:8px!important}.my-md-3{margin-bottom:12px!important;margin-top:12px!important}.my-md-4{margin-bottom:16px!important;margin-top:16px!important}.my-md-5{margin-bottom:20px!important;margin-top:20px!important}.my-md-6{margin-bottom:24px!important;margin-top:24px!important}.my-md-7{margin-bottom:28px!important;margin-top:28px!important}.my-md-8{margin-bottom:32px!important;margin-top:32px!important}.my-md-9{margin-bottom:36px!important;margin-top:36px!important}.my-md-10{margin-bottom:40px!important;margin-top:40px!important}.my-md-11{margin-bottom:44px!important;margin-top:44px!important}.my-md-12{margin-bottom:48px!important;margin-top:48px!important}.my-md-13{margin-bottom:52px!important;margin-top:52px!important}.my-md-14{margin-bottom:56px!important;margin-top:56px!important}.my-md-15{margin-bottom:60px!important;margin-top:60px!important}.my-md-16{margin-bottom:64px!important;margin-top:64px!important}.my-md-auto{margin-bottom:auto!important;margin-top:auto!important}.mt-md-0{margin-top:0!important}.mt-md-1{margin-top:4px!important}.mt-md-2{margin-top:8px!important}.mt-md-3{margin-top:12px!important}.mt-md-4{margin-top:16px!important}.mt-md-5{margin-top:20px!important}.mt-md-6{margin-top:24px!important}.mt-md-7{margin-top:28px!important}.mt-md-8{margin-top:32px!important}.mt-md-9{margin-top:36px!important}.mt-md-10{margin-top:40px!important}.mt-md-11{margin-top:44px!important}.mt-md-12{margin-top:48px!important}.mt-md-13{margin-top:52px!important}.mt-md-14{margin-top:56px!important}.mt-md-15{margin-top:60px!important}.mt-md-16{margin-top:64px!important}.mt-md-auto{margin-top:auto!important}.mr-md-0{margin-right:0!important}.mr-md-1{margin-right:4px!important}.mr-md-2{margin-right:8px!important}.mr-md-3{margin-right:12px!important}.mr-md-4{margin-right:16px!important}.mr-md-5{margin-right:20px!important}.mr-md-6{margin-right:24px!important}.mr-md-7{margin-right:28px!important}.mr-md-8{margin-right:32px!important}.mr-md-9{margin-right:36px!important}.mr-md-10{margin-right:40px!important}.mr-md-11{margin-right:44px!important}.mr-md-12{margin-right:48px!important}.mr-md-13{margin-right:52px!important}.mr-md-14{margin-right:56px!important}.mr-md-15{margin-right:60px!important}.mr-md-16{margin-right:64px!important}.mr-md-auto{margin-right:auto!important}.mb-md-0{margin-bottom:0!important}.mb-md-1{margin-bottom:4px!important}.mb-md-2{margin-bottom:8px!important}.mb-md-3{margin-bottom:12px!important}.mb-md-4{margin-bottom:16px!important}.mb-md-5{margin-bottom:20px!important}.mb-md-6{margin-bottom:24px!important}.mb-md-7{margin-bottom:28px!important}.mb-md-8{margin-bottom:32px!important}.mb-md-9{margin-bottom:36px!important}.mb-md-10{margin-bottom:40px!important}.mb-md-11{margin-bottom:44px!important}.mb-md-12{margin-bottom:48px!important}.mb-md-13{margin-bottom:52px!important}.mb-md-14{margin-bottom:56px!important}.mb-md-15{margin-bottom:60px!important}.mb-md-16{margin-bottom:64px!important}.mb-md-auto{margin-bottom:auto!important}.ml-md-0{margin-left:0!important}.ml-md-1{margin-left:4px!important}.ml-md-2{margin-left:8px!important}.ml-md-3{margin-left:12px!important}.ml-md-4{margin-left:16px!important}.ml-md-5{margin-left:20px!important}.ml-md-6{margin-left:24px!important}.ml-md-7{margin-left:28px!important}.ml-md-8{margin-left:32px!important}.ml-md-9{margin-left:36px!important}.ml-md-10{margin-left:40px!important}.ml-md-11{margin-left:44px!important}.ml-md-12{margin-left:48px!important}.ml-md-13{margin-left:52px!important}.ml-md-14{margin-left:56px!important}.ml-md-15{margin-left:60px!important}.ml-md-16{margin-left:64px!important}.ml-md-auto{margin-left:auto!important}.ms-md-0{margin-inline-start:0!important}.ms-md-1{margin-inline-start:4px!important}.ms-md-2{margin-inline-start:8px!important}.ms-md-3{margin-inline-start:12px!important}.ms-md-4{margin-inline-start:16px!important}.ms-md-5{margin-inline-start:20px!important}.ms-md-6{margin-inline-start:24px!important}.ms-md-7{margin-inline-start:28px!important}.ms-md-8{margin-inline-start:32px!important}.ms-md-9{margin-inline-start:36px!important}.ms-md-10{margin-inline-start:40px!important}.ms-md-11{margin-inline-start:44px!important}.ms-md-12{margin-inline-start:48px!important}.ms-md-13{margin-inline-start:52px!important}.ms-md-14{margin-inline-start:56px!important}.ms-md-15{margin-inline-start:60px!important}.ms-md-16{margin-inline-start:64px!important}.ms-md-auto{margin-inline-start:auto!important}.me-md-0{margin-inline-end:0!important}.me-md-1{margin-inline-end:4px!important}.me-md-2{margin-inline-end:8px!important}.me-md-3{margin-inline-end:12px!important}.me-md-4{margin-inline-end:16px!important}.me-md-5{margin-inline-end:20px!important}.me-md-6{margin-inline-end:24px!important}.me-md-7{margin-inline-end:28px!important}.me-md-8{margin-inline-end:32px!important}.me-md-9{margin-inline-end:36px!important}.me-md-10{margin-inline-end:40px!important}.me-md-11{margin-inline-end:44px!important}.me-md-12{margin-inline-end:48px!important}.me-md-13{margin-inline-end:52px!important}.me-md-14{margin-inline-end:56px!important}.me-md-15{margin-inline-end:60px!important}.me-md-16{margin-inline-end:64px!important}.me-md-auto{margin-inline-end:auto!important}.ma-md-n1{margin:-4px!important}.ma-md-n2{margin:-8px!important}.ma-md-n3{margin:-12px!important}.ma-md-n4{margin:-16px!important}.ma-md-n5{margin:-20px!important}.ma-md-n6{margin:-24px!important}.ma-md-n7{margin:-28px!important}.ma-md-n8{margin:-32px!important}.ma-md-n9{margin:-36px!important}.ma-md-n10{margin:-40px!important}.ma-md-n11{margin:-44px!important}.ma-md-n12{margin:-48px!important}.ma-md-n13{margin:-52px!important}.ma-md-n14{margin:-56px!important}.ma-md-n15{margin:-60px!important}.ma-md-n16{margin:-64px!important}.mx-md-n1{margin-left:-4px!important;margin-right:-4px!important}.mx-md-n2{margin-left:-8px!important;margin-right:-8px!important}.mx-md-n3{margin-left:-12px!important;margin-right:-12px!important}.mx-md-n4{margin-left:-16px!important;margin-right:-16px!important}.mx-md-n5{margin-left:-20px!important;margin-right:-20px!important}.mx-md-n6{margin-left:-24px!important;margin-right:-24px!important}.mx-md-n7{margin-left:-28px!important;margin-right:-28px!important}.mx-md-n8{margin-left:-32px!important;margin-right:-32px!important}.mx-md-n9{margin-left:-36px!important;margin-right:-36px!important}.mx-md-n10{margin-left:-40px!important;margin-right:-40px!important}.mx-md-n11{margin-left:-44px!important;margin-right:-44px!important}.mx-md-n12{margin-left:-48px!important;margin-right:-48px!important}.mx-md-n13{margin-left:-52px!important;margin-right:-52px!important}.mx-md-n14{margin-left:-56px!important;margin-right:-56px!important}.mx-md-n15{margin-left:-60px!important;margin-right:-60px!important}.mx-md-n16{margin-left:-64px!important;margin-right:-64px!important}.my-md-n1{margin-bottom:-4px!important;margin-top:-4px!important}.my-md-n2{margin-bottom:-8px!important;margin-top:-8px!important}.my-md-n3{margin-bottom:-12px!important;margin-top:-12px!important}.my-md-n4{margin-bottom:-16px!important;margin-top:-16px!important}.my-md-n5{margin-bottom:-20px!important;margin-top:-20px!important}.my-md-n6{margin-bottom:-24px!important;margin-top:-24px!important}.my-md-n7{margin-bottom:-28px!important;margin-top:-28px!important}.my-md-n8{margin-bottom:-32px!important;margin-top:-32px!important}.my-md-n9{margin-bottom:-36px!important;margin-top:-36px!important}.my-md-n10{margin-bottom:-40px!important;margin-top:-40px!important}.my-md-n11{margin-bottom:-44px!important;margin-top:-44px!important}.my-md-n12{margin-bottom:-48px!important;margin-top:-48px!important}.my-md-n13{margin-bottom:-52px!important;margin-top:-52px!important}.my-md-n14{margin-bottom:-56px!important;margin-top:-56px!important}.my-md-n15{margin-bottom:-60px!important;margin-top:-60px!important}.my-md-n16{margin-bottom:-64px!important;margin-top:-64px!important}.mt-md-n1{margin-top:-4px!important}.mt-md-n2{margin-top:-8px!important}.mt-md-n3{margin-top:-12px!important}.mt-md-n4{margin-top:-16px!important}.mt-md-n5{margin-top:-20px!important}.mt-md-n6{margin-top:-24px!important}.mt-md-n7{margin-top:-28px!important}.mt-md-n8{margin-top:-32px!important}.mt-md-n9{margin-top:-36px!important}.mt-md-n10{margin-top:-40px!important}.mt-md-n11{margin-top:-44px!important}.mt-md-n12{margin-top:-48px!important}.mt-md-n13{margin-top:-52px!important}.mt-md-n14{margin-top:-56px!important}.mt-md-n15{margin-top:-60px!important}.mt-md-n16{margin-top:-64px!important}.mr-md-n1{margin-right:-4px!important}.mr-md-n2{margin-right:-8px!important}.mr-md-n3{margin-right:-12px!important}.mr-md-n4{margin-right:-16px!important}.mr-md-n5{margin-right:-20px!important}.mr-md-n6{margin-right:-24px!important}.mr-md-n7{margin-right:-28px!important}.mr-md-n8{margin-right:-32px!important}.mr-md-n9{margin-right:-36px!important}.mr-md-n10{margin-right:-40px!important}.mr-md-n11{margin-right:-44px!important}.mr-md-n12{margin-right:-48px!important}.mr-md-n13{margin-right:-52px!important}.mr-md-n14{margin-right:-56px!important}.mr-md-n15{margin-right:-60px!important}.mr-md-n16{margin-right:-64px!important}.mb-md-n1{margin-bottom:-4px!important}.mb-md-n2{margin-bottom:-8px!important}.mb-md-n3{margin-bottom:-12px!important}.mb-md-n4{margin-bottom:-16px!important}.mb-md-n5{margin-bottom:-20px!important}.mb-md-n6{margin-bottom:-24px!important}.mb-md-n7{margin-bottom:-28px!important}.mb-md-n8{margin-bottom:-32px!important}.mb-md-n9{margin-bottom:-36px!important}.mb-md-n10{margin-bottom:-40px!important}.mb-md-n11{margin-bottom:-44px!important}.mb-md-n12{margin-bottom:-48px!important}.mb-md-n13{margin-bottom:-52px!important}.mb-md-n14{margin-bottom:-56px!important}.mb-md-n15{margin-bottom:-60px!important}.mb-md-n16{margin-bottom:-64px!important}.ml-md-n1{margin-left:-4px!important}.ml-md-n2{margin-left:-8px!important}.ml-md-n3{margin-left:-12px!important}.ml-md-n4{margin-left:-16px!important}.ml-md-n5{margin-left:-20px!important}.ml-md-n6{margin-left:-24px!important}.ml-md-n7{margin-left:-28px!important}.ml-md-n8{margin-left:-32px!important}.ml-md-n9{margin-left:-36px!important}.ml-md-n10{margin-left:-40px!important}.ml-md-n11{margin-left:-44px!important}.ml-md-n12{margin-left:-48px!important}.ml-md-n13{margin-left:-52px!important}.ml-md-n14{margin-left:-56px!important}.ml-md-n15{margin-left:-60px!important}.ml-md-n16{margin-left:-64px!important}.ms-md-n1{margin-inline-start:-4px!important}.ms-md-n2{margin-inline-start:-8px!important}.ms-md-n3{margin-inline-start:-12px!important}.ms-md-n4{margin-inline-start:-16px!important}.ms-md-n5{margin-inline-start:-20px!important}.ms-md-n6{margin-inline-start:-24px!important}.ms-md-n7{margin-inline-start:-28px!important}.ms-md-n8{margin-inline-start:-32px!important}.ms-md-n9{margin-inline-start:-36px!important}.ms-md-n10{margin-inline-start:-40px!important}.ms-md-n11{margin-inline-start:-44px!important}.ms-md-n12{margin-inline-start:-48px!important}.ms-md-n13{margin-inline-start:-52px!important}.ms-md-n14{margin-inline-start:-56px!important}.ms-md-n15{margin-inline-start:-60px!important}.ms-md-n16{margin-inline-start:-64px!important}.me-md-n1{margin-inline-end:-4px!important}.me-md-n2{margin-inline-end:-8px!important}.me-md-n3{margin-inline-end:-12px!important}.me-md-n4{margin-inline-end:-16px!important}.me-md-n5{margin-inline-end:-20px!important}.me-md-n6{margin-inline-end:-24px!important}.me-md-n7{margin-inline-end:-28px!important}.me-md-n8{margin-inline-end:-32px!important}.me-md-n9{margin-inline-end:-36px!important}.me-md-n10{margin-inline-end:-40px!important}.me-md-n11{margin-inline-end:-44px!important}.me-md-n12{margin-inline-end:-48px!important}.me-md-n13{margin-inline-end:-52px!important}.me-md-n14{margin-inline-end:-56px!important}.me-md-n15{margin-inline-end:-60px!important}.me-md-n16{margin-inline-end:-64px!important}.pa-md-0{padding:0!important}.pa-md-1{padding:4px!important}.pa-md-2{padding:8px!important}.pa-md-3{padding:12px!important}.pa-md-4{padding:16px!important}.pa-md-5{padding:20px!important}.pa-md-6{padding:24px!important}.pa-md-7{padding:28px!important}.pa-md-8{padding:32px!important}.pa-md-9{padding:36px!important}.pa-md-10{padding:40px!important}.pa-md-11{padding:44px!important}.pa-md-12{padding:48px!important}.pa-md-13{padding:52px!important}.pa-md-14{padding:56px!important}.pa-md-15{padding:60px!important}.pa-md-16{padding:64px!important}.px-md-0{padding-left:0!important;padding-right:0!important}.px-md-1{padding-left:4px!important;padding-right:4px!important}.px-md-2{padding-left:8px!important;padding-right:8px!important}.px-md-3{padding-left:12px!important;padding-right:12px!important}.px-md-4{padding-left:16px!important;padding-right:16px!important}.px-md-5{padding-left:20px!important;padding-right:20px!important}.px-md-6{padding-left:24px!important;padding-right:24px!important}.px-md-7{padding-left:28px!important;padding-right:28px!important}.px-md-8{padding-left:32px!important;padding-right:32px!important}.px-md-9{padding-left:36px!important;padding-right:36px!important}.px-md-10{padding-left:40px!important;padding-right:40px!important}.px-md-11{padding-left:44px!important;padding-right:44px!important}.px-md-12{padding-left:48px!important;padding-right:48px!important}.px-md-13{padding-left:52px!important;padding-right:52px!important}.px-md-14{padding-left:56px!important;padding-right:56px!important}.px-md-15{padding-left:60px!important;padding-right:60px!important}.px-md-16{padding-left:64px!important;padding-right:64px!important}.py-md-0{padding-bottom:0!important;padding-top:0!important}.py-md-1{padding-bottom:4px!important;padding-top:4px!important}.py-md-2{padding-bottom:8px!important;padding-top:8px!important}.py-md-3{padding-bottom:12px!important;padding-top:12px!important}.py-md-4{padding-bottom:16px!important;padding-top:16px!important}.py-md-5{padding-bottom:20px!important;padding-top:20px!important}.py-md-6{padding-bottom:24px!important;padding-top:24px!important}.py-md-7{padding-bottom:28px!important;padding-top:28px!important}.py-md-8{padding-bottom:32px!important;padding-top:32px!important}.py-md-9{padding-bottom:36px!important;padding-top:36px!important}.py-md-10{padding-bottom:40px!important;padding-top:40px!important}.py-md-11{padding-bottom:44px!important;padding-top:44px!important}.py-md-12{padding-bottom:48px!important;padding-top:48px!important}.py-md-13{padding-bottom:52px!important;padding-top:52px!important}.py-md-14{padding-bottom:56px!important;padding-top:56px!important}.py-md-15{padding-bottom:60px!important;padding-top:60px!important}.py-md-16{padding-bottom:64px!important;padding-top:64px!important}.pt-md-0{padding-top:0!important}.pt-md-1{padding-top:4px!important}.pt-md-2{padding-top:8px!important}.pt-md-3{padding-top:12px!important}.pt-md-4{padding-top:16px!important}.pt-md-5{padding-top:20px!important}.pt-md-6{padding-top:24px!important}.pt-md-7{padding-top:28px!important}.pt-md-8{padding-top:32px!important}.pt-md-9{padding-top:36px!important}.pt-md-10{padding-top:40px!important}.pt-md-11{padding-top:44px!important}.pt-md-12{padding-top:48px!important}.pt-md-13{padding-top:52px!important}.pt-md-14{padding-top:56px!important}.pt-md-15{padding-top:60px!important}.pt-md-16{padding-top:64px!important}.pr-md-0{padding-right:0!important}.pr-md-1{padding-right:4px!important}.pr-md-2{padding-right:8px!important}.pr-md-3{padding-right:12px!important}.pr-md-4{padding-right:16px!important}.pr-md-5{padding-right:20px!important}.pr-md-6{padding-right:24px!important}.pr-md-7{padding-right:28px!important}.pr-md-8{padding-right:32px!important}.pr-md-9{padding-right:36px!important}.pr-md-10{padding-right:40px!important}.pr-md-11{padding-right:44px!important}.pr-md-12{padding-right:48px!important}.pr-md-13{padding-right:52px!important}.pr-md-14{padding-right:56px!important}.pr-md-15{padding-right:60px!important}.pr-md-16{padding-right:64px!important}.pb-md-0{padding-bottom:0!important}.pb-md-1{padding-bottom:4px!important}.pb-md-2{padding-bottom:8px!important}.pb-md-3{padding-bottom:12px!important}.pb-md-4{padding-bottom:16px!important}.pb-md-5{padding-bottom:20px!important}.pb-md-6{padding-bottom:24px!important}.pb-md-7{padding-bottom:28px!important}.pb-md-8{padding-bottom:32px!important}.pb-md-9{padding-bottom:36px!important}.pb-md-10{padding-bottom:40px!important}.pb-md-11{padding-bottom:44px!important}.pb-md-12{padding-bottom:48px!important}.pb-md-13{padding-bottom:52px!important}.pb-md-14{padding-bottom:56px!important}.pb-md-15{padding-bottom:60px!important}.pb-md-16{padding-bottom:64px!important}.pl-md-0{padding-left:0!important}.pl-md-1{padding-left:4px!important}.pl-md-2{padding-left:8px!important}.pl-md-3{padding-left:12px!important}.pl-md-4{padding-left:16px!important}.pl-md-5{padding-left:20px!important}.pl-md-6{padding-left:24px!important}.pl-md-7{padding-left:28px!important}.pl-md-8{padding-left:32px!important}.pl-md-9{padding-left:36px!important}.pl-md-10{padding-left:40px!important}.pl-md-11{padding-left:44px!important}.pl-md-12{padding-left:48px!important}.pl-md-13{padding-left:52px!important}.pl-md-14{padding-left:56px!important}.pl-md-15{padding-left:60px!important}.pl-md-16{padding-left:64px!important}.ps-md-0{padding-inline-start:0!important}.ps-md-1{padding-inline-start:4px!important}.ps-md-2{padding-inline-start:8px!important}.ps-md-3{padding-inline-start:12px!important}.ps-md-4{padding-inline-start:16px!important}.ps-md-5{padding-inline-start:20px!important}.ps-md-6{padding-inline-start:24px!important}.ps-md-7{padding-inline-start:28px!important}.ps-md-8{padding-inline-start:32px!important}.ps-md-9{padding-inline-start:36px!important}.ps-md-10{padding-inline-start:40px!important}.ps-md-11{padding-inline-start:44px!important}.ps-md-12{padding-inline-start:48px!important}.ps-md-13{padding-inline-start:52px!important}.ps-md-14{padding-inline-start:56px!important}.ps-md-15{padding-inline-start:60px!important}.ps-md-16{padding-inline-start:64px!important}.pe-md-0{padding-inline-end:0!important}.pe-md-1{padding-inline-end:4px!important}.pe-md-2{padding-inline-end:8px!important}.pe-md-3{padding-inline-end:12px!important}.pe-md-4{padding-inline-end:16px!important}.pe-md-5{padding-inline-end:20px!important}.pe-md-6{padding-inline-end:24px!important}.pe-md-7{padding-inline-end:28px!important}.pe-md-8{padding-inline-end:32px!important}.pe-md-9{padding-inline-end:36px!important}.pe-md-10{padding-inline-end:40px!important}.pe-md-11{padding-inline-end:44px!important}.pe-md-12{padding-inline-end:48px!important}.pe-md-13{padding-inline-end:52px!important}.pe-md-14{padding-inline-end:56px!important}.pe-md-15{padding-inline-end:60px!important}.pe-md-16{padding-inline-end:64px!important}.text-md-left{text-align:left!important}.text-md-right{text-align:right!important}.text-md-center{text-align:center!important}.text-md-justify{text-align:justify!important}.text-md-start{text-align:start!important}.text-md-end{text-align:end!important}.text-md-h1{font-size:6rem!important;letter-spacing:-.015625em!important;line-height:6rem}.text-md-h1,.text-md-h2{font-family:Roboto,sans-serif!important;font-weight:300;text-transform:none!important}.text-md-h2{font-size:3.75rem!important;letter-spacing:-.0083333333em!important;line-height:3.75rem}.text-md-h3{font-size:3rem!important;letter-spacing:normal!important;line-height:3.125rem}.text-md-h3,.text-md-h4{font-family:Roboto,sans-serif!important;font-weight:400;text-transform:none!important}.text-md-h4{font-size:2.125rem!important;letter-spacing:.0073529412em!important;line-height:2.5rem}.text-md-h5{font-size:1.5rem!important;font-weight:400;letter-spacing:normal!important}.text-md-h5,.text-md-h6{font-family:Roboto,sans-serif!important;line-height:2rem;text-transform:none!important}.text-md-h6{font-size:1.25rem!important;font-weight:500;letter-spacing:.0125em!important}.text-md-subtitle-1{font-size:1rem!important;font-weight:400;letter-spacing:.009375em!important;line-height:1.75rem}.text-md-subtitle-1,.text-md-subtitle-2{font-family:Roboto,sans-serif!important;text-transform:none!important}.text-md-subtitle-2{font-size:.875rem!important;font-weight:500;letter-spacing:.0071428571em!important;line-height:1.375rem}.text-md-body-1{font-size:1rem!important;letter-spacing:.03125em!important;line-height:1.5rem}.text-md-body-1,.text-md-body-2{font-family:Roboto,sans-serif!important;font-weight:400;text-transform:none!important}.text-md-body-2{font-size:.875rem!important;letter-spacing:.0178571429em!important;line-height:1.25rem}.text-md-button{font-family:Roboto,sans-serif!important;font-size:.875rem!important;font-weight:500;letter-spacing:.0892857143em!important;line-height:2.25rem;text-transform:uppercase!important}.text-md-caption{font-weight:400;letter-spacing:.0333333333em!important;line-height:1.25rem;text-transform:none!important}.text-md-caption,.text-md-overline{font-family:Roboto,sans-serif!important;font-size:.75rem!important}.text-md-overline{font-weight:500;letter-spacing:.1666666667em!important;line-height:2rem;text-transform:uppercase!important}}@media (min-width:1280px){.d-lg-none{display:none!important}.d-lg-inline{display:inline!important}.d-lg-inline-block{display:inline-block!important}.d-lg-block{display:block!important}.d-lg-table{display:table!important}.d-lg-table-row{display:table-row!important}.d-lg-table-cell{display:table-cell!important}.d-lg-flex{display:flex!important}.d-lg-inline-flex{display:inline-flex!important}.float-lg-none{float:none!important}.float-lg-left{float:left!important}.float-lg-right{float:right!important}.v-locale--is-rtl .float-lg-end{float:left!important}.v-locale--is-ltr .float-lg-end,.v-locale--is-rtl .float-lg-start{float:right!important}.v-locale--is-ltr .float-lg-start{float:left!important}.flex-lg-1-1,.flex-lg-fill{flex:1 1 auto!important}.flex-lg-1-0{flex:1 0 auto!important}.flex-lg-0-1{flex:0 1 auto!important}.flex-lg-0-0{flex:0 0 auto!important}.flex-lg-1-1-100{flex:1 1 100%!important}.flex-lg-1-0-100{flex:1 0 100%!important}.flex-lg-0-1-100{flex:0 1 100%!important}.flex-lg-0-0-100{flex:0 0 100%!important}.flex-lg-row{flex-direction:row!important}.flex-lg-column{flex-direction:column!important}.flex-lg-row-reverse{flex-direction:row-reverse!important}.flex-lg-column-reverse{flex-direction:column-reverse!important}.flex-lg-grow-0{flex-grow:0!important}.flex-lg-grow-1{flex-grow:1!important}.flex-lg-shrink-0{flex-shrink:0!important}.flex-lg-shrink-1{flex-shrink:1!important}.flex-lg-wrap{flex-wrap:wrap!important}.flex-lg-nowrap{flex-wrap:nowrap!important}.flex-lg-wrap-reverse{flex-wrap:wrap-reverse!important}.justify-lg-start{justify-content:flex-start!important}.justify-lg-end{justify-content:flex-end!important}.justify-lg-center{justify-content:center!important}.justify-lg-space-between{justify-content:space-between!important}.justify-lg-space-around{justify-content:space-around!important}.justify-lg-space-evenly{justify-content:space-evenly!important}.align-lg-start{align-items:flex-start!important}.align-lg-end{align-items:flex-end!important}.align-lg-center{align-items:center!important}.align-lg-baseline{align-items:baseline!important}.align-lg-stretch{align-items:stretch!important}.align-content-lg-start{align-content:flex-start!important}.align-content-lg-end{align-content:flex-end!important}.align-content-lg-center{align-content:center!important}.align-content-lg-space-between{align-content:space-between!important}.align-content-lg-space-around{align-content:space-around!important}.align-content-lg-space-evenly{align-content:space-evenly!important}.align-content-lg-stretch{align-content:stretch!important}.align-self-lg-auto{align-self:auto!important}.align-self-lg-start{align-self:flex-start!important}.align-self-lg-end{align-self:flex-end!important}.align-self-lg-center{align-self:center!important}.align-self-lg-baseline{align-self:baseline!important}.align-self-lg-stretch{align-self:stretch!important}.order-lg-first{order:-1!important}.order-lg-0{order:0!important}.order-lg-1{order:1!important}.order-lg-2{order:2!important}.order-lg-3{order:3!important}.order-lg-4{order:4!important}.order-lg-5{order:5!important}.order-lg-6{order:6!important}.order-lg-7{order:7!important}.order-lg-8{order:8!important}.order-lg-9{order:9!important}.order-lg-10{order:10!important}.order-lg-11{order:11!important}.order-lg-12{order:12!important}.order-lg-last{order:13!important}.ga-lg-0{gap:0!important}.ga-lg-1{gap:4px!important}.ga-lg-2{gap:8px!important}.ga-lg-3{gap:12px!important}.ga-lg-4{gap:16px!important}.ga-lg-5{gap:20px!important}.ga-lg-6{gap:24px!important}.ga-lg-7{gap:28px!important}.ga-lg-8{gap:32px!important}.ga-lg-9{gap:36px!important}.ga-lg-10{gap:40px!important}.ga-lg-11{gap:44px!important}.ga-lg-12{gap:48px!important}.ga-lg-13{gap:52px!important}.ga-lg-14{gap:56px!important}.ga-lg-15{gap:60px!important}.ga-lg-16{gap:64px!important}.ga-lg-auto{gap:auto!important}.gr-lg-0{row-gap:0!important}.gr-lg-1{row-gap:4px!important}.gr-lg-2{row-gap:8px!important}.gr-lg-3{row-gap:12px!important}.gr-lg-4{row-gap:16px!important}.gr-lg-5{row-gap:20px!important}.gr-lg-6{row-gap:24px!important}.gr-lg-7{row-gap:28px!important}.gr-lg-8{row-gap:32px!important}.gr-lg-9{row-gap:36px!important}.gr-lg-10{row-gap:40px!important}.gr-lg-11{row-gap:44px!important}.gr-lg-12{row-gap:48px!important}.gr-lg-13{row-gap:52px!important}.gr-lg-14{row-gap:56px!important}.gr-lg-15{row-gap:60px!important}.gr-lg-16{row-gap:64px!important}.gr-lg-auto{row-gap:auto!important}.gc-lg-0{-moz-column-gap:0!important;column-gap:0!important}.gc-lg-1{-moz-column-gap:4px!important;column-gap:4px!important}.gc-lg-2{-moz-column-gap:8px!important;column-gap:8px!important}.gc-lg-3{-moz-column-gap:12px!important;column-gap:12px!important}.gc-lg-4{-moz-column-gap:16px!important;column-gap:16px!important}.gc-lg-5{-moz-column-gap:20px!important;column-gap:20px!important}.gc-lg-6{-moz-column-gap:24px!important;column-gap:24px!important}.gc-lg-7{-moz-column-gap:28px!important;column-gap:28px!important}.gc-lg-8{-moz-column-gap:32px!important;column-gap:32px!important}.gc-lg-9{-moz-column-gap:36px!important;column-gap:36px!important}.gc-lg-10{-moz-column-gap:40px!important;column-gap:40px!important}.gc-lg-11{-moz-column-gap:44px!important;column-gap:44px!important}.gc-lg-12{-moz-column-gap:48px!important;column-gap:48px!important}.gc-lg-13{-moz-column-gap:52px!important;column-gap:52px!important}.gc-lg-14{-moz-column-gap:56px!important;column-gap:56px!important}.gc-lg-15{-moz-column-gap:60px!important;column-gap:60px!important}.gc-lg-16{-moz-column-gap:64px!important;column-gap:64px!important}.gc-lg-auto{-moz-column-gap:auto!important;column-gap:auto!important}.ma-lg-0{margin:0!important}.ma-lg-1{margin:4px!important}.ma-lg-2{margin:8px!important}.ma-lg-3{margin:12px!important}.ma-lg-4{margin:16px!important}.ma-lg-5{margin:20px!important}.ma-lg-6{margin:24px!important}.ma-lg-7{margin:28px!important}.ma-lg-8{margin:32px!important}.ma-lg-9{margin:36px!important}.ma-lg-10{margin:40px!important}.ma-lg-11{margin:44px!important}.ma-lg-12{margin:48px!important}.ma-lg-13{margin:52px!important}.ma-lg-14{margin:56px!important}.ma-lg-15{margin:60px!important}.ma-lg-16{margin:64px!important}.ma-lg-auto{margin:auto!important}.mx-lg-0{margin-left:0!important;margin-right:0!important}.mx-lg-1{margin-left:4px!important;margin-right:4px!important}.mx-lg-2{margin-left:8px!important;margin-right:8px!important}.mx-lg-3{margin-left:12px!important;margin-right:12px!important}.mx-lg-4{margin-left:16px!important;margin-right:16px!important}.mx-lg-5{margin-left:20px!important;margin-right:20px!important}.mx-lg-6{margin-left:24px!important;margin-right:24px!important}.mx-lg-7{margin-left:28px!important;margin-right:28px!important}.mx-lg-8{margin-left:32px!important;margin-right:32px!important}.mx-lg-9{margin-left:36px!important;margin-right:36px!important}.mx-lg-10{margin-left:40px!important;margin-right:40px!important}.mx-lg-11{margin-left:44px!important;margin-right:44px!important}.mx-lg-12{margin-left:48px!important;margin-right:48px!important}.mx-lg-13{margin-left:52px!important;margin-right:52px!important}.mx-lg-14{margin-left:56px!important;margin-right:56px!important}.mx-lg-15{margin-left:60px!important;margin-right:60px!important}.mx-lg-16{margin-left:64px!important;margin-right:64px!important}.mx-lg-auto{margin-left:auto!important;margin-right:auto!important}.my-lg-0{margin-bottom:0!important;margin-top:0!important}.my-lg-1{margin-bottom:4px!important;margin-top:4px!important}.my-lg-2{margin-bottom:8px!important;margin-top:8px!important}.my-lg-3{margin-bottom:12px!important;margin-top:12px!important}.my-lg-4{margin-bottom:16px!important;margin-top:16px!important}.my-lg-5{margin-bottom:20px!important;margin-top:20px!important}.my-lg-6{margin-bottom:24px!important;margin-top:24px!important}.my-lg-7{margin-bottom:28px!important;margin-top:28px!important}.my-lg-8{margin-bottom:32px!important;margin-top:32px!important}.my-lg-9{margin-bottom:36px!important;margin-top:36px!important}.my-lg-10{margin-bottom:40px!important;margin-top:40px!important}.my-lg-11{margin-bottom:44px!important;margin-top:44px!important}.my-lg-12{margin-bottom:48px!important;margin-top:48px!important}.my-lg-13{margin-bottom:52px!important;margin-top:52px!important}.my-lg-14{margin-bottom:56px!important;margin-top:56px!important}.my-lg-15{margin-bottom:60px!important;margin-top:60px!important}.my-lg-16{margin-bottom:64px!important;margin-top:64px!important}.my-lg-auto{margin-bottom:auto!important;margin-top:auto!important}.mt-lg-0{margin-top:0!important}.mt-lg-1{margin-top:4px!important}.mt-lg-2{margin-top:8px!important}.mt-lg-3{margin-top:12px!important}.mt-lg-4{margin-top:16px!important}.mt-lg-5{margin-top:20px!important}.mt-lg-6{margin-top:24px!important}.mt-lg-7{margin-top:28px!important}.mt-lg-8{margin-top:32px!important}.mt-lg-9{margin-top:36px!important}.mt-lg-10{margin-top:40px!important}.mt-lg-11{margin-top:44px!important}.mt-lg-12{margin-top:48px!important}.mt-lg-13{margin-top:52px!important}.mt-lg-14{margin-top:56px!important}.mt-lg-15{margin-top:60px!important}.mt-lg-16{margin-top:64px!important}.mt-lg-auto{margin-top:auto!important}.mr-lg-0{margin-right:0!important}.mr-lg-1{margin-right:4px!important}.mr-lg-2{margin-right:8px!important}.mr-lg-3{margin-right:12px!important}.mr-lg-4{margin-right:16px!important}.mr-lg-5{margin-right:20px!important}.mr-lg-6{margin-right:24px!important}.mr-lg-7{margin-right:28px!important}.mr-lg-8{margin-right:32px!important}.mr-lg-9{margin-right:36px!important}.mr-lg-10{margin-right:40px!important}.mr-lg-11{margin-right:44px!important}.mr-lg-12{margin-right:48px!important}.mr-lg-13{margin-right:52px!important}.mr-lg-14{margin-right:56px!important}.mr-lg-15{margin-right:60px!important}.mr-lg-16{margin-right:64px!important}.mr-lg-auto{margin-right:auto!important}.mb-lg-0{margin-bottom:0!important}.mb-lg-1{margin-bottom:4px!important}.mb-lg-2{margin-bottom:8px!important}.mb-lg-3{margin-bottom:12px!important}.mb-lg-4{margin-bottom:16px!important}.mb-lg-5{margin-bottom:20px!important}.mb-lg-6{margin-bottom:24px!important}.mb-lg-7{margin-bottom:28px!important}.mb-lg-8{margin-bottom:32px!important}.mb-lg-9{margin-bottom:36px!important}.mb-lg-10{margin-bottom:40px!important}.mb-lg-11{margin-bottom:44px!important}.mb-lg-12{margin-bottom:48px!important}.mb-lg-13{margin-bottom:52px!important}.mb-lg-14{margin-bottom:56px!important}.mb-lg-15{margin-bottom:60px!important}.mb-lg-16{margin-bottom:64px!important}.mb-lg-auto{margin-bottom:auto!important}.ml-lg-0{margin-left:0!important}.ml-lg-1{margin-left:4px!important}.ml-lg-2{margin-left:8px!important}.ml-lg-3{margin-left:12px!important}.ml-lg-4{margin-left:16px!important}.ml-lg-5{margin-left:20px!important}.ml-lg-6{margin-left:24px!important}.ml-lg-7{margin-left:28px!important}.ml-lg-8{margin-left:32px!important}.ml-lg-9{margin-left:36px!important}.ml-lg-10{margin-left:40px!important}.ml-lg-11{margin-left:44px!important}.ml-lg-12{margin-left:48px!important}.ml-lg-13{margin-left:52px!important}.ml-lg-14{margin-left:56px!important}.ml-lg-15{margin-left:60px!important}.ml-lg-16{margin-left:64px!important}.ml-lg-auto{margin-left:auto!important}.ms-lg-0{margin-inline-start:0!important}.ms-lg-1{margin-inline-start:4px!important}.ms-lg-2{margin-inline-start:8px!important}.ms-lg-3{margin-inline-start:12px!important}.ms-lg-4{margin-inline-start:16px!important}.ms-lg-5{margin-inline-start:20px!important}.ms-lg-6{margin-inline-start:24px!important}.ms-lg-7{margin-inline-start:28px!important}.ms-lg-8{margin-inline-start:32px!important}.ms-lg-9{margin-inline-start:36px!important}.ms-lg-10{margin-inline-start:40px!important}.ms-lg-11{margin-inline-start:44px!important}.ms-lg-12{margin-inline-start:48px!important}.ms-lg-13{margin-inline-start:52px!important}.ms-lg-14{margin-inline-start:56px!important}.ms-lg-15{margin-inline-start:60px!important}.ms-lg-16{margin-inline-start:64px!important}.ms-lg-auto{margin-inline-start:auto!important}.me-lg-0{margin-inline-end:0!important}.me-lg-1{margin-inline-end:4px!important}.me-lg-2{margin-inline-end:8px!important}.me-lg-3{margin-inline-end:12px!important}.me-lg-4{margin-inline-end:16px!important}.me-lg-5{margin-inline-end:20px!important}.me-lg-6{margin-inline-end:24px!important}.me-lg-7{margin-inline-end:28px!important}.me-lg-8{margin-inline-end:32px!important}.me-lg-9{margin-inline-end:36px!important}.me-lg-10{margin-inline-end:40px!important}.me-lg-11{margin-inline-end:44px!important}.me-lg-12{margin-inline-end:48px!important}.me-lg-13{margin-inline-end:52px!important}.me-lg-14{margin-inline-end:56px!important}.me-lg-15{margin-inline-end:60px!important}.me-lg-16{margin-inline-end:64px!important}.me-lg-auto{margin-inline-end:auto!important}.ma-lg-n1{margin:-4px!important}.ma-lg-n2{margin:-8px!important}.ma-lg-n3{margin:-12px!important}.ma-lg-n4{margin:-16px!important}.ma-lg-n5{margin:-20px!important}.ma-lg-n6{margin:-24px!important}.ma-lg-n7{margin:-28px!important}.ma-lg-n8{margin:-32px!important}.ma-lg-n9{margin:-36px!important}.ma-lg-n10{margin:-40px!important}.ma-lg-n11{margin:-44px!important}.ma-lg-n12{margin:-48px!important}.ma-lg-n13{margin:-52px!important}.ma-lg-n14{margin:-56px!important}.ma-lg-n15{margin:-60px!important}.ma-lg-n16{margin:-64px!important}.mx-lg-n1{margin-left:-4px!important;margin-right:-4px!important}.mx-lg-n2{margin-left:-8px!important;margin-right:-8px!important}.mx-lg-n3{margin-left:-12px!important;margin-right:-12px!important}.mx-lg-n4{margin-left:-16px!important;margin-right:-16px!important}.mx-lg-n5{margin-left:-20px!important;margin-right:-20px!important}.mx-lg-n6{margin-left:-24px!important;margin-right:-24px!important}.mx-lg-n7{margin-left:-28px!important;margin-right:-28px!important}.mx-lg-n8{margin-left:-32px!important;margin-right:-32px!important}.mx-lg-n9{margin-left:-36px!important;margin-right:-36px!important}.mx-lg-n10{margin-left:-40px!important;margin-right:-40px!important}.mx-lg-n11{margin-left:-44px!important;margin-right:-44px!important}.mx-lg-n12{margin-left:-48px!important;margin-right:-48px!important}.mx-lg-n13{margin-left:-52px!important;margin-right:-52px!important}.mx-lg-n14{margin-left:-56px!important;margin-right:-56px!important}.mx-lg-n15{margin-left:-60px!important;margin-right:-60px!important}.mx-lg-n16{margin-left:-64px!important;margin-right:-64px!important}.my-lg-n1{margin-bottom:-4px!important;margin-top:-4px!important}.my-lg-n2{margin-bottom:-8px!important;margin-top:-8px!important}.my-lg-n3{margin-bottom:-12px!important;margin-top:-12px!important}.my-lg-n4{margin-bottom:-16px!important;margin-top:-16px!important}.my-lg-n5{margin-bottom:-20px!important;margin-top:-20px!important}.my-lg-n6{margin-bottom:-24px!important;margin-top:-24px!important}.my-lg-n7{margin-bottom:-28px!important;margin-top:-28px!important}.my-lg-n8{margin-bottom:-32px!important;margin-top:-32px!important}.my-lg-n9{margin-bottom:-36px!important;margin-top:-36px!important}.my-lg-n10{margin-bottom:-40px!important;margin-top:-40px!important}.my-lg-n11{margin-bottom:-44px!important;margin-top:-44px!important}.my-lg-n12{margin-bottom:-48px!important;margin-top:-48px!important}.my-lg-n13{margin-bottom:-52px!important;margin-top:-52px!important}.my-lg-n14{margin-bottom:-56px!important;margin-top:-56px!important}.my-lg-n15{margin-bottom:-60px!important;margin-top:-60px!important}.my-lg-n16{margin-bottom:-64px!important;margin-top:-64px!important}.mt-lg-n1{margin-top:-4px!important}.mt-lg-n2{margin-top:-8px!important}.mt-lg-n3{margin-top:-12px!important}.mt-lg-n4{margin-top:-16px!important}.mt-lg-n5{margin-top:-20px!important}.mt-lg-n6{margin-top:-24px!important}.mt-lg-n7{margin-top:-28px!important}.mt-lg-n8{margin-top:-32px!important}.mt-lg-n9{margin-top:-36px!important}.mt-lg-n10{margin-top:-40px!important}.mt-lg-n11{margin-top:-44px!important}.mt-lg-n12{margin-top:-48px!important}.mt-lg-n13{margin-top:-52px!important}.mt-lg-n14{margin-top:-56px!important}.mt-lg-n15{margin-top:-60px!important}.mt-lg-n16{margin-top:-64px!important}.mr-lg-n1{margin-right:-4px!important}.mr-lg-n2{margin-right:-8px!important}.mr-lg-n3{margin-right:-12px!important}.mr-lg-n4{margin-right:-16px!important}.mr-lg-n5{margin-right:-20px!important}.mr-lg-n6{margin-right:-24px!important}.mr-lg-n7{margin-right:-28px!important}.mr-lg-n8{margin-right:-32px!important}.mr-lg-n9{margin-right:-36px!important}.mr-lg-n10{margin-right:-40px!important}.mr-lg-n11{margin-right:-44px!important}.mr-lg-n12{margin-right:-48px!important}.mr-lg-n13{margin-right:-52px!important}.mr-lg-n14{margin-right:-56px!important}.mr-lg-n15{margin-right:-60px!important}.mr-lg-n16{margin-right:-64px!important}.mb-lg-n1{margin-bottom:-4px!important}.mb-lg-n2{margin-bottom:-8px!important}.mb-lg-n3{margin-bottom:-12px!important}.mb-lg-n4{margin-bottom:-16px!important}.mb-lg-n5{margin-bottom:-20px!important}.mb-lg-n6{margin-bottom:-24px!important}.mb-lg-n7{margin-bottom:-28px!important}.mb-lg-n8{margin-bottom:-32px!important}.mb-lg-n9{margin-bottom:-36px!important}.mb-lg-n10{margin-bottom:-40px!important}.mb-lg-n11{margin-bottom:-44px!important}.mb-lg-n12{margin-bottom:-48px!important}.mb-lg-n13{margin-bottom:-52px!important}.mb-lg-n14{margin-bottom:-56px!important}.mb-lg-n15{margin-bottom:-60px!important}.mb-lg-n16{margin-bottom:-64px!important}.ml-lg-n1{margin-left:-4px!important}.ml-lg-n2{margin-left:-8px!important}.ml-lg-n3{margin-left:-12px!important}.ml-lg-n4{margin-left:-16px!important}.ml-lg-n5{margin-left:-20px!important}.ml-lg-n6{margin-left:-24px!important}.ml-lg-n7{margin-left:-28px!important}.ml-lg-n8{margin-left:-32px!important}.ml-lg-n9{margin-left:-36px!important}.ml-lg-n10{margin-left:-40px!important}.ml-lg-n11{margin-left:-44px!important}.ml-lg-n12{margin-left:-48px!important}.ml-lg-n13{margin-left:-52px!important}.ml-lg-n14{margin-left:-56px!important}.ml-lg-n15{margin-left:-60px!important}.ml-lg-n16{margin-left:-64px!important}.ms-lg-n1{margin-inline-start:-4px!important}.ms-lg-n2{margin-inline-start:-8px!important}.ms-lg-n3{margin-inline-start:-12px!important}.ms-lg-n4{margin-inline-start:-16px!important}.ms-lg-n5{margin-inline-start:-20px!important}.ms-lg-n6{margin-inline-start:-24px!important}.ms-lg-n7{margin-inline-start:-28px!important}.ms-lg-n8{margin-inline-start:-32px!important}.ms-lg-n9{margin-inline-start:-36px!important}.ms-lg-n10{margin-inline-start:-40px!important}.ms-lg-n11{margin-inline-start:-44px!important}.ms-lg-n12{margin-inline-start:-48px!important}.ms-lg-n13{margin-inline-start:-52px!important}.ms-lg-n14{margin-inline-start:-56px!important}.ms-lg-n15{margin-inline-start:-60px!important}.ms-lg-n16{margin-inline-start:-64px!important}.me-lg-n1{margin-inline-end:-4px!important}.me-lg-n2{margin-inline-end:-8px!important}.me-lg-n3{margin-inline-end:-12px!important}.me-lg-n4{margin-inline-end:-16px!important}.me-lg-n5{margin-inline-end:-20px!important}.me-lg-n6{margin-inline-end:-24px!important}.me-lg-n7{margin-inline-end:-28px!important}.me-lg-n8{margin-inline-end:-32px!important}.me-lg-n9{margin-inline-end:-36px!important}.me-lg-n10{margin-inline-end:-40px!important}.me-lg-n11{margin-inline-end:-44px!important}.me-lg-n12{margin-inline-end:-48px!important}.me-lg-n13{margin-inline-end:-52px!important}.me-lg-n14{margin-inline-end:-56px!important}.me-lg-n15{margin-inline-end:-60px!important}.me-lg-n16{margin-inline-end:-64px!important}.pa-lg-0{padding:0!important}.pa-lg-1{padding:4px!important}.pa-lg-2{padding:8px!important}.pa-lg-3{padding:12px!important}.pa-lg-4{padding:16px!important}.pa-lg-5{padding:20px!important}.pa-lg-6{padding:24px!important}.pa-lg-7{padding:28px!important}.pa-lg-8{padding:32px!important}.pa-lg-9{padding:36px!important}.pa-lg-10{padding:40px!important}.pa-lg-11{padding:44px!important}.pa-lg-12{padding:48px!important}.pa-lg-13{padding:52px!important}.pa-lg-14{padding:56px!important}.pa-lg-15{padding:60px!important}.pa-lg-16{padding:64px!important}.px-lg-0{padding-left:0!important;padding-right:0!important}.px-lg-1{padding-left:4px!important;padding-right:4px!important}.px-lg-2{padding-left:8px!important;padding-right:8px!important}.px-lg-3{padding-left:12px!important;padding-right:12px!important}.px-lg-4{padding-left:16px!important;padding-right:16px!important}.px-lg-5{padding-left:20px!important;padding-right:20px!important}.px-lg-6{padding-left:24px!important;padding-right:24px!important}.px-lg-7{padding-left:28px!important;padding-right:28px!important}.px-lg-8{padding-left:32px!important;padding-right:32px!important}.px-lg-9{padding-left:36px!important;padding-right:36px!important}.px-lg-10{padding-left:40px!important;padding-right:40px!important}.px-lg-11{padding-left:44px!important;padding-right:44px!important}.px-lg-12{padding-left:48px!important;padding-right:48px!important}.px-lg-13{padding-left:52px!important;padding-right:52px!important}.px-lg-14{padding-left:56px!important;padding-right:56px!important}.px-lg-15{padding-left:60px!important;padding-right:60px!important}.px-lg-16{padding-left:64px!important;padding-right:64px!important}.py-lg-0{padding-bottom:0!important;padding-top:0!important}.py-lg-1{padding-bottom:4px!important;padding-top:4px!important}.py-lg-2{padding-bottom:8px!important;padding-top:8px!important}.py-lg-3{padding-bottom:12px!important;padding-top:12px!important}.py-lg-4{padding-bottom:16px!important;padding-top:16px!important}.py-lg-5{padding-bottom:20px!important;padding-top:20px!important}.py-lg-6{padding-bottom:24px!important;padding-top:24px!important}.py-lg-7{padding-bottom:28px!important;padding-top:28px!important}.py-lg-8{padding-bottom:32px!important;padding-top:32px!important}.py-lg-9{padding-bottom:36px!important;padding-top:36px!important}.py-lg-10{padding-bottom:40px!important;padding-top:40px!important}.py-lg-11{padding-bottom:44px!important;padding-top:44px!important}.py-lg-12{padding-bottom:48px!important;padding-top:48px!important}.py-lg-13{padding-bottom:52px!important;padding-top:52px!important}.py-lg-14{padding-bottom:56px!important;padding-top:56px!important}.py-lg-15{padding-bottom:60px!important;padding-top:60px!important}.py-lg-16{padding-bottom:64px!important;padding-top:64px!important}.pt-lg-0{padding-top:0!important}.pt-lg-1{padding-top:4px!important}.pt-lg-2{padding-top:8px!important}.pt-lg-3{padding-top:12px!important}.pt-lg-4{padding-top:16px!important}.pt-lg-5{padding-top:20px!important}.pt-lg-6{padding-top:24px!important}.pt-lg-7{padding-top:28px!important}.pt-lg-8{padding-top:32px!important}.pt-lg-9{padding-top:36px!important}.pt-lg-10{padding-top:40px!important}.pt-lg-11{padding-top:44px!important}.pt-lg-12{padding-top:48px!important}.pt-lg-13{padding-top:52px!important}.pt-lg-14{padding-top:56px!important}.pt-lg-15{padding-top:60px!important}.pt-lg-16{padding-top:64px!important}.pr-lg-0{padding-right:0!important}.pr-lg-1{padding-right:4px!important}.pr-lg-2{padding-right:8px!important}.pr-lg-3{padding-right:12px!important}.pr-lg-4{padding-right:16px!important}.pr-lg-5{padding-right:20px!important}.pr-lg-6{padding-right:24px!important}.pr-lg-7{padding-right:28px!important}.pr-lg-8{padding-right:32px!important}.pr-lg-9{padding-right:36px!important}.pr-lg-10{padding-right:40px!important}.pr-lg-11{padding-right:44px!important}.pr-lg-12{padding-right:48px!important}.pr-lg-13{padding-right:52px!important}.pr-lg-14{padding-right:56px!important}.pr-lg-15{padding-right:60px!important}.pr-lg-16{padding-right:64px!important}.pb-lg-0{padding-bottom:0!important}.pb-lg-1{padding-bottom:4px!important}.pb-lg-2{padding-bottom:8px!important}.pb-lg-3{padding-bottom:12px!important}.pb-lg-4{padding-bottom:16px!important}.pb-lg-5{padding-bottom:20px!important}.pb-lg-6{padding-bottom:24px!important}.pb-lg-7{padding-bottom:28px!important}.pb-lg-8{padding-bottom:32px!important}.pb-lg-9{padding-bottom:36px!important}.pb-lg-10{padding-bottom:40px!important}.pb-lg-11{padding-bottom:44px!important}.pb-lg-12{padding-bottom:48px!important}.pb-lg-13{padding-bottom:52px!important}.pb-lg-14{padding-bottom:56px!important}.pb-lg-15{padding-bottom:60px!important}.pb-lg-16{padding-bottom:64px!important}.pl-lg-0{padding-left:0!important}.pl-lg-1{padding-left:4px!important}.pl-lg-2{padding-left:8px!important}.pl-lg-3{padding-left:12px!important}.pl-lg-4{padding-left:16px!important}.pl-lg-5{padding-left:20px!important}.pl-lg-6{padding-left:24px!important}.pl-lg-7{padding-left:28px!important}.pl-lg-8{padding-left:32px!important}.pl-lg-9{padding-left:36px!important}.pl-lg-10{padding-left:40px!important}.pl-lg-11{padding-left:44px!important}.pl-lg-12{padding-left:48px!important}.pl-lg-13{padding-left:52px!important}.pl-lg-14{padding-left:56px!important}.pl-lg-15{padding-left:60px!important}.pl-lg-16{padding-left:64px!important}.ps-lg-0{padding-inline-start:0!important}.ps-lg-1{padding-inline-start:4px!important}.ps-lg-2{padding-inline-start:8px!important}.ps-lg-3{padding-inline-start:12px!important}.ps-lg-4{padding-inline-start:16px!important}.ps-lg-5{padding-inline-start:20px!important}.ps-lg-6{padding-inline-start:24px!important}.ps-lg-7{padding-inline-start:28px!important}.ps-lg-8{padding-inline-start:32px!important}.ps-lg-9{padding-inline-start:36px!important}.ps-lg-10{padding-inline-start:40px!important}.ps-lg-11{padding-inline-start:44px!important}.ps-lg-12{padding-inline-start:48px!important}.ps-lg-13{padding-inline-start:52px!important}.ps-lg-14{padding-inline-start:56px!important}.ps-lg-15{padding-inline-start:60px!important}.ps-lg-16{padding-inline-start:64px!important}.pe-lg-0{padding-inline-end:0!important}.pe-lg-1{padding-inline-end:4px!important}.pe-lg-2{padding-inline-end:8px!important}.pe-lg-3{padding-inline-end:12px!important}.pe-lg-4{padding-inline-end:16px!important}.pe-lg-5{padding-inline-end:20px!important}.pe-lg-6{padding-inline-end:24px!important}.pe-lg-7{padding-inline-end:28px!important}.pe-lg-8{padding-inline-end:32px!important}.pe-lg-9{padding-inline-end:36px!important}.pe-lg-10{padding-inline-end:40px!important}.pe-lg-11{padding-inline-end:44px!important}.pe-lg-12{padding-inline-end:48px!important}.pe-lg-13{padding-inline-end:52px!important}.pe-lg-14{padding-inline-end:56px!important}.pe-lg-15{padding-inline-end:60px!important}.pe-lg-16{padding-inline-end:64px!important}.text-lg-left{text-align:left!important}.text-lg-right{text-align:right!important}.text-lg-center{text-align:center!important}.text-lg-justify{text-align:justify!important}.text-lg-start{text-align:start!important}.text-lg-end{text-align:end!important}.text-lg-h1{font-size:6rem!important;letter-spacing:-.015625em!important;line-height:6rem}.text-lg-h1,.text-lg-h2{font-family:Roboto,sans-serif!important;font-weight:300;text-transform:none!important}.text-lg-h2{font-size:3.75rem!important;letter-spacing:-.0083333333em!important;line-height:3.75rem}.text-lg-h3{font-size:3rem!important;letter-spacing:normal!important;line-height:3.125rem}.text-lg-h3,.text-lg-h4{font-family:Roboto,sans-serif!important;font-weight:400;text-transform:none!important}.text-lg-h4{font-size:2.125rem!important;letter-spacing:.0073529412em!important;line-height:2.5rem}.text-lg-h5{font-size:1.5rem!important;font-weight:400;letter-spacing:normal!important}.text-lg-h5,.text-lg-h6{font-family:Roboto,sans-serif!important;line-height:2rem;text-transform:none!important}.text-lg-h6{font-size:1.25rem!important;font-weight:500;letter-spacing:.0125em!important}.text-lg-subtitle-1{font-size:1rem!important;font-weight:400;letter-spacing:.009375em!important;line-height:1.75rem}.text-lg-subtitle-1,.text-lg-subtitle-2{font-family:Roboto,sans-serif!important;text-transform:none!important}.text-lg-subtitle-2{font-size:.875rem!important;font-weight:500;letter-spacing:.0071428571em!important;line-height:1.375rem}.text-lg-body-1{font-size:1rem!important;letter-spacing:.03125em!important;line-height:1.5rem}.text-lg-body-1,.text-lg-body-2{font-family:Roboto,sans-serif!important;font-weight:400;text-transform:none!important}.text-lg-body-2{font-size:.875rem!important;letter-spacing:.0178571429em!important;line-height:1.25rem}.text-lg-button{font-family:Roboto,sans-serif!important;font-size:.875rem!important;font-weight:500;letter-spacing:.0892857143em!important;line-height:2.25rem;text-transform:uppercase!important}.text-lg-caption{font-weight:400;letter-spacing:.0333333333em!important;line-height:1.25rem;text-transform:none!important}.text-lg-caption,.text-lg-overline{font-family:Roboto,sans-serif!important;font-size:.75rem!important}.text-lg-overline{font-weight:500;letter-spacing:.1666666667em!important;line-height:2rem;text-transform:uppercase!important}}@media (min-width:1920px){.d-xl-none{display:none!important}.d-xl-inline{display:inline!important}.d-xl-inline-block{display:inline-block!important}.d-xl-block{display:block!important}.d-xl-table{display:table!important}.d-xl-table-row{display:table-row!important}.d-xl-table-cell{display:table-cell!important}.d-xl-flex{display:flex!important}.d-xl-inline-flex{display:inline-flex!important}.float-xl-none{float:none!important}.float-xl-left{float:left!important}.float-xl-right{float:right!important}.v-locale--is-rtl .float-xl-end{float:left!important}.v-locale--is-ltr .float-xl-end,.v-locale--is-rtl .float-xl-start{float:right!important}.v-locale--is-ltr .float-xl-start{float:left!important}.flex-xl-1-1,.flex-xl-fill{flex:1 1 auto!important}.flex-xl-1-0{flex:1 0 auto!important}.flex-xl-0-1{flex:0 1 auto!important}.flex-xl-0-0{flex:0 0 auto!important}.flex-xl-1-1-100{flex:1 1 100%!important}.flex-xl-1-0-100{flex:1 0 100%!important}.flex-xl-0-1-100{flex:0 1 100%!important}.flex-xl-0-0-100{flex:0 0 100%!important}.flex-xl-row{flex-direction:row!important}.flex-xl-column{flex-direction:column!important}.flex-xl-row-reverse{flex-direction:row-reverse!important}.flex-xl-column-reverse{flex-direction:column-reverse!important}.flex-xl-grow-0{flex-grow:0!important}.flex-xl-grow-1{flex-grow:1!important}.flex-xl-shrink-0{flex-shrink:0!important}.flex-xl-shrink-1{flex-shrink:1!important}.flex-xl-wrap{flex-wrap:wrap!important}.flex-xl-nowrap{flex-wrap:nowrap!important}.flex-xl-wrap-reverse{flex-wrap:wrap-reverse!important}.justify-xl-start{justify-content:flex-start!important}.justify-xl-end{justify-content:flex-end!important}.justify-xl-center{justify-content:center!important}.justify-xl-space-between{justify-content:space-between!important}.justify-xl-space-around{justify-content:space-around!important}.justify-xl-space-evenly{justify-content:space-evenly!important}.align-xl-start{align-items:flex-start!important}.align-xl-end{align-items:flex-end!important}.align-xl-center{align-items:center!important}.align-xl-baseline{align-items:baseline!important}.align-xl-stretch{align-items:stretch!important}.align-content-xl-start{align-content:flex-start!important}.align-content-xl-end{align-content:flex-end!important}.align-content-xl-center{align-content:center!important}.align-content-xl-space-between{align-content:space-between!important}.align-content-xl-space-around{align-content:space-around!important}.align-content-xl-space-evenly{align-content:space-evenly!important}.align-content-xl-stretch{align-content:stretch!important}.align-self-xl-auto{align-self:auto!important}.align-self-xl-start{align-self:flex-start!important}.align-self-xl-end{align-self:flex-end!important}.align-self-xl-center{align-self:center!important}.align-self-xl-baseline{align-self:baseline!important}.align-self-xl-stretch{align-self:stretch!important}.order-xl-first{order:-1!important}.order-xl-0{order:0!important}.order-xl-1{order:1!important}.order-xl-2{order:2!important}.order-xl-3{order:3!important}.order-xl-4{order:4!important}.order-xl-5{order:5!important}.order-xl-6{order:6!important}.order-xl-7{order:7!important}.order-xl-8{order:8!important}.order-xl-9{order:9!important}.order-xl-10{order:10!important}.order-xl-11{order:11!important}.order-xl-12{order:12!important}.order-xl-last{order:13!important}.ga-xl-0{gap:0!important}.ga-xl-1{gap:4px!important}.ga-xl-2{gap:8px!important}.ga-xl-3{gap:12px!important}.ga-xl-4{gap:16px!important}.ga-xl-5{gap:20px!important}.ga-xl-6{gap:24px!important}.ga-xl-7{gap:28px!important}.ga-xl-8{gap:32px!important}.ga-xl-9{gap:36px!important}.ga-xl-10{gap:40px!important}.ga-xl-11{gap:44px!important}.ga-xl-12{gap:48px!important}.ga-xl-13{gap:52px!important}.ga-xl-14{gap:56px!important}.ga-xl-15{gap:60px!important}.ga-xl-16{gap:64px!important}.ga-xl-auto{gap:auto!important}.gr-xl-0{row-gap:0!important}.gr-xl-1{row-gap:4px!important}.gr-xl-2{row-gap:8px!important}.gr-xl-3{row-gap:12px!important}.gr-xl-4{row-gap:16px!important}.gr-xl-5{row-gap:20px!important}.gr-xl-6{row-gap:24px!important}.gr-xl-7{row-gap:28px!important}.gr-xl-8{row-gap:32px!important}.gr-xl-9{row-gap:36px!important}.gr-xl-10{row-gap:40px!important}.gr-xl-11{row-gap:44px!important}.gr-xl-12{row-gap:48px!important}.gr-xl-13{row-gap:52px!important}.gr-xl-14{row-gap:56px!important}.gr-xl-15{row-gap:60px!important}.gr-xl-16{row-gap:64px!important}.gr-xl-auto{row-gap:auto!important}.gc-xl-0{-moz-column-gap:0!important;column-gap:0!important}.gc-xl-1{-moz-column-gap:4px!important;column-gap:4px!important}.gc-xl-2{-moz-column-gap:8px!important;column-gap:8px!important}.gc-xl-3{-moz-column-gap:12px!important;column-gap:12px!important}.gc-xl-4{-moz-column-gap:16px!important;column-gap:16px!important}.gc-xl-5{-moz-column-gap:20px!important;column-gap:20px!important}.gc-xl-6{-moz-column-gap:24px!important;column-gap:24px!important}.gc-xl-7{-moz-column-gap:28px!important;column-gap:28px!important}.gc-xl-8{-moz-column-gap:32px!important;column-gap:32px!important}.gc-xl-9{-moz-column-gap:36px!important;column-gap:36px!important}.gc-xl-10{-moz-column-gap:40px!important;column-gap:40px!important}.gc-xl-11{-moz-column-gap:44px!important;column-gap:44px!important}.gc-xl-12{-moz-column-gap:48px!important;column-gap:48px!important}.gc-xl-13{-moz-column-gap:52px!important;column-gap:52px!important}.gc-xl-14{-moz-column-gap:56px!important;column-gap:56px!important}.gc-xl-15{-moz-column-gap:60px!important;column-gap:60px!important}.gc-xl-16{-moz-column-gap:64px!important;column-gap:64px!important}.gc-xl-auto{-moz-column-gap:auto!important;column-gap:auto!important}.ma-xl-0{margin:0!important}.ma-xl-1{margin:4px!important}.ma-xl-2{margin:8px!important}.ma-xl-3{margin:12px!important}.ma-xl-4{margin:16px!important}.ma-xl-5{margin:20px!important}.ma-xl-6{margin:24px!important}.ma-xl-7{margin:28px!important}.ma-xl-8{margin:32px!important}.ma-xl-9{margin:36px!important}.ma-xl-10{margin:40px!important}.ma-xl-11{margin:44px!important}.ma-xl-12{margin:48px!important}.ma-xl-13{margin:52px!important}.ma-xl-14{margin:56px!important}.ma-xl-15{margin:60px!important}.ma-xl-16{margin:64px!important}.ma-xl-auto{margin:auto!important}.mx-xl-0{margin-left:0!important;margin-right:0!important}.mx-xl-1{margin-left:4px!important;margin-right:4px!important}.mx-xl-2{margin-left:8px!important;margin-right:8px!important}.mx-xl-3{margin-left:12px!important;margin-right:12px!important}.mx-xl-4{margin-left:16px!important;margin-right:16px!important}.mx-xl-5{margin-left:20px!important;margin-right:20px!important}.mx-xl-6{margin-left:24px!important;margin-right:24px!important}.mx-xl-7{margin-left:28px!important;margin-right:28px!important}.mx-xl-8{margin-left:32px!important;margin-right:32px!important}.mx-xl-9{margin-left:36px!important;margin-right:36px!important}.mx-xl-10{margin-left:40px!important;margin-right:40px!important}.mx-xl-11{margin-left:44px!important;margin-right:44px!important}.mx-xl-12{margin-left:48px!important;margin-right:48px!important}.mx-xl-13{margin-left:52px!important;margin-right:52px!important}.mx-xl-14{margin-left:56px!important;margin-right:56px!important}.mx-xl-15{margin-left:60px!important;margin-right:60px!important}.mx-xl-16{margin-left:64px!important;margin-right:64px!important}.mx-xl-auto{margin-left:auto!important;margin-right:auto!important}.my-xl-0{margin-bottom:0!important;margin-top:0!important}.my-xl-1{margin-bottom:4px!important;margin-top:4px!important}.my-xl-2{margin-bottom:8px!important;margin-top:8px!important}.my-xl-3{margin-bottom:12px!important;margin-top:12px!important}.my-xl-4{margin-bottom:16px!important;margin-top:16px!important}.my-xl-5{margin-bottom:20px!important;margin-top:20px!important}.my-xl-6{margin-bottom:24px!important;margin-top:24px!important}.my-xl-7{margin-bottom:28px!important;margin-top:28px!important}.my-xl-8{margin-bottom:32px!important;margin-top:32px!important}.my-xl-9{margin-bottom:36px!important;margin-top:36px!important}.my-xl-10{margin-bottom:40px!important;margin-top:40px!important}.my-xl-11{margin-bottom:44px!important;margin-top:44px!important}.my-xl-12{margin-bottom:48px!important;margin-top:48px!important}.my-xl-13{margin-bottom:52px!important;margin-top:52px!important}.my-xl-14{margin-bottom:56px!important;margin-top:56px!important}.my-xl-15{margin-bottom:60px!important;margin-top:60px!important}.my-xl-16{margin-bottom:64px!important;margin-top:64px!important}.my-xl-auto{margin-bottom:auto!important;margin-top:auto!important}.mt-xl-0{margin-top:0!important}.mt-xl-1{margin-top:4px!important}.mt-xl-2{margin-top:8px!important}.mt-xl-3{margin-top:12px!important}.mt-xl-4{margin-top:16px!important}.mt-xl-5{margin-top:20px!important}.mt-xl-6{margin-top:24px!important}.mt-xl-7{margin-top:28px!important}.mt-xl-8{margin-top:32px!important}.mt-xl-9{margin-top:36px!important}.mt-xl-10{margin-top:40px!important}.mt-xl-11{margin-top:44px!important}.mt-xl-12{margin-top:48px!important}.mt-xl-13{margin-top:52px!important}.mt-xl-14{margin-top:56px!important}.mt-xl-15{margin-top:60px!important}.mt-xl-16{margin-top:64px!important}.mt-xl-auto{margin-top:auto!important}.mr-xl-0{margin-right:0!important}.mr-xl-1{margin-right:4px!important}.mr-xl-2{margin-right:8px!important}.mr-xl-3{margin-right:12px!important}.mr-xl-4{margin-right:16px!important}.mr-xl-5{margin-right:20px!important}.mr-xl-6{margin-right:24px!important}.mr-xl-7{margin-right:28px!important}.mr-xl-8{margin-right:32px!important}.mr-xl-9{margin-right:36px!important}.mr-xl-10{margin-right:40px!important}.mr-xl-11{margin-right:44px!important}.mr-xl-12{margin-right:48px!important}.mr-xl-13{margin-right:52px!important}.mr-xl-14{margin-right:56px!important}.mr-xl-15{margin-right:60px!important}.mr-xl-16{margin-right:64px!important}.mr-xl-auto{margin-right:auto!important}.mb-xl-0{margin-bottom:0!important}.mb-xl-1{margin-bottom:4px!important}.mb-xl-2{margin-bottom:8px!important}.mb-xl-3{margin-bottom:12px!important}.mb-xl-4{margin-bottom:16px!important}.mb-xl-5{margin-bottom:20px!important}.mb-xl-6{margin-bottom:24px!important}.mb-xl-7{margin-bottom:28px!important}.mb-xl-8{margin-bottom:32px!important}.mb-xl-9{margin-bottom:36px!important}.mb-xl-10{margin-bottom:40px!important}.mb-xl-11{margin-bottom:44px!important}.mb-xl-12{margin-bottom:48px!important}.mb-xl-13{margin-bottom:52px!important}.mb-xl-14{margin-bottom:56px!important}.mb-xl-15{margin-bottom:60px!important}.mb-xl-16{margin-bottom:64px!important}.mb-xl-auto{margin-bottom:auto!important}.ml-xl-0{margin-left:0!important}.ml-xl-1{margin-left:4px!important}.ml-xl-2{margin-left:8px!important}.ml-xl-3{margin-left:12px!important}.ml-xl-4{margin-left:16px!important}.ml-xl-5{margin-left:20px!important}.ml-xl-6{margin-left:24px!important}.ml-xl-7{margin-left:28px!important}.ml-xl-8{margin-left:32px!important}.ml-xl-9{margin-left:36px!important}.ml-xl-10{margin-left:40px!important}.ml-xl-11{margin-left:44px!important}.ml-xl-12{margin-left:48px!important}.ml-xl-13{margin-left:52px!important}.ml-xl-14{margin-left:56px!important}.ml-xl-15{margin-left:60px!important}.ml-xl-16{margin-left:64px!important}.ml-xl-auto{margin-left:auto!important}.ms-xl-0{margin-inline-start:0!important}.ms-xl-1{margin-inline-start:4px!important}.ms-xl-2{margin-inline-start:8px!important}.ms-xl-3{margin-inline-start:12px!important}.ms-xl-4{margin-inline-start:16px!important}.ms-xl-5{margin-inline-start:20px!important}.ms-xl-6{margin-inline-start:24px!important}.ms-xl-7{margin-inline-start:28px!important}.ms-xl-8{margin-inline-start:32px!important}.ms-xl-9{margin-inline-start:36px!important}.ms-xl-10{margin-inline-start:40px!important}.ms-xl-11{margin-inline-start:44px!important}.ms-xl-12{margin-inline-start:48px!important}.ms-xl-13{margin-inline-start:52px!important}.ms-xl-14{margin-inline-start:56px!important}.ms-xl-15{margin-inline-start:60px!important}.ms-xl-16{margin-inline-start:64px!important}.ms-xl-auto{margin-inline-start:auto!important}.me-xl-0{margin-inline-end:0!important}.me-xl-1{margin-inline-end:4px!important}.me-xl-2{margin-inline-end:8px!important}.me-xl-3{margin-inline-end:12px!important}.me-xl-4{margin-inline-end:16px!important}.me-xl-5{margin-inline-end:20px!important}.me-xl-6{margin-inline-end:24px!important}.me-xl-7{margin-inline-end:28px!important}.me-xl-8{margin-inline-end:32px!important}.me-xl-9{margin-inline-end:36px!important}.me-xl-10{margin-inline-end:40px!important}.me-xl-11{margin-inline-end:44px!important}.me-xl-12{margin-inline-end:48px!important}.me-xl-13{margin-inline-end:52px!important}.me-xl-14{margin-inline-end:56px!important}.me-xl-15{margin-inline-end:60px!important}.me-xl-16{margin-inline-end:64px!important}.me-xl-auto{margin-inline-end:auto!important}.ma-xl-n1{margin:-4px!important}.ma-xl-n2{margin:-8px!important}.ma-xl-n3{margin:-12px!important}.ma-xl-n4{margin:-16px!important}.ma-xl-n5{margin:-20px!important}.ma-xl-n6{margin:-24px!important}.ma-xl-n7{margin:-28px!important}.ma-xl-n8{margin:-32px!important}.ma-xl-n9{margin:-36px!important}.ma-xl-n10{margin:-40px!important}.ma-xl-n11{margin:-44px!important}.ma-xl-n12{margin:-48px!important}.ma-xl-n13{margin:-52px!important}.ma-xl-n14{margin:-56px!important}.ma-xl-n15{margin:-60px!important}.ma-xl-n16{margin:-64px!important}.mx-xl-n1{margin-left:-4px!important;margin-right:-4px!important}.mx-xl-n2{margin-left:-8px!important;margin-right:-8px!important}.mx-xl-n3{margin-left:-12px!important;margin-right:-12px!important}.mx-xl-n4{margin-left:-16px!important;margin-right:-16px!important}.mx-xl-n5{margin-left:-20px!important;margin-right:-20px!important}.mx-xl-n6{margin-left:-24px!important;margin-right:-24px!important}.mx-xl-n7{margin-left:-28px!important;margin-right:-28px!important}.mx-xl-n8{margin-left:-32px!important;margin-right:-32px!important}.mx-xl-n9{margin-left:-36px!important;margin-right:-36px!important}.mx-xl-n10{margin-left:-40px!important;margin-right:-40px!important}.mx-xl-n11{margin-left:-44px!important;margin-right:-44px!important}.mx-xl-n12{margin-left:-48px!important;margin-right:-48px!important}.mx-xl-n13{margin-left:-52px!important;margin-right:-52px!important}.mx-xl-n14{margin-left:-56px!important;margin-right:-56px!important}.mx-xl-n15{margin-left:-60px!important;margin-right:-60px!important}.mx-xl-n16{margin-left:-64px!important;margin-right:-64px!important}.my-xl-n1{margin-bottom:-4px!important;margin-top:-4px!important}.my-xl-n2{margin-bottom:-8px!important;margin-top:-8px!important}.my-xl-n3{margin-bottom:-12px!important;margin-top:-12px!important}.my-xl-n4{margin-bottom:-16px!important;margin-top:-16px!important}.my-xl-n5{margin-bottom:-20px!important;margin-top:-20px!important}.my-xl-n6{margin-bottom:-24px!important;margin-top:-24px!important}.my-xl-n7{margin-bottom:-28px!important;margin-top:-28px!important}.my-xl-n8{margin-bottom:-32px!important;margin-top:-32px!important}.my-xl-n9{margin-bottom:-36px!important;margin-top:-36px!important}.my-xl-n10{margin-bottom:-40px!important;margin-top:-40px!important}.my-xl-n11{margin-bottom:-44px!important;margin-top:-44px!important}.my-xl-n12{margin-bottom:-48px!important;margin-top:-48px!important}.my-xl-n13{margin-bottom:-52px!important;margin-top:-52px!important}.my-xl-n14{margin-bottom:-56px!important;margin-top:-56px!important}.my-xl-n15{margin-bottom:-60px!important;margin-top:-60px!important}.my-xl-n16{margin-bottom:-64px!important;margin-top:-64px!important}.mt-xl-n1{margin-top:-4px!important}.mt-xl-n2{margin-top:-8px!important}.mt-xl-n3{margin-top:-12px!important}.mt-xl-n4{margin-top:-16px!important}.mt-xl-n5{margin-top:-20px!important}.mt-xl-n6{margin-top:-24px!important}.mt-xl-n7{margin-top:-28px!important}.mt-xl-n8{margin-top:-32px!important}.mt-xl-n9{margin-top:-36px!important}.mt-xl-n10{margin-top:-40px!important}.mt-xl-n11{margin-top:-44px!important}.mt-xl-n12{margin-top:-48px!important}.mt-xl-n13{margin-top:-52px!important}.mt-xl-n14{margin-top:-56px!important}.mt-xl-n15{margin-top:-60px!important}.mt-xl-n16{margin-top:-64px!important}.mr-xl-n1{margin-right:-4px!important}.mr-xl-n2{margin-right:-8px!important}.mr-xl-n3{margin-right:-12px!important}.mr-xl-n4{margin-right:-16px!important}.mr-xl-n5{margin-right:-20px!important}.mr-xl-n6{margin-right:-24px!important}.mr-xl-n7{margin-right:-28px!important}.mr-xl-n8{margin-right:-32px!important}.mr-xl-n9{margin-right:-36px!important}.mr-xl-n10{margin-right:-40px!important}.mr-xl-n11{margin-right:-44px!important}.mr-xl-n12{margin-right:-48px!important}.mr-xl-n13{margin-right:-52px!important}.mr-xl-n14{margin-right:-56px!important}.mr-xl-n15{margin-right:-60px!important}.mr-xl-n16{margin-right:-64px!important}.mb-xl-n1{margin-bottom:-4px!important}.mb-xl-n2{margin-bottom:-8px!important}.mb-xl-n3{margin-bottom:-12px!important}.mb-xl-n4{margin-bottom:-16px!important}.mb-xl-n5{margin-bottom:-20px!important}.mb-xl-n6{margin-bottom:-24px!important}.mb-xl-n7{margin-bottom:-28px!important}.mb-xl-n8{margin-bottom:-32px!important}.mb-xl-n9{margin-bottom:-36px!important}.mb-xl-n10{margin-bottom:-40px!important}.mb-xl-n11{margin-bottom:-44px!important}.mb-xl-n12{margin-bottom:-48px!important}.mb-xl-n13{margin-bottom:-52px!important}.mb-xl-n14{margin-bottom:-56px!important}.mb-xl-n15{margin-bottom:-60px!important}.mb-xl-n16{margin-bottom:-64px!important}.ml-xl-n1{margin-left:-4px!important}.ml-xl-n2{margin-left:-8px!important}.ml-xl-n3{margin-left:-12px!important}.ml-xl-n4{margin-left:-16px!important}.ml-xl-n5{margin-left:-20px!important}.ml-xl-n6{margin-left:-24px!important}.ml-xl-n7{margin-left:-28px!important}.ml-xl-n8{margin-left:-32px!important}.ml-xl-n9{margin-left:-36px!important}.ml-xl-n10{margin-left:-40px!important}.ml-xl-n11{margin-left:-44px!important}.ml-xl-n12{margin-left:-48px!important}.ml-xl-n13{margin-left:-52px!important}.ml-xl-n14{margin-left:-56px!important}.ml-xl-n15{margin-left:-60px!important}.ml-xl-n16{margin-left:-64px!important}.ms-xl-n1{margin-inline-start:-4px!important}.ms-xl-n2{margin-inline-start:-8px!important}.ms-xl-n3{margin-inline-start:-12px!important}.ms-xl-n4{margin-inline-start:-16px!important}.ms-xl-n5{margin-inline-start:-20px!important}.ms-xl-n6{margin-inline-start:-24px!important}.ms-xl-n7{margin-inline-start:-28px!important}.ms-xl-n8{margin-inline-start:-32px!important}.ms-xl-n9{margin-inline-start:-36px!important}.ms-xl-n10{margin-inline-start:-40px!important}.ms-xl-n11{margin-inline-start:-44px!important}.ms-xl-n12{margin-inline-start:-48px!important}.ms-xl-n13{margin-inline-start:-52px!important}.ms-xl-n14{margin-inline-start:-56px!important}.ms-xl-n15{margin-inline-start:-60px!important}.ms-xl-n16{margin-inline-start:-64px!important}.me-xl-n1{margin-inline-end:-4px!important}.me-xl-n2{margin-inline-end:-8px!important}.me-xl-n3{margin-inline-end:-12px!important}.me-xl-n4{margin-inline-end:-16px!important}.me-xl-n5{margin-inline-end:-20px!important}.me-xl-n6{margin-inline-end:-24px!important}.me-xl-n7{margin-inline-end:-28px!important}.me-xl-n8{margin-inline-end:-32px!important}.me-xl-n9{margin-inline-end:-36px!important}.me-xl-n10{margin-inline-end:-40px!important}.me-xl-n11{margin-inline-end:-44px!important}.me-xl-n12{margin-inline-end:-48px!important}.me-xl-n13{margin-inline-end:-52px!important}.me-xl-n14{margin-inline-end:-56px!important}.me-xl-n15{margin-inline-end:-60px!important}.me-xl-n16{margin-inline-end:-64px!important}.pa-xl-0{padding:0!important}.pa-xl-1{padding:4px!important}.pa-xl-2{padding:8px!important}.pa-xl-3{padding:12px!important}.pa-xl-4{padding:16px!important}.pa-xl-5{padding:20px!important}.pa-xl-6{padding:24px!important}.pa-xl-7{padding:28px!important}.pa-xl-8{padding:32px!important}.pa-xl-9{padding:36px!important}.pa-xl-10{padding:40px!important}.pa-xl-11{padding:44px!important}.pa-xl-12{padding:48px!important}.pa-xl-13{padding:52px!important}.pa-xl-14{padding:56px!important}.pa-xl-15{padding:60px!important}.pa-xl-16{padding:64px!important}.px-xl-0{padding-left:0!important;padding-right:0!important}.px-xl-1{padding-left:4px!important;padding-right:4px!important}.px-xl-2{padding-left:8px!important;padding-right:8px!important}.px-xl-3{padding-left:12px!important;padding-right:12px!important}.px-xl-4{padding-left:16px!important;padding-right:16px!important}.px-xl-5{padding-left:20px!important;padding-right:20px!important}.px-xl-6{padding-left:24px!important;padding-right:24px!important}.px-xl-7{padding-left:28px!important;padding-right:28px!important}.px-xl-8{padding-left:32px!important;padding-right:32px!important}.px-xl-9{padding-left:36px!important;padding-right:36px!important}.px-xl-10{padding-left:40px!important;padding-right:40px!important}.px-xl-11{padding-left:44px!important;padding-right:44px!important}.px-xl-12{padding-left:48px!important;padding-right:48px!important}.px-xl-13{padding-left:52px!important;padding-right:52px!important}.px-xl-14{padding-left:56px!important;padding-right:56px!important}.px-xl-15{padding-left:60px!important;padding-right:60px!important}.px-xl-16{padding-left:64px!important;padding-right:64px!important}.py-xl-0{padding-bottom:0!important;padding-top:0!important}.py-xl-1{padding-bottom:4px!important;padding-top:4px!important}.py-xl-2{padding-bottom:8px!important;padding-top:8px!important}.py-xl-3{padding-bottom:12px!important;padding-top:12px!important}.py-xl-4{padding-bottom:16px!important;padding-top:16px!important}.py-xl-5{padding-bottom:20px!important;padding-top:20px!important}.py-xl-6{padding-bottom:24px!important;padding-top:24px!important}.py-xl-7{padding-bottom:28px!important;padding-top:28px!important}.py-xl-8{padding-bottom:32px!important;padding-top:32px!important}.py-xl-9{padding-bottom:36px!important;padding-top:36px!important}.py-xl-10{padding-bottom:40px!important;padding-top:40px!important}.py-xl-11{padding-bottom:44px!important;padding-top:44px!important}.py-xl-12{padding-bottom:48px!important;padding-top:48px!important}.py-xl-13{padding-bottom:52px!important;padding-top:52px!important}.py-xl-14{padding-bottom:56px!important;padding-top:56px!important}.py-xl-15{padding-bottom:60px!important;padding-top:60px!important}.py-xl-16{padding-bottom:64px!important;padding-top:64px!important}.pt-xl-0{padding-top:0!important}.pt-xl-1{padding-top:4px!important}.pt-xl-2{padding-top:8px!important}.pt-xl-3{padding-top:12px!important}.pt-xl-4{padding-top:16px!important}.pt-xl-5{padding-top:20px!important}.pt-xl-6{padding-top:24px!important}.pt-xl-7{padding-top:28px!important}.pt-xl-8{padding-top:32px!important}.pt-xl-9{padding-top:36px!important}.pt-xl-10{padding-top:40px!important}.pt-xl-11{padding-top:44px!important}.pt-xl-12{padding-top:48px!important}.pt-xl-13{padding-top:52px!important}.pt-xl-14{padding-top:56px!important}.pt-xl-15{padding-top:60px!important}.pt-xl-16{padding-top:64px!important}.pr-xl-0{padding-right:0!important}.pr-xl-1{padding-right:4px!important}.pr-xl-2{padding-right:8px!important}.pr-xl-3{padding-right:12px!important}.pr-xl-4{padding-right:16px!important}.pr-xl-5{padding-right:20px!important}.pr-xl-6{padding-right:24px!important}.pr-xl-7{padding-right:28px!important}.pr-xl-8{padding-right:32px!important}.pr-xl-9{padding-right:36px!important}.pr-xl-10{padding-right:40px!important}.pr-xl-11{padding-right:44px!important}.pr-xl-12{padding-right:48px!important}.pr-xl-13{padding-right:52px!important}.pr-xl-14{padding-right:56px!important}.pr-xl-15{padding-right:60px!important}.pr-xl-16{padding-right:64px!important}.pb-xl-0{padding-bottom:0!important}.pb-xl-1{padding-bottom:4px!important}.pb-xl-2{padding-bottom:8px!important}.pb-xl-3{padding-bottom:12px!important}.pb-xl-4{padding-bottom:16px!important}.pb-xl-5{padding-bottom:20px!important}.pb-xl-6{padding-bottom:24px!important}.pb-xl-7{padding-bottom:28px!important}.pb-xl-8{padding-bottom:32px!important}.pb-xl-9{padding-bottom:36px!important}.pb-xl-10{padding-bottom:40px!important}.pb-xl-11{padding-bottom:44px!important}.pb-xl-12{padding-bottom:48px!important}.pb-xl-13{padding-bottom:52px!important}.pb-xl-14{padding-bottom:56px!important}.pb-xl-15{padding-bottom:60px!important}.pb-xl-16{padding-bottom:64px!important}.pl-xl-0{padding-left:0!important}.pl-xl-1{padding-left:4px!important}.pl-xl-2{padding-left:8px!important}.pl-xl-3{padding-left:12px!important}.pl-xl-4{padding-left:16px!important}.pl-xl-5{padding-left:20px!important}.pl-xl-6{padding-left:24px!important}.pl-xl-7{padding-left:28px!important}.pl-xl-8{padding-left:32px!important}.pl-xl-9{padding-left:36px!important}.pl-xl-10{padding-left:40px!important}.pl-xl-11{padding-left:44px!important}.pl-xl-12{padding-left:48px!important}.pl-xl-13{padding-left:52px!important}.pl-xl-14{padding-left:56px!important}.pl-xl-15{padding-left:60px!important}.pl-xl-16{padding-left:64px!important}.ps-xl-0{padding-inline-start:0!important}.ps-xl-1{padding-inline-start:4px!important}.ps-xl-2{padding-inline-start:8px!important}.ps-xl-3{padding-inline-start:12px!important}.ps-xl-4{padding-inline-start:16px!important}.ps-xl-5{padding-inline-start:20px!important}.ps-xl-6{padding-inline-start:24px!important}.ps-xl-7{padding-inline-start:28px!important}.ps-xl-8{padding-inline-start:32px!important}.ps-xl-9{padding-inline-start:36px!important}.ps-xl-10{padding-inline-start:40px!important}.ps-xl-11{padding-inline-start:44px!important}.ps-xl-12{padding-inline-start:48px!important}.ps-xl-13{padding-inline-start:52px!important}.ps-xl-14{padding-inline-start:56px!important}.ps-xl-15{padding-inline-start:60px!important}.ps-xl-16{padding-inline-start:64px!important}.pe-xl-0{padding-inline-end:0!important}.pe-xl-1{padding-inline-end:4px!important}.pe-xl-2{padding-inline-end:8px!important}.pe-xl-3{padding-inline-end:12px!important}.pe-xl-4{padding-inline-end:16px!important}.pe-xl-5{padding-inline-end:20px!important}.pe-xl-6{padding-inline-end:24px!important}.pe-xl-7{padding-inline-end:28px!important}.pe-xl-8{padding-inline-end:32px!important}.pe-xl-9{padding-inline-end:36px!important}.pe-xl-10{padding-inline-end:40px!important}.pe-xl-11{padding-inline-end:44px!important}.pe-xl-12{padding-inline-end:48px!important}.pe-xl-13{padding-inline-end:52px!important}.pe-xl-14{padding-inline-end:56px!important}.pe-xl-15{padding-inline-end:60px!important}.pe-xl-16{padding-inline-end:64px!important}.text-xl-left{text-align:left!important}.text-xl-right{text-align:right!important}.text-xl-center{text-align:center!important}.text-xl-justify{text-align:justify!important}.text-xl-start{text-align:start!important}.text-xl-end{text-align:end!important}.text-xl-h1{font-size:6rem!important;letter-spacing:-.015625em!important;line-height:6rem}.text-xl-h1,.text-xl-h2{font-family:Roboto,sans-serif!important;font-weight:300;text-transform:none!important}.text-xl-h2{font-size:3.75rem!important;letter-spacing:-.0083333333em!important;line-height:3.75rem}.text-xl-h3{font-size:3rem!important;letter-spacing:normal!important;line-height:3.125rem}.text-xl-h3,.text-xl-h4{font-family:Roboto,sans-serif!important;font-weight:400;text-transform:none!important}.text-xl-h4{font-size:2.125rem!important;letter-spacing:.0073529412em!important;line-height:2.5rem}.text-xl-h5{font-size:1.5rem!important;font-weight:400;letter-spacing:normal!important}.text-xl-h5,.text-xl-h6{font-family:Roboto,sans-serif!important;line-height:2rem;text-transform:none!important}.text-xl-h6{font-size:1.25rem!important;font-weight:500;letter-spacing:.0125em!important}.text-xl-subtitle-1{font-size:1rem!important;font-weight:400;letter-spacing:.009375em!important;line-height:1.75rem}.text-xl-subtitle-1,.text-xl-subtitle-2{font-family:Roboto,sans-serif!important;text-transform:none!important}.text-xl-subtitle-2{font-size:.875rem!important;font-weight:500;letter-spacing:.0071428571em!important;line-height:1.375rem}.text-xl-body-1{font-size:1rem!important;letter-spacing:.03125em!important;line-height:1.5rem}.text-xl-body-1,.text-xl-body-2{font-family:Roboto,sans-serif!important;font-weight:400;text-transform:none!important}.text-xl-body-2{font-size:.875rem!important;letter-spacing:.0178571429em!important;line-height:1.25rem}.text-xl-button{font-family:Roboto,sans-serif!important;font-size:.875rem!important;font-weight:500;letter-spacing:.0892857143em!important;line-height:2.25rem;text-transform:uppercase!important}.text-xl-caption{font-weight:400;letter-spacing:.0333333333em!important;line-height:1.25rem;text-transform:none!important}.text-xl-caption,.text-xl-overline{font-family:Roboto,sans-serif!important;font-size:.75rem!important}.text-xl-overline{font-weight:500;letter-spacing:.1666666667em!important;line-height:2rem;text-transform:uppercase!important}}@media (min-width:2560px){.d-xxl-none{display:none!important}.d-xxl-inline{display:inline!important}.d-xxl-inline-block{display:inline-block!important}.d-xxl-block{display:block!important}.d-xxl-table{display:table!important}.d-xxl-table-row{display:table-row!important}.d-xxl-table-cell{display:table-cell!important}.d-xxl-flex{display:flex!important}.d-xxl-inline-flex{display:inline-flex!important}.float-xxl-none{float:none!important}.float-xxl-left{float:left!important}.float-xxl-right{float:right!important}.v-locale--is-rtl .float-xxl-end{float:left!important}.v-locale--is-ltr .float-xxl-end,.v-locale--is-rtl .float-xxl-start{float:right!important}.v-locale--is-ltr .float-xxl-start{float:left!important}.flex-xxl-1-1,.flex-xxl-fill{flex:1 1 auto!important}.flex-xxl-1-0{flex:1 0 auto!important}.flex-xxl-0-1{flex:0 1 auto!important}.flex-xxl-0-0{flex:0 0 auto!important}.flex-xxl-1-1-100{flex:1 1 100%!important}.flex-xxl-1-0-100{flex:1 0 100%!important}.flex-xxl-0-1-100{flex:0 1 100%!important}.flex-xxl-0-0-100{flex:0 0 100%!important}.flex-xxl-row{flex-direction:row!important}.flex-xxl-column{flex-direction:column!important}.flex-xxl-row-reverse{flex-direction:row-reverse!important}.flex-xxl-column-reverse{flex-direction:column-reverse!important}.flex-xxl-grow-0{flex-grow:0!important}.flex-xxl-grow-1{flex-grow:1!important}.flex-xxl-shrink-0{flex-shrink:0!important}.flex-xxl-shrink-1{flex-shrink:1!important}.flex-xxl-wrap{flex-wrap:wrap!important}.flex-xxl-nowrap{flex-wrap:nowrap!important}.flex-xxl-wrap-reverse{flex-wrap:wrap-reverse!important}.justify-xxl-start{justify-content:flex-start!important}.justify-xxl-end{justify-content:flex-end!important}.justify-xxl-center{justify-content:center!important}.justify-xxl-space-between{justify-content:space-between!important}.justify-xxl-space-around{justify-content:space-around!important}.justify-xxl-space-evenly{justify-content:space-evenly!important}.align-xxl-start{align-items:flex-start!important}.align-xxl-end{align-items:flex-end!important}.align-xxl-center{align-items:center!important}.align-xxl-baseline{align-items:baseline!important}.align-xxl-stretch{align-items:stretch!important}.align-content-xxl-start{align-content:flex-start!important}.align-content-xxl-end{align-content:flex-end!important}.align-content-xxl-center{align-content:center!important}.align-content-xxl-space-between{align-content:space-between!important}.align-content-xxl-space-around{align-content:space-around!important}.align-content-xxl-space-evenly{align-content:space-evenly!important}.align-content-xxl-stretch{align-content:stretch!important}.align-self-xxl-auto{align-self:auto!important}.align-self-xxl-start{align-self:flex-start!important}.align-self-xxl-end{align-self:flex-end!important}.align-self-xxl-center{align-self:center!important}.align-self-xxl-baseline{align-self:baseline!important}.align-self-xxl-stretch{align-self:stretch!important}.order-xxl-first{order:-1!important}.order-xxl-0{order:0!important}.order-xxl-1{order:1!important}.order-xxl-2{order:2!important}.order-xxl-3{order:3!important}.order-xxl-4{order:4!important}.order-xxl-5{order:5!important}.order-xxl-6{order:6!important}.order-xxl-7{order:7!important}.order-xxl-8{order:8!important}.order-xxl-9{order:9!important}.order-xxl-10{order:10!important}.order-xxl-11{order:11!important}.order-xxl-12{order:12!important}.order-xxl-last{order:13!important}.ga-xxl-0{gap:0!important}.ga-xxl-1{gap:4px!important}.ga-xxl-2{gap:8px!important}.ga-xxl-3{gap:12px!important}.ga-xxl-4{gap:16px!important}.ga-xxl-5{gap:20px!important}.ga-xxl-6{gap:24px!important}.ga-xxl-7{gap:28px!important}.ga-xxl-8{gap:32px!important}.ga-xxl-9{gap:36px!important}.ga-xxl-10{gap:40px!important}.ga-xxl-11{gap:44px!important}.ga-xxl-12{gap:48px!important}.ga-xxl-13{gap:52px!important}.ga-xxl-14{gap:56px!important}.ga-xxl-15{gap:60px!important}.ga-xxl-16{gap:64px!important}.ga-xxl-auto{gap:auto!important}.gr-xxl-0{row-gap:0!important}.gr-xxl-1{row-gap:4px!important}.gr-xxl-2{row-gap:8px!important}.gr-xxl-3{row-gap:12px!important}.gr-xxl-4{row-gap:16px!important}.gr-xxl-5{row-gap:20px!important}.gr-xxl-6{row-gap:24px!important}.gr-xxl-7{row-gap:28px!important}.gr-xxl-8{row-gap:32px!important}.gr-xxl-9{row-gap:36px!important}.gr-xxl-10{row-gap:40px!important}.gr-xxl-11{row-gap:44px!important}.gr-xxl-12{row-gap:48px!important}.gr-xxl-13{row-gap:52px!important}.gr-xxl-14{row-gap:56px!important}.gr-xxl-15{row-gap:60px!important}.gr-xxl-16{row-gap:64px!important}.gr-xxl-auto{row-gap:auto!important}.gc-xxl-0{-moz-column-gap:0!important;column-gap:0!important}.gc-xxl-1{-moz-column-gap:4px!important;column-gap:4px!important}.gc-xxl-2{-moz-column-gap:8px!important;column-gap:8px!important}.gc-xxl-3{-moz-column-gap:12px!important;column-gap:12px!important}.gc-xxl-4{-moz-column-gap:16px!important;column-gap:16px!important}.gc-xxl-5{-moz-column-gap:20px!important;column-gap:20px!important}.gc-xxl-6{-moz-column-gap:24px!important;column-gap:24px!important}.gc-xxl-7{-moz-column-gap:28px!important;column-gap:28px!important}.gc-xxl-8{-moz-column-gap:32px!important;column-gap:32px!important}.gc-xxl-9{-moz-column-gap:36px!important;column-gap:36px!important}.gc-xxl-10{-moz-column-gap:40px!important;column-gap:40px!important}.gc-xxl-11{-moz-column-gap:44px!important;column-gap:44px!important}.gc-xxl-12{-moz-column-gap:48px!important;column-gap:48px!important}.gc-xxl-13{-moz-column-gap:52px!important;column-gap:52px!important}.gc-xxl-14{-moz-column-gap:56px!important;column-gap:56px!important}.gc-xxl-15{-moz-column-gap:60px!important;column-gap:60px!important}.gc-xxl-16{-moz-column-gap:64px!important;column-gap:64px!important}.gc-xxl-auto{-moz-column-gap:auto!important;column-gap:auto!important}.ma-xxl-0{margin:0!important}.ma-xxl-1{margin:4px!important}.ma-xxl-2{margin:8px!important}.ma-xxl-3{margin:12px!important}.ma-xxl-4{margin:16px!important}.ma-xxl-5{margin:20px!important}.ma-xxl-6{margin:24px!important}.ma-xxl-7{margin:28px!important}.ma-xxl-8{margin:32px!important}.ma-xxl-9{margin:36px!important}.ma-xxl-10{margin:40px!important}.ma-xxl-11{margin:44px!important}.ma-xxl-12{margin:48px!important}.ma-xxl-13{margin:52px!important}.ma-xxl-14{margin:56px!important}.ma-xxl-15{margin:60px!important}.ma-xxl-16{margin:64px!important}.ma-xxl-auto{margin:auto!important}.mx-xxl-0{margin-left:0!important;margin-right:0!important}.mx-xxl-1{margin-left:4px!important;margin-right:4px!important}.mx-xxl-2{margin-left:8px!important;margin-right:8px!important}.mx-xxl-3{margin-left:12px!important;margin-right:12px!important}.mx-xxl-4{margin-left:16px!important;margin-right:16px!important}.mx-xxl-5{margin-left:20px!important;margin-right:20px!important}.mx-xxl-6{margin-left:24px!important;margin-right:24px!important}.mx-xxl-7{margin-left:28px!important;margin-right:28px!important}.mx-xxl-8{margin-left:32px!important;margin-right:32px!important}.mx-xxl-9{margin-left:36px!important;margin-right:36px!important}.mx-xxl-10{margin-left:40px!important;margin-right:40px!important}.mx-xxl-11{margin-left:44px!important;margin-right:44px!important}.mx-xxl-12{margin-left:48px!important;margin-right:48px!important}.mx-xxl-13{margin-left:52px!important;margin-right:52px!important}.mx-xxl-14{margin-left:56px!important;margin-right:56px!important}.mx-xxl-15{margin-left:60px!important;margin-right:60px!important}.mx-xxl-16{margin-left:64px!important;margin-right:64px!important}.mx-xxl-auto{margin-left:auto!important;margin-right:auto!important}.my-xxl-0{margin-bottom:0!important;margin-top:0!important}.my-xxl-1{margin-bottom:4px!important;margin-top:4px!important}.my-xxl-2{margin-bottom:8px!important;margin-top:8px!important}.my-xxl-3{margin-bottom:12px!important;margin-top:12px!important}.my-xxl-4{margin-bottom:16px!important;margin-top:16px!important}.my-xxl-5{margin-bottom:20px!important;margin-top:20px!important}.my-xxl-6{margin-bottom:24px!important;margin-top:24px!important}.my-xxl-7{margin-bottom:28px!important;margin-top:28px!important}.my-xxl-8{margin-bottom:32px!important;margin-top:32px!important}.my-xxl-9{margin-bottom:36px!important;margin-top:36px!important}.my-xxl-10{margin-bottom:40px!important;margin-top:40px!important}.my-xxl-11{margin-bottom:44px!important;margin-top:44px!important}.my-xxl-12{margin-bottom:48px!important;margin-top:48px!important}.my-xxl-13{margin-bottom:52px!important;margin-top:52px!important}.my-xxl-14{margin-bottom:56px!important;margin-top:56px!important}.my-xxl-15{margin-bottom:60px!important;margin-top:60px!important}.my-xxl-16{margin-bottom:64px!important;margin-top:64px!important}.my-xxl-auto{margin-bottom:auto!important;margin-top:auto!important}.mt-xxl-0{margin-top:0!important}.mt-xxl-1{margin-top:4px!important}.mt-xxl-2{margin-top:8px!important}.mt-xxl-3{margin-top:12px!important}.mt-xxl-4{margin-top:16px!important}.mt-xxl-5{margin-top:20px!important}.mt-xxl-6{margin-top:24px!important}.mt-xxl-7{margin-top:28px!important}.mt-xxl-8{margin-top:32px!important}.mt-xxl-9{margin-top:36px!important}.mt-xxl-10{margin-top:40px!important}.mt-xxl-11{margin-top:44px!important}.mt-xxl-12{margin-top:48px!important}.mt-xxl-13{margin-top:52px!important}.mt-xxl-14{margin-top:56px!important}.mt-xxl-15{margin-top:60px!important}.mt-xxl-16{margin-top:64px!important}.mt-xxl-auto{margin-top:auto!important}.mr-xxl-0{margin-right:0!important}.mr-xxl-1{margin-right:4px!important}.mr-xxl-2{margin-right:8px!important}.mr-xxl-3{margin-right:12px!important}.mr-xxl-4{margin-right:16px!important}.mr-xxl-5{margin-right:20px!important}.mr-xxl-6{margin-right:24px!important}.mr-xxl-7{margin-right:28px!important}.mr-xxl-8{margin-right:32px!important}.mr-xxl-9{margin-right:36px!important}.mr-xxl-10{margin-right:40px!important}.mr-xxl-11{margin-right:44px!important}.mr-xxl-12{margin-right:48px!important}.mr-xxl-13{margin-right:52px!important}.mr-xxl-14{margin-right:56px!important}.mr-xxl-15{margin-right:60px!important}.mr-xxl-16{margin-right:64px!important}.mr-xxl-auto{margin-right:auto!important}.mb-xxl-0{margin-bottom:0!important}.mb-xxl-1{margin-bottom:4px!important}.mb-xxl-2{margin-bottom:8px!important}.mb-xxl-3{margin-bottom:12px!important}.mb-xxl-4{margin-bottom:16px!important}.mb-xxl-5{margin-bottom:20px!important}.mb-xxl-6{margin-bottom:24px!important}.mb-xxl-7{margin-bottom:28px!important}.mb-xxl-8{margin-bottom:32px!important}.mb-xxl-9{margin-bottom:36px!important}.mb-xxl-10{margin-bottom:40px!important}.mb-xxl-11{margin-bottom:44px!important}.mb-xxl-12{margin-bottom:48px!important}.mb-xxl-13{margin-bottom:52px!important}.mb-xxl-14{margin-bottom:56px!important}.mb-xxl-15{margin-bottom:60px!important}.mb-xxl-16{margin-bottom:64px!important}.mb-xxl-auto{margin-bottom:auto!important}.ml-xxl-0{margin-left:0!important}.ml-xxl-1{margin-left:4px!important}.ml-xxl-2{margin-left:8px!important}.ml-xxl-3{margin-left:12px!important}.ml-xxl-4{margin-left:16px!important}.ml-xxl-5{margin-left:20px!important}.ml-xxl-6{margin-left:24px!important}.ml-xxl-7{margin-left:28px!important}.ml-xxl-8{margin-left:32px!important}.ml-xxl-9{margin-left:36px!important}.ml-xxl-10{margin-left:40px!important}.ml-xxl-11{margin-left:44px!important}.ml-xxl-12{margin-left:48px!important}.ml-xxl-13{margin-left:52px!important}.ml-xxl-14{margin-left:56px!important}.ml-xxl-15{margin-left:60px!important}.ml-xxl-16{margin-left:64px!important}.ml-xxl-auto{margin-left:auto!important}.ms-xxl-0{margin-inline-start:0!important}.ms-xxl-1{margin-inline-start:4px!important}.ms-xxl-2{margin-inline-start:8px!important}.ms-xxl-3{margin-inline-start:12px!important}.ms-xxl-4{margin-inline-start:16px!important}.ms-xxl-5{margin-inline-start:20px!important}.ms-xxl-6{margin-inline-start:24px!important}.ms-xxl-7{margin-inline-start:28px!important}.ms-xxl-8{margin-inline-start:32px!important}.ms-xxl-9{margin-inline-start:36px!important}.ms-xxl-10{margin-inline-start:40px!important}.ms-xxl-11{margin-inline-start:44px!important}.ms-xxl-12{margin-inline-start:48px!important}.ms-xxl-13{margin-inline-start:52px!important}.ms-xxl-14{margin-inline-start:56px!important}.ms-xxl-15{margin-inline-start:60px!important}.ms-xxl-16{margin-inline-start:64px!important}.ms-xxl-auto{margin-inline-start:auto!important}.me-xxl-0{margin-inline-end:0!important}.me-xxl-1{margin-inline-end:4px!important}.me-xxl-2{margin-inline-end:8px!important}.me-xxl-3{margin-inline-end:12px!important}.me-xxl-4{margin-inline-end:16px!important}.me-xxl-5{margin-inline-end:20px!important}.me-xxl-6{margin-inline-end:24px!important}.me-xxl-7{margin-inline-end:28px!important}.me-xxl-8{margin-inline-end:32px!important}.me-xxl-9{margin-inline-end:36px!important}.me-xxl-10{margin-inline-end:40px!important}.me-xxl-11{margin-inline-end:44px!important}.me-xxl-12{margin-inline-end:48px!important}.me-xxl-13{margin-inline-end:52px!important}.me-xxl-14{margin-inline-end:56px!important}.me-xxl-15{margin-inline-end:60px!important}.me-xxl-16{margin-inline-end:64px!important}.me-xxl-auto{margin-inline-end:auto!important}.ma-xxl-n1{margin:-4px!important}.ma-xxl-n2{margin:-8px!important}.ma-xxl-n3{margin:-12px!important}.ma-xxl-n4{margin:-16px!important}.ma-xxl-n5{margin:-20px!important}.ma-xxl-n6{margin:-24px!important}.ma-xxl-n7{margin:-28px!important}.ma-xxl-n8{margin:-32px!important}.ma-xxl-n9{margin:-36px!important}.ma-xxl-n10{margin:-40px!important}.ma-xxl-n11{margin:-44px!important}.ma-xxl-n12{margin:-48px!important}.ma-xxl-n13{margin:-52px!important}.ma-xxl-n14{margin:-56px!important}.ma-xxl-n15{margin:-60px!important}.ma-xxl-n16{margin:-64px!important}.mx-xxl-n1{margin-left:-4px!important;margin-right:-4px!important}.mx-xxl-n2{margin-left:-8px!important;margin-right:-8px!important}.mx-xxl-n3{margin-left:-12px!important;margin-right:-12px!important}.mx-xxl-n4{margin-left:-16px!important;margin-right:-16px!important}.mx-xxl-n5{margin-left:-20px!important;margin-right:-20px!important}.mx-xxl-n6{margin-left:-24px!important;margin-right:-24px!important}.mx-xxl-n7{margin-left:-28px!important;margin-right:-28px!important}.mx-xxl-n8{margin-left:-32px!important;margin-right:-32px!important}.mx-xxl-n9{margin-left:-36px!important;margin-right:-36px!important}.mx-xxl-n10{margin-left:-40px!important;margin-right:-40px!important}.mx-xxl-n11{margin-left:-44px!important;margin-right:-44px!important}.mx-xxl-n12{margin-left:-48px!important;margin-right:-48px!important}.mx-xxl-n13{margin-left:-52px!important;margin-right:-52px!important}.mx-xxl-n14{margin-left:-56px!important;margin-right:-56px!important}.mx-xxl-n15{margin-left:-60px!important;margin-right:-60px!important}.mx-xxl-n16{margin-left:-64px!important;margin-right:-64px!important}.my-xxl-n1{margin-bottom:-4px!important;margin-top:-4px!important}.my-xxl-n2{margin-bottom:-8px!important;margin-top:-8px!important}.my-xxl-n3{margin-bottom:-12px!important;margin-top:-12px!important}.my-xxl-n4{margin-bottom:-16px!important;margin-top:-16px!important}.my-xxl-n5{margin-bottom:-20px!important;margin-top:-20px!important}.my-xxl-n6{margin-bottom:-24px!important;margin-top:-24px!important}.my-xxl-n7{margin-bottom:-28px!important;margin-top:-28px!important}.my-xxl-n8{margin-bottom:-32px!important;margin-top:-32px!important}.my-xxl-n9{margin-bottom:-36px!important;margin-top:-36px!important}.my-xxl-n10{margin-bottom:-40px!important;margin-top:-40px!important}.my-xxl-n11{margin-bottom:-44px!important;margin-top:-44px!important}.my-xxl-n12{margin-bottom:-48px!important;margin-top:-48px!important}.my-xxl-n13{margin-bottom:-52px!important;margin-top:-52px!important}.my-xxl-n14{margin-bottom:-56px!important;margin-top:-56px!important}.my-xxl-n15{margin-bottom:-60px!important;margin-top:-60px!important}.my-xxl-n16{margin-bottom:-64px!important;margin-top:-64px!important}.mt-xxl-n1{margin-top:-4px!important}.mt-xxl-n2{margin-top:-8px!important}.mt-xxl-n3{margin-top:-12px!important}.mt-xxl-n4{margin-top:-16px!important}.mt-xxl-n5{margin-top:-20px!important}.mt-xxl-n6{margin-top:-24px!important}.mt-xxl-n7{margin-top:-28px!important}.mt-xxl-n8{margin-top:-32px!important}.mt-xxl-n9{margin-top:-36px!important}.mt-xxl-n10{margin-top:-40px!important}.mt-xxl-n11{margin-top:-44px!important}.mt-xxl-n12{margin-top:-48px!important}.mt-xxl-n13{margin-top:-52px!important}.mt-xxl-n14{margin-top:-56px!important}.mt-xxl-n15{margin-top:-60px!important}.mt-xxl-n16{margin-top:-64px!important}.mr-xxl-n1{margin-right:-4px!important}.mr-xxl-n2{margin-right:-8px!important}.mr-xxl-n3{margin-right:-12px!important}.mr-xxl-n4{margin-right:-16px!important}.mr-xxl-n5{margin-right:-20px!important}.mr-xxl-n6{margin-right:-24px!important}.mr-xxl-n7{margin-right:-28px!important}.mr-xxl-n8{margin-right:-32px!important}.mr-xxl-n9{margin-right:-36px!important}.mr-xxl-n10{margin-right:-40px!important}.mr-xxl-n11{margin-right:-44px!important}.mr-xxl-n12{margin-right:-48px!important}.mr-xxl-n13{margin-right:-52px!important}.mr-xxl-n14{margin-right:-56px!important}.mr-xxl-n15{margin-right:-60px!important}.mr-xxl-n16{margin-right:-64px!important}.mb-xxl-n1{margin-bottom:-4px!important}.mb-xxl-n2{margin-bottom:-8px!important}.mb-xxl-n3{margin-bottom:-12px!important}.mb-xxl-n4{margin-bottom:-16px!important}.mb-xxl-n5{margin-bottom:-20px!important}.mb-xxl-n6{margin-bottom:-24px!important}.mb-xxl-n7{margin-bottom:-28px!important}.mb-xxl-n8{margin-bottom:-32px!important}.mb-xxl-n9{margin-bottom:-36px!important}.mb-xxl-n10{margin-bottom:-40px!important}.mb-xxl-n11{margin-bottom:-44px!important}.mb-xxl-n12{margin-bottom:-48px!important}.mb-xxl-n13{margin-bottom:-52px!important}.mb-xxl-n14{margin-bottom:-56px!important}.mb-xxl-n15{margin-bottom:-60px!important}.mb-xxl-n16{margin-bottom:-64px!important}.ml-xxl-n1{margin-left:-4px!important}.ml-xxl-n2{margin-left:-8px!important}.ml-xxl-n3{margin-left:-12px!important}.ml-xxl-n4{margin-left:-16px!important}.ml-xxl-n5{margin-left:-20px!important}.ml-xxl-n6{margin-left:-24px!important}.ml-xxl-n7{margin-left:-28px!important}.ml-xxl-n8{margin-left:-32px!important}.ml-xxl-n9{margin-left:-36px!important}.ml-xxl-n10{margin-left:-40px!important}.ml-xxl-n11{margin-left:-44px!important}.ml-xxl-n12{margin-left:-48px!important}.ml-xxl-n13{margin-left:-52px!important}.ml-xxl-n14{margin-left:-56px!important}.ml-xxl-n15{margin-left:-60px!important}.ml-xxl-n16{margin-left:-64px!important}.ms-xxl-n1{margin-inline-start:-4px!important}.ms-xxl-n2{margin-inline-start:-8px!important}.ms-xxl-n3{margin-inline-start:-12px!important}.ms-xxl-n4{margin-inline-start:-16px!important}.ms-xxl-n5{margin-inline-start:-20px!important}.ms-xxl-n6{margin-inline-start:-24px!important}.ms-xxl-n7{margin-inline-start:-28px!important}.ms-xxl-n8{margin-inline-start:-32px!important}.ms-xxl-n9{margin-inline-start:-36px!important}.ms-xxl-n10{margin-inline-start:-40px!important}.ms-xxl-n11{margin-inline-start:-44px!important}.ms-xxl-n12{margin-inline-start:-48px!important}.ms-xxl-n13{margin-inline-start:-52px!important}.ms-xxl-n14{margin-inline-start:-56px!important}.ms-xxl-n15{margin-inline-start:-60px!important}.ms-xxl-n16{margin-inline-start:-64px!important}.me-xxl-n1{margin-inline-end:-4px!important}.me-xxl-n2{margin-inline-end:-8px!important}.me-xxl-n3{margin-inline-end:-12px!important}.me-xxl-n4{margin-inline-end:-16px!important}.me-xxl-n5{margin-inline-end:-20px!important}.me-xxl-n6{margin-inline-end:-24px!important}.me-xxl-n7{margin-inline-end:-28px!important}.me-xxl-n8{margin-inline-end:-32px!important}.me-xxl-n9{margin-inline-end:-36px!important}.me-xxl-n10{margin-inline-end:-40px!important}.me-xxl-n11{margin-inline-end:-44px!important}.me-xxl-n12{margin-inline-end:-48px!important}.me-xxl-n13{margin-inline-end:-52px!important}.me-xxl-n14{margin-inline-end:-56px!important}.me-xxl-n15{margin-inline-end:-60px!important}.me-xxl-n16{margin-inline-end:-64px!important}.pa-xxl-0{padding:0!important}.pa-xxl-1{padding:4px!important}.pa-xxl-2{padding:8px!important}.pa-xxl-3{padding:12px!important}.pa-xxl-4{padding:16px!important}.pa-xxl-5{padding:20px!important}.pa-xxl-6{padding:24px!important}.pa-xxl-7{padding:28px!important}.pa-xxl-8{padding:32px!important}.pa-xxl-9{padding:36px!important}.pa-xxl-10{padding:40px!important}.pa-xxl-11{padding:44px!important}.pa-xxl-12{padding:48px!important}.pa-xxl-13{padding:52px!important}.pa-xxl-14{padding:56px!important}.pa-xxl-15{padding:60px!important}.pa-xxl-16{padding:64px!important}.px-xxl-0{padding-left:0!important;padding-right:0!important}.px-xxl-1{padding-left:4px!important;padding-right:4px!important}.px-xxl-2{padding-left:8px!important;padding-right:8px!important}.px-xxl-3{padding-left:12px!important;padding-right:12px!important}.px-xxl-4{padding-left:16px!important;padding-right:16px!important}.px-xxl-5{padding-left:20px!important;padding-right:20px!important}.px-xxl-6{padding-left:24px!important;padding-right:24px!important}.px-xxl-7{padding-left:28px!important;padding-right:28px!important}.px-xxl-8{padding-left:32px!important;padding-right:32px!important}.px-xxl-9{padding-left:36px!important;padding-right:36px!important}.px-xxl-10{padding-left:40px!important;padding-right:40px!important}.px-xxl-11{padding-left:44px!important;padding-right:44px!important}.px-xxl-12{padding-left:48px!important;padding-right:48px!important}.px-xxl-13{padding-left:52px!important;padding-right:52px!important}.px-xxl-14{padding-left:56px!important;padding-right:56px!important}.px-xxl-15{padding-left:60px!important;padding-right:60px!important}.px-xxl-16{padding-left:64px!important;padding-right:64px!important}.py-xxl-0{padding-bottom:0!important;padding-top:0!important}.py-xxl-1{padding-bottom:4px!important;padding-top:4px!important}.py-xxl-2{padding-bottom:8px!important;padding-top:8px!important}.py-xxl-3{padding-bottom:12px!important;padding-top:12px!important}.py-xxl-4{padding-bottom:16px!important;padding-top:16px!important}.py-xxl-5{padding-bottom:20px!important;padding-top:20px!important}.py-xxl-6{padding-bottom:24px!important;padding-top:24px!important}.py-xxl-7{padding-bottom:28px!important;padding-top:28px!important}.py-xxl-8{padding-bottom:32px!important;padding-top:32px!important}.py-xxl-9{padding-bottom:36px!important;padding-top:36px!important}.py-xxl-10{padding-bottom:40px!important;padding-top:40px!important}.py-xxl-11{padding-bottom:44px!important;padding-top:44px!important}.py-xxl-12{padding-bottom:48px!important;padding-top:48px!important}.py-xxl-13{padding-bottom:52px!important;padding-top:52px!important}.py-xxl-14{padding-bottom:56px!important;padding-top:56px!important}.py-xxl-15{padding-bottom:60px!important;padding-top:60px!important}.py-xxl-16{padding-bottom:64px!important;padding-top:64px!important}.pt-xxl-0{padding-top:0!important}.pt-xxl-1{padding-top:4px!important}.pt-xxl-2{padding-top:8px!important}.pt-xxl-3{padding-top:12px!important}.pt-xxl-4{padding-top:16px!important}.pt-xxl-5{padding-top:20px!important}.pt-xxl-6{padding-top:24px!important}.pt-xxl-7{padding-top:28px!important}.pt-xxl-8{padding-top:32px!important}.pt-xxl-9{padding-top:36px!important}.pt-xxl-10{padding-top:40px!important}.pt-xxl-11{padding-top:44px!important}.pt-xxl-12{padding-top:48px!important}.pt-xxl-13{padding-top:52px!important}.pt-xxl-14{padding-top:56px!important}.pt-xxl-15{padding-top:60px!important}.pt-xxl-16{padding-top:64px!important}.pr-xxl-0{padding-right:0!important}.pr-xxl-1{padding-right:4px!important}.pr-xxl-2{padding-right:8px!important}.pr-xxl-3{padding-right:12px!important}.pr-xxl-4{padding-right:16px!important}.pr-xxl-5{padding-right:20px!important}.pr-xxl-6{padding-right:24px!important}.pr-xxl-7{padding-right:28px!important}.pr-xxl-8{padding-right:32px!important}.pr-xxl-9{padding-right:36px!important}.pr-xxl-10{padding-right:40px!important}.pr-xxl-11{padding-right:44px!important}.pr-xxl-12{padding-right:48px!important}.pr-xxl-13{padding-right:52px!important}.pr-xxl-14{padding-right:56px!important}.pr-xxl-15{padding-right:60px!important}.pr-xxl-16{padding-right:64px!important}.pb-xxl-0{padding-bottom:0!important}.pb-xxl-1{padding-bottom:4px!important}.pb-xxl-2{padding-bottom:8px!important}.pb-xxl-3{padding-bottom:12px!important}.pb-xxl-4{padding-bottom:16px!important}.pb-xxl-5{padding-bottom:20px!important}.pb-xxl-6{padding-bottom:24px!important}.pb-xxl-7{padding-bottom:28px!important}.pb-xxl-8{padding-bottom:32px!important}.pb-xxl-9{padding-bottom:36px!important}.pb-xxl-10{padding-bottom:40px!important}.pb-xxl-11{padding-bottom:44px!important}.pb-xxl-12{padding-bottom:48px!important}.pb-xxl-13{padding-bottom:52px!important}.pb-xxl-14{padding-bottom:56px!important}.pb-xxl-15{padding-bottom:60px!important}.pb-xxl-16{padding-bottom:64px!important}.pl-xxl-0{padding-left:0!important}.pl-xxl-1{padding-left:4px!important}.pl-xxl-2{padding-left:8px!important}.pl-xxl-3{padding-left:12px!important}.pl-xxl-4{padding-left:16px!important}.pl-xxl-5{padding-left:20px!important}.pl-xxl-6{padding-left:24px!important}.pl-xxl-7{padding-left:28px!important}.pl-xxl-8{padding-left:32px!important}.pl-xxl-9{padding-left:36px!important}.pl-xxl-10{padding-left:40px!important}.pl-xxl-11{padding-left:44px!important}.pl-xxl-12{padding-left:48px!important}.pl-xxl-13{padding-left:52px!important}.pl-xxl-14{padding-left:56px!important}.pl-xxl-15{padding-left:60px!important}.pl-xxl-16{padding-left:64px!important}.ps-xxl-0{padding-inline-start:0!important}.ps-xxl-1{padding-inline-start:4px!important}.ps-xxl-2{padding-inline-start:8px!important}.ps-xxl-3{padding-inline-start:12px!important}.ps-xxl-4{padding-inline-start:16px!important}.ps-xxl-5{padding-inline-start:20px!important}.ps-xxl-6{padding-inline-start:24px!important}.ps-xxl-7{padding-inline-start:28px!important}.ps-xxl-8{padding-inline-start:32px!important}.ps-xxl-9{padding-inline-start:36px!important}.ps-xxl-10{padding-inline-start:40px!important}.ps-xxl-11{padding-inline-start:44px!important}.ps-xxl-12{padding-inline-start:48px!important}.ps-xxl-13{padding-inline-start:52px!important}.ps-xxl-14{padding-inline-start:56px!important}.ps-xxl-15{padding-inline-start:60px!important}.ps-xxl-16{padding-inline-start:64px!important}.pe-xxl-0{padding-inline-end:0!important}.pe-xxl-1{padding-inline-end:4px!important}.pe-xxl-2{padding-inline-end:8px!important}.pe-xxl-3{padding-inline-end:12px!important}.pe-xxl-4{padding-inline-end:16px!important}.pe-xxl-5{padding-inline-end:20px!important}.pe-xxl-6{padding-inline-end:24px!important}.pe-xxl-7{padding-inline-end:28px!important}.pe-xxl-8{padding-inline-end:32px!important}.pe-xxl-9{padding-inline-end:36px!important}.pe-xxl-10{padding-inline-end:40px!important}.pe-xxl-11{padding-inline-end:44px!important}.pe-xxl-12{padding-inline-end:48px!important}.pe-xxl-13{padding-inline-end:52px!important}.pe-xxl-14{padding-inline-end:56px!important}.pe-xxl-15{padding-inline-end:60px!important}.pe-xxl-16{padding-inline-end:64px!important}.text-xxl-left{text-align:left!important}.text-xxl-right{text-align:right!important}.text-xxl-center{text-align:center!important}.text-xxl-justify{text-align:justify!important}.text-xxl-start{text-align:start!important}.text-xxl-end{text-align:end!important}.text-xxl-h1{font-size:6rem!important;letter-spacing:-.015625em!important;line-height:6rem}.text-xxl-h1,.text-xxl-h2{font-family:Roboto,sans-serif!important;font-weight:300;text-transform:none!important}.text-xxl-h2{font-size:3.75rem!important;letter-spacing:-.0083333333em!important;line-height:3.75rem}.text-xxl-h3{font-size:3rem!important;letter-spacing:normal!important;line-height:3.125rem}.text-xxl-h3,.text-xxl-h4{font-family:Roboto,sans-serif!important;font-weight:400;text-transform:none!important}.text-xxl-h4{font-size:2.125rem!important;letter-spacing:.0073529412em!important;line-height:2.5rem}.text-xxl-h5{font-size:1.5rem!important;font-weight:400;letter-spacing:normal!important}.text-xxl-h5,.text-xxl-h6{font-family:Roboto,sans-serif!important;line-height:2rem;text-transform:none!important}.text-xxl-h6{font-size:1.25rem!important;font-weight:500;letter-spacing:.0125em!important}.text-xxl-subtitle-1{font-size:1rem!important;font-weight:400;letter-spacing:.009375em!important;line-height:1.75rem}.text-xxl-subtitle-1,.text-xxl-subtitle-2{font-family:Roboto,sans-serif!important;text-transform:none!important}.text-xxl-subtitle-2{font-size:.875rem!important;font-weight:500;letter-spacing:.0071428571em!important;line-height:1.375rem}.text-xxl-body-1{font-size:1rem!important;letter-spacing:.03125em!important;line-height:1.5rem}.text-xxl-body-1,.text-xxl-body-2{font-family:Roboto,sans-serif!important;font-weight:400;text-transform:none!important}.text-xxl-body-2{font-size:.875rem!important;letter-spacing:.0178571429em!important;line-height:1.25rem}.text-xxl-button{font-family:Roboto,sans-serif!important;font-size:.875rem!important;font-weight:500;letter-spacing:.0892857143em!important;line-height:2.25rem;text-transform:uppercase!important}.text-xxl-caption{font-weight:400;letter-spacing:.0333333333em!important;line-height:1.25rem;text-transform:none!important}.text-xxl-caption,.text-xxl-overline{font-family:Roboto,sans-serif!important;font-size:.75rem!important}.text-xxl-overline{font-weight:500;letter-spacing:.1666666667em!important;line-height:2rem;text-transform:uppercase!important}}@media print{.d-print-none{display:none!important}.d-print-inline{display:inline!important}.d-print-inline-block{display:inline-block!important}.d-print-block{display:block!important}.d-print-table{display:table!important}.d-print-table-row{display:table-row!important}.d-print-table-cell{display:table-cell!important}.d-print-flex{display:flex!important}.d-print-inline-flex{display:inline-flex!important}.float-print-none{float:none!important}.float-print-left{float:left!important}.float-print-right{float:right!important}.v-locale--is-rtl .float-print-end{float:left!important}.v-locale--is-ltr .float-print-end,.v-locale--is-rtl .float-print-start{float:right!important}.v-locale--is-ltr .float-print-start{float:left!important}}", "#page[data-v-09fad6ab]{height:100vh}", ".v-application{background:rgb(var(--v-theme-background));color:rgba(var(--v-theme-on-background),var(--v-high-emphasis-opacity));display:flex}.v-application__wrap{backface-visibility:hidden;display:flex;flex:1 1 auto;flex-direction:column;max-width:100%;min-height:100vh;min-height:100dvh;position:relative}"], wh = Object.freeze(Object.defineProperty({ __proto__: null, default: bh }, Symbol.toStringTag, { value: "Module" })), kh = [".line[data-v-360ecffe]{pointer-events:none;position:fixed;--line-width:5px;background-color:var(--490c7733);--xs:calc(var(--1dd4592b)*1px);--ys:calc(var(--1dd4594a)*1px);--xe:calc(var(--1dd4591d)*1px);--ye:calc(var(--1dd4593c)*1px);--xm:calc((var(--xs) + var(--xe))/2);--lwr:calc((var(--xe) - var(--xs))/2);--lhr:calc(var(--ye) - var(--ys));--lw:calc(max(var(--lwr), -1*var(--lwr)));--lh:calc(max(var(--lhr), -1*var(--lhr)))}#start[data-v-360ecffe]{left:calc(min(var(--xs), var(--xm)));top:var(--ys)}#end[data-v-360ecffe],#start[data-v-360ecffe]{height:var(--line-width);width:var(--lw)}#end[data-v-360ecffe]{left:calc(min(var(--xe), var(--xm)));top:var(--ye)}#middle[data-v-360ecffe]{height:calc(var(--lh) + var(--line-width));left:var(--xm);top:calc(min(var(--ys), var(--ye)));width:var(--line-width)}", "#socket[data-v-91c58806]{background-color:var(--ea906046);height:15px;width:15px}", '.v-btn{align-items:center;border-color:rgba(var(--v-border-color),var(--v-border-opacity));border-radius:4px;border-style:solid;border-width:0;display:inline-grid;flex-shrink:0;font-weight:500;grid-template-areas:"prepend content append";grid-template-columns:max-content auto max-content;justify-content:center;letter-spacing:.0892857143em;line-height:normal;max-width:100%;outline:none;position:relative;text-decoration:none;text-indent:.0892857143em;text-transform:uppercase;transition-duration:.28s;transition-property:box-shadow,transform,opacity,background;transition-timing-function:cubic-bezier(.4,0,.2,1);-webkit-user-select:none;-moz-user-select:none;user-select:none;vertical-align:middle}.v-btn--size-x-small{--v-btn-size:0.625rem;--v-btn-height:20px;font-size:var(--v-btn-size);min-width:36px;padding:0 8px}.v-btn--size-small{--v-btn-size:0.75rem;--v-btn-height:28px;font-size:var(--v-btn-size);min-width:50px;padding:0 12px}.v-btn--size-default{--v-btn-size:0.875rem;--v-btn-height:36px;font-size:var(--v-btn-size);min-width:64px;padding:0 16px}.v-btn--size-large{--v-btn-size:1rem;--v-btn-height:44px;font-size:var(--v-btn-size);min-width:78px;padding:0 20px}.v-btn--size-x-large{--v-btn-size:1.125rem;--v-btn-height:52px;font-size:var(--v-btn-size);min-width:92px;padding:0 24px}.v-btn.v-btn--density-default{height:calc(var(--v-btn-height))}.v-btn.v-btn--density-comfortable{height:calc(var(--v-btn-height) - 8px)}.v-btn.v-btn--density-compact{height:calc(var(--v-btn-height) - 12px)}.v-btn--border{border-width:thin;box-shadow:none}.v-btn--absolute{position:absolute}.v-btn--fixed{position:fixed}.v-btn:hover>.v-btn__overlay{opacity:calc(var(--v-hover-opacity)*var(--v-theme-overlay-multiplier))}.v-btn:focus-visible>.v-btn__overlay{opacity:calc(var(--v-focus-opacity)*var(--v-theme-overlay-multiplier))}@supports not selector(:focus-visible){.v-btn:focus>.v-btn__overlay{opacity:calc(var(--v-focus-opacity)*var(--v-theme-overlay-multiplier))}}.v-btn--active>.v-btn__overlay,.v-btn[aria-haspopup=menu][aria-expanded=true]>.v-btn__overlay{opacity:calc(var(--v-activated-opacity)*var(--v-theme-overlay-multiplier))}.v-btn--active:hover>.v-btn__overlay,.v-btn[aria-haspopup=menu][aria-expanded=true]:hover>.v-btn__overlay{opacity:calc((var(--v-activated-opacity) + var(--v-hover-opacity))*var(--v-theme-overlay-multiplier))}.v-btn--active:focus-visible>.v-btn__overlay,.v-btn[aria-haspopup=menu][aria-expanded=true]:focus-visible>.v-btn__overlay{opacity:calc((var(--v-activated-opacity) + var(--v-focus-opacity))*var(--v-theme-overlay-multiplier))}@supports not selector(:focus-visible){.v-btn--active:focus>.v-btn__overlay,.v-btn[aria-haspopup=menu][aria-expanded=true]:focus>.v-btn__overlay{opacity:calc((var(--v-activated-opacity) + var(--v-focus-opacity))*var(--v-theme-overlay-multiplier))}}.v-btn--variant-outlined,.v-btn--variant-plain,.v-btn--variant-text,.v-btn--variant-tonal{background:transparent;color:inherit}.v-btn--variant-plain{opacity:.62}.v-btn--variant-plain:focus,.v-btn--variant-plain:hover{opacity:1}.v-btn--variant-plain .v-btn__overlay{display:none}.v-btn--variant-elevated,.v-btn--variant-flat{background:rgb(var(--v-theme-surface));color:rgba(var(--v-theme-on-surface),var(--v-high-emphasis-opacity))}.v-btn--variant-elevated{box-shadow:0 3px 1px -2px var(--v-shadow-key-umbra-opacity,rgba(0,0,0,.2)),0 2px 2px 0 var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.14)),0 1px 5px 0 var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.12))}.v-btn--variant-flat{box-shadow:0 0 0 0 var(--v-shadow-key-umbra-opacity,rgba(0,0,0,.2)),0 0 0 0 var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.14)),0 0 0 0 var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.12))}.v-btn--variant-outlined{border:thin solid}.v-btn--variant-text .v-btn__overlay{background:currentColor}.v-btn--variant-tonal .v-btn__underlay{background:currentColor;border-radius:inherit;bottom:0;left:0;opacity:var(--v-activated-opacity);pointer-events:none;position:absolute;right:0;top:0}@supports selector(:focus-visible){.v-btn:after{border:2px solid;border-radius:inherit;content:"";height:100%;left:0;opacity:0;pointer-events:none;position:absolute;top:0;transition:opacity .2s ease-in-out;width:100%}.v-btn:focus-visible:after{opacity:calc(var(--v-theme-overlay-multiplier)*.25)}}.v-btn--icon{border-radius:50%;min-width:0;padding:0}.v-btn--icon.v-btn--size-default{--v-btn-size:1rem}.v-btn--icon.v-btn--density-default{height:calc(var(--v-btn-height) + 12px);width:calc(var(--v-btn-height) + 12px)}.v-btn--icon.v-btn--density-comfortable{height:calc(var(--v-btn-height));width:calc(var(--v-btn-height))}.v-btn--icon.v-btn--density-compact{height:calc(var(--v-btn-height) - 8px);width:calc(var(--v-btn-height) - 8px)}.v-btn--elevated:focus,.v-btn--elevated:hover{box-shadow:0 2px 4px -1px var(--v-shadow-key-umbra-opacity,rgba(0,0,0,.2)),0 4px 5px 0 var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.14)),0 1px 10px 0 var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.12))}.v-btn--elevated:active{box-shadow:0 5px 5px -3px var(--v-shadow-key-umbra-opacity,rgba(0,0,0,.2)),0 8px 10px 1px var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.14)),0 3px 14px 2px var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.12))}.v-btn--flat{box-shadow:none}.v-btn--block{display:flex;flex:1 0 auto;min-width:100%}.v-btn--disabled{opacity:.26;pointer-events:none}.v-btn--disabled:hover{opacity:.26}.v-btn--disabled.v-btn--variant-elevated,.v-btn--disabled.v-btn--variant-flat{background:rgb(var(--v-theme-surface));box-shadow:none;color:rgba(var(--v-theme-on-surface),.26);opacity:1}.v-btn--disabled.v-btn--variant-elevated .v-btn__overlay,.v-btn--disabled.v-btn--variant-flat .v-btn__overlay{opacity:.4615384615}.v-btn--loading{pointer-events:none}.v-btn--loading .v-btn__append,.v-btn--loading .v-btn__content,.v-btn--loading .v-btn__prepend{opacity:0}.v-btn--stacked{align-content:center;grid-template-areas:"prepend" "content" "append";grid-template-columns:auto;grid-template-rows:max-content max-content max-content;justify-items:center}.v-btn--stacked .v-btn__content{flex-direction:column;line-height:1.25}.v-btn--stacked .v-btn__append,.v-btn--stacked .v-btn__content>.v-icon--end,.v-btn--stacked .v-btn__content>.v-icon--start,.v-btn--stacked .v-btn__prepend{margin-inline:0}.v-btn--stacked .v-btn__content>.v-icon--start,.v-btn--stacked .v-btn__prepend{margin-bottom:4px}.v-btn--stacked .v-btn__append,.v-btn--stacked .v-btn__content>.v-icon--end{margin-top:4px}.v-btn--stacked.v-btn--size-x-small{--v-btn-size:0.625rem;--v-btn-height:56px;font-size:var(--v-btn-size);min-width:56px;padding:0 12px}.v-btn--stacked.v-btn--size-small{--v-btn-size:0.75rem;--v-btn-height:64px;font-size:var(--v-btn-size);min-width:64px;padding:0 14px}.v-btn--stacked.v-btn--size-default{--v-btn-size:0.875rem;--v-btn-height:72px;font-size:var(--v-btn-size);min-width:72px;padding:0 16px}.v-btn--stacked.v-btn--size-large{--v-btn-size:1rem;--v-btn-height:80px;font-size:var(--v-btn-size);min-width:80px;padding:0 18px}.v-btn--stacked.v-btn--size-x-large{--v-btn-size:1.125rem;--v-btn-height:88px;font-size:var(--v-btn-size);min-width:88px;padding:0 20px}.v-btn--stacked.v-btn--density-default{height:calc(var(--v-btn-height))}.v-btn--stacked.v-btn--density-comfortable{height:calc(var(--v-btn-height) - 16px)}.v-btn--stacked.v-btn--density-compact{height:calc(var(--v-btn-height) - 24px)}.v-btn--slim{padding:0 8px}.v-btn--rounded{border-radius:24px}.v-btn--rounded.v-btn--icon{border-radius:4px}.v-btn .v-icon{--v-icon-size-multiplier:0.8571428571}.v-btn--icon .v-icon{--v-icon-size-multiplier:1}.v-btn--stacked .v-icon{--v-icon-size-multiplier:1.1428571429}.v-btn__loader{align-items:center;display:flex;height:100%;justify-content:center;left:0;position:absolute;top:0;width:100%}.v-btn__append,.v-btn__content,.v-btn__prepend{align-items:center;display:flex;transition:transform,opacity .2s cubic-bezier(.4,0,.2,1)}.v-btn__prepend{grid-area:prepend;margin-inline:calc(var(--v-btn-height)/-9) calc(var(--v-btn-height)/4.5)}.v-btn__append{grid-area:append;margin-inline:calc(var(--v-btn-height)/4.5) calc(var(--v-btn-height)/-9)}.v-btn__content{grid-area:content;justify-content:center;white-space:nowrap}.v-btn__content>.v-icon--start{margin-inline:calc(var(--v-btn-height)/-9) calc(var(--v-btn-height)/4.5)}.v-btn__content>.v-icon--end{margin-inline:calc(var(--v-btn-height)/4.5) calc(var(--v-btn-height)/-9)}.v-btn--stacked .v-btn__content{white-space:normal}.v-btn__overlay{background-color:currentColor;border-radius:inherit;opacity:0;transition:opacity .2s ease-in-out}.v-btn__overlay,.v-btn__underlay{height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%}.v-card-actions .v-btn~.v-btn:not(.v-btn-toggle .v-btn){margin-inline-start:.5rem}.v-pagination .v-btn{border-radius:4px}.v-pagination .v-btn--rounded{border-radius:50%}.v-btn__overlay{transition:none}.v-pagination__item--is-active .v-btn__overlay{opacity:var(--v-border-opacity)}', ".v-btn-toggle>.v-btn.v-btn--active:not(.v-btn--disabled)>.v-btn__overlay{opacity:calc(var(--v-activated-opacity)*var(--v-theme-overlay-multiplier))}.v-btn-toggle>.v-btn.v-btn--active:not(.v-btn--disabled):hover>.v-btn__overlay{opacity:calc((var(--v-activated-opacity) + var(--v-hover-opacity))*var(--v-theme-overlay-multiplier))}.v-btn-toggle>.v-btn.v-btn--active:not(.v-btn--disabled):focus-visible>.v-btn__overlay{opacity:calc((var(--v-activated-opacity) + var(--v-focus-opacity))*var(--v-theme-overlay-multiplier))}@supports not selector(:focus-visible){.v-btn-toggle>.v-btn.v-btn--active:not(.v-btn--disabled):focus>.v-btn__overlay{opacity:calc((var(--v-activated-opacity) + var(--v-focus-opacity))*var(--v-theme-overlay-multiplier))}}", ".v-btn-group{background:transparent;border-color:rgba(var(--v-border-color),var(--v-border-opacity));border-radius:4px;border-style:solid;border-width:0;box-shadow:0 0 0 0 var(--v-shadow-key-umbra-opacity,rgba(0,0,0,.2)),0 0 0 0 var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.14)),0 0 0 0 var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.12));color:rgba(var(--v-theme-on-surface),var(--v-high-emphasis-opacity));display:inline-flex;flex-wrap:nowrap;max-width:100%;min-width:0;overflow:hidden;vertical-align:middle}.v-btn-group--border{border-width:thin;box-shadow:none}.v-btn-group--density-default.v-btn-group{height:48px}.v-btn-group--density-comfortable.v-btn-group{height:40px}.v-btn-group--density-compact.v-btn-group{height:36px}.v-btn-group .v-btn{border-color:inherit;border-radius:0}.v-btn-group .v-btn:not(:last-child){border-inline-end:none}.v-btn-group .v-btn:not(:first-child){border-inline-start:none}.v-btn-group .v-btn:first-child{border-end-start-radius:inherit;border-start-start-radius:inherit}.v-btn-group .v-btn:last-child{border-end-end-radius:inherit;border-start-end-radius:inherit}.v-btn-group--divided .v-btn:not(:last-child){border-inline-end-color:rgba(var(--v-border-color),var(--v-border-opacity));border-inline-end-style:solid;border-inline-end-width:thin}.v-btn-group--tile{border-radius:0}", '.v-icon{--v-icon-size-multiplier:1;align-items:center;display:inline-flex;font-feature-settings:"liga";height:1em;justify-content:center;letter-spacing:normal;line-height:1;min-width:1em;position:relative;text-align:center;text-indent:0;-webkit-user-select:none;-moz-user-select:none;user-select:none;vertical-align:middle;width:1em}.v-icon--clickable{cursor:pointer}.v-icon--size-x-small{font-size:calc(var(--v-icon-size-multiplier)*1em)}.v-icon--size-small{font-size:calc(var(--v-icon-size-multiplier)*1.25em)}.v-icon--size-default{font-size:calc(var(--v-icon-size-multiplier)*1.5em)}.v-icon--size-large{font-size:calc(var(--v-icon-size-multiplier)*1.75em)}.v-icon--size-x-large{font-size:calc(var(--v-icon-size-multiplier)*2em)}.v-icon__svg{fill:currentColor;height:100%;width:100%}.v-icon--start{margin-inline-end:8px}.v-icon--end{margin-inline-start:8px}', ".v-progress-circular{align-items:center;display:inline-flex;justify-content:center;position:relative;vertical-align:middle}.v-progress-circular>svg{bottom:0;height:100%;left:0;margin:auto;position:absolute;right:0;top:0;width:100%;z-index:0}.v-progress-circular__content{align-items:center;display:flex;justify-content:center}.v-progress-circular__underlay{color:rgba(var(--v-border-color),var(--v-border-opacity));stroke:currentColor;z-index:1}.v-progress-circular__overlay{stroke:currentColor;transition:all .2s ease-in-out,stroke-width 0s;z-index:2}.v-progress-circular--size-x-small{height:16px;width:16px}.v-progress-circular--size-small{height:24px;width:24px}.v-progress-circular--size-default{height:32px;width:32px}.v-progress-circular--size-large{height:48px;width:48px}.v-progress-circular--size-x-large{height:64px;width:64px}.v-progress-circular--indeterminate>svg{animation:progress-circular-rotate 1.4s linear infinite;transform-origin:center center;transition:all .2s ease-in-out}.v-progress-circular--indeterminate .v-progress-circular__overlay{animation:progress-circular-dash 1.4s ease-in-out infinite,progress-circular-rotate 1.4s linear infinite;stroke-dasharray:25,200;stroke-dashoffset:0;stroke-linecap:round;transform:rotate(-90deg);transform-origin:center center}.v-progress-circular--disable-shrink>svg{animation-duration:.7s}.v-progress-circular--disable-shrink .v-progress-circular__overlay{animation:none}.v-progress-circular--indeterminate:not(.v-progress-circular--visible) .v-progress-circular__overlay,.v-progress-circular--indeterminate:not(.v-progress-circular--visible)>svg{animation-play-state:paused!important}@keyframes progress-circular-dash{0%{stroke-dasharray:1,200;stroke-dashoffset:0px}50%{stroke-dasharray:100,200;stroke-dashoffset:-15px}to{stroke-dasharray:100,200;stroke-dashoffset:-124px}}@keyframes progress-circular-rotate{to{transform:rotate(270deg)}}", ".v-progress-linear{background:transparent;overflow:hidden;position:relative;transition:.2s cubic-bezier(.4,0,.2,1);width:100%}.v-progress-linear__background{background:currentColor;bottom:0;left:0;opacity:var(--v-border-opacity);position:absolute;top:0;transition-property:width,left,right;transition:inherit}.v-progress-linear__content{align-items:center;display:flex;height:100%;justify-content:center;left:0;pointer-events:none;position:absolute;top:0;width:100%}.v-progress-linear__determinate,.v-progress-linear__indeterminate{background:currentColor}.v-progress-linear__determinate{height:inherit;left:0;position:absolute;transition:inherit;transition-property:width,left,right}.v-progress-linear__indeterminate .long,.v-progress-linear__indeterminate .short{animation-duration:2.2s;animation-iteration-count:infinite;animation-play-state:paused;bottom:0;height:inherit;left:0;position:absolute;right:auto;top:0;width:auto;will-change:left,right}.v-progress-linear__indeterminate .long{animation-name:indeterminate-ltr}.v-progress-linear__indeterminate .short{animation-name:indeterminate-short-ltr}.v-progress-linear__stream{animation:stream .25s linear infinite;animation-play-state:paused;bottom:0;left:auto;opacity:.3;pointer-events:none;position:absolute;transition:inherit;transition-property:width,left,right}.v-progress-linear--reverse .v-progress-linear__background,.v-progress-linear--reverse .v-progress-linear__content,.v-progress-linear--reverse .v-progress-linear__determinate,.v-progress-linear--reverse .v-progress-linear__indeterminate .long,.v-progress-linear--reverse .v-progress-linear__indeterminate .short{left:auto;right:0}.v-progress-linear--reverse .v-progress-linear__indeterminate .long{animation-name:indeterminate-rtl}.v-progress-linear--reverse .v-progress-linear__indeterminate .short{animation-name:indeterminate-short-rtl}.v-progress-linear--reverse .v-progress-linear__stream{right:auto}.v-progress-linear--absolute,.v-progress-linear--fixed{left:0;z-index:1}.v-progress-linear--absolute{position:absolute}.v-progress-linear--fixed{position:fixed}.v-progress-linear--rounded{border-radius:9999px}.v-progress-linear--rounded.v-progress-linear--rounded-bar .v-progress-linear__determinate,.v-progress-linear--rounded.v-progress-linear--rounded-bar .v-progress-linear__indeterminate{border-radius:inherit}.v-progress-linear--striped .v-progress-linear__determinate{animation:progress-linear-stripes 1s linear infinite;background-image:linear-gradient(135deg,hsla(0,0%,100%,.25) 25%,transparent 0,transparent 50%,hsla(0,0%,100%,.25) 0,hsla(0,0%,100%,.25) 75%,transparent 0,transparent);background-repeat:repeat;background-size:var(--v-progress-linear-height)}.v-progress-linear--active .v-progress-linear__indeterminate .long,.v-progress-linear--active .v-progress-linear__indeterminate .short,.v-progress-linear--active .v-progress-linear__stream{animation-play-state:running}.v-progress-linear--rounded-bar .v-progress-linear__determinate,.v-progress-linear--rounded-bar .v-progress-linear__indeterminate,.v-progress-linear--rounded-bar .v-progress-linear__stream+.v-progress-linear__background{border-radius:9999px}.v-progress-linear--rounded-bar .v-progress-linear__determinate{border-end-start-radius:0;border-start-start-radius:0}@keyframes indeterminate-ltr{0%{left:-90%;right:100%}60%{left:-90%;right:100%}to{left:100%;right:-35%}}@keyframes indeterminate-rtl{0%{left:100%;right:-90%}60%{left:100%;right:-90%}to{left:-35%;right:100%}}@keyframes indeterminate-short-ltr{0%{left:-200%;right:100%}60%{left:107%;right:-8%}to{left:107%;right:-8%}}@keyframes indeterminate-short-rtl{0%{left:100%;right:-200%}60%{left:-8%;right:107%}to{left:-8%;right:107%}}@keyframes stream{to{transform:translateX(var(--v-progress-linear-stream-to))}}@keyframes progress-linear-stripes{0%{background-position-x:var(--v-progress-linear-height)}}", ".v-ripple__container{border-radius:inherit;contain:strict;height:100%;width:100%;z-index:0}.v-ripple__animation,.v-ripple__container{color:inherit;left:0;overflow:hidden;pointer-events:none;position:absolute;top:0}.v-ripple__animation{background:currentColor;border-radius:50%;opacity:0;will-change:transform,opacity}.v-ripple__animation--enter{opacity:0;transition:none}.v-ripple__animation--in{opacity:calc(var(--v-theme-overlay-multiplier)*.25);transition:transform .25s cubic-bezier(0,0,.2,1),opacity .1s cubic-bezier(0,0,.2,1)}.v-ripple__animation--out{opacity:0;transition:opacity .3s cubic-bezier(0,0,.2,1)}", ".v-list{background:rgba(var(--v-theme-surface));border-color:rgba(var(--v-border-color),var(--v-border-opacity));border-radius:0;border-style:solid;border-width:0;box-shadow:0 0 0 0 var(--v-shadow-key-umbra-opacity,rgba(0,0,0,.2)),0 0 0 0 var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.14)),0 0 0 0 var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.12));color:rgba(var(--v-theme-on-surface),var(--v-high-emphasis-opacity));outline:none;overflow:auto;padding:8px 0;position:relative}.v-list--border{border-width:thin;box-shadow:none}.v-list--disabled{pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.v-list--nav{padding-inline:8px}.v-list--rounded{border-radius:4px}.v-list--subheader{padding-top:0}.v-list-img{border-radius:inherit;display:flex;height:100%;left:0;overflow:hidden;position:absolute;top:0;width:100%;z-index:-1}.v-list-subheader{align-items:center;background:inherit;color:rgba(var(--v-theme-on-surface),var(--v-medium-emphasis-opacity));display:flex;font-size:.875rem;font-weight:400;line-height:1.375rem;min-height:40px;padding-inline-end:16px;transition:min-height .2s cubic-bezier(.4,0,.2,1)}.v-list-subheader__text{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.v-list--density-default .v-list-subheader{min-height:40px;padding-inline-start:calc(16px + var(--indent-padding))!important}.v-list--density-comfortable .v-list-subheader{min-height:36px;padding-inline-start:calc(16px + var(--indent-padding))!important}.v-list--density-compact .v-list-subheader{min-height:32px;padding-inline-start:calc(16px + var(--indent-padding))!important}.v-list-subheader--inset{--indent-padding:56px}.v-list--nav .v-list-subheader{font-size:.75rem}.v-list-subheader--sticky{background:inherit;left:0;position:sticky;top:0;z-index:1}.v-list__overlay{background-color:currentColor;border-radius:inherit;bottom:0;left:0;opacity:0;pointer-events:none;position:absolute;right:0;top:0;transition:opacity .2s ease-in-out}", '.v-list-item{align-items:center;border-color:rgba(var(--v-border-color),var(--v-border-opacity));border-radius:0;border-style:solid;border-width:0;display:grid;flex:none;grid-template-areas:"prepend content append";grid-template-columns:max-content 1fr auto;max-width:100%;outline:none;padding:4px 16px;position:relative;text-decoration:none}.v-list-item--border{border-width:thin;box-shadow:none}.v-list-item:hover>.v-list-item__overlay{opacity:calc(var(--v-hover-opacity)*var(--v-theme-overlay-multiplier))}.v-list-item:focus-visible>.v-list-item__overlay{opacity:calc(var(--v-focus-opacity)*var(--v-theme-overlay-multiplier))}@supports not selector(:focus-visible){.v-list-item:focus>.v-list-item__overlay{opacity:calc(var(--v-focus-opacity)*var(--v-theme-overlay-multiplier))}}.v-list-item--active>.v-list-item__overlay,.v-list-item[aria-haspopup=menu][aria-expanded=true]>.v-list-item__overlay{opacity:calc(var(--v-activated-opacity)*var(--v-theme-overlay-multiplier))}.v-list-item--active:hover>.v-list-item__overlay,.v-list-item[aria-haspopup=menu][aria-expanded=true]:hover>.v-list-item__overlay{opacity:calc((var(--v-activated-opacity) + var(--v-hover-opacity))*var(--v-theme-overlay-multiplier))}.v-list-item--active:focus-visible>.v-list-item__overlay,.v-list-item[aria-haspopup=menu][aria-expanded=true]:focus-visible>.v-list-item__overlay{opacity:calc((var(--v-activated-opacity) + var(--v-focus-opacity))*var(--v-theme-overlay-multiplier))}@supports not selector(:focus-visible){.v-list-item--active:focus>.v-list-item__overlay,.v-list-item[aria-haspopup=menu][aria-expanded=true]:focus>.v-list-item__overlay{opacity:calc((var(--v-activated-opacity) + var(--v-focus-opacity))*var(--v-theme-overlay-multiplier))}}.v-list-item--variant-outlined,.v-list-item--variant-plain,.v-list-item--variant-text,.v-list-item--variant-tonal{background:transparent;color:inherit}.v-list-item--variant-plain{opacity:.62}.v-list-item--variant-plain:focus,.v-list-item--variant-plain:hover{opacity:1}.v-list-item--variant-plain .v-list-item__overlay{display:none}.v-list-item--variant-elevated,.v-list-item--variant-flat{background:rgba(var(--v-theme-surface));color:rgba(var(--v-theme-on-surface),var(--v-high-emphasis-opacity))}.v-list-item--variant-elevated{box-shadow:0 2px 1px -1px var(--v-shadow-key-umbra-opacity,rgba(0,0,0,.2)),0 1px 1px 0 var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.14)),0 1px 3px 0 var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.12))}.v-list-item--variant-flat{box-shadow:0 0 0 0 var(--v-shadow-key-umbra-opacity,rgba(0,0,0,.2)),0 0 0 0 var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.14)),0 0 0 0 var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.12))}.v-list-item--variant-outlined{border:thin solid}.v-list-item--variant-text .v-list-item__overlay{background:currentColor}.v-list-item--variant-tonal .v-list-item__underlay{background:currentColor;border-radius:inherit;bottom:0;left:0;opacity:var(--v-activated-opacity);pointer-events:none;position:absolute;right:0;top:0}@supports selector(:focus-visible){.v-list-item:after{border:2px solid;border-radius:4px;content:"";height:100%;left:0;opacity:0;pointer-events:none;position:absolute;top:0;transition:opacity .2s ease-in-out;width:100%}.v-list-item:focus-visible:after{opacity:calc(var(--v-theme-overlay-multiplier)*.15)}}.v-list-item__append>.v-badge .v-icon,.v-list-item__append>.v-icon,.v-list-item__prepend>.v-badge .v-icon,.v-list-item__prepend>.v-icon{opacity:var(--v-medium-emphasis-opacity)}.v-list-item--active .v-list-item__append>.v-badge .v-icon,.v-list-item--active .v-list-item__append>.v-icon,.v-list-item--active .v-list-item__prepend>.v-badge .v-icon,.v-list-item--active .v-list-item__prepend>.v-icon{opacity:1}.v-list-item--rounded{border-radius:4px}.v-list-item--disabled{opacity:.6;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.v-list-item--link{cursor:pointer}.v-navigation-drawer--rail.v-navigation-drawer--expand-on-hover:not(.v-navigation-drawer--is-hovering) .v-list-item .v-avatar,.v-navigation-drawer--rail:not(.v-navigation-drawer--expand-on-hover) .v-list-item .v-avatar{--v-avatar-height:24px}.v-list-item__prepend{align-items:center;align-self:center;display:flex;grid-area:prepend}.v-list-item__prepend>.v-badge~.v-list-item__spacer,.v-list-item__prepend>.v-icon~.v-list-item__spacer,.v-list-item__prepend>.v-tooltip~.v-list-item__spacer{width:32px}.v-list-item__prepend>.v-avatar~.v-list-item__spacer{width:16px}.v-list-item--slim .v-list-item__prepend>.v-badge~.v-list-item__spacer,.v-list-item--slim .v-list-item__prepend>.v-icon~.v-list-item__spacer,.v-list-item--slim .v-list-item__prepend>.v-tooltip~.v-list-item__spacer{width:8px}.v-list-item--slim .v-list-item__prepend>.v-avatar~.v-list-item__spacer{width:4px}.v-list-item--three-line .v-list-item__prepend{align-self:start}.v-list-item__append{align-items:center;align-self:center;display:flex;grid-area:append}.v-list-item__append .v-list-item__spacer{order:-1;transition:width .15s cubic-bezier(.4,0,.2,1)}.v-list-item__append>.v-badge~.v-list-item__spacer,.v-list-item__append>.v-icon~.v-list-item__spacer,.v-list-item__append>.v-tooltip~.v-list-item__spacer{width:32px}.v-list-item__append>.v-avatar~.v-list-item__spacer{width:16px}.v-list-item--slim .v-list-item__append>.v-badge~.v-list-item__spacer,.v-list-item--slim .v-list-item__append>.v-icon~.v-list-item__spacer,.v-list-item--slim .v-list-item__append>.v-tooltip~.v-list-item__spacer{width:8px}.v-list-item--slim .v-list-item__append>.v-avatar~.v-list-item__spacer{width:4px}.v-list-item--three-line .v-list-item__append{align-self:start}.v-list-item__content{align-self:center;grid-area:content;overflow:hidden}.v-list-item-action{align-items:center;align-self:center;display:flex;flex:none;grid-area:prepend;transition:inherit;transition-property:height,width}.v-list-item-action--start{margin-inline-end:12px}.v-list-item-action--end{margin-inline-start:12px}.v-list-item-media{margin-bottom:0;margin-top:0}.v-list-item-media--start{margin-inline-end:16px}.v-list-item-media--end{margin-inline-start:16px}.v-list-item--two-line .v-list-item-media{margin-bottom:-4px;margin-top:-4px}.v-list-item--three-line .v-list-item-media{margin-bottom:0;margin-top:0}.v-list-item-subtitle{-webkit-box-orient:vertical;display:-webkit-box;font-size:.875rem;font-weight:400;letter-spacing:.0178571429em;line-height:1rem;opacity:var(--v-medium-emphasis-opacity);overflow:hidden;padding:0;text-overflow:ellipsis;text-transform:none}.v-list-item--one-line .v-list-item-subtitle{-webkit-line-clamp:1}.v-list-item--two-line .v-list-item-subtitle{-webkit-line-clamp:2}.v-list-item--three-line .v-list-item-subtitle{-webkit-line-clamp:3}.v-list-item--nav .v-list-item-subtitle{font-size:.75rem;font-weight:400;letter-spacing:.0178571429em;line-height:1rem}.v-list-item-title{-webkit-hyphens:auto;hyphens:auto;overflow:hidden;overflow-wrap:normal;padding:0;text-overflow:ellipsis;white-space:nowrap;word-break:normal;word-wrap:break-word;font-size:1rem;font-weight:400;letter-spacing:.009375em;line-height:1.5rem;text-transform:none}.v-list-item--nav .v-list-item-title{font-size:.8125rem;font-weight:500;letter-spacing:normal;line-height:1rem}.v-list-item--density-default{min-height:40px}.v-list-item--density-default.v-list-item--one-line{min-height:48px;padding-bottom:4px;padding-top:4px}.v-list-item--density-default.v-list-item--two-line{min-height:64px;padding-bottom:12px;padding-top:12px}.v-list-item--density-default.v-list-item--three-line{min-height:88px;padding-bottom:16px;padding-top:16px}.v-list-item--density-default.v-list-item--three-line .v-list-item__append,.v-list-item--density-default.v-list-item--three-line .v-list-item__prepend{padding-top:8px}.v-list-item--density-default:not(.v-list-item--nav).v-list-item--one-line,.v-list-item--density-default:not(.v-list-item--nav).v-list-item--three-line,.v-list-item--density-default:not(.v-list-item--nav).v-list-item--two-line{padding-inline:16px}.v-list-item--density-comfortable{min-height:36px}.v-list-item--density-comfortable.v-list-item--one-line{min-height:44px}.v-list-item--density-comfortable.v-list-item--two-line{min-height:60px;padding-bottom:8px;padding-top:8px}.v-list-item--density-comfortable.v-list-item--three-line{min-height:84px;padding-bottom:12px;padding-top:12px}.v-list-item--density-comfortable.v-list-item--three-line .v-list-item__append,.v-list-item--density-comfortable.v-list-item--three-line .v-list-item__prepend{padding-top:6px}.v-list-item--density-comfortable:not(.v-list-item--nav).v-list-item--one-line,.v-list-item--density-comfortable:not(.v-list-item--nav).v-list-item--three-line,.v-list-item--density-comfortable:not(.v-list-item--nav).v-list-item--two-line{padding-inline:16px}.v-list-item--density-compact{min-height:32px}.v-list-item--density-compact.v-list-item--one-line{min-height:40px}.v-list-item--density-compact.v-list-item--two-line{min-height:56px;padding-bottom:4px;padding-top:4px}.v-list-item--density-compact.v-list-item--three-line{min-height:80px;padding-bottom:8px;padding-top:8px}.v-list-item--density-compact.v-list-item--three-line .v-list-item__append,.v-list-item--density-compact.v-list-item--three-line .v-list-item__prepend{padding-top:4px}.v-list-item--density-compact:not(.v-list-item--nav).v-list-item--one-line,.v-list-item--density-compact:not(.v-list-item--nav).v-list-item--three-line,.v-list-item--density-compact:not(.v-list-item--nav).v-list-item--two-line{padding-inline:16px}.v-list-item--nav{padding-inline:8px}.v-list .v-list-item--nav:not(:only-child){margin-bottom:4px}.v-list-item__underlay{position:absolute}.v-list-item__overlay{background-color:currentColor;border-radius:inherit;bottom:0;left:0;opacity:0;pointer-events:none;position:absolute;right:0;top:0;transition:opacity .2s ease-in-out}.v-list-item--active.v-list-item--variant-elevated .v-list-item__overlay{--v-theme-overlay-multiplier:0}.v-list{--indent-padding:0px}.v-list--nav{--indent-padding:-8px}.v-list-group{--list-indent-size:16px;--parent-padding:var(--indent-padding);--prepend-width:40px}.v-list-group--fluid{--list-indent-size:0px}.v-list-group--prepend{--parent-padding:calc(var(--indent-padding) + var(--prepend-width))}.v-list-group--fluid.v-list-group--prepend{--parent-padding:var(--indent-padding)}.v-list-group__items{--indent-padding:calc(var(--parent-padding) + var(--list-indent-size))}.v-list-group__items .v-list-item{padding-inline-start:calc(16px + var(--indent-padding))!important}.v-list-group__header.v-list-item--active:not(:focus-visible) .v-list-item__overlay{opacity:0}.v-list-group__header.v-list-item--active:hover .v-list-item__overlay{opacity:calc(var(--v-hover-opacity)*var(--v-theme-overlay-multiplier))}', ".v-avatar{align-items:center;border-radius:50%;display:inline-flex;flex:none;justify-content:center;line-height:normal;overflow:hidden;position:relative;text-align:center;transition:.2s cubic-bezier(.4,0,.2,1);transition-property:width,height;vertical-align:middle}.v-avatar.v-avatar--size-x-small{--v-avatar-height:24px}.v-avatar.v-avatar--size-small{--v-avatar-height:32px}.v-avatar.v-avatar--size-default{--v-avatar-height:40px}.v-avatar.v-avatar--size-large{--v-avatar-height:48px}.v-avatar.v-avatar--size-x-large{--v-avatar-height:56px}.v-avatar.v-avatar--density-default{height:calc(var(--v-avatar-height));width:calc(var(--v-avatar-height))}.v-avatar.v-avatar--density-comfortable{height:calc(var(--v-avatar-height) - 4px);width:calc(var(--v-avatar-height) - 4px)}.v-avatar.v-avatar--density-compact{height:calc(var(--v-avatar-height) - 8px);width:calc(var(--v-avatar-height) - 8px)}.v-avatar--variant-outlined,.v-avatar--variant-plain,.v-avatar--variant-text,.v-avatar--variant-tonal{background:transparent;color:inherit}.v-avatar--variant-plain{opacity:.62}.v-avatar--variant-plain:focus,.v-avatar--variant-plain:hover{opacity:1}.v-avatar--variant-plain .v-avatar__overlay{display:none}.v-avatar--variant-elevated,.v-avatar--variant-flat{background:var(--v-theme-surface);color:rgba(var(--v-theme-on-surface),var(--v-medium-emphasis-opacity))}.v-avatar--variant-elevated{box-shadow:0 2px 1px -1px var(--v-shadow-key-umbra-opacity,rgba(0,0,0,.2)),0 1px 1px 0 var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.14)),0 1px 3px 0 var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.12))}.v-avatar--variant-flat{box-shadow:0 0 0 0 var(--v-shadow-key-umbra-opacity,rgba(0,0,0,.2)),0 0 0 0 var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.14)),0 0 0 0 var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.12))}.v-avatar--variant-outlined{border:thin solid}.v-avatar--variant-text .v-avatar__overlay{background:currentColor}.v-avatar--variant-tonal .v-avatar__underlay{background:currentColor;border-radius:inherit;bottom:0;left:0;opacity:var(--v-activated-opacity);pointer-events:none;position:absolute;right:0;top:0}.v-avatar--rounded{border-radius:4px}.v-avatar .v-img{height:100%;width:100%}", ".v-img{--v-theme-overlay-multiplier:3;z-index:0}.v-img--booting .v-responsive__sizer{transition:none}.v-img__error,.v-img__gradient,.v-img__img,.v-img__picture,.v-img__placeholder{height:100%;left:0;position:absolute;top:0;width:100%;z-index:-1}.v-img__img--preload{filter:blur(4px)}.v-img__img--contain{-o-object-fit:contain;object-fit:contain}.v-img__img--cover{-o-object-fit:cover;object-fit:cover}.v-img__gradient{background-repeat:no-repeat}", ".v-responsive{display:flex;flex:1 0 auto;max-height:100%;max-width:100%;overflow:hidden;position:relative}.v-responsive--inline{display:inline-flex;flex:0 0 auto}.v-responsive__content{flex:1 0 0px;max-width:100%}.v-responsive__sizer~.v-responsive__content{margin-inline-start:-100%}.v-responsive__sizer{flex:1 0 0px;pointer-events:none;transition:padding-bottom .2s cubic-bezier(.4,0,.2,1)}", ".v-divider{border-style:solid;border-width:thin 0 0;display:block;flex:1 1 100%;height:0;max-height:0;opacity:var(--v-border-opacity);transition:inherit}.v-divider--vertical{align-self:stretch;border-width:0 thin 0 0;display:inline-flex;height:inherit;margin-left:-1px;max-height:100%;max-width:0;vertical-align:text-bottom;width:0}.v-divider--inset:not(.v-divider--vertical){margin-inline-start:72px;max-width:calc(100% - 72px)}.v-divider--inset.v-divider--vertical{margin-bottom:8px;margin-top:8px;max-height:calc(100% - 16px)}", ".v-menu>.v-overlay__content{border-radius:4px;display:flex;flex-direction:column}.v-menu>.v-overlay__content>.v-card,.v-menu>.v-overlay__content>.v-list,.v-menu>.v-overlay__content>.v-sheet{background:rgb(var(--v-theme-surface));border-radius:inherit;box-shadow:0 5px 5px -3px var(--v-shadow-key-umbra-opacity,rgba(0,0,0,.2)),0 8px 10px 1px var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.14)),0 3px 14px 2px var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.12));height:100%;overflow:auto}", ".v-overlay-container{contain:layout;display:contents;left:0;pointer-events:none;position:absolute;top:0}.v-overlay-scroll-blocked{padding-inline-end:var(--v-scrollbar-offset)}.v-overlay-scroll-blocked:not(html){overflow-y:hidden!important}html.v-overlay-scroll-blocked{height:100%;left:var(--v-body-scroll-x);position:fixed;top:var(--v-body-scroll-y);width:100%}.v-overlay{border-radius:inherit;bottom:0;display:flex;left:0;pointer-events:none;position:fixed;right:0;top:0}.v-overlay__content{contain:layout;outline:none;pointer-events:auto;position:absolute}.v-overlay__scrim{background:rgb(var(--v-theme-on-surface));border-radius:inherit;bottom:0;left:0;opacity:.32;pointer-events:auto;position:fixed;right:0;top:0}.v-overlay--absolute,.v-overlay--contained .v-overlay__scrim{position:absolute}.v-overlay--scroll-blocked{padding-inline-end:var(--v-scrollbar-offset)}", ".v-sheet{background:rgb(var(--v-theme-surface));border-color:rgba(var(--v-border-color),var(--v-border-opacity));border-radius:0;border-style:solid;border-width:0;box-shadow:0 0 0 0 var(--v-shadow-key-umbra-opacity,rgba(0,0,0,.2)),0 0 0 0 var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.14)),0 0 0 0 var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.12));color:rgba(var(--v-theme-on-background),var(--v-high-emphasis-opacity));display:block}.v-sheet--border{border-width:thin;box-shadow:none}.v-sheet--absolute{position:absolute}.v-sheet--fixed{position:fixed}.v-sheet--relative{position:relative}.v-sheet--sticky{position:sticky}.v-sheet--rounded{border-radius:4px}", "#node[data-v-babecec4]{border:100px;border-color:red;padding:20px}#border[data-v-babecec4]{left:calc(var(--a288afe6)*1px);padding:5px;position:absolute;top:calc(var(--a288afe4)*1px)}.static_border[data-v-babecec4]{outline:dashed #ff0}.animated_border[data-v-babecec4]{animation:border-dance-babecec4 1s linear infinite;background-image:linear-gradient(90deg,var(--22666edb) 50%,transparent 0),linear-gradient(90deg,var(--22666edb) 50%,transparent 0),linear-gradient(0deg,var(--22666edb) 50%,transparent 0),linear-gradient(0deg,var(--22666edb) 50%,transparent 0);background-position:0 0,100% 100%,0 100%,100% 0;background-repeat:repeat-x,repeat-x,repeat-y,repeat-y;background-size:15px 4px,15px 4px,4px 15px,4px 15px}@keyframes border-dance-babecec4{0%{background-position:0 0,100% 100%,0 100%,100% 0}to{background-position:left 15px top,right 15px bottom,left bottom 15px,right top 15px}}h1[data-v-babecec4]{-webkit-user-select:none;-moz-user-select:none;user-select:none;white-space:nowrap}", ".v-text-field input{color:inherit;flex:1;min-width:0;opacity:0;transition:opacity .15s cubic-bezier(.4,0,.2,1)}.v-text-field input:active,.v-text-field input:focus{outline:none}.v-text-field input:invalid{box-shadow:none}.v-text-field .v-field{cursor:text}.v-text-field--prefixed.v-text-field .v-field__input{--v-field-padding-start:6px}.v-text-field--suffixed.v-text-field .v-field__input{--v-field-padding-end:0}.v-text-field .v-input__details{padding-inline:16px}.v-input--plain-underlined.v-text-field .v-input__details{padding-inline:0}.v-text-field .v-field--active input,.v-text-field .v-field--no-label input{opacity:1}.v-text-field .v-field--single-line input{transition:none}.v-text-field__prefix,.v-text-field__suffix{align-items:center;color:rgba(var(--v-theme-on-surface),var(--v-medium-emphasis-opacity));cursor:default;display:flex;min-height:max(var(--v-input-control-height,56px),1.5rem + var(--v-field-input-padding-top) + var(--v-field-input-padding-bottom));opacity:0;padding-bottom:var(--v-field-padding-bottom,6px);padding-top:calc(var(--v-field-padding-top, 4px) + var(--v-input-padding-top, 0));transition:inherit;white-space:nowrap}.v-field--active .v-text-field__prefix,.v-field--active .v-text-field__suffix{opacity:1}.v-field--disabled .v-text-field__prefix,.v-field--disabled .v-text-field__suffix{color:rgba(var(--v-theme-on-surface),var(--v-disabled-opacity))}.v-text-field__prefix{padding-inline-start:var(--v-field-padding-start)}.v-text-field__suffix{padding-inline-end:var(--v-field-padding-end)}", ".v-counter{color:rgba(var(--v-theme-on-surface),var(--v-medium-emphasis-opacity));flex:0 1 auto;font-size:12px;transition-duration:.15s}", '.v-field{border-radius:4px;contain:layout;display:grid;flex:1 0;font-size:16px;grid-area:control;grid-template-areas:"prepend-inner field clear append-inner";grid-template-columns:min-content minmax(0,1fr) min-content min-content;letter-spacing:.009375em;max-width:100%;position:relative;--v-field-padding-start:16px;--v-field-padding-end:16px;--v-field-padding-top:8px;--v-field-padding-bottom:4px;--v-field-input-padding-top:calc(var(--v-field-padding-top, 8px) + var(--v-input-padding-top, 0));--v-field-input-padding-bottom:var(--v-field-padding-bottom,4px)}.v-field--disabled{opacity:var(--v-disabled-opacity);pointer-events:none}.v-field .v-chip{--v-chip-height:24px}.v-field--prepended{padding-inline-start:12px}.v-field--appended{padding-inline-end:12px}.v-field--variant-solo,.v-field--variant-solo-filled,.v-field--variant-solo-inverted{background:rgb(var(--v-theme-surface));border-color:transparent;box-shadow:0 3px 1px -2px var(--v-shadow-key-umbra-opacity,rgba(0,0,0,.2)),0 2px 2px 0 var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.14)),0 1px 5px 0 var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.12));color:rgba(var(--v-theme-on-surface),var(--v-high-emphasis-opacity))}.v-field--variant-solo-inverted.v-field--focused{color:rgb(var(--v-theme-on-surface-variant))}.v-field--variant-filled{border-bottom-left-radius:0;border-bottom-right-radius:0}.v-input--density-default .v-field--variant-filled,.v-input--density-default .v-field--variant-solo,.v-input--density-default .v-field--variant-solo-filled,.v-input--density-default .v-field--variant-solo-inverted{--v-input-control-height:56px;--v-field-padding-bottom:4px}.v-input--density-comfortable .v-field--variant-filled,.v-input--density-comfortable .v-field--variant-solo,.v-input--density-comfortable .v-field--variant-solo-filled,.v-input--density-comfortable .v-field--variant-solo-inverted{--v-input-control-height:48px;--v-field-padding-bottom:0px}.v-input--density-compact .v-field--variant-filled,.v-input--density-compact .v-field--variant-solo,.v-input--density-compact .v-field--variant-solo-filled,.v-input--density-compact .v-field--variant-solo-inverted{--v-input-control-height:40px;--v-field-padding-bottom:0px}.v-field--no-label,.v-field--single-line,.v-field--variant-outlined{--v-field-padding-top:0px}.v-input--density-default .v-field--no-label,.v-input--density-default .v-field--single-line,.v-input--density-default .v-field--variant-outlined{--v-field-padding-bottom:16px}.v-input--density-comfortable .v-field--no-label,.v-input--density-comfortable .v-field--single-line,.v-input--density-comfortable .v-field--variant-outlined{--v-field-padding-bottom:12px}.v-input--density-compact .v-field--no-label,.v-input--density-compact .v-field--single-line,.v-input--density-compact .v-field--variant-outlined{--v-field-padding-bottom:8px}.v-field--variant-plain,.v-field--variant-underlined{border-radius:0;padding:0}.v-field--variant-plain.v-field,.v-field--variant-underlined.v-field{--v-field-padding-start:0px;--v-field-padding-end:0px}.v-input--density-default .v-field--variant-plain,.v-input--density-default .v-field--variant-underlined{--v-input-control-height:48px;--v-field-padding-top:4px;--v-field-padding-bottom:4px}.v-input--density-comfortable .v-field--variant-plain,.v-input--density-comfortable .v-field--variant-underlined{--v-input-control-height:40px;--v-field-padding-top:2px;--v-field-padding-bottom:0px}.v-input--density-compact .v-field--variant-plain,.v-input--density-compact .v-field--variant-underlined{--v-input-control-height:32px;--v-field-padding-top:0px;--v-field-padding-bottom:0px}.v-field--flat{box-shadow:none}.v-field--rounded{border-radius:9999px}.v-field.v-field--prepended{--v-field-padding-start:6px}.v-field.v-field--appended{--v-field-padding-end:6px}.v-field__input{align-items:center;color:inherit;-moz-column-gap:2px;column-gap:2px;display:flex;flex-wrap:wrap;letter-spacing:.009375em;min-height:max(var(--v-input-control-height,56px),1.5rem + var(--v-field-input-padding-top) + var(--v-field-input-padding-bottom));min-width:0;opacity:var(--v-high-emphasis-opacity);padding-inline:var(--v-field-padding-start) var(--v-field-padding-end);padding-bottom:var(--v-field-input-padding-bottom);padding-top:var(--v-field-input-padding-top);position:relative;width:100%}.v-input--density-default .v-field__input{row-gap:8px}.v-input--density-comfortable .v-field__input{row-gap:6px}.v-input--density-compact .v-field__input{row-gap:4px}.v-field__input input{letter-spacing:inherit}.v-field__input input::-moz-placeholder,input.v-field__input::-moz-placeholder,textarea.v-field__input::-moz-placeholder{color:currentColor;opacity:var(--v-disabled-opacity)}.v-field__input input::placeholder,input.v-field__input::placeholder,textarea.v-field__input::placeholder{color:currentColor;opacity:var(--v-disabled-opacity)}.v-field__input:active,.v-field__input:focus{outline:none}.v-field__input:invalid{box-shadow:none}.v-field__field{align-items:flex-start;display:flex;flex:1 0;grid-area:field;position:relative}.v-field__prepend-inner{grid-area:prepend-inner;padding-inline-end:var(--v-field-padding-after)}.v-field__clearable{grid-area:clear}.v-field__append-inner{grid-area:append-inner;padding-inline-start:var(--v-field-padding-after)}.v-field__append-inner,.v-field__clearable,.v-field__prepend-inner{align-items:flex-start;display:flex;padding-top:var(--v-input-padding-top,8px)}.v-field--center-affix .v-field__append-inner,.v-field--center-affix .v-field__clearable,.v-field--center-affix .v-field__prepend-inner{align-items:center;padding-top:0}.v-field.v-field--variant-plain .v-field__append-inner,.v-field.v-field--variant-plain .v-field__clearable,.v-field.v-field--variant-plain .v-field__prepend-inner,.v-field.v-field--variant-underlined .v-field__append-inner,.v-field.v-field--variant-underlined .v-field__clearable,.v-field.v-field--variant-underlined .v-field__prepend-inner{align-items:flex-start;padding-bottom:var(--v-field-padding-bottom,4px);padding-top:calc(var(--v-field-padding-top, 8px) + var(--v-input-padding-top, 0))}.v-field--focused .v-field__append-inner,.v-field--focused .v-field__prepend-inner{opacity:1}.v-field__append-inner>.v-icon,.v-field__clearable>.v-icon,.v-field__prepend-inner>.v-icon{opacity:var(--v-medium-emphasis-opacity)}.v-field--disabled .v-field__append-inner>.v-icon,.v-field--disabled .v-field__clearable>.v-icon,.v-field--disabled .v-field__prepend-inner>.v-icon,.v-field--error .v-field__append-inner>.v-icon,.v-field--error .v-field__clearable>.v-icon,.v-field--error .v-field__prepend-inner>.v-icon{opacity:1}.v-field--error:not(.v-field--disabled) .v-field__append-inner>.v-icon,.v-field--error:not(.v-field--disabled) .v-field__clearable>.v-icon,.v-field--error:not(.v-field--disabled) .v-field__prepend-inner>.v-icon{color:rgb(var(--v-theme-error))}.v-field__clearable{cursor:pointer;margin-inline:4px;opacity:0;overflow:hidden;transition:.15s cubic-bezier(.4,0,.2,1);transition-property:opacity,transform,width}.v-field--focused .v-field__clearable,.v-field--persistent-clear .v-field__clearable{opacity:1}@media (hover:hover){.v-field:hover .v-field__clearable{opacity:1}}@media (hover:none){.v-field__clearable{opacity:1}}.v-label.v-field-label{contain:layout paint;display:block;margin-inline-end:var(--v-field-padding-end);margin-inline-start:var(--v-field-padding-start);max-width:calc(100% - var(--v-field-padding-start) - var(--v-field-padding-end));pointer-events:none;position:absolute;top:var(--v-input-padding-top);transform-origin:left center;transition:.15s cubic-bezier(.4,0,.2,1);transition-property:opacity,transform;z-index:1}.v-field--variant-plain .v-label.v-field-label,.v-field--variant-underlined .v-label.v-field-label{top:calc(var(--v-input-padding-top) + var(--v-field-padding-top))}.v-field--center-affix .v-label.v-field-label{top:50%;transform:translateY(-50%)}.v-field--active .v-label.v-field-label{visibility:hidden}.v-field--error .v-label.v-field-label,.v-field--focused .v-label.v-field-label{opacity:1}.v-field--error:not(.v-field--disabled) .v-label.v-field-label{color:rgb(var(--v-theme-error))}.v-label.v-field-label--floating{--v-field-label-scale:0.75em;font-size:var(--v-field-label-scale);max-width:100%;visibility:hidden}.v-field--center-affix .v-label.v-field-label--floating{transform:none}.v-field.v-field--active .v-label.v-field-label--floating{visibility:unset}.v-input--density-default .v-field--variant-filled .v-label.v-field-label--floating,.v-input--density-default .v-field--variant-solo .v-label.v-field-label--floating,.v-input--density-default .v-field--variant-solo-filled .v-label.v-field-label--floating,.v-input--density-default .v-field--variant-solo-inverted .v-label.v-field-label--floating{top:7px}.v-input--density-comfortable .v-field--variant-filled .v-label.v-field-label--floating,.v-input--density-comfortable .v-field--variant-solo .v-label.v-field-label--floating,.v-input--density-comfortable .v-field--variant-solo-filled .v-label.v-field-label--floating,.v-input--density-comfortable .v-field--variant-solo-inverted .v-label.v-field-label--floating{top:5px}.v-input--density-compact .v-field--variant-filled .v-label.v-field-label--floating,.v-input--density-compact .v-field--variant-solo .v-label.v-field-label--floating,.v-input--density-compact .v-field--variant-solo-filled .v-label.v-field-label--floating,.v-input--density-compact .v-field--variant-solo-inverted .v-label.v-field-label--floating{top:3px}.v-field--variant-plain .v-label.v-field-label--floating,.v-field--variant-underlined .v-label.v-field-label--floating{margin:0;top:var(--v-input-padding-top);transform:translateY(-16px)}.v-field--variant-outlined .v-label.v-field-label--floating{margin:0 4px;position:static;transform:translateY(-50%);transform-origin:center}.v-field__outline{--v-field-border-width:1px;--v-field-border-opacity:0.38;align-items:stretch;contain:layout;display:flex;height:100%;left:0;pointer-events:none;position:absolute;right:0;width:100%}@media (hover:hover){.v-field:hover .v-field__outline{--v-field-border-opacity:var(--v-high-emphasis-opacity)}}.v-field--error:not(.v-field--disabled) .v-field__outline{color:rgb(var(--v-theme-error))}.v-field.v-field--focused .v-field__outline,.v-input.v-input--error .v-field__outline{--v-field-border-opacity:1}.v-field--variant-outlined.v-field--focused .v-field__outline{--v-field-border-width:2px}.v-field--variant-filled .v-field__outline:before,.v-field--variant-underlined .v-field__outline:before{border-color:currentColor;border-style:solid;border-width:0 0 var(--v-field-border-width);content:"";height:100%;left:0;opacity:var(--v-field-border-opacity);position:absolute;top:0;transition:opacity .25s cubic-bezier(.4,0,.2,1);width:100%}.v-field--variant-filled .v-field__outline:after,.v-field--variant-underlined .v-field__outline:after{border:solid;border-width:0 0 2px;content:"";height:100%;left:0;position:absolute;top:0;transform:scaleX(0);transition:transform .15s cubic-bezier(.4,0,.2,1);width:100%}.v-field--focused.v-field--variant-filled .v-field__outline:after,.v-field--focused.v-field--variant-underlined .v-field__outline:after{transform:scaleX(1)}.v-field--variant-outlined .v-field__outline{border-radius:inherit}.v-field--variant-outlined .v-field__outline__end,.v-field--variant-outlined .v-field__outline__notch:after,.v-field--variant-outlined .v-field__outline__notch:before,.v-field--variant-outlined .v-field__outline__start{border:0 solid;opacity:var(--v-field-border-opacity);transition:opacity .25s cubic-bezier(.4,0,.2,1)}.v-field--variant-outlined .v-field__outline__start{border-bottom-width:var(--v-field-border-width);border-end-end-radius:0;border-end-start-radius:inherit;border-inline-start-width:var(--v-field-border-width);border-start-end-radius:0;border-start-start-radius:inherit;border-top-width:var(--v-field-border-width);flex:0 0 12px}.v-field--rounded.v-field--variant-outlined .v-field__outline__start,[class*=" rounded-"].v-field--variant-outlined .v-field__outline__start,[class^=rounded-].v-field--variant-outlined .v-field__outline__start{flex-basis:calc(var(--v-input-control-height)/2 + 2px)}.v-field--variant-outlined .v-field__outline__notch{flex:none;max-width:calc(100% - 12px);position:relative}.v-field--variant-outlined .v-field__outline__notch:after,.v-field--variant-outlined .v-field__outline__notch:before{content:"";height:100%;left:0;opacity:var(--v-field-border-opacity);position:absolute;top:0;transition:opacity .25s cubic-bezier(.4,0,.2,1);width:100%}.v-field--variant-outlined .v-field__outline__notch:before{border-width:var(--v-field-border-width) 0 0}.v-field--variant-outlined .v-field__outline__notch:after{border-width:0 0 var(--v-field-border-width);bottom:0}.v-field--active.v-field--variant-outlined .v-field__outline__notch:before{opacity:0}.v-field--variant-outlined .v-field__outline__end{border-bottom-width:var(--v-field-border-width);border-end-end-radius:inherit;border-end-start-radius:0;border-inline-end-width:var(--v-field-border-width);border-start-end-radius:inherit;border-start-start-radius:0;border-top-width:var(--v-field-border-width);flex:1}.v-field__loader{border-bottom-left-radius:inherit;border-bottom-right-radius:inherit;border-top-left-radius:0;border-top-right-radius:0;left:0;overflow:hidden;position:absolute;right:0;top:calc(100% - 2px);width:100%}.v-field--variant-outlined .v-field__loader{top:calc(100% - 3px)}.v-field__overlay{border-radius:inherit;height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%}.v-field--variant-filled .v-field__overlay{background-color:currentColor;opacity:.04;transition:opacity .25s cubic-bezier(.4,0,.2,1)}.v-field--variant-filled.v-field--has-background .v-field__overlay{opacity:0}@media (hover:hover){.v-field--variant-filled:hover .v-field__overlay{opacity:calc((.04 + var(--v-hover-opacity))*var(--v-theme-overlay-multiplier))}}.v-field--variant-filled.v-field--focused .v-field__overlay{opacity:calc((.04 + var(--v-focus-opacity))*var(--v-theme-overlay-multiplier))}.v-field--variant-solo-filled .v-field__overlay{background-color:currentColor;opacity:.04;transition:opacity .25s cubic-bezier(.4,0,.2,1)}@media (hover:hover){.v-field--variant-solo-filled:hover .v-field__overlay{opacity:calc((.04 + var(--v-hover-opacity))*var(--v-theme-overlay-multiplier))}}.v-field--variant-solo-filled.v-field--focused .v-field__overlay{opacity:calc((.04 + var(--v-focus-opacity))*var(--v-theme-overlay-multiplier))}.v-field--variant-solo-inverted .v-field__overlay{transition:opacity .25s cubic-bezier(.4,0,.2,1)}.v-field--variant-solo-inverted.v-field--has-background .v-field__overlay{opacity:0}@media (hover:hover){.v-field--variant-solo-inverted:hover .v-field__overlay{opacity:calc((.04 + var(--v-hover-opacity))*var(--v-theme-overlay-multiplier))}}.v-field--variant-solo-inverted.v-field--focused .v-field__overlay{background-color:rgb(var(--v-theme-surface-variant));opacity:1}.v-field--reverse .v-field__field,.v-field--reverse .v-field__input{flex-direction:row-reverse}.v-field--reverse .v-field__input,.v-field--reverse input{text-align:end}.v-input--disabled .v-field--variant-filled .v-field__outline:before,.v-input--disabled .v-field--variant-underlined .v-field__outline:before{-o-border-image:repeating-linear-gradient(to right,rgba(var(--v-theme-on-surface),var(--v-disabled-opacity)) 0,rgba(var(--v-theme-on-surface),var(--v-disabled-opacity)) 2px,transparent 2px,transparent 4px) 1 repeat;border-image:repeating-linear-gradient(to right,rgba(var(--v-theme-on-surface),var(--v-disabled-opacity)) 0,rgba(var(--v-theme-on-surface),var(--v-disabled-opacity)) 2px,transparent 2px,transparent 4px) 1 repeat}.v-field--loading .v-field__outline:after,.v-field--loading .v-field__outline:before{opacity:0}', ".v-label{align-items:center;color:inherit;display:inline-flex;font-size:1rem;letter-spacing:.009375em;min-width:0;opacity:var(--v-medium-emphasis-opacity);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.v-label--clickable{cursor:pointer}", '.v-input{display:grid;flex:1 1 auto;font-size:1rem;font-weight:400;line-height:1.5}.v-input--disabled{pointer-events:none}.v-input--density-default{--v-input-control-height:56px;--v-input-padding-top:16px}.v-input--density-comfortable{--v-input-control-height:48px;--v-input-padding-top:12px}.v-input--density-compact{--v-input-control-height:40px;--v-input-padding-top:8px}.v-input--vertical{grid-template-areas:"append" "control" "prepend";grid-template-columns:min-content;grid-template-rows:max-content auto max-content}.v-input--vertical .v-input__prepend{margin-block-start:16px}.v-input--vertical .v-input__append{margin-block-end:16px}.v-input--horizontal{grid-template-areas:"prepend control append" "a messages b";grid-template-columns:max-content minmax(0,1fr) max-content;grid-template-rows:auto auto}.v-input--horizontal .v-input__prepend{margin-inline-end:16px}.v-input--horizontal .v-input__append{margin-inline-start:16px}.v-input__details{align-items:flex-end;display:flex;font-size:.75rem;font-weight:400;grid-area:messages;justify-content:space-between;letter-spacing:.0333333333em;line-height:normal;min-height:22px;overflow:hidden;padding-top:6px}.v-input__append>.v-icon,.v-input__details>.v-icon,.v-input__prepend>.v-icon{opacity:var(--v-medium-emphasis-opacity)}.v-input--disabled .v-input__append .v-messages,.v-input--disabled .v-input__append>.v-icon,.v-input--disabled .v-input__details .v-messages,.v-input--disabled .v-input__details>.v-icon,.v-input--disabled .v-input__prepend .v-messages,.v-input--disabled .v-input__prepend>.v-icon,.v-input--error .v-input__append .v-messages,.v-input--error .v-input__append>.v-icon,.v-input--error .v-input__details .v-messages,.v-input--error .v-input__details>.v-icon,.v-input--error .v-input__prepend .v-messages,.v-input--error .v-input__prepend>.v-icon{opacity:1}.v-input--disabled .v-input__append,.v-input--disabled .v-input__details,.v-input--disabled .v-input__prepend{opacity:var(--v-disabled-opacity)}.v-input--error:not(.v-input--disabled) .v-input__append .v-messages,.v-input--error:not(.v-input--disabled) .v-input__append>.v-icon,.v-input--error:not(.v-input--disabled) .v-input__details .v-messages,.v-input--error:not(.v-input--disabled) .v-input__details>.v-icon,.v-input--error:not(.v-input--disabled) .v-input__prepend .v-messages,.v-input--error:not(.v-input--disabled) .v-input__prepend>.v-icon{color:rgb(var(--v-theme-error))}.v-input__append,.v-input__prepend{align-items:flex-start;display:flex;padding-top:var(--v-input-padding-top)}.v-input--center-affix .v-input__append,.v-input--center-affix .v-input__prepend{align-items:center;padding-top:0}.v-input__prepend{grid-area:prepend}.v-input__append{grid-area:append}.v-input__control{display:flex;grid-area:control}.v-input--hide-spin-buttons input::-webkit-inner-spin-button,.v-input--hide-spin-buttons input::-webkit-outer-spin-button{-webkit-appearance:none;margin:0}.v-input--hide-spin-buttons input[type=number]{-moz-appearance:textfield}.v-input--plain-underlined .v-input__append,.v-input--plain-underlined .v-input__prepend{align-items:flex-start}.v-input--density-default.v-input--plain-underlined .v-input__append,.v-input--density-default.v-input--plain-underlined .v-input__prepend{padding-top:calc(var(--v-input-padding-top) + 4px)}.v-input--density-comfortable.v-input--plain-underlined .v-input__append,.v-input--density-comfortable.v-input--plain-underlined .v-input__prepend{padding-top:calc(var(--v-input-padding-top) + 2px)}.v-input--density-compact.v-input--plain-underlined .v-input__append,.v-input--density-compact.v-input--plain-underlined .v-input__prepend{padding-top:calc(var(--v-input-padding-top))}', ".v-messages{flex:1 1 auto;font-size:12px;min-height:14px;min-width:1px;opacity:var(--v-medium-emphasis-opacity);position:relative}.v-messages__message{line-height:12px;overflow-wrap:break-word;word-break:break-word;word-wrap:break-word;-webkit-hyphens:auto;hyphens:auto;transition-duration:.15s}", ".v-textarea .v-field{--v-textarea-control-height:var(--v-input-control-height)}.v-textarea .v-field__field{--v-input-control-height:var(--v-textarea-control-height)}.v-textarea .v-field__input{flex:1 1 auto;-webkit-mask-image:linear-gradient(to bottom,transparent,transparent calc(var(--v-field-padding-top, 0) + var(--v-input-padding-top, 0) - 6px),#000 calc(var(--v-field-padding-top, 0) + var(--v-input-padding-top, 0) + 4px));mask-image:linear-gradient(to bottom,transparent,transparent calc(var(--v-field-padding-top, 0) + var(--v-input-padding-top, 0) - 6px),#000 calc(var(--v-field-padding-top, 0) + var(--v-input-padding-top, 0) + 4px));outline:none}.v-textarea .v-field__input.v-textarea__sizer{height:0!important;left:0;min-height:0!important;pointer-events:none;position:absolute;top:0;visibility:hidden}.v-textarea--no-resize .v-field__input{resize:none}.v-textarea .v-field--active textarea,.v-textarea .v-field--no-label textarea{opacity:1}.v-textarea textarea{flex:1;min-width:0;opacity:0;transition:opacity .15s cubic-bezier(.4,0,.2,1)}.v-textarea textarea:active,.v-textarea textarea:focus{outline:none}.v-textarea textarea:invalid{box-shadow:none}", '.v-card{border-color:rgba(var(--v-border-color),var(--v-border-opacity));border-radius:4px;border-style:solid;border-width:0;display:block;overflow:hidden;overflow-wrap:break-word;padding:0;position:relative;text-decoration:none;transition-duration:.28s;transition-property:box-shadow,opacity,background;transition-timing-function:cubic-bezier(.4,0,.2,1);z-index:0}.v-card--border{border-width:thin;box-shadow:none}.v-card--absolute{position:absolute}.v-card--fixed{position:fixed}.v-card:hover>.v-card__overlay{opacity:calc(var(--v-hover-opacity)*var(--v-theme-overlay-multiplier))}.v-card:focus-visible>.v-card__overlay{opacity:calc(var(--v-focus-opacity)*var(--v-theme-overlay-multiplier))}@supports not selector(:focus-visible){.v-card:focus>.v-card__overlay{opacity:calc(var(--v-focus-opacity)*var(--v-theme-overlay-multiplier))}}.v-card--active>.v-card__overlay,.v-card[aria-haspopup=menu][aria-expanded=true]>.v-card__overlay{opacity:calc(var(--v-activated-opacity)*var(--v-theme-overlay-multiplier))}.v-card--active:hover>.v-card__overlay,.v-card[aria-haspopup=menu][aria-expanded=true]:hover>.v-card__overlay{opacity:calc((var(--v-activated-opacity) + var(--v-hover-opacity))*var(--v-theme-overlay-multiplier))}.v-card--active:focus-visible>.v-card__overlay,.v-card[aria-haspopup=menu][aria-expanded=true]:focus-visible>.v-card__overlay{opacity:calc((var(--v-activated-opacity) + var(--v-focus-opacity))*var(--v-theme-overlay-multiplier))}@supports not selector(:focus-visible){.v-card--active:focus>.v-card__overlay,.v-card[aria-haspopup=menu][aria-expanded=true]:focus>.v-card__overlay{opacity:calc((var(--v-activated-opacity) + var(--v-focus-opacity))*var(--v-theme-overlay-multiplier))}}.v-card--variant-outlined,.v-card--variant-plain,.v-card--variant-text,.v-card--variant-tonal{background:transparent;color:inherit}.v-card--variant-plain{opacity:.62}.v-card--variant-plain:focus,.v-card--variant-plain:hover{opacity:1}.v-card--variant-plain .v-card__overlay{display:none}.v-card--variant-elevated,.v-card--variant-flat{background:rgb(var(--v-theme-surface));color:rgba(var(--v-theme-on-surface),var(--v-high-emphasis-opacity))}.v-card--variant-elevated{box-shadow:0 2px 1px -1px var(--v-shadow-key-umbra-opacity,rgba(0,0,0,.2)),0 1px 1px 0 var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.14)),0 1px 3px 0 var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.12))}.v-card--variant-flat{box-shadow:0 0 0 0 var(--v-shadow-key-umbra-opacity,rgba(0,0,0,.2)),0 0 0 0 var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.14)),0 0 0 0 var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.12))}.v-card--variant-outlined{border:thin solid}.v-card--variant-text .v-card__overlay{background:currentColor}.v-card--variant-tonal .v-card__underlay{background:currentColor;border-radius:inherit;bottom:0;left:0;opacity:var(--v-activated-opacity);pointer-events:none;position:absolute;right:0;top:0}.v-card--disabled{pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.v-card--disabled>:not(.v-card__loader){opacity:.6}.v-card--flat{box-shadow:none}.v-card--hover{cursor:pointer}.v-card--hover:after,.v-card--hover:before{border-radius:inherit;bottom:0;content:"";display:block;left:0;pointer-events:none;position:absolute;right:0;top:0;transition:inherit}.v-card--hover:before{box-shadow:0 2px 1px -1px var(--v-shadow-key-umbra-opacity,rgba(0,0,0,.2)),0 1px 1px 0 var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.14)),0 1px 3px 0 var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.12));opacity:1;z-index:-1}.v-card--hover:after{box-shadow:0 5px 5px -3px var(--v-shadow-key-umbra-opacity,rgba(0,0,0,.2)),0 8px 10px 1px var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.14)),0 3px 14px 2px var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.12));opacity:0;z-index:1}.v-card--hover:hover:after{opacity:1}.v-card--hover:hover:before{opacity:0}.v-card--hover:hover{box-shadow:0 5px 5px -3px var(--v-shadow-key-umbra-opacity,rgba(0,0,0,.2)),0 8px 10px 1px var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.14)),0 3px 14px 2px var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.12))}.v-card--link{cursor:pointer}.v-card-actions{align-items:center;display:flex;flex:none;min-height:52px;padding:.5rem}.v-card-item{align-items:center;display:grid;flex:none;grid-template-areas:"prepend content append";grid-template-columns:max-content auto max-content;padding:.625rem 1rem}.v-card-item+.v-card-text{padding-top:0}.v-card-item__prepend{grid-area:prepend;padding-inline-end:1rem}.v-card-item__append{grid-area:append;padding-inline-start:1rem}.v-card-item__content{align-self:center;grid-area:content;overflow:hidden}.v-card-title{display:block;flex:none;font-size:1.25rem;font-weight:500;-webkit-hyphens:auto;hyphens:auto;letter-spacing:.0125em;min-width:0;overflow:hidden;overflow-wrap:normal;padding:.5rem 1rem;text-overflow:ellipsis;text-transform:none;white-space:nowrap;word-break:normal;word-wrap:break-word}.v-card .v-card-title{line-height:2rem}.v-card--density-comfortable .v-card-title{line-height:1.75rem}.v-card--density-compact .v-card-title{line-height:1.55rem}.v-card-item .v-card-title{padding:0}.v-card-title+.v-card-actions,.v-card-title+.v-card-text{padding-top:0}.v-card-subtitle{display:block;flex:none;font-size:.875rem;font-weight:400;letter-spacing:.0178571429em;opacity:var(--v-medium-emphasis-opacity);overflow:hidden;padding:0 1rem;text-overflow:ellipsis;text-transform:none;white-space:nowrap}.v-card .v-card-subtitle{line-height:1.25rem}.v-card--density-comfortable .v-card-subtitle{line-height:1.125rem}.v-card--density-compact .v-card-subtitle{line-height:1rem}.v-card-item .v-card-subtitle{padding:0 0 .25rem}.v-card-text{flex:1 1 auto;font-size:.875rem;font-weight:400;letter-spacing:.0178571429em;padding:1rem;text-transform:none}.v-card .v-card-text{line-height:1.25rem}.v-card--density-comfortable .v-card-text{line-height:1.2rem}.v-card--density-compact .v-card-text{line-height:1.15rem}.v-card__image{display:flex;flex:1 1 auto;height:100%;left:0;overflow:hidden;position:absolute;top:0;width:100%;z-index:-1}.v-card__content{border-radius:inherit;overflow:hidden;position:relative}.v-card__loader{bottom:auto;width:100%;z-index:1}.v-card__loader,.v-card__overlay{left:0;position:absolute;right:0;top:0}.v-card__overlay{background-color:currentColor;border-radius:inherit;bottom:0;opacity:0;pointer-events:none;transition:opacity .2s ease-in-out}', ".v-main{flex:1 0 auto;max-width:100%;padding:var(--v-layout-top) var(--v-layout-right) var(--v-layout-bottom) var(--v-layout-left);transition:.2s cubic-bezier(.4,0,.2,1)}.v-main__scroller{max-width:100%;position:relative}.v-main--scrollable{display:flex;height:100%;left:0;position:absolute;top:0;width:100%}.v-main--scrollable>.v-main__scroller{flex:1 1 auto;overflow-y:auto;--v-layout-left:0px;--v-layout-right:0px;--v-layout-top:0px;--v-layout-bottom:0px}", ".v-navigation-drawer{-webkit-overflow-scrolling:touch;background:rgb(var(--v-theme-surface));border-color:rgba(var(--v-border-color),var(--v-border-opacity));border-style:solid;border-width:0;box-shadow:0 0 0 0 var(--v-shadow-key-umbra-opacity,rgba(0,0,0,.2)),0 0 0 0 var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.14)),0 0 0 0 var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.12));color:rgba(var(--v-theme-on-surface),var(--v-high-emphasis-opacity));display:flex;flex-direction:column;height:100%;max-width:100%;pointer-events:auto;position:absolute;transition-duration:.2s;transition-property:box-shadow,transform,visibility,width,height,left,right,top,bottom;transition-timing-function:cubic-bezier(.4,0,.2,1)}.v-navigation-drawer--border{border-width:thin;box-shadow:none}.v-navigation-drawer--rounded{border-radius:4px}.v-navigation-drawer--top{border-bottom-width:thin;top:0}.v-navigation-drawer--bottom{border-top-width:thin;left:0}.v-navigation-drawer--left{border-right-width:thin;left:0;right:auto;top:0}.v-navigation-drawer--right{border-left-width:thin;left:auto;right:0;top:0}.v-navigation-drawer--floating{border:none}.v-navigation-drawer--temporary{box-shadow:0 8px 10px -5px var(--v-shadow-key-umbra-opacity,rgba(0,0,0,.2)),0 16px 24px 2px var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.14)),0 6px 30px 5px var(--v-shadow-key-penumbra-opacity,rgba(0,0,0,.12))}.v-navigation-drawer--sticky{height:auto;transition:box-shadow,transform,visibility,width,height,left,right}.v-navigation-drawer .v-list{overflow:hidden}.v-navigation-drawer__content{flex:0 1 auto;height:100%;max-width:100%;overflow-x:hidden;overflow-y:auto}.v-navigation-drawer__img{height:100%;left:0;position:absolute;top:0;width:100%;z-index:-1}.v-navigation-drawer__img img{height:inherit;-o-object-fit:cover;object-fit:cover;width:inherit}.v-navigation-drawer__scrim{background:#000;height:100%;left:0;opacity:.2;position:absolute;top:0;transition:opacity .2s cubic-bezier(.4,0,.2,1);width:100%;z-index:1}.v-navigation-drawer__append,.v-navigation-drawer__prepend{flex:none;overflow:hidden}", ".v-tooltip>.v-overlay__content{background:rgb(var(--v-theme-surface-variant));border-radius:4px;color:rgb(var(--v-theme-on-surface-variant));display:inline-block;font-size:.875rem;line-height:1.6;opacity:1;padding:5px 16px;pointer-events:none;text-transform:none;transition-property:opacity,transform;width:auto}.v-tooltip>.v-overlay__content[class*=enter-active]{transition-duration:.15s;transition-timing-function:cubic-bezier(0,0,.2,1)}.v-tooltip>.v-overlay__content[class*=leave-active]{transition-duration:75ms;transition-timing-function:cubic-bezier(.4,0,1,1)}", "#mouse_tracker[data-v-4d3919b8]{height:0;left:calc(var(--18c627d4)*1px);position:fixed;top:calc(var(--18c627d5)*1px);width:0}#container[data-v-4d3919b8]{background:radial-gradient(circle,#fff 4px,transparent 0);background-size:40px 40px;height:100%;position:relative;width:100%}#node_container[data-v-4d3919b8]{height:0;left:calc(var(--03e5234c)*1px);position:relative;top:calc(var(--03e5234d)*1px);transform:scale(var(--04102340));width:0}"], Sh = Object.freeze(Object.defineProperty({ __proto__: null, default: kh }, Symbol.toStringTag, { value: "Module" })), Ch = '.spotlight[data-v-ccd3db62]{background:linear-gradient(45deg,#00dc82,#36e4da 50%,#0047e1);bottom:-30vh;filter:blur(20vh);height:40vh}.gradient-border[data-v-ccd3db62]{-webkit-backdrop-filter:blur(10px);backdrop-filter:blur(10px);border-radius:.5rem;position:relative}@media (prefers-color-scheme:light){.gradient-border[data-v-ccd3db62]{background-color:hsla(0,0%,100%,.3)}.gradient-border[data-v-ccd3db62]:before{background:linear-gradient(90deg,#e2e2e2,#e2e2e2 25%,#00dc82 50%,#36e4da 75%,#0047e1)}}@media (prefers-color-scheme:dark){.gradient-border[data-v-ccd3db62]{background-color:hsla(0,0%,8%,.3)}.gradient-border[data-v-ccd3db62]:before{background:linear-gradient(90deg,#303030,#303030 25%,#00dc82 50%,#36e4da 75%,#0047e1)}}.gradient-border[data-v-ccd3db62]:before{background-size:400% auto;border-radius:.5rem;bottom:0;content:"";left:0;-webkit-mask:linear-gradient(#fff 0 0) content-box,linear-gradient(#fff 0 0);mask:linear-gradient(#fff 0 0) content-box,linear-gradient(#fff 0 0);-webkit-mask-composite:xor;mask-composite:exclude;opacity:.5;padding:2px;position:absolute;right:0;top:0;transition:background-position .3s ease-in-out,opacity .2s ease-in-out;width:100%}.gradient-border[data-v-ccd3db62]:hover:before{background-position:-50% 0;opacity:1}.bg-white[data-v-ccd3db62]{--tw-bg-opacity:1;background-color:rgba(255,255,255,var(--tw-bg-opacity))}.cursor-pointer[data-v-ccd3db62]{cursor:pointer}.flex[data-v-ccd3db62]{display:flex}.grid[data-v-ccd3db62]{display:grid}.place-content-center[data-v-ccd3db62]{place-content:center}.items-center[data-v-ccd3db62]{align-items:center}.justify-center[data-v-ccd3db62]{justify-content:center}.font-sans[data-v-ccd3db62]{font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji}.font-medium[data-v-ccd3db62]{font-weight:500}.font-light[data-v-ccd3db62]{font-weight:300}.text-8xl[data-v-ccd3db62]{font-size:6rem;line-height:1}.text-xl[data-v-ccd3db62]{font-size:1.25rem;line-height:1.75rem}.leading-tight[data-v-ccd3db62]{line-height:1.25}.mb-8[data-v-ccd3db62]{margin-bottom:2rem}.mb-16[data-v-ccd3db62]{margin-bottom:4rem}.max-w-520px[data-v-ccd3db62]{max-width:520px}.min-h-screen[data-v-ccd3db62]{min-height:100vh}.overflow-hidden[data-v-ccd3db62]{overflow:hidden}.px-8[data-v-ccd3db62]{padding-left:2rem;padding-right:2rem}.py-2[data-v-ccd3db62]{padding-bottom:.5rem;padding-top:.5rem}.px-4[data-v-ccd3db62]{padding-left:1rem;padding-right:1rem}.fixed[data-v-ccd3db62]{position:fixed}.left-0[data-v-ccd3db62]{left:0}.right-0[data-v-ccd3db62]{right:0}.text-center[data-v-ccd3db62]{text-align:center}.text-black[data-v-ccd3db62]{--tw-text-opacity:1;color:rgba(0,0,0,var(--tw-text-opacity))}.antialiased[data-v-ccd3db62]{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.w-full[data-v-ccd3db62]{width:100%}.z-10[data-v-ccd3db62]{z-index:10}.z-20[data-v-ccd3db62]{z-index:20}@media (min-width:640px){.sm\\:text-4xl[data-v-ccd3db62]{font-size:2.25rem;line-height:2.5rem}.sm\\:text-xl[data-v-ccd3db62]{font-size:1.25rem;line-height:1.75rem}.sm\\:text-10xl[data-v-ccd3db62]{font-size:10rem;line-height:1}.sm\\:px-0[data-v-ccd3db62]{padding-left:0;padding-right:0}.sm\\:py-3[data-v-ccd3db62]{padding-bottom:.75rem;padding-top:.75rem}.sm\\:px-6[data-v-ccd3db62]{padding-left:1.5rem;padding-right:1.5rem}}@media (prefers-color-scheme:dark){.dark\\:bg-black[data-v-ccd3db62]{--tw-bg-opacity:1;background-color:rgba(0,0,0,var(--tw-bg-opacity))}.dark\\:text-white[data-v-ccd3db62]{--tw-text-opacity:1;color:rgba(255,255,255,var(--tw-text-opacity))}}', Eh = [Ch, Ch], _h = Object.freeze(Object.defineProperty({ __proto__: null, default: Eh }, Symbol.toStringTag, { value: "Module" })), Ph = ".spotlight[data-v-df79c84d]{background:linear-gradient(45deg,#00dc82,#36e4da 50%,#0047e1);filter:blur(20vh)}.bg-white[data-v-df79c84d]{--tw-bg-opacity:1;background-color:rgba(255,255,255,var(--tw-bg-opacity))}.grid[data-v-df79c84d]{display:grid}.place-content-center[data-v-df79c84d]{place-content:center}.font-sans[data-v-df79c84d]{font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji}.font-medium[data-v-df79c84d]{font-weight:500}.font-light[data-v-df79c84d]{font-weight:300}.h-1\\/2[data-v-df79c84d]{height:50%}.text-8xl[data-v-df79c84d]{font-size:6rem;line-height:1}.text-xl[data-v-df79c84d]{font-size:1.25rem;line-height:1.75rem}.leading-tight[data-v-df79c84d]{line-height:1.25}.mb-8[data-v-df79c84d]{margin-bottom:2rem}.mb-16[data-v-df79c84d]{margin-bottom:4rem}.max-w-520px[data-v-df79c84d]{max-width:520px}.min-h-screen[data-v-df79c84d]{min-height:100vh}.overflow-hidden[data-v-df79c84d]{overflow:hidden}.px-8[data-v-df79c84d]{padding-left:2rem;padding-right:2rem}.fixed[data-v-df79c84d]{position:fixed}.left-0[data-v-df79c84d]{left:0}.right-0[data-v-df79c84d]{right:0}.-bottom-1\\/2[data-v-df79c84d]{bottom:-50%}.text-center[data-v-df79c84d]{text-align:center}.text-black[data-v-df79c84d]{--tw-text-opacity:1;color:rgba(0,0,0,var(--tw-text-opacity))}.antialiased[data-v-df79c84d]{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}@media (min-width:640px){.sm\\:text-4xl[data-v-df79c84d]{font-size:2.25rem;line-height:2.5rem}.sm\\:text-10xl[data-v-df79c84d]{font-size:10rem;line-height:1}.sm\\:px-0[data-v-df79c84d]{padding-left:0;padding-right:0}}@media (prefers-color-scheme:dark){.dark\\:bg-black[data-v-df79c84d]{--tw-bg-opacity:1;background-color:rgba(0,0,0,var(--tw-bg-opacity))}.dark\\:text-white[data-v-df79c84d]{--tw-text-opacity:1;color:rgba(255,255,255,var(--tw-text-opacity))}}", Th = [Ph, Ph], Ah = Object.freeze(Object.defineProperty({ __proto__: null, default: Th }, Symbol.toStringTag, { value: "Module" }));
  }();
})();
//# sourceMappingURL=index.js.map
